[
  {
    "Id": "43235946",
    "PostTypeId": "1",
    "CreationDate": "2017-04-05T15:47:57.290",
    "Score": "9",
    "ViewCount": "15951",
    "Body": "<p>Spring Boot doesn't read application properties when running in Docker container.</p>  <p>My <strong>application.yml</strong></p>  <pre><code>server:   port: 8080   context-path: /mail custom:   greeting: Hello YML </code></pre>  <p><strong>Dockerfile</strong></p>  <pre><code>FROM java:8-jre VOLUME /tmp COPY ./mail.jar /app/mail.jar RUN sh -c 'touch /app/mail.jar' ENV JAVA_OPTS='' ENTRYPOINT [ 'sh', '-c', 'java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app/mail.jar' ] EXPOSE 8080 </code></pre>  <p>And a simple <strong>ApplicationController</strong></p>  <pre><code>@RestController public class ApplicationController {    private final Environment environment;    @Autowired   public ApplicationController(Environment environment) {     this.environment = environment;   }    @RequestMapping(path = '/')   public Hello hello() {     final Hello hello = new Hello();     hello.setGreeting(environment.getProperty('custom.greeting'));     return hello;   } } </code></pre>  <p>I'm using IntelliJ Docker plugin that automatically map ports 8080(docker):18080(host) and makes app available on <strong>http://localhost:18080</strong></p>  <p><strong>Docker</strong></p>  <ol> <li>server.context-path property isn't applied. App still available with <strong>/</strong> and not with <strong>/mail/</strong></li> <li>custom.greeting property not reads from properties file and controller returns <strong>{'greeting':null}</strong> instead <strong>{'greeting':'Hello YML'}</strong></li> </ol>  <p><strong>Without Docker</strong></p>  <ol start='3'> <li><p>context-path applied properly</p></li> <li><p>custom.greeting property returns by controller properly</p></li> </ol> ",
    "OwnerUserId": "4611579",
    "LastActivityDate": "2020-11-23T14:05:37.003",
    "Title": "Spring Boot can't read application.properties in Docker",
    "Tags": "<spring><docker><intellij-idea><spring-boot><dockerfile>",
    "AnswerCount": "3",
    "CommentCount": "8",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>You have to add the application.properties file in the docker /app/ directory. Ur docker directory structure will be</p>  <pre><code>app    -main.jar    -application.properties </code></pre>  <p>You can do so by using <code>ADD /ur/local/location/application.properties /app/application.properties</code></p>  <p>Then better write this command in your docker file</p>  <pre><code>ENTRYPOINT ['java' ,'-Djava.security.egd=file:/dev/./urandom --spring.config.location=classpath:file:/app/application-properties','-jar','/app/main.jar'] </code></pre>  <p>Your whole dockerFile should look like this:</p>  <pre><code>FROM java:8-jre VOLUME /tmp COPY ./mail.jar /app/mail.jar ADD /ur/local/location/application.properties /app/application.properties ENTRYPOINT ['java' ,'-Djava.security.egd=file:/dev/./urandom --spring.config.location=classpath:file:/app/application-properties','-jar','/app/main.jar'] EXPOSE 8080 </code></pre> "
  },
  {
    "Id": "43313424",
    "PostTypeId": "1",
    "CreationDate": "2017-04-10T00:36:45.593",
    "Score": "9",
    "ViewCount": "1747",
    "Body": "<p>So we have Java microservices written with Spring-Boot, using Consul for service discovery and config management and running in Docker containers.  All of it is working, but when a container dies or a service restarts the old service-id never goes away in Consul and the service forever after shows as 'Failing' in the Consul UI, even though the new container has registered and shows all Green.</p>  <p>We are not using heartbeat - but I cannot find much documentation on what the difference between heartbeat and healthcheck are for Consul.</p>  <p>Here's my bootstrp.yml</p>  <pre><code>spring:   application:     name: my-service   cloud:     config:       enabled: false     consul:       host: ${discovery.host:localhost}       port: ${discovery.port:8500}       config:         watch:           wait-time: 30           delay: 10000          profile-separator: '-'         format: FILES       discovery:         prefer-ip-address: true         instanceId: ${spring.application.name}:${spring.application.instance_id:${random.value}} </code></pre>  <p>There are other settings to enable heartbeat, but the docs say something about this putting more stress on the Consul cluster.</p>  <p>Has anyone managed to get Consul and Spring Boot/Docker services to actually de-register automatically?  It actually doesn't cause any real problems, but it makes the Consul UI pretty useless to actually monitor for up/down services.</p> ",
    "OwnerUserId": "68612",
    "LastEditorUserId": "68612",
    "LastEditDate": "2017-04-18T23:44:33.180",
    "LastActivityDate": "2017-04-27T13:51:33.883",
    "Title": "Consul and Spring Boot services in Docker - not deregistering",
    "Tags": "<java><docker><spring-boot><microservices><consul>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Consul doesn't automatically deregister services.</p>  <p>See <a href='https://groups.google.com/forum/#!topic/consul-tool/slV5xfWRpEE' rel='nofollow noreferrer'>https://groups.google.com/forum/#!topic/consul-tool/slV5xfWRpEE</a> for the hint about the same question. According to that thread you need to either update the config or perform an <a href='https://www.consul.io/api/agent.html#agent_service_register' rel='nofollow noreferrer'>Agent API call</a>. Since the agent is the source of truth, you shouldn't try to update via Catalog API. See <a href='https://github.com/hashicorp/consul/issues/1188#issuecomment-185977469' rel='nofollow noreferrer'>GitHub</a> for details. They also mention at the Google group that you don't necessarily have to deregister services if the node goes down gracefully, but that doesn't seem to be your use case.</p>  <p>Please have a look at <a href='https://stackoverflow.com/questions/32259323/consul-not-deregistering-zombie-services'>Consul not deregistering zombie services</a> for hints about automating the service de-registration using either the api or tools like <a href='https://github.com/gliderlabs/registrator' rel='nofollow noreferrer'>registrator</a>.</p> "
  },
  {
    "Id": "44738469",
    "PostTypeId": "1",
    "CreationDate": "2017-06-24T16:20:56.010",
    "Score": "9",
    "ViewCount": "7110",
    "Body": "<p>I have a spring cloud config server and packaged it as a docker image then I have spring cloud eureka server which is also packaged as docker image.</p>  <p>When I run the two using docker compose I get the following error.</p>  <p><code>discovery-service_1  | 2017-06-24 15:36:12.059  INFO 5 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Fetching config from server at: http://config-service:9001 discovery-service_1  | 2017-06-24 15:36:12.997  WARN 5 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Could not locate PropertySource: I/O error on GET request for 'http://config-service:9001/cls-discovery-service/default': Connection refused (Connection refused); nested exception is java.net.ConnectException: Connection refused (Connection refused) </code></p>  <blockquote>   <p>Although the config service is up and running successfully, discover service still does not find it for some reason.</p> </blockquote>  <p><strong>Docker compose file being used here is this</strong>  <code> version: '2' services:         config-service:                 image: cloudsea/cls-config-service                 ports:                 - 9001:9001                 expose:                 - '9001'         discovery-service:                 image: cloudsea/cls-discovery-service                 depends_on:                 - config-service                 environment:                         CLOUD_SEA_CONFIG_SERVER_URI: http://config-service:9001                         EUREKA_DEFAULT_ZONE_URL: http://discovery-service:8761/eureka/                 ports:                 - 8761:8761                 links:                 - config-service:config-service </code></p>  <p>Below is the <strong>bootstrap.properties</strong> for DISCOVERY SERVICE</p>  <p><code>spring.cloud.config.uri = ${CLOUD_SEA_CONFIG_SERVER_URI:http://localhost:9001} spring.application.name = ${SPRING_APPLICATION_NAME:cls-discovery-service} </code></p>  <p>Below is the <strong>cls-discovery-service.properties</strong> for DISCOVERY SERVICE located in github.</p>  <p><code>server.port=${SERVER_PORT:8761} eureka.client.registerWithEureka: false eureka.client.fetchRegistry: false eureka.client.serviceUrl.defaultZone: ${EUREKA_DEFAULT_ZONE_URL:http://localhost:8761/eureka/} eureka.server.eviction-interval-timer-in-ms: 1000 </code></p>  <p>I am assuming something is wrong with my docker-compose.yml but I am not sure.</p>  <p>Any help will I am stick in this for hours ... heading close to days :(</p> ",
    "OwnerUserId": "3058432",
    "LastActivityDate": "2018-02-06T23:23:47.990",
    "Title": "Spring Cloud Config Server not working with Docker compose",
    "Tags": "<spring-boot><docker-compose><spring-cloud><spring-cloud-netflix><spring-cloud-config>",
    "AnswerCount": "3",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>I solved it by adding this configuration to the <strong>discovery service's bootstrap.yml</strong>.</p>  <pre><code>spring:   cloud:     config:       failFast: true       retry:         initialInterval: 3000         multiplier: 1.3         maxInterval: 5000         maxAttempts: 20 </code></pre>  <p>Then add <strong>spring-boot-starter-aop</strong> and <strong>spring-retry</strong> to the <strong>discovery service's maven dependencies</strong>.</p>  <pre><code>&lt;dependency&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;     &lt;version&gt;${spring-boot-starter-aop.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;     &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;     &lt;version&gt;${spring-retry.version}&lt;/version&gt; &lt;/dependency&gt; </code></pre>  <p>The problem is they're both starting at the same time. But the discovery service depends on the config service.</p>  <p>When you start the discovery service, it's going to say '<strong>Fetching config from server</strong>' again and again until config service is up.</p>  <p><strong>After the config service starts, discovery service is going to get its configuration successfully</strong> and then it's going to start itself.</p> "
  },
  {
    "Id": "51768216",
    "PostTypeId": "1",
    "AcceptedAnswerId": "51769581",
    "CreationDate": "2018-08-09T13:22:18.877",
    "Score": "9",
    "ViewCount": "19101",
    "Body": "<p>I have created some services in spring boot, I have 11 fat jars and I deploy them in docker containers, my doubt was that every jar was consuming between 1 and 1.5 GB of RAM without any use, I check the RAM by running:</p>  <pre><code>docker stats containername </code></pre>  <p>At first I thought that it was the java container and I tried to change to one that uses alpine but nothing changed, so I think the only problem is my jar. Is there a way to change the RAM that the jar is using? Or this behavior is normal because every jar has an embedded tomcat? Or maybe is better to put some jars together and deploy them as war and use only one tomcat for a group of 'jars'? Can someone share his/her experience?,</p>  <p>Thanks in advance.</p> ",
    "OwnerUserId": "5121282",
    "LastEditorUserId": "2115836",
    "LastEditDate": "2019-03-15T09:54:47.457",
    "LastActivityDate": "2019-03-15T09:54:47.457",
    "Title": "Spring boot is consuming too much RAM",
    "Tags": "<docker><spring-boot>",
    "AnswerCount": "3",
    "CommentCount": "5",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>You can set memory usage of docker container using <code>-e JAVA_OPTS='-Xmx64M -Xms64M'</code>.</p>  <p>docker file:</p>  <pre><code>FROM openjdk:8-jre-alpine VOLUME ./mysql:/var/lib/mysql ADD /build/libs/application.jar app.jar ENTRYPOINT exec java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app.jar </code></pre>  <p>image run:</p>  <pre><code> docker run -d --name container-name -p 9100:9100 -e JAVA_OPTS='-Xmx512M -Xms512M'   imagename:tag </code></pre>  <p>Here i set 512Mb memory usage . you can set 1g or as per your requirement. After run using this check your memory usage. it will max 512Mb.</p> ",
    "highest_rated_answer": "<p>This is how Java behaves in general. The JVM takes as much memory as you give it, and it will perform a process called <strong>Garbage collection</strong> (<a href='https://stackoverflow.com/questions/3798424/what-is-the-garbage-collector-in-java'>What is the garbage collector in Java</a>) to free up space once it decides it should do so.</p>  <p>However, if you don't tell your JVM how much memory it can use, it will use the system defaults, which depend on your systems memory and the amount of cores you have. You can verify this using the following command (<a href='https://stackoverflow.com/questions/4667483/how-is-the-default-java-heap-size-determined'>How is the default Java heap size determined</a>):</p>  <pre><code>java -XX:+PrintFlagsFinal -version | grep HeapSize </code></pre>  <p>On my machine, that's an initial heap memory of 256MiB and a maximum heap size of 4GiB. However, that doesn't mean that your application needs it. </p>  <p>A good way of measuring your memory is by using a monitoring tool like jvisualvm. Additionally, you could use actuator's <code>/health</code> endpoint to see the heap memory usage as well.</p>  <p>Your heap memory usage will normally have a sawtooth pattern (<a href='https://stackoverflow.com/questions/7219532/why-a-sawtooth-shaped-graph'>Why a sawtooth shaped graph</a>), where the memory is gradually being used, and eventually freed by the garbage collector.</p>  <p><a href='https://i.stack.imgur.com/c1hou.png' rel='noreferrer'><img src='https://i.stack.imgur.com/c1hou.png' alt='Example of JVisualVM'></a></p>  <p>The memory that is left over after a garbage collection are usually objects that cannot be destroyed because they're still in use. You could see this as your working memory. Now, to configure your <code>-Xmx</code> you'll have to see how your application behaves after trying it out:</p>  <ul> <li>Configure it below your normal memory usage and your application will go out of memory, throwing an <code>OutOfMemoryError</code>.</li> <li>Configure it too low but above your minimal memory usage, and you will see a huge performance hit, due to the garbage collector continuously having to free memory.</li> <li>Configure it too high and you'll reserve memory you won't need in most of the cases, so wasting too much resources.</li> </ul>  <p>From the screenshot above, you can see that my application reserves about 1GiB of memory for heap usage, while it only uses about 30MiB after a garbage collection. That means that it has a way too high <code>-Xmx</code> value, so we could change it to different values and see how the application behaves.</p>  <p>People often prefer to work in powers of 2 (even though there is no limitation, as seen in <a href='https://stackoverflow.com/questions/11465609/jvm-heap-setting-pattern'>jvm heap setting pattern</a>). In my case, I need to go with at least 30MiB, since that's the amount of memory my application uses at all times. So that means I could try <code>-Xmx32m</code>, see how it performs, and adjust if it goes out of memory or performs worse.</p> "
  },
  {
    "Id": "54773058",
    "PostTypeId": "1",
    "CreationDate": "2019-02-19T18:48:48.617",
    "Score": "9",
    "ViewCount": "9227",
    "Body": "<p>I have a Docker image for a spring boot 2 app, in the image I use spring.config.additional-location to pass a some properties stored in a file on the container itself.</p>  <p>Now I want to use this container in another as a layer in another container or use it in a docker-compose file and I may need to override the spring.config.additional-location.</p>  <p>I tried to override it in an ENV variable: <code>SPRING_CONFIG_ADDITIONAL-LOCATION</code> with no success.</p>  <p>What is the proper way to achieve this.</p> ",
    "OwnerUserId": "986437",
    "LastActivityDate": "2019-03-01T19:57:17.787",
    "Title": "spring.config.additional-location as environmental variable",
    "Tags": "<java><spring><spring-boot><docker>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Value for spring.config.additional-location must be a directory path and not a file path. I'm not sure if this is a bug or a feature, since spring.config.location allows both.</p>  <p>For example inside docker-compose.yml you can set spring.config.additional-location as:</p>  <pre><code>version: '3'     services:       myapp:         build: .         environment:                 - 'SPRING_CONFIG_ADDITIONAL-LOCATION=file:/opt/myapp/config/'           - 'SPRING_PROFILES_ACTIVE=production' ... </code></pre>  <p>Then Spring Boot will look up for /opt/myapp/config/application-production.properties file to load properties from.</p>  <p>More about this in <a href='https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html' rel='noreferrer'>Spring Boot Externalized Configuration</a></p> "
  },
  {
    "Id": "58853372",
    "PostTypeId": "1",
    "AcceptedAnswerId": "58853599",
    "CreationDate": "2019-11-14T09:27:45.480",
    "Score": "9",
    "ViewCount": "9609",
    "Body": "<pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ARG JAR_FILE COPY ${JAR_FILE} app.jar ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre>  <p>The above <code>Dockerfile</code> sample is from the official <a href='https://spring.io/guides/gs/spring-boot-docker/' rel='noreferrer'>Spring Boot guide</a> for docker. I would like to know what the security property is used for since I don't usually set that up when running the app on my local development environment but it seems to come up on various containerization guides. Cheers!</p> ",
    "OwnerUserId": "2480182",
    "LastActivityDate": "2020-05-09T21:46:06.053",
    "Title": "What exactly does '-Djava.security.egd=file:/dev/./urandom' do when containerizing a Spring Boot application",
    "Tags": "<spring><spring-boot><docker><spring-security><dockerfile>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>The purpose of that security property is to speed up tomcat startup. By default the library used to generate random number in JVM on Unix systems relies on <code>/dev/random</code>. On docker containers there isn't enough entropy to support <code>/dev/random</code>. See <a href='https://stackoverflow.com/q/26021181/8482479'>Not enough entropy to support <code>/dev/random</code> in docker containers running in boot2docker</a>. The random number generator is used for session ID generation. Changing it to <code>/dev/urandom</code> will make the startup process faster.</p>  <p>Similar question <a href='https://stackoverflow.com/q/28201794/8482479'>Slow startup on Tomcat 7.0.57 because of SecureRandom</a></p> ",
    "highest_rated_answer": "<p>From Java 9 through Java 11 (LTS), this option is to increase the entropy of random numbers generated by the <strong>java.security.SecureRandom</strong> class whilst avoiding the risk of having the code blocked unexpectedly. It configures the JVM:</p>  <ol> <li>To seed the <strong>SecureRandom</strong> class using the <code>/dev/urandom</code> special file on Unix-like  OSes to avoid having the code unexpectedly blocked due to lack of entropy.</li> <li>To use the <em>Deterministic Random Bit Generator (DRBG)</em> mechanisms<br> described in <a href='https://csrc.nist.gov/publications/detail/sp/800-90a/rev-1/final' rel='nofollow noreferrer'>NIST 800-90Ar1</a>. These mechanisms implement modern        algorithms as strong as SHA-512 and AES-256.</li> </ol> "
  },
  {
    "Id": "70085543",
    "PostTypeId": "1",
    "AcceptedAnswerId": "70094866",
    "CreationDate": "2021-11-23T17:48:13.257",
    "Score": "9",
    "ViewCount": "11644",
    "Body": "<p>I'm using testcontainer version <code>1.15.2</code>. Tests are run in intellij on windows 10. I have a wiremock container. By default it listens on the port <code>8080</code>. I would like to map this port to let's say <code>8081</code>. So I do:</p> <pre><code>public WiremockContainer() {     super(&quot;wiremock/wiremock:2.9.0-alpine&quot;);      self()             .waitingFor(Wait.forLogMessage(&quot;.*port:\\\\s*8080.*&quot;, 1)                     .withStartupTimeout(Duration.ofSeconds(25L)))             .withCreateContainerCmdModifier(cmd -&gt; cmd.getHostConfig()                     .withPortBindings(new PortBinding(Ports.Binding.bindPort(8081), new ExposedPort(8080)))             )             .withNetworkAliases(&quot;wiremock&quot;)             .withExposedPorts(8081); } </code></pre> <p>When the container is created it listens on the random port, not the <code>8081</code>[1]. What am I doing wrong ? What should I do to make the container listen on <code>8081</code> instead of the random port ?</p> <p>[1]</p> <ol> <li>I have another container that tries to connect on <code>http://wiremock:8081</code> and keep getting <code>Connection refused</code></li> <li>When I add: <code>.waitingFor((...)forPort(8081)(...)));</code> timeout occurs.</li> </ol> ",
    "OwnerUserId": "2010564",
    "LastEditorUserId": "2010564",
    "LastEditDate": "2021-11-24T12:03:11.203",
    "LastActivityDate": "2023-11-20T09:23:29.550",
    "Title": "Testcontainer cannot configure port binding",
    "Tags": "<java><spring-boot><testcontainers><docker-java><testcontainers-junit5>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>You cannot choose which actual port is used on the host machine. TestContainers chooses one automatically and makes it accessible through <code>getMappedPort(containerPort)</code> method on the container instance. You can also use <code>getFirstMappedPort()</code> if you only have one.</p> <pre><code>Integer hostPort = container.getMappedPort(8080); Integer hostPort = container.getFirstMappedPort(); </code></pre> <p><a href='https://www.testcontainers.org/features/networking/' rel='noreferrer'>https://www.testcontainers.org/features/networking/</a></p> ",
    "highest_rated_answer": "<p>You can use set port bindings</p> <pre><code>List&lt;String&gt; portBindings = new ArrayList&lt;&gt;(); portBindings.add(&quot;5673:5672&quot;); // hostPort:containerPort portBindings.add(&quot;15673:15672&quot;); // hostPort:containerPort container.setPortBindings(portBindings); </code></pre> "
  },
  {
    "Id": "72263445",
    "PostTypeId": "1",
    "CreationDate": "2022-05-16T17:42:50.990",
    "Score": "9",
    "ViewCount": "31669",
    "Body": "<p>I am using a containerized Spring boot application in Kubernetes. But the application automatically exits and restarts with exit code 143 and error message &quot;Error&quot;.</p> <p>I am not sure how to identify the reason for this error.</p> <p>My first idea was that Kubernetes stopped the container due to too high resource usage, as described <a href='https://komodor.com/learn/exit-codes-in-containers-and-kubernetes-the-complete-guide/' rel='noreferrer'>here</a>, but I can't see the corresponding kubelet logs.</p> <p>Is there any way to identify the cause/origin of the <code>SIGTERM</code>? Maybe from spring-boot itself, or from the JVM?</p> ",
    "OwnerUserId": "12344281",
    "LastActivityDate": "2024-02-08T16:00:19.620",
    "Title": "Kubernetes Pod terminates with Exit Code 143",
    "Tags": "<spring-boot><docker><kubernetes><jvm><exit-code>",
    "AnswerCount": "4",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<blockquote> <p>Exit Code 143</p> </blockquote> <ol> <li><p>It denotes that the process was terminated by an <code>external signal</code>.</p> </li> <li><p>The number 143 is a sum of two numbers: 128+x, <code># where x is the signal number sent to the process that caused it to terminate.</code></p> </li> <li><p>In the example, x equals 15, which is the number of the <code>SIGTERM</code> signal, meaning the process was killed forcibly.</p> </li> </ol> <p>Hope this helps better.</p> "
  },
  {
    "Id": "37057772",
    "PostTypeId": "1",
    "AcceptedAnswerId": "37058838",
    "CreationDate": "2016-05-05T18:31:19.767",
    "Score": "8",
    "ViewCount": "27008",
    "Body": "<p>In my project, web app is developed using Spring boot with default tomcat server. I am using NGINX as load-balancer and have configured my spring-boot-web-app in NGINX configuration as follows:</p>  <pre><code>location /spring-boot-web-app {      proxy_pass http://spring-boot-web-app/ }  http {     upstream /spring-boot-web-app {         server &lt;IP_of_spring_boot_app&gt;:&lt;Port_of_spring_boot_app&gt;     } } </code></pre>  <p>Now lets say NGINX IP and port as <strong>nginx_ip</strong> and <strong>nginx_port</strong> respectively. Also working URL for my web app as: <strong><a href='http://web_app_ip:web_app_port/rest/echo/hi' rel='noreferrer'>http://web_app_ip:web_app_port/rest/echo/hi</a></strong></p>  <p>The above URL works fine. But when i try to hit same URI via NGINX it throws 404. URL used via NGINX as:  <a href='http://nginx_ip:nginx_port/spring-boot-web-app/rest/echo/hi' rel='noreferrer'>http://nginx_ip:nginx_port/spring-boot-web-app/rest/echo/hi</a></p>  <p>Is there something i am missing?</p> ",
    "OwnerUserId": "4318036",
    "LastEditorUserId": "1986826",
    "LastEditDate": "2016-05-05T20:35:50.650",
    "LastActivityDate": "2017-01-04T13:10:28.913",
    "Title": "Spring Boot and Nginx integration",
    "Tags": "<nginx><docker><spring-boot><reverse-proxy><proxypass>",
    "AnswerCount": "1",
    "CommentCount": "8",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>This works for me. Can you try this?</p>  <ol> <li><p>Running tomcat</p>  <pre><code>docker run -d -p 8080:8080 --name=tomcat tomcat:8  </code></pre></li> <li><p>Running nginx </p>  <pre><code>docker run -d -p 80:80 --link tomcat:tomcat --name=nginx nginx </code></pre></li> <li><p>Go inside nginx container and update the conf</p>  <pre><code>docker exec -it nginx bash </code></pre>  <p><strong>/etc/nginx/nginx.conf:</strong></p>  <pre><code>server {    listen 80 default_server;   server_name subdomain.domain.com;   location / {       proxy_pass http://tomcat:8080;       proxy_set_header Host      $host;       proxy_set_header X-Real-IP $remote_addr;   } } </code></pre></li> <li><p>Restart nginx service</p>  <pre><code>nginx -s reload </code></pre></li> <li><p>Access the tomcat through nginx from host browser. You may need to add entry to /etc/hosts</p>  <pre><code>http://subdomain.domain.com </code></pre></li> </ol>  <p>Complete nginx conf: <a href='https://gist.github.com/chgangaraju/9c74f73494a8dac54ecea93e5e4d55b5' rel='noreferrer'>nginx.conf</a></p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "39217402",
    "PostTypeId": "1",
    "CreationDate": "2016-08-30T01:12:30.090",
    "Score": "8",
    "ViewCount": "26857",
    "Body": "<p>I am novice to Spring Boot Microservices and Docker.</p> <p>The dockerfile in microservice project:</p> <p><a href='https://i.stack.imgur.com/3TYtK.png' rel='noreferrer'><img src='https://i.stack.imgur.com/3TYtK.png' alt='dockerfile' /></a></p> <p>docker build:</p> <p><a href='https://i.stack.imgur.com/iB8fT.png' rel='noreferrer'><img src='https://i.stack.imgur.com/iB8fT.png' alt='docker build' /></a></p> <p>docker images:</p> <p><a href='https://i.stack.imgur.com/ZZ427.png' rel='noreferrer'><img src='https://i.stack.imgur.com/ZZ427.png' alt='docker images' /></a></p> <p>when running the image, there is an error: Unable to access jarfile register_server.jar</p> <p><a href='https://i.stack.imgur.com/hF9eX.png' rel='noreferrer'><img src='https://i.stack.imgur.com/hF9eX.png' alt='error' /></a></p> <p>Cheers, Sean</p> ",
    "OwnerUserId": "1766812",
    "LastEditorUserId": "-1",
    "LastEditDate": "2020-06-20T09:12:55.060",
    "LastActivityDate": "2019-01-17T18:10:23.123",
    "Title": "Unable to access jarfile when running Docker image",
    "Tags": "<spring><docker><spring-boot>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>You need to specify either the absolute target path or set the <code>WORKDIR</code></p> <h3>Dockerfile Reference - Add</h3> <p><a href='https://docs.docker.com/engine/reference/builder/#add' rel='nofollow noreferrer'>https://docs.docker.com/engine/reference/builder/#add</a></p> <p>The <code>&lt;dest&gt;</code> is an absolute path, or a path relative to <code>WORKDIR</code>, into which the source will be copied inside the destination container. For example:</p> <pre><code>ADD test relativeDir/          # adds &quot;test&quot; to `WORKDIR`/relativeDir/ ADD test /absoluteDir/         # adds &quot;test&quot; to /absoluteDir/  </code></pre> "
  },
  {
    "Id": "39894788",
    "PostTypeId": "1",
    "CreationDate": "2016-10-06T11:28:17.053",
    "Score": "8",
    "ViewCount": "5657",
    "Body": "<p>I'm Facing a FileNotFoundException while loading a JSON file which is in class path of Java jar using docker containers, it is a Spring-Boot application. This JSON file is available in resource folder . I'm Able to see the JSON file in docker under ./target/classes/ path.</p>  <pre><code>Resource resource = resourceLoader.getResource('classpath:folderNm/file.json'); HashMap&lt;String, String&gt; headerMapping = (HashMap&lt;String, String&gt;) parser.parse(new FileReader(resource.getFile().getAbsolutePath())); </code></pre>  <p>But I get this exception:</p>  <pre><code>java.io.FileNotFoundException: class path resource [folderNm/file.json] cannot be resolved to absolute file path because it does not reside in the file system: jar:file:/app.jar!/folderNm/file.json </code></pre>  <p>I tried</p>  <p>-> <code>resource.getFile().getPath();</code> -> <code>resource.getFile().getCanonicalPath();</code> -> '<code>./target/classes/folderName/fileName</code>' (hardcoded FilePath location) -> '<code>/app.jar!/folderNm/file.json</code>' (hardcoded FilePath location)</p>  <pre><code>InputStream inputStream = getClass().getResourceAsStream('xyz.json'); BufferedReader br = new BufferedReader(new InputStreamReader(inputStream, 'UTF-8'));             StringBuilder responseStrBuilder = new StringBuilder();             String inputStr;             while ((inputStr = br.readLine()) != null)                 responseStrBuilder.append(inputStr); </code></pre>  <p>none of the way above are running. Kindly Suggest a way to resolve this issue.</p> ",
    "OwnerUserId": "2324149",
    "LastEditorUserId": "57135",
    "LastEditDate": "2018-02-28T17:12:57.647",
    "LastActivityDate": "2018-02-28T17:12:57.647",
    "Title": "Facing FileNotFoundException while accessing JSON File in classpath using java in docker containers(SprintBootApplication)",
    "Tags": "<java><json><linux><docker><spring-boot>",
    "AnswerCount": "2",
    "CommentCount": "5",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Assuming that in the maven structure (you are using maven, right?) your file is located at <code>src/main/resources/folderName/file.json</code>, the path you pass to <code>getResourceAsStream</code> should be <strong>/folderName/file.json</strong></p>  <p>Actually everything is explained in <a href='https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getResourceAsStream-java.lang.String-' rel='nofollow'>javadocs</a>:</p>  <blockquote>   <p>Before delegation, an absolute resource name is constructed from the   given resource name using this algorithm:</p>      <ul>   <li>If the name begins with a '/' ('\\u002f'), then the absolute name of   the resource is the portion of the name following the '/'. </li>   <li>Otherwise,   the absolute name is of the following form: modified_package_name/name</li>   </ul>      <p>Where the modified_package_name is the package name of this object   with '/' substituted for '.' ('\\u002e').</p> </blockquote>  <p>Basically if you skip the '/' in front, it looks for the <em>folderName</em> inside the package of your class. Following code works fine for me:</p>  <pre><code>    InputStream inputStream = StackTest.class.getResourceAsStream('/folderName/file.json');     BufferedReader br = new BufferedReader(new InputStreamReader(inputStream, 'UTF-8'));     StringBuilder responseStrBuilder = new StringBuilder();     String inputStr;     while ((inputStr = br.readLine()) != null)         responseStrBuilder.append(inputStr);     System.out.println(responseStrBuilder.toString()); </code></pre>  <p>assuming I have my <em>file.json</em> in src/main/resources/folderName. I don't think it has anything to do with docker. Btw, I think you could make use of <a href='https://commons.apache.org/proper/commons-io/javadocs/api-release/org/apache/commons/io/IOUtils.html#toString(java.io.InputStream,%20java.nio.charset.Charset)' rel='nofollow'>Apache Commons IOUtils.toString</a> that helps turning InputStream into a String.</p> "
  },
  {
    "Id": "44125915",
    "PostTypeId": "1",
    "CreationDate": "2017-05-23T04:38:27.997",
    "Score": "8",
    "ViewCount": "16961",
    "Body": "<p>I have a spring boot application that connects to a mongo db and deployed the app with docker.  I am using this docker-compose.yml file, which works fine:</p>  <pre><code>version: '2' services:   db:       container_name: app-db       image: mongo       volumes:         - /data/db:/data/db       ports:         - 27017:27017   web:     container_name: spring-app     image: spring-app     depends_on:       - db     environment:       SPRING_DATA_MONGODB_URI: mongodb://db:27017/appDB       SPRING_DATA_MONGODB_HOST: db     ports:       - 8080:8080 </code></pre>  <p>Currently, the app is using the application.properties file embedded in the spring app docker image (spring-app).  How do I externalize / pass-in the application.properties file using docker-compose?</p>  <p>Thank you for your help</p> ",
    "OwnerUserId": "107216",
    "LastActivityDate": "2020-07-16T23:38:45.787",
    "Title": "docker-compose - externalize spring application.properties",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>You must make use of the Spring Profiles to define the environment variables depending on your requirement.</p>  <pre><code>server:     port: 9000 ---  spring:     profiles: development server:     port: 9001  ---  spring:     profiles: production server:     port: 0 </code></pre>  <p>Reference: <a href='https://docs.spring.io/spring-boot/docs/current/reference/html/howto-properties-and-configuration.html#howto-change-configuration-depending-on-the-environment' rel='noreferrer'>https://docs.spring.io/spring-boot/docs/current/reference/html/howto-properties-and-configuration.html#howto-change-configuration-depending-on-the-environment</a></p>  <p>You can define which profile needs to be picked up during the runtime.</p>  <pre><code>version: '2' services:   db:       container_name: app-db       image: mongo       volumes:         - /data/db:/data/db       ports:         - 27017:27017   web:     container_name: spring-app     image: spring-app     depends_on:       - db     environment:       SPRING_DATA_MONGODB_URI: mongodb://db:27017/appDB       SPRING_DATA_MONGODB_HOST: db       SPRING_PROFILES_ACTIVE=development     ports:       - 8080:8080 </code></pre>  <p>But this will require you to rebuild the docker image if there is a change in the configuration which is not ideal. Here comes the Spring Cloud Config (Vault) comes in handy which helps you to externalize your configuration.</p>  <p><a href='http://cloud.spring.io/spring-cloud-static/spring-cloud-config/1.3.0.RELEASE/' rel='noreferrer'>http://cloud.spring.io/spring-cloud-static/spring-cloud-config/1.3.0.RELEASE/</a></p> "
  },
  {
    "Id": "44157039",
    "PostTypeId": "1",
    "CreationDate": "2017-05-24T11:26:58.923",
    "Score": "8",
    "ViewCount": "3335",
    "Body": "<p>I want to configure my spring interceptor in such a way that with every request it should get called.</p>  <ul> <li>I am using interceptor in API-GATEWAY <strong>(Spring-Boot)</strong></li> <li>From API-GATEWAY I am calling other microservices.</li> <li>The call's to other microservices from API-GATEWAY is working fine.</li> <li>Other Services which I am calling are Node.js Service, on the other hand, my API-Gateway is in spring boot.</li> <li>All the services (Node.js + Spring-Boot) are running on <strong>Docker Container</strong>.</li> </ul>  <p>I am facing an issue in Interceptor. I want to configure it in such a way that with every request it should be called the <code>preHandle()</code> and perform the operations that I have written in it.</p>  <p>I have notice one issue that I want to mention here.</p>  <p><strong>If the services which I am calling is stopped (Not Running), Interceptor is working properly and giving me a response like somename-service not found. If the same services are running at this time Interceptor is not executed.</strong></p>  <p>Here is my code snippet </p>  <pre><code>@EnableEurekaClient @SpringBootApplication @EnableZuulProxy @Configuration public class Application extends WebMvcConfigurerAdapter {      public static void main(String[] args) {         SpringApplication.run(Application.class, args);     }      @Autowired     private TokenValidateInterceptor tokenValidateInterceptor;      @Override     public void addInterceptors(InterceptorRegistry registry) {          registry.addInterceptor(tokenValidateInterceptor).addPathPatterns('/**');       } </code></pre>  <p>Interceptor </p>  <pre><code>@Component public class TokenValidateInterceptor extends HandlerInterceptorAdapter {       @Override     public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {         LOG.info('#### Starting TokenValidateInterceptor.preHandle ####');          String apiKey = null;         try {             apiKey = request.getHeader('apikey');              LOG.info('The request come with apikey ======' + apiKey);              LOG.info('Actual apikey ======' + azureApikey);   } </code></pre> ",
    "OwnerUserId": "7789526",
    "LastEditorUserId": "7789526",
    "LastEditDate": "2017-05-25T13:38:26.887",
    "LastActivityDate": "2020-08-10T12:15:30.360",
    "Title": "How to configure spring interceptor to get called with every request",
    "Tags": "<java><node.js><docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>You have to add this interceptor to your dispatcher xml file:</p>  <pre><code>&lt;?xml version='1.0' encoding='UTF-8'?&gt; &lt;beans xmlns='http://www.springframework.org/schema/beans'     xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'     xmlns:p='http://www.springframework.org/schema/p'     xsi:schemaLocation='http://www.springframework.org/schema/beans      http://www.springframework.org/schema/beans/spring-beans.xsd'&gt;       &lt;bean id='handlerMapping' class='org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping' p:interceptors-ref='tokenInterceptor' /&gt;      &lt;bean id='tokenInterceptor' class='yourpackage.TokenValidateInterceptor' /&gt;  &lt;/beans&gt; </code></pre>  <p>There are few nice samples here:</p>  <ul> <li><a href='https://examples.javacodegeeks.com/enterprise-java/spring/mvc/spring-mvc-interceptor-tutorial/' rel='nofollow noreferrer'>Spring MVC Interceptot</a></li> <li><a href='https://dzone.com/sites/all/files/SpringExample9.zip' rel='nofollow noreferrer'>Dzone Spring Interceptor</a> </li> </ul> "
  },
  {
    "Id": "44689202",
    "PostTypeId": "1",
    "AcceptedAnswerId": "45233417",
    "CreationDate": "2017-06-22T02:34:26.467",
    "Score": "8",
    "ViewCount": "9364",
    "Body": "<p>I have several microservices running in Docker Data Center. I have the same Eureka configuration across the services/applications. But some of the applications are registering with their <code>eth0</code> IP address instead of the container ID. </p>  <p>I have tried setting the <code>preferIpAddress</code> as <code>false</code> but it is not enforcing all the time.</p>  <p>There is no pattern. The same service which registers with container ID during the previous deployment gets registered with IP the other time. I want my services to register always with its container id. Is there a way to enforce it or am I missing something?</p>  <p>Note: I have also cleared all the old docker images from the registry, deployment nodes and tried from the scratch as well.</p>  <p>Eureka Server Config:</p>  <pre><code>eureka:   instance:     hostname: discovery   client:     registerWithEureka: false     fetchRegistry: false     serviceUrl:       defaultZone: http://${eureka.instance.hostname}:8761/eureka/ </code></pre>  <p>Microservices client config (It is same across all the microservices)</p>  <pre><code>eureka:   client:     healthcheck:       enabled: true     serviceUrl:       defaultZone: http://discovery:8761/eureka/   instance:     preferIpAddress: false     metadataMap:       instanceId: ${vcap.application.instance_id:${spring.application.name}:${spring.application.instance_id:${random.value}}} </code></pre>  <p>Eureka Dashboard Snapshot: <a href='https://i.stack.imgur.com/wlBLF.png' rel='nofollow noreferrer'><img src='https://i.stack.imgur.com/wlBLF.png' alt='enter image description here'></a></p> ",
    "OwnerUserId": "2498986",
    "LastEditorUserId": "1033581",
    "LastEditDate": "2018-11-02T10:54:58.280",
    "LastActivityDate": "2021-11-29T01:07:05.323",
    "Title": "Springboot client unable register with Eureka using Docker container id",
    "Tags": "<docker><spring-boot><spring-cloud><netflix-eureka>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>In docker the container-id will be set as the hostname of the container by default. Containers can talk with each other using container-id (or here hostname)</p>  <p>So this issue can be solved by preferring hostname instead of ip. </p>  <p>But only way of making sure that registration happens through hostname is by setting <code>eureka.instance.hostname</code> <a href='https://github.com/spring-cloud/spring-cloud-netflix/issues/2084#issuecomment-312360744' rel='nofollow noreferrer'>reference</a></p>  <p>In docker you can set the container-id at run-time from the hostname by using the entry point as shell script (for example start.sh) and the script should be something similar to</p>  <pre><code>#!/bin/sh export HOST_NAME=`hostname` java -Djava.security.egd=file:/dev/./urandom -Xmx1024m -jar /app.jar </code></pre>  <p>and make sure you add <code>eureka.instance.hostname=${HOST_NAME}</code> in your application.yml</p>  <p>or you can reuse the <code>HOSTNAME</code> variable which is set by default in Docker and configuration becomes <code>eureka.instance.hostname=${HOSTNAME}</code></p>  <p>I have added the same info in <a href='https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#prefer-ip-address' rel='nofollow noreferrer'>documentation</a></p>  <p>Update: looks like this can also be fixed by using <code>endpoint_mode: dnsrr</code> in the compose file (have to confirm). <a href='https://github.com/spring-cloud/spring-cloud-netflix/issues/1820#issuecomment-363814355' rel='nofollow noreferrer'>Refer this</a></p> ",
    "highest_rated_answer": "<p>Try setting <code>eureka.instance.hostname</code> in your client config. </p> "
  },
  {
    "Id": "47266795",
    "PostTypeId": "1",
    "AcceptedAnswerId": "50781480",
    "CreationDate": "2017-11-13T14:34:43.837",
    "Score": "8",
    "ViewCount": "8110",
    "Body": "<p>I took this example <a href='https://github.com/paulc4/microservices-demo' rel='noreferrer'>https://github.com/paulc4/microservices-demo</a> and I created 3 docker images from it, with the following Dockerfiles:</p>  <p>springdocker-registration:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ADD target/microservice-demo-1.1.0.RELEASE.jar app.jar EXPOSE 1111 ENTRYPOINT exec java -jar /app.jar registration </code></pre>  <p>springdocker-accounts:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ADD target/microservice-demo-1.1.0.RELEASE.jar app.jar EXPOSE 2222 ENTRYPOINT exec java -jar /app.jar accounts </code></pre>  <p>springdocker-web:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ADD target/microservice-demo-1.1.0.RELEASE.jar app.jar EXPOSE 3333 ENTRYPOINT exec java -jar /app.jar web </code></pre>  <p>If I run the three images separately everything works ok, the <code>web</code> and <code>accounts</code> services register to the <code>registration</code> service (which is an implementation of the eureka registry) and I can use my application. However when using <code>docker-compose</code> with the following <code>docker-compose.yml</code> file</p>  <pre><code>version: '3.4' services:  registration:   image: springdocker-registration   ports:    - '1111:1111'   accounts:   image: springdocker-accounts   ports:    - '2222:2222'   links:    - registration   depends_on:    - registration   web:   image: springdocker-web   ports:    - '3333:3333'   depends_on:    - registration    - accounts   links:    - registration </code></pre>  <p>the services <code>web</code> and <code>accounts</code> are not able to register to the <code>registration</code> service. Here are the configuration files for the applications:</p>  <p>registration-server.yml:</p>  <pre><code>eureka:   instance:     hostname: localhost   client:       registerWithEureka: false     fetchRegistry: false     serviceUrl:      defaultZone: http://localhost:1111/eureka/  server:   port: 1111     spring:   thymeleaf:     enabled: false  </code></pre>  <p>accounts-server.yml:</p>  <pre><code>spring:   application:      name: accounts-service     freemarker:     enabled: false              thymeleaf:     cache: false                 prefix: classpath:/accounts-server/templates/      error:   path: /error  server:   port: 2222     eureka:   client:     serviceUrl:       defaultZone: http://localhost:1111/eureka   instance:     leaseRenewalIntervalInSeconds: 5        preferIpAddress: true </code></pre>  <p>web-server.yml</p>  <pre><code>spring:   application:     name: web-service    freemarker:     enabled: false        thymeleaf:     cache: false            prefix: classpath:/web-server/templates/     error:   path: /error  eureka:   client:     serviceUrl:       defaultZone: http://localhost:1111/eureka   instance:     leaseRenewalIntervalInSeconds: 5      preferIpAddress: true  server:   port: 3333   </code></pre>  <p>I can post the full console log of <code>docker-compose up</code> but I think this is the interesting point:</p>  <pre><code>1: ERROR RedirectingEurekaHttpClient - Request execution error com.sun.jersey.api.client.ClientHandlerException: java.net.ConnectException: Connection refused (Connection refused)  1: ERROR DiscoveryClient - DiscoveryClient_WEB-SERVICE/e3b5e6b3396c:web-service:3333 - was unable to refresh its cache! status = Cannot execute request on any known server com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server </code></pre> ",
    "OwnerUserId": "1534252",
    "LastEditorUserId": "1534252",
    "LastEditDate": "2017-11-14T08:36:09.360",
    "LastActivityDate": "2020-05-02T19:12:28.273",
    "Title": "Applications not registering to eureka when using docker-compose",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>Since its running in docker, don't use <code>localhost</code>. Docker compose lets you refer to container names.</p>  <pre><code>eureka:   client:     serviceUrl:       defaultZone: http://registration:1111/eureka </code></pre>  <p>Side note: <code>defaultZone</code> must be exact, I spent 2 days wondering why it wouldn't work since intellij auto completes to do <code>default-zone</code> which wont work.</p> ",
    "highest_rated_answer": "<p>For those who are working with docker-compose and if in your services yml file you have the following:</p>  <pre><code>eureka:   client:     serviceUrl:       # Will get overridden in docker-compose       defaultZone: http://localhost:1111/eureka </code></pre>  <p>You can override this in your docker-compose file like below while running <code>docker-compose up</code></p>  <pre><code>version: '3.3' services:   # Other services registered above   web:   image: springdocker-web   environment:     # Important for clients to register with eureka    - eureka.client.serviceUrl.defaultZone=http://registration:8761/eureka/   ports:    - '3333:3333'   depends_on:    - registration    - accounts   links:    - registration </code></pre>  <p>Tested on Docker version 19.03.8</p> "
  },
  {
    "Id": "47321197",
    "PostTypeId": "1",
    "CreationDate": "2017-11-16T03:42:07.823",
    "Score": "8",
    "ViewCount": "6901",
    "Body": "<p>Deploy <code>Spring Cloud</code> project with <code>docker</code>, some code in the <code>pom.xml</code>:</p>  <pre><code>&lt;build&gt;         &lt;plugins&gt;             &lt;plugin&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;             &lt;/plugin&gt;             &lt;!-- tag::plugin[] --&gt;             &lt;plugin&gt;                 &lt;groupId&gt;com.spotify&lt;/groupId&gt;                 &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;                 &lt;version&gt;0.4.3&lt;/version&gt;                 &lt;configuration&gt;                     &lt;imageName&gt;${docker.image.prefix}/${project.artifactId}&lt;/imageName&gt;                     &lt;dockerDirectory&gt;${project.basedir}&lt;/dockerDirectory&gt;                     &lt;resources&gt;                         &lt;resource&gt;                             &lt;targetPath&gt;/&lt;/targetPath&gt;                             &lt;directory&gt;${project.build.directory}&lt;/directory&gt;                             &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;                         &lt;/resource&gt;                     &lt;/resources&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt;             &lt;!-- end::plugin[] --&gt;              &lt;plugin&gt;                 &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                 &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;                 &lt;configuration&gt;                     &lt;skipTests&gt;true&lt;/skipTests&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt;         &lt;/plugins&gt;     &lt;/build&gt; </code></pre>  <p>when i run the command: <code>mvn package docker:build</code>, it throws errors:</p>  <pre><code>[INFO] ------------------------------------------------------------------------ [ERROR] Failed to execute goal com.spotify:docker-maven-plugin:0.4.3:build (default) on project users-microservice: Exception caught: java.util.concurrent.ExecutionException: com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: org.apache.http.conn.HttpHostConnectException: Connect to localhost:2375 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused -&gt; [Help 1] [ERROR] [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch. [ERROR] Re-run Maven using the -X switch to enable full debug logging. [ERROR] [ERROR] For more information about the errors and possible solutions, please read the following articles: [ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException [ERROR] [ERROR] After correcting the problems, you can resume the build with the command </code></pre>  <p>why will it connect to localhost:2375? Any idea, i will appreciate!</p> ",
    "OwnerUserId": "5443977",
    "LastEditorUserId": "5443977",
    "LastEditDate": "2017-11-17T03:13:11.887",
    "LastActivityDate": "2017-11-25T09:33:56.050",
    "Title": "Failed to execute goal com.spotify:docker-maven-plugin:0.4.3:build Exception caught: HttpHostConnectException: Connect to localhost:2375",
    "Tags": "<docker><spring-boot><maven-3><spring-cloud>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Please update your <code>docker-maven-plugin</code>'s version from 0.4.3 to 1.0.0</p>  <pre><code>&lt;build&gt;         &lt;plugins&gt;             &lt;plugin&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;             &lt;/plugin&gt;             &lt;!-- tag::plugin[] --&gt;             &lt;plugin&gt;                 &lt;groupId&gt;com.spotify&lt;/groupId&gt;                 &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;                 &lt;version&gt;1.0.0&lt;/version&gt;                 &lt;configuration&gt;                     &lt;imageName&gt;${docker.image.prefix}/${project.artifactId}&lt;/imageName&gt;                     &lt;dockerDirectory&gt;${project.basedir}&lt;/dockerDirectory&gt;                     &lt;resources&gt;                         &lt;resource&gt;                             &lt;targetPath&gt;/&lt;/targetPath&gt;                             &lt;directory&gt;${project.build.directory}&lt;/directory&gt;                             &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;                         &lt;/resource&gt;                     &lt;/resources&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt;             &lt;!-- end::plugin[] --&gt;              &lt;plugin&gt;                 &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                 &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;                 &lt;configuration&gt;                     &lt;skipTests&gt;true&lt;/skipTests&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt;         &lt;/plugins&gt;     &lt;/build&gt; </code></pre> "
  },
  {
    "Id": "48359972",
    "PostTypeId": "1",
    "AcceptedAnswerId": "48360582",
    "CreationDate": "2018-01-20T19:01:14.387",
    "Score": "8",
    "ViewCount": "14597",
    "Body": "<p>I am attempting to build a 'service' consisting of a Spring Boot application and PostgreSQL database. I have been able to access the database (running in a container) from the Spring Boot app while the Spring Boot application was running on my local machine. Now, when I attempt to move the Spring Boot application to a container, I am received the following error:</p>  <pre><code>inventory_1  | 2018-01-20 18:43:06.108 ERROR 1 --- [nio-8080-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.transaction.CannotCreateTransactionException: Could not open JPA EntityManager for transaction; nested exception is org.hibernate.exception.JDBCConnectionException: Unable to acquire JDBC Connection] with root cause inventory_1  | inventory_1  | java.net.ConnectException: Connection refused (Connection refused) </code></pre>  <p>However, I am able to connect to DB from my local machine: <code>psql -h localhost -p 5000 -U kelly_psql -d leisurely_diversion</code></p>  <p>My application.properties file:</p>  <pre><code>spring.jpa.hibernate.ddl-auto=none spring.jpa.show-sql=false spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect spring.datasource.url=jdbc:postgresql://localhost:5432/leisurely_diversion spring.datasource.username=kelly_psql spring.datasource.password=pass spring.datasource.driver-class-name=org.postgresql.Driver </code></pre>  <p>My docker-compose file:</p>  <pre><code>    # Use postgres/example user/password credentials version: '3.2'  services:   db:     image: postgres     ports:       - 5000:5432     environment:       POSTGRES_PASSWORD: example     volumes:       - type: volume         source: psql_data         target: /var/lib/postgresql/data     networks:        - app     restart: always   inventory:     image: kellymarchewa/inventory_api     depends_on:         - db     ports:       - 8080:8080     networks:       - app     restart: always volumes:   psql_data: networks:    app: </code></pre>  <p>My Dockerfile (from the <a href='https://spring.io/guides/gs/spring-boot-docker/' rel='noreferrer'>Spring website</a>)</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ARG JAR_FILE ADD ${JAR_FILE} app.jar ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre>  <p>I suspect the issue lies in a misunderstanding (on my part) of Docker or containers, but I am not sure. Any advice would be appreciated.</p> ",
    "OwnerUserId": "4783710",
    "LastEditorUserId": "2597143",
    "LastEditDate": "2018-01-21T15:35:31.800",
    "LastActivityDate": "2020-09-16T11:15:30.143",
    "Title": "Spring Boot, PostgreSQL, and Docker - Connection Refused whil Running in Container",
    "Tags": "<spring><postgresql><docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>You are pointing your application towards <code>localhost</code>, but this is not shared between containers.</p>  <p>To access another container you have to refer to its <code>hostname</code>.</p>  <p>In your case, I understand that you want the <code>inventory</code> service to access the <code>db</code> service. So you should use the following <code>datasource</code> url:</p>  <pre><code>spring.datasource.url=jdbc:postgresql://db:5432/leisurely_diversion </code></pre>  <p>See this simple tutorial about connecting to a container from another container with docker compose: <a href='https://docs.docker.com/compose/gettingstarted/' rel='noreferrer'>https://docs.docker.com/compose/gettingstarted/</a></p> ",
    "highest_rated_answer": "<p>Like in my case if you are using <strong>Docker Toolbox</strong> for windows 8.1 then you cannot use &quot;localhost&quot;,</p> <p>Instead you have to use docker machine ip;</p> <pre><code> host&gt; docker-machine ip default   192.168.99.100 </code></pre> <p>After that your url will look like;</p> <pre><code> spring.datasource.url=jdbc:postgresql://192.168.99.100:5432/bankdb </code></pre> <p>This will successfully connect to docker Postgres DB.</p> <p>Cheers!!</p> "
  },
  {
    "Id": "49941955",
    "PostTypeId": "1",
    "AcceptedAnswerId": "51043076",
    "CreationDate": "2018-04-20T12:44:51.257",
    "Score": "8",
    "ViewCount": "11090",
    "Body": "<p>If I try to build a Docker container with a Spring Boot application under Windows 10, I get the following error:</p>  <pre><code>&gt; Task :docker FAILED COPY failed: stat /var/lib/docker/tmp/docker-builder711841135/myproject.jar: no such file or directory </code></pre>  <p>I'm using Docker Community Edition in version 18.03.0-ce-win59 (16762) and Gradle 4.7 with Java 8.</p>  <p><strong>build.gradle</strong> (shortened):</p>  <pre><code>plugins {     id 'java'     id 'org.springframework.boot' version '2.0.1.RELEASE'     id 'com.palantir.docker' version '0.19.2' }  version = '2.0.0' sourceCompatibility = 1.8 group = 'com.example'  repositories {     mavenCentral() }  bootJar {     archiveName 'myproject.jar' }  dependencies {     ... }  docker {     dependsOn(build)     name '${project.group}/${jar.baseName}'     files bootJar } </code></pre>  <p><strong>Dockerfile</strong> (sibling of build.gradle in the top-level project directory):</p>  <pre><code>FROM openjdk:8-jre COPY build/libs/myproject.jar myproject.jar  ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/myproject.jar'] </code></pre>  <p>If I build the Docker container with Docker only (without Gradle) it works.</p>  <p>How can I let Gradle (or Docker?) find the file myproject.jar?</p> ",
    "OwnerUserId": "238134",
    "LastEditorUserId": "238134",
    "LastEditDate": "2018-04-20T14:07:26.917",
    "LastActivityDate": "2021-06-23T03:48:16.967",
    "Title": ".jar file not found when building a Docker container with Palantir Gradle plug-in",
    "Tags": "<java><docker><spring-boot><gradle>",
    "AnswerCount": "5",
    "CommentCount": "8",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>The problem is the <code>COPY</code> command in the Docker file:</p>  <pre><code>COPY build/libs/myproject.jar myproject.jar </code></pre>  <p>The source directory <code>build/libs/</code> is not where the files for building the Docker container reside. Instead the directory <code>build/docker/</code> is used as Docker build context. When <code>COPY</code> is executed this directory is the effective working directory. </p>  <p>The correct <code>COPY</code> command is as simple as this:</p>  <pre><code>COPY myproject.jar / </code></pre>  <p>Docker task:</p>  <pre><code>docker {     dependsOn bootJar     name '${project.group}/${jar.baseName}:${version}'     files bootJar.archivePath } </code></pre>  <p>If you want to copy resources too, you need to add <code>processResources</code> to the <code>files</code> parameter:</p>  <pre><code>files bootJar.archivePath, processResources </code></pre> ",
    "highest_rated_answer": "<p>It works with following config of the <code>docker</code> task:</p>  <pre><code>docker {     dependsOn build     name '${project.group}/${jar.baseName}'     files bootJar.archivePath     buildArgs(['JAR_FILE': '${bootJar.archiveName}']) } </code></pre>  <p>Using this slightly different docker file:</p>  <pre><code>FROM openjdk:8-jre ARG JAR_FILE COPY ${JAR_FILE} app.jar ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre> "
  },
  {
    "Id": "50216280",
    "PostTypeId": "1",
    "AcceptedAnswerId": "50222583",
    "CreationDate": "2018-05-07T14:09:25.160",
    "Score": "8",
    "ViewCount": "62148",
    "Body": "<p>The docker container is not able to access the jar file, that is being accessed over the mount point <code>/my/project/dir</code>. I am certain it is not a permission issue, because I changed the access rights locally, so it should be able to read/write/execute it.</p>  <p>This is the <code>Dockerfile</code>:</p>  <pre><code>FROM tomcat:9-jre8 RUN apt-get update &amp;&amp; apt-get install librrds-perl rrdtool -y VOLUME ['/data/rrdtool', '/my/project/dir'] ENTRYPOINT [ 'java','-jar','/my/project/dir/build/libs/spring-project-0.1.0.jar' ] </code></pre>  <p>And this is the <code>docker-compose.yml</code> file:</p>  <pre><code>version: '2' services:  db:    container_name: db1    image: mysql:8    restart: always    environment:      MYSQL_ROOT_PASSWORD: password123      MYSQL_USER: user123      MYSQL_PASSWORD: pasw      MYSQL_DATABASE: mydb    expose:      - '3307'  db2:    container_name: db2    image: mysql:8    restart: always    environment:      MYSQL_ROOT_PASSWORD: password123      MYSQL_USER: user123      MYSQL_PASSWORD: pasw      MYSQL_DATABASE: mydb2    expose:      - '3308'  spring:    container_name: spring-boot-project    build:       context: ./      dockerfile: Dockerfile    links:      - db:db1      - db2:db2    depends_on:      - db      - db2    expose:      - '8081'    ports:      - '8081:8081'    restart: always </code></pre>  <p>This is the output from <code>docker-compose logs spring</code>:</p>  <pre><code>Error: Unable to access jarfile /my/project/dir/build/libs/spring-project-0.1.0.jar </code></pre> ",
    "OwnerUserId": "5703530",
    "LastEditorUserId": "5703530",
    "LastEditDate": "2018-05-07T18:25:15.080",
    "LastActivityDate": "2022-09-12T12:19:49.007",
    "Title": "Docker unable to access jar file",
    "Tags": "<java><docker><spring-boot><jar><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "4",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>I don't see you copying the <code>jar</code> into the container anywhere. You should try moving a <code>VOLUME</code> declaration from <code>Dockerfile</code> to the <code>compose</code> file into the <code>spring</code> service  like this:</p>  <pre><code>  volumes:     - /my/project/dir:/app </code></pre>  <p>And then inside Dockerfile you should point to the dir:</p>  <pre><code>ENTRYPOINT [ 'java','-jar','/app/build/libs/spring-project-0.1.0.jar' ] </code></pre>  <p>Later on if you'd like to deploy it (for example) you should copy the project files directly into the image instead of utilizing the <code>volumes</code> approach. So in <code>Dockerfile</code> you'd then do:</p>  <pre><code>COPY . /app </code></pre>  <p>instead of <code>VOLUME [..]</code></p>  <p><strong>Putting it all together:</strong></p>  <p><strong>development:</strong></p>  <p>Dockerfile:</p>  <pre><code>FROM tomcat:9-jre8 RUN apt-get update &amp;&amp; apt-get install librrds-perl rrdtool -y ENTRYPOINT [ 'java','-jar','/app/build/libs/spring-project-0.1.0.jar' ] </code></pre>  <p>compose-file:</p>  <pre><code>version: '2' services:     [..]     spring:        container_name: spring-boot-project        build: .        links:          - db:db1          - db2:db2        depends_on:          - db          - db2        ports:          - '8081:8081'        restart: always        volumes:          - /my/project/dir:/app </code></pre>  <p><strong>deployment:</strong></p>  <p>Dockerfile (that is placed inside project's folder, docker build requires it's build context to be in a current directory):</p>  <pre><code>FROM tomcat:9-jre8 RUN apt-get update &amp;&amp; apt-get install librrds-perl rrdtool -y COPY . /app ENTRYPOINT [ 'java','-jar','/app/build/libs/spring-project-0.1.0.jar' ] </code></pre>  <p>compose-file:</p>  <pre><code>version: '2' services:     [..]     spring:        container_name: spring-boot-project        build: .        links:          - db:db1          - db2:db2        depends_on:          - db          - db2        expose:          - '8081' </code></pre> ",
    "highest_rated_answer": "<p>If you are using <code>Spring-Boot</code> Project with <code>Maven</code> build. Try with below</p> <p><strong>Dockerfile</strong>.</p> <pre><code>FROM maven:3.8.4-openjdk-17 as maven-builder COPY src /app/src COPY pom.xml /app  RUN mvn -f /app/pom.xml clean package -DskipTests FROM openjdk:17-alpine  COPY --from=maven-builder app/target/dockube-spring-boot.jar /app-service/dockube-spring-boot.jar WORKDIR /app-service  EXPOSE 8080 ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;dockube-spring-boot.jar&quot;] </code></pre> <blockquote> <p>dockube-spring-boot.jar // replace with your generated jar name</p> </blockquote> <p>Here is the <a href='https://github.com/Maheshbhusanoor/dockube-spring-boot' rel='nofollow noreferrer'>Sample Code Available</a></p> "
  },
  {
    "Id": "52933220",
    "PostTypeId": "1",
    "AcceptedAnswerId": "52934014",
    "CreationDate": "2018-10-22T15:49:48.663",
    "Score": "8",
    "ViewCount": "18844",
    "Body": "<p>We working in small team of 4 people. We using docker to deploy our services. One of the services is a java Spring Boot project which is deployed after building docker image with maven. To make docker image of Spring Boot service we use <code>mvn clean package dockerfile:build</code>.</p>  <p>The fun part is that my colleagues have no problem building docker image of Spring Boot service. And I get maven error message:</p>  <pre><code>[ERROR] Failed to execute goal com.spotify:dockerfile-maven-plugin:1.3.6:build (default-cli) on project 'foo': Could not build image: com.spotify.docker.client.shaded.com.fasterxml.jackson.databind.JsonMappingException: Can not construct instance of com.spotify.docker.client.messages.RegistryAuth: no String-argument constructor/factory method to deserialize from String value ('osxkeychain') </code></pre>  <p>I tried to remove all maven repositories from <code>.m2/repository</code>, restart docker, and remove all images.</p>  <p>Later I tried to run <code>mvn clean package dockerfile:build</code> in to two separate commands:</p>  <ul> <li><code>mvn package</code>, then</li> <li><code>mvn docker:build</code></li> </ul>  <p><code>mvn package</code> passed, and <code>mvn docker:build</code> failed with the same error as shown above.</p>  <p>Maven version <code>3.5.4</code>, Docker version <code>18.06.1-ce, build e68fc7a</code>, OS: macOS mojave</p>  <p>I even tried to restart my PC hoping that it will fix it...</p>  <p>Edited: Here is the maven pom plugin <code>dockerfile-maven-plugin</code></p>  <pre><code>... &lt;plugin&gt;     &lt;groupId&gt;com.spotify&lt;/groupId&gt;     &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;     &lt;version&gt;1.3.6&lt;/version&gt;     &lt;configuration&gt;         &lt;repository&gt;${project.artifactId}&lt;/repository&gt;     &lt;/configuration&gt; &lt;/plugin&gt; ... </code></pre>  <p>Edit 2:</p>  <p>Full error message:</p>  <pre><code>[ERROR] Failed to execute goal com.spotify:dockerfile-maven-plugin:1.3.6:build (default) on project spring-boot-service: Could not build image: com.spotify.docker.client.shaded.com.fasterxml.jackson.databind.JsonMappingException: Can not construct instance of com.spotify.docker.client.messages.RegistryAuth: no String-argument constructor/factory method to deserialize from String value ('swarm') [ERROR]  at [Source: N/A; line: -1, column: -1] (through reference chain: java.util.LinkedHashMap['stackOrchestrator']) [ERROR] -&gt; [Help 1] [ERROR]  [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch. [ERROR] Re-run Maven using the -X switch to enable full debug logging. [ERROR]  [ERROR] For more information about the errors and possible solutions, please read the following articles: [ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException </code></pre>  <p>Edit 3:</p>  <p>docker-compose.yml</p>  <pre><code>wrapper:   image: spring-boot-service:latest ports:   - '8080:8080' expose:   - '8080' links:   - db   - another-service </code></pre>  <p>Solved:</p>  <p>In my case it was wrong version of <code>dockerfile-maven-plugin</code>. I used <code>1.3.6</code>, and <code>1.4.7</code> fixed the problem. </p>  <p>Thanks to <a href='https://stackoverflow.com/users/3301492/boris'>Boris</a>!</p>  <p>Update: One more thing!</p>  <p>Make sure when <code>mvn</code> finish build naming is correct, for example:</p>  <pre><code>[INFO] Successfully built **spring-boot-service:0.0.1-SNAPSHOT** </code></pre>  <p>And <code>docker-compose.yml</code> should look like this:</p>  <pre><code>... wrapper:   image: **spring-boot-service:0.0.1-SNAPSHOT** ... </code></pre> ",
    "OwnerUserId": "5834613",
    "LastEditorUserId": "5834613",
    "LastEditDate": "2018-10-22T17:35:29.400",
    "LastActivityDate": "2022-08-11T11:28:21.330",
    "Title": "Failed to execute goal com.spotify:dockerfile-maven-plugin:1.3.6:build on project 'foo': Could not build image:",
    "Tags": "<java><maven><docker><spring-boot>",
    "AnswerCount": "2",
    "CommentCount": "4",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>Here is the <a href='https://github.com/spotify/dockerfile-maven/tree/master/plugin' rel='nofollow noreferrer'>dockerfile-maven-plugin</a> config:</p> <pre class='lang-xml prettyprint-override'><code>&lt;plugin&gt;   &lt;groupId&gt;com.spotify&lt;/groupId&gt;   &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;   &lt;version&gt;${dockerfile-maven-plugin.version}&lt;/version&gt;   &lt;executions&gt;     &lt;execution&gt;       &lt;id&gt;default&lt;/id&gt;       &lt;goals&gt;         &lt;goal&gt;build&lt;/goal&gt;         &lt;goal&gt;push&lt;/goal&gt;       &lt;/goals&gt;     &lt;/execution&gt;   &lt;/executions&gt;   &lt;configuration&gt;     &lt;repository&gt;${project.artifactId}&lt;/repository&gt;     &lt;tag&gt;${project.version}&lt;/tag&gt;     &lt;buildArgs&gt;       &lt;JAR_FILE&gt;target/${project.build.finalName}.jar&lt;/JAR_FILE&gt;     &lt;/buildArgs&gt;   &lt;/configuration&gt; &lt;/plugin&gt; </code></pre> <p><strong>NOTE:</strong> use the latest released version <a href='https://search.maven.org/artifact/com.spotify/dockerfile-maven-plugin' rel='nofollow noreferrer'>1.4.7</a></p> <p>This configures the plugin to build and push your image with a <a href='https://github.com/spotify/dockerfile-maven#consistent-build-lifecycle' rel='nofollow noreferrer'>single command</a>:</p> <pre class='lang-bash prettyprint-override'><code>$ mvn clean deploy </code></pre> <p>If you only want to build the Docker image, run:</p> <pre class='lang-bash prettyprint-override'><code>$ mvn clean package </code></pre> ",
    "highest_rated_answer": "<p>Solution:</p> <ol> <li>Go to docker desktop</li> <li>Open settings</li> <li>Go to general and put tick on Expose daemon on tcp://localhost:2375 without TLS <a href='https://i.stack.imgur.com/0FJ6S.png' rel='nofollow noreferrer'>enter image description here</a></li> </ol> "
  },
  {
    "Id": "53407287",
    "PostTypeId": "1",
    "CreationDate": "2018-11-21T07:39:54.870",
    "Score": "8",
    "ViewCount": "18758",
    "Body": "<p>I have a spring boot project which I'd like to containerize using docker. I have a couple of spring boot applications which connect to same MySql server.</p>  <p>My spring applications requires the database to be completely setup (i.e. all the tables to be created and some data to be inserted in some of the tables) in order to start.</p>  <p>I am using <strong>Docker</strong> version <strong>18.09.0</strong> and <strong>docker-compose</strong> version <strong>1.23.1</strong> and ubuntu <strong>16.04</strong> LTS</p>  <hr>  <p>I have two files <strong><code>create.sql</code></strong> and <strong><code>insert.sql</code></strong>, which I use to initialise the database to be used by the application.</p>  <p>I create the images using the command <strong><code>docker-compose.yml</code></strong> and it runs successfully and creates the images.</p>  <p>I have the following questions.</p>  <ol> <li><p>I assume when using docker-compose, a container starts as soon as all its dependent containers have started. Is there a way to wait for the mysql server to be up and ready to accept connections, before my API container gets started?</p></li> <li><p>If I chose to create containers separately for the applications and mysql, and not use docker-compose, how do I make sure that my applications connect to the mysql container?</p></li> <li><p>Is there any other tool which might help me achieve this?</p></li> </ol>  <p><strong>Note:</strong> I have tried to use <strong><code>docker inspect &lt;container_id&gt;</code></strong> to find the the IpAddress for the mysql container and use it to connect, but it doesn't work as well.</p>  <hr>  <p>The following are the files I am using to create images.</p>  <p><strong><code>docker-compose.yml</code></strong> file.</p>  <pre><code>version: '3'  services:   demo-mysql:     image: demo-mysql     build: ./demo-mysql     volumes:       - /mnt/data/mysql-data:/var/lib/mysql     ports:       - 3306:3306     environment:       - MYSQL_ROOT_PASSWORD=root       - MYSQL_DATABASE=demo       - MYSQL_PASSWORD=root    demo-api:     image: demo-api-1.0     build: ./api     depends_on:       - demo-mysql     ports:       - 8080:8080     environment:       - DATABASE_HOST=demo-mysql       - DATABASE_USER=root       - DATABASE_PASSWORD=root       - DATABASE_NAME=demo       - DATABASE_PORT=3306    demo1-app:     image: demo1-app-1.0     build: ./demo1     depends_on:       - demo-mysql     ports:       - 8090:8090     environment:       - DATABASE_HOST=demo-mysql       - DATABASE_USER=root       - DATABASE_PASSWORD=root       - DATABASE_NAME=demo       - DATABASE_PORT=3306 </code></pre>  <p>The following is the <strong><code>Dockerfile</code></strong> for the spring boot project</p>  <pre><code>FROM java:8  VOLUME /tmp  ARG DATA_PATH=/src/main/resources ARG APP_PORT=8080  EXPOSE ${APP_PORT}  ADD /build/libs/demo-api.jar demo-api.jar  ENTRYPOINT ['java','-jar','demo-api.jar'] </code></pre>  <p>The following is the <strong><code>Dockerfile</code></strong> I used to create my mysql image</p>  <pre><code>FROM mysql:5.7  ENV MYSQL_DATABASE=demo \\     MYSQL_USER=root \\     MYSQL_ROOT_PASSWORD=root  ADD ./1.0/create.sql /docker-entrypoint-initdb.d ADD ./1.0/insert.sql /docker-entrypoint-initdb.d  EXPOSE 3306 </code></pre> ",
    "OwnerUserId": "5788945",
    "LastActivityDate": "2023-10-15T19:43:52.260",
    "Title": "Docker compose wait for database service initialisation",
    "Tags": "<mysql><spring-boot><docker><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Use the <code>healthcheck</code> feature of docker-compose (<a href='https://docs.docker.com/compose/compose-file/#healthcheck' rel='nofollow noreferrer'>https://docs.docker.com/compose/compose-file/#healthcheck</a>).  Something like this:</p>  <pre><code>services:   demo-mysql:     image: demo-mysql     build: ./demo-mysql     volumes:       - /mnt/data/mysql-data:/var/lib/mysql     ports:       - 3306:3306     environment:       - MYSQL_ROOT_PASSWORD=root       - MYSQL_DATABASE=demo       - MYSQL_PASSWORD=root     healthcheck:       test: ['CMD-SHELL', 'mysqladmin ping']       interval: 10s       timeout: 2s       retries: 10 </code></pre>  <p>The depending containers will not start until the demo-mysql container is healthy</p> "
  },
  {
    "Id": "54616163",
    "PostTypeId": "1",
    "CreationDate": "2019-02-10T12:03:09.857",
    "Score": "8",
    "ViewCount": "31366",
    "Body": "<p>I wanted to build my springboot project. Then I want to dockerize my code. But when I built, I got error. I think this occured caused by postgresql setting. But I could not find reason. </p>  <p>Could you please help me?</p>  <pre><code>docker-compose.yml file;  version: '2' services:   web:     build: .     ports:       - 8080:8080   db:     container_name: productdb     image: postgres:9.5     volumes:     - sample_db:/var/lib/postgresql/data     environment:     - POSTGRES_PASSWORD=bright     - POSTGRES_USER=postgres     - POSTGRES_DB=productdb     - PGDATA=/var/lib/postgresql/data/pgdata     ports:     - '5432:5432'  volumes:   productdb: {} </code></pre>  <p>application.yml file;</p>  <pre><code>server:   port: 8761 eureka:   client:   registerWithEureka: false   fetchRegistry: false   server:   enableSelfPreservation: false   waitTimeInMsWhenSyncEmpty: 0  spring:   application:     name: product-service   datasource:     url: jdbc:postgresql://db:5432/productdb     username: postgres     password: xxxx     initialization-mode: always   jpa:     show-sql: true     hibernate:       ddl-auto:     properties:       hibernate:         temp:           use_jdbc_metadata_defaults: false </code></pre>  <p>Error looks like;</p>  <p>org.postgresql.util.PSQLException: The connection attempt failed.</p>  <p>Thank you</p> ",
    "OwnerUserId": "2152509",
    "LastEditorUserId": "2152509",
    "LastEditDate": "2019-02-11T10:31:53.677",
    "LastActivityDate": "2022-12-14T03:34:06.037",
    "Title": "How do I solve postgresql error 'connection attempt failed'?",
    "Tags": "<postgresql><spring-boot><docker>",
    "AnswerCount": "3",
    "CommentCount": "4",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>If your docker-compose.yml file is well configured, it should be start two containers:</p>  <pre><code>docker ps </code></pre>  <p><a href='https://i.stack.imgur.com/JNaAv.png' rel='nofollow noreferrer'><img src='https://i.stack.imgur.com/JNaAv.png' alt='docker ps'></a> source: <a href='https://intelligentbee.com/2017/09/18/setup-docker-symfony-project/' rel='nofollow noreferrer'>https://intelligentbee.com/2017/09/18/setup-docker-symfony-project/</a></p>  <p>One for app and one for db. </p>  <p>These containers are in the same host, so if your web need to connect to the database, you must the ip instead : localhost, 127.0.0.1 or 0.0.0.0 </p>  <p>You cat get  the ip with this</p>  <pre><code>hostname -I| awk '{printf $1}' </code></pre>  <p>If your web and your database would be in different host, you can use the public ip where is hosted the database. But as you are using <strong>docker-compose</strong> this is not the case.</p>  <p>I suggest you to test if your database is ready and available, before using it in your web app.</p>  <p>In order to test your database , You can following one of these approaches:</p>  <hr>  <h1>Check db status with telnet</h1>  <p>There are several way , but the easiest option is the <strong>telnet</strong> command. For instance, in order to test if mysql container is ready to use in the same machine where was started:</p>  <pre><code>telnet localhost 3306 </code></pre>  <p>If your mysql is ready, telnet must show you a result like the following picture:</p>  <p><a href='https://i.stack.imgur.com/KHmfJ.png' rel='nofollow noreferrer'><img src='https://i.stack.imgur.com/KHmfJ.png' alt='telnet ok mysql'></a></p>  <p>Any other negative result, would indicate that your mysql container is exited or wrong.</p>  <p><strong>Note:Change 3306 for the correct postgress port</strong></p>  <hr>  <h1>Check db status with Database IDE</h1>  <p>Other option for UI users is testing the database connection using some Database IDE. Just download one of the several postgress client IDEs and testing your database.</p>  <hr>  <h1>Don't hardcode parameters</h1>  <p>It is a good practice to externalize configuration using environment variables. Spring and docker <strong>know</strong> and allow us to use them. </p>  <p>So, modify your <strong>application.yml</strong> :</p>  <p>From </p>  <pre><code>datasource:     url: jdbc:postgresql://db:5432/productdb </code></pre>  <p>To</p>  <pre><code>datasource:     url: jdbc:postgresql://${DATABASE_HOST}:5432/productdb </code></pre>  <p>For <strong>development</strong>, in your eclipse use <a href='https://raw.githubusercontent.com/jrichardsz/static_resources/master/eclipse/eclipse-env.png' rel='nofollow noreferrer'>run as configurations  >> environment section</a></p>  <p>For <strong>production</strong> you can:</p>  <ul> <li>export variable before <strong>run</strong></li> <li>pass it to your docker run sentence...</li> </ul>  <pre><code>docker run -d \\ --name my_funny_api \\ -p 8080:8080 \\ -e 'DATABASE_HOST=10.10.01.52' \\ -i -t my_funny_api_image </code></pre>  <p>or</p>  <pre><code>export HOST_IP=$(hostname -I| awk '{printf $1}')  docker run -d \\ --name my_funny_api \\ -p 8080:8080 \\ -e 'DATABASE_HOST=${DATABASE_HOST}' \\ -i -t my_funny_api_image </code></pre>  <ul> <li>Finally to avoid manually task to manage your variables, you can use : <a href='http://github.com/jrichardsz/tachikoma-ops' rel='nofollow noreferrer'>http://github.com/jrichardsz/tachikoma-ops</a></li> </ul> "
  },
  {
    "Id": "54928051",
    "PostTypeId": "1",
    "AcceptedAnswerId": "54929485",
    "CreationDate": "2019-02-28T14:34:45.250",
    "Score": "8",
    "ViewCount": "6630",
    "Body": "<p>i have technical problem trying solving when deploying my app spring boot app with docker container.</p>  <blockquote>   <p>org.apache.kafka.common.KafkaException: org.apache.kafka.common.KafkaException: Failed to load SSL keystore /tmp/tomcat-docbase.4737956707529585395.8080/deployments/app/certs/kafka.truststore.jks</p> </blockquote>  <p>/deployments is my workdir configure in dockerfile</p>  <p>i find it strange that it picking on tmp/tomcat docbase because when configuring for other truststore it getting in the correct place. Here what inside my application.yaml</p>  <pre><code>spring:    kafka:      bootstrap-servers:localhost:9092      ssl:        truststore-location: /deployments/app/certs/kafka-truststore.jks        truststore-password: test      consumer:       group-id: consumerid server:    ssl:     enabled: false     key-store: /deployments/app/certs/dp--dev.jks     key-store-password: changeit     trust-store: /deployments/app/certs/ol-truststore-dev.jks     trust-store-password: test </code></pre>  <p>it something that i am missing or it relate to kafka springframework lib that i am using ?</p> ",
    "OwnerUserId": "2142023",
    "LastEditorUserId": "1240763",
    "LastEditDate": "2020-09-01T19:33:45.390",
    "LastActivityDate": "2020-09-01T19:33:45.390",
    "Title": "problem path for truststore inside docker with spring boot and kafka",
    "Tags": "<spring-boot><docker><apache-kafka><spring-kafka>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>The truststore-location is a Spring <code>Resource</code> (<code>classpath:</code> by default) so it looks for the file on the class path. Boot checks the file is present so I don't see how it got past boot without error and gets passed to Kafka (unless it's also on the class path). If Boot finds it ok, Kafka should too.</p>  <p>Try <code>file:/deployments/app/certs/kafka-truststore.jks</code></p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "55562381",
    "PostTypeId": "1",
    "AcceptedAnswerId": "55635671",
    "CreationDate": "2019-04-07T18:34:58.743",
    "Score": "8",
    "ViewCount": "11712",
    "Body": "<p>Dockerfile</p>  <pre><code>FROM openjdk:8  ADD target/docker-spring-boot.jar docker-spring-boot.jar EXPOSE 8085 ENTRYPOINT ['java','-jar','docker-spring-boot.jar'] </code></pre>  <p>command to build docker</p>  <pre><code>docker build -f Dockerfile -t docker-spring-boot . </code></pre>  <p>spring boot jar location below .</p>  <pre><code>target/docker-spring-boot.jar </code></pre>  <p>command to run docker</p>  <pre><code>docker run -p 8085:8085 docker-spring-boot </code></pre>  <p>The application works normally without a docker. Not able to run the application on docker.</p>  <p>Error:</p>  <pre><code>This site can\u2019t be reached </code></pre>  <p>docker run logs</p>  <pre><code> E:\\micorservices_samples\\docker-spring-boot\\docker-springbootdocker run -p 8085 :8085 docker-spring-boot     .   ____          _            __ _ _  /\\\\ / ___'_ __ _ _(_)_ __  __  _ \\ \\ \\ \\ ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\  \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )   '  |____| .__|_| |_|_| |_\\__, | / / / /   =========|_|==============|___/=/_/_/_/  :: Spring Boot ::        (v2.1.4.RELEASE)   2019-04-07 18:29:47.944  INFO 1 --- [           main]  c.r.d.DockerSpringbootAppl ication        : Starting  DockerSpringbootApplication v0.0.1-SNAPSHOT on 352ac4d 12009 with PID  1 (/docker-spring-boot.jar started by root in /) 2019-04-07  18:29:47.970  INFO 1 --- [main] c.r.d.DockerSpringbootAppl  ication        : No active profile set, falling back to default  profiles: defaul t 2019-04-07 18:29:54.302  INFO 1 --- [            main] o.s.b.w.embedded.tomcat.To mcatWebServer  : Tomcat initialized  with port(s): 8085 (http) 2019-04-07 18:29:54.463  INFO 1 --- [         main] o.apache.catalina.core.Sta ndardService   : Starting service  [Tomcat] 2019-04-07 18:29:54.464  INFO 1 --- [           main]  org.apache.catalina.core.S tandardEngine  : Starting Servlet engine:  [Apache Tomcat/9.0.17] 2019-04-07 18:29:54.854  INFO 1 --- [            main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring  embedded WebApplicationContext 2019-04-07 18:29:54.855  INFO 1 --- [    main] o.s.web.context.ContextLoa der            : Root  WebApplicationContext: initialization completed in 6539 ms 2019-04-07  18:29:55.859  INFO 1 --- [main] o.s.s.concurrent.ThreadPoo  lTaskExecutor  : Initializing ExecutorService  'applicationTaskExecutor' 2019-04-07 18:29:56.691  INFO 1 --- [         main] o.s.b.w.embedded.tomcat.To mcatWebServer  : Tomcat started on  port(s): 8085 (http) with context path '' 2019-04-07 18:29:56.705   INFO 1 --- [main] c.r.d.DockerSpringbootAppl ication         : Started DockerSpringbootApplication in 10.902 seconds (JVM runn ing  for 12.566)     C:\\Users\\Mabeldocker logs -f 20026c6c7602     .   ____          _            __ _ _  /\\\\ / ___'_ __ _ _(_)_ __  __  _ \\ \\ \\ \\ ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\  \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )   '  |____| .__|_| |_|_| |_\\__, | / / / /   =========|_|==============|___/=/_/_/_/  :: Spring Boot ::        (v2.1.4.RELEASE)   2019-04-07 18:51:23.381  INFO 1 --- [           main]  c.r.d.DockerSpringbootAppl ication        : Starting  DockerSpringbootApplication v0.0.1-SNAPSHOT on 20026c6 c7602 with PID  1 (/dsb.jar started by root in /) 2019-04-07 18:51:23.403  INFO 1 ---  [           main] c.r.d.DockerSpringbootAppl ication        : No  active profile set, falling back to default profiles: defaul t  2019-04-07 18:51:29.434  INFO 1 --- [main]  o.s.b.w.embedded.tomcat.To mcatWebServer  : Tomcat initialized with  port(s): 8085 (http) 2019-04-07 18:51:29.608  INFO 1 --- [            main] o.apache.catalina.core.Sta ndardService   : Starting service  [Tomcat] 2019-04-07 18:51:29.613  INFO 1 --- [           main]  org.apache.catalina.core.S tandardEngine  : Starting Servlet engine:  [Apache Tomcat/9.0.17] 2019-04-07 18:51:30.012  INFO 1 --- [            main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring  embedded WebApplicationContext 2019-04-07 18:51:30.014  INFO 1 --- [    main] o.s.web.context.ContextLoa der            : Root  WebApplicationContext: initialization completed in 6275 ms 2019-04-07  18:51:31.038  INFO 1 --- [           main] o.s.s.concurrent.ThreadPoo  lTaskExecutor  : Initializing ExecutorService  'applicationTaskExecutor' 2019-04-07 18:51:31.879  INFO 1 --- [         main] o.s.b.w.embedded.tomcat.To mcatWebServer  : Tomcat started on  port(s): 8085 (http) with context path '' 2019-04-07 18:51:31.895   INFO 1 --- [           main] c.r.d.DockerSpringbootAppl ication         : Started DockerSpringbootApplication in 10.631 seconds (JVM runn ing  for 12.241) </code></pre>  <p>Github link <a href='https://github.com/robert07ravikumar/spring-boot-docker' rel='noreferrer'>https://github.com/robert07ravikumar/spring-boot-docker</a></p>  <p><a href='https://i.stack.imgur.com/AHQ2Q.png' rel='noreferrer'><img src='https://i.stack.imgur.com/AHQ2Q.png' alt='enter image description here'></a></p> ",
    "OwnerUserId": "4844908",
    "LastEditorUserId": "3968921",
    "LastEditDate": "2019-04-11T08:05:30.060",
    "LastActivityDate": "2021-09-09T23:29:17.500",
    "Title": "Not able to connect to docker image with a spring boot application",
    "Tags": "<java><spring><spring-boot><docker><containers>",
    "AnswerCount": "6",
    "CommentCount": "5",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>The URLs I was trying was <code>localhost</code> , <code>127.0.0.1</code> , <code>0.0.0.0</code>, etc .</p>  <p>The application worked once I ran the docker host URL:</p>  <p><code>http://192.168.99.100:8085/rest/docker/hello1</code></p> ",
    "highest_rated_answer": "<p>Your application seems fine, and it seems you can access it <em>from within the container</em> with localhost as per your comment:</p>  <pre><code>root@a6664e1d3b83:/# curl localhost:8085/rest/docker/hello1  Greetings root@a6664e1d3b83:/# . I am able to get the response from the curl url  </code></pre>  <p>It's probably because <strong>Spring Boot will bind to localhost by default (127.0.0.1)</strong>. You need to add the following properties to bind to all host (or specify which IP on which to bind):</p>  <pre><code>server.address=0.0.0.0 # Bind all </code></pre>  <p>In your <code>application.properties</code></p>  <p>See <a href='https://stackoverflow.com/questions/23946369/how-to-configure-embedded-tomcat-integrated-with-spring-to-listen-requests-to-ip'>this post</a> and the <a href='https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html' rel='noreferrer'>Spring Boot Common Properties</a></p> "
  },
  {
    "Id": "56441497",
    "PostTypeId": "1",
    "AcceptedAnswerId": "56441664",
    "CreationDate": "2019-06-04T09:52:04.153",
    "Score": "8",
    "ViewCount": "19487",
    "Body": "<p>What I'm trying to do is, connect from my spring-boot app to mysql database in Docker. Each in their own container.</p>  <p>But I must be having something wrong because I can't do it.</p>  <p><strong>To keep it simple :</strong></p>  <p>application-properties :</p>  <pre><code># URL for the mysql db spring.datasource.url=jdbc:mysql://workaround-mysql:3308/workaround?serverTimezone=UTC&amp;max_allowed_packet=15728640 # User name in mysql spring.datasource.username=springuser # Password for mysql spring.datasource.password=admin #Port at which application runs server.port=8080 </code></pre>  <p>docker-compose for MySQL:</p>  <pre><code>version: '3' services:   workaround-mysql:     container_name: workaround-mysql     image: mysql     environment:       MYSQL_DATABASE: workaround       MYSQL_USER: springuser       MYSQL_PASSWORD: admin       MYSQL_ROOT_PASSWORD: admin       MYSQL_ROOT_HOST: '%'     ports:       - '3308:3306'     restart: always </code></pre>  <p>So pretty simple right ? Database I start with <code>docker-compose up</code>:</p>  <p><a href='https://i.stack.imgur.com/NKfvA.png' rel='noreferrer'><img src='https://i.stack.imgur.com/NKfvA.png' alt='enter image description here'></a></p>  <p>All seems to be working fine so far.</p>  <p>Now that I have db started, to the application, this is its <code>docker-compose.yml</code>:</p>  <pre><code>version: '3' services:    workaround:     restart: always     # will build ./docker/workaround/Dockerfile     build: ./docker/workaround     working_dir: /workaround     volumes:       - ./:/workaround       - ~/.m2:/root/.m2     expose:       - '8080'     command: 'mvn clean spring-boot:run' </code></pre>  <p>For its <code>Dockerfile</code> I use Linux Alpine and Java.</p>  <pre><code>FROM alpine:3.9 ....add java... RUN apk update RUN apk add dos2unix --update-cache --repository http://dl-3.alpinelinux.org/alpine/edge/community/ --allow-untrusted RUN apk add bash RUN apk add maven </code></pre>  <p>Super simple. Now let's start the application :</p>  <p><a href='https://i.stack.imgur.com/VFGe0.png' rel='noreferrer'><img src='https://i.stack.imgur.com/VFGe0.png' alt='enter image description here'></a></p>  <p><a href='https://i.stack.imgur.com/WEpR6.png' rel='noreferrer'><img src='https://i.stack.imgur.com/WEpR6.png' alt='enter image description here'></a></p>  <p><a href='https://i.stack.imgur.com/w6o93.png' rel='noreferrer'><img src='https://i.stack.imgur.com/w6o93.png' alt='enter image description here'></a></p>  <p>Unknown host, so let's try the IP then :</p>  <pre><code>    docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' workaround-mysql  # URL for the mysql db spring.datasource.url=jdbc:mysql://172.20.0.2:3308/workaround?serverTimezone=UTC&amp;max_allowed_packet=15728640 </code></pre>  <p>Now I get timeout:</p>  <p><a href='https://i.stack.imgur.com/AOtVs.png' rel='noreferrer'><img src='https://i.stack.imgur.com/AOtVs.png' alt='enter image description here'></a></p>  <p>As you can see I get error. What is wrong with my setup and how to fix this? Either I have unknown host exception or Refused to connect or connection timeout.</p>  <p>I have tried:</p>  <ul> <li>Using ip of a container in my application.properties, didn't work</li> <li>Different ports for MySQL and application </li> <li>Different images and versions of MySQL </li> <li>Having everything in one docker compose with wait</li> <li>timer for database.</li> <li>Minimal setup with <a href='https://github.com/hellokoding/hellokoding-courses/tree/master/docker-examples/dockercompose-springboot-mysql-nginx' rel='noreferrer'>https://github.com/hellokoding/hellokoding-courses/tree/master/docker-examples/dockercompose-springboot-mysql-nginx</a> Also resulted in communication link failure, Site was accessible but I doubt that db was connected properly.</li> </ul>  <p><strong>Notes</strong>: </p>  <ul> <li><p>I run this all on one computer I use port 3308 because I have local MySQL db at 3306.</p></li> <li><p>Here is <code>docker ps -a</code></p></li> </ul>  <p><a href='https://i.stack.imgur.com/z7YJK.png' rel='noreferrer'><img src='https://i.stack.imgur.com/z7YJK.png' alt='enter image description here'></a></p>  <p>@Vusal ANSWER output :</p>  <p><a href='https://i.stack.imgur.com/EIUFN.png' rel='noreferrer'><img src='https://i.stack.imgur.com/EIUFN.png' alt='enter image description here'></a></p>  <p>Only thing different from code in answer I did wait for database to be ready 30 seconds</p>  <pre><code>command: /bin/bash -c 'sleep 30;mvn clean spring-boot:run;' </code></pre> ",
    "OwnerUserId": "2733333",
    "LastEditorUserId": "472495",
    "LastEditDate": "2019-06-04T21:39:08.083",
    "LastActivityDate": "2020-07-19T06:01:40.877",
    "Title": "Docker MySQL - can't connect from Spring Boot app to MySQL database",
    "Tags": "<mysql><spring><spring-boot><docker><docker-compose>",
    "AnswerCount": "4",
    "CommentCount": "7",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>Try this <code>docker-compose.yml</code>: </p>  <pre><code>version: '3' services:   workaround-mysql:     container_name: workaround-mysql     image: mysql     environment:       MYSQL_DATABASE: workaround       MYSQL_USER: springuser       MYSQL_PASSWORD: admin       MYSQL_ROOT_PASSWORD: admin       MYSQL_ROOT_HOST: '%'     ports:       - '3308:3306'     restart: always   workaround:     depends_on:        - workaround-mysql     restart: always     # will build ./docker/workaround/Dockerfile     build: ./docker/workaround     working_dir: /workaround     volumes:       - ./:/workaround       - ~/.m2:/root/.m2     expose:       - '8080'     command: 'mvn clean spring-boot:run' </code></pre>  <p>And update your <code>application.properties</code> to use the next JDBC connection url: </p>  <pre><code>spring.datasource.url=jdbc:mysql://workaround-mysql:3306/workaround?serverTimezone=UTC&amp;max_allowed_packet=15728640 </code></pre>  <p>It should work when both containers in the same docker-compose file, because docker-compose creates default network for containers, so they can resolve each other by name.</p> ",
    "highest_rated_answer": "<p>What you haven't tried so far is running both containers on the same Docker network.</p> <p>First, forget about IP addressing - using it should be avoided by all means.</p> <p>Second, launch both compose instances with the same Docker network.</p> <p>Third, <strong>do not</strong> expose ports - inside bridge network all ports are accessible to running containers.</p> <ol> <li><p>Create global network</p> <pre><code> docker network create foo </code></pre> </li> <li><p>Modify both compose files so that they use this network instead of creating each one its own:</p> <pre><code> version: '3.5'  services:   ....   networks:    default:      external: true      name: foo </code></pre> </li> <li><p>Remove <code>expose</code> directives from compose files - inside one network all ports are exposed by default</p> </li> <li><p>Modify connection strings to use default <code>3306</code> port instead of <code>3308</code></p> </li> <li><p>Enjoy</p> </li> </ol> "
  },
  {
    "Id": "56938511",
    "PostTypeId": "1",
    "CreationDate": "2019-07-08T15:50:21.217",
    "Score": "8",
    "ViewCount": "7029",
    "Body": "<p>I have a Spring Boot Application and developed it with a mongo db which was running in brew services. </p>  <p>To get a connection to the db I just had to put the following into application.properties in Spring Boot </p>  <pre><code>spring.data.mongodb.uri=mongodb://localhost:27017/db </code></pre>  <p>changing the application properties to </p>  <pre><code>spring.data.mongodb.uri=mongodb://mongo:27017/db </code></pre>  <p>didtn't change anything, same Error as before.</p>  <p>Now I'm trying to put the SpringBoot Application and the MongoDB into Docker-Containers, but cant get any connection working.</p>  <p>So this is my Dockerfile in the SpringBoot Application:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp EXPOSE 8080 ADD /build/libs/dg-0.0.1-SNAPSHOT.jar dg-0.0.1-SNAPSHOT.jar ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/dg-0.0.1-SNAPSHOT.jar'] </code></pre>  <p>This is my Docker-Compose.yml file:</p>  <pre><code>version: '3'  services:  mongo:  container_name: docker-mongo  image: mongo:latest  ports:    - '27017:27017'  volumes:   - ./data/db:/data/db  spring:  depends_on:    - mongo  image:    docker-spring-http-alpine  ports:    - '8080:8080'  links:    - mongo </code></pre>  <p>After executing Docker-Compose with </p>  <pre><code>docker-compose up </code></pre>  <p>I get the following error: (this is the actual error message )</p>  <pre><code>2019-07-08 23:10:19.990  INFO 1 --- [localhost:27017] org.mongodb.driver.cluster: Exception in monitor thread while connecting to server localhost:27017       com.mongodb.MongoSocketOpenException: Exception opening socket at com.mongodb.internal.connection.SocketStream.open(SocketStream.java:67) ~[mongodb-driver-core-3.8.2.jar!/:na] at com.mongodb.internal.connection.InternalStreamConnection.open(InternalStreamConnection.java:126) ~[mongodb-driver-core-3.8.2.jar!/:na] at com.mongodb.internal.connection.DefaultServerMonitor$ServerMonitorRunnable.run(DefaultServerMonitor.java:117) ~[mongodb-driver-core-3.8.2.jar!/:na] at java.lang.Thread.run(Thread.java:748) [na:1.8.0_212] Caused by: java.net.ConnectException: Connection refused (Connection refused) at java.net.PlainSocketImpl.socketConnect(Native Method) ~[na:1.8.0_212] at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350) ~[na:1.8.0_212] at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206) ~[na:1.8.0_212] at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188) ~[na:1.8.0_212] at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392) ~[na:1.8.0_212] at java.net.Socket.connect(Socket.java:589) ~[na:1.8.0_212] at com.mongodb.internal.connection.SocketStreamHelper.initialize(SocketStreamHelper.java:64) ~[mongodb-driver-core-3.8.2.jar!/:na] at com.mongodb.internal.connection.SocketStream.open(SocketStream.java:62) ~[mongodb-driver-core-3.8.2.jar!/:na] ... 3 common frames omitted </code></pre>  <p>Does someone know whats the problem here? In development environment it works like a charm.</p>  <p>Thanks in advance</p>  <p>Adding the following line to the Dockerfile </p>  <pre><code>'-Dspring.data.mongodb.uri=mongodb://mongo:27017/dg' </code></pre>  <p>into Entrypoint like this solved the connection issue</p>  <pre><code>ENTRYPOINT ['java', '-Dspring.data.mongodb.uri=mongodb://mongo:27017/dg','-Djava.security.egd=file:/dev/./urandom','-jar','/dg-0.0.1-SNAPSHOT.jar'] </code></pre>  <p>I was able to get connection to the db without the mentioned line above in the Entrypoint in the Dockerfile. I guess this is if you like to connect your db over 'links'</p>  <p>But now I was able to connect over Network, this is my code:</p>  <pre><code>version: '3.6'  services:   mongo:  container_name: docker_mongo  networks:    - gateway  ports:    - '27017:27017'  hostname: mongo  image: mongo:latest  volumes:    - ./data/db:/data/db   spring:  container_name: docker-spring  networks:    - gateway  ports:    - '8080:8080'  hostname: spring  depends_on:    - mongo  image: dg-docker-spring-http-alpine-j  networks: gateway: driver: 'bridge' </code></pre>  <p>and the following in application properties</p>  <pre><code>spring.data.mongodb.host=docker_mongo spring.data.mongodb.port=27017 spring.data.mongodb.database=db </code></pre>  <p>So it looks like the connection is working over Network now. The same code did not work with Version 3.0</p>  <p>To prevent SpringBoot to connect automatically to mongo over localhost it's also necessary to exclude MongoAutoConfiguration!</p>  <pre><code>@SpringBootApplication(exclude={MongoAutoConfiguration.class}) </code></pre>  <p>Thank you all for your help</p> ",
    "OwnerUserId": "4461271",
    "LastEditorUserId": "4461271",
    "LastEditDate": "2019-07-12T13:51:34.053",
    "LastActivityDate": "2019-07-12T13:51:34.053",
    "Title": "SpringBoot in Docker not connecting to Mongo in Docker",
    "Tags": "<mongodb><spring-boot><docker><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>EDIT:</p>  <p>I've never done spring-boot development, but the error you are saying is being displayed may very well be unrelated to the mongo issue. However, here is an explanation as to why your mongo-connection is failing:</p>  <hr>  <p><code>docker-compose</code> creates a virtual network if one hasn't been specified in the file (like in your case). </p>  <p>All your applications run inside of this network, completely isolated from each other. As such, <code>localhost</code> in your spring-boot container actually refers to itself. Meaning your spring-boot application is expecting the <code>mongo</code> instance to be running inside of its container (which its not, it's in a different container).</p>  <p>This would have been fine when both the database and application was running on your laptop's network. But as mentioned, they are now running in the <code>docker-compose</code> network, in complete isolation.</p>  <p>However, <code>docker-compose</code> is really clever! It creates a DNS for each of your containers which uses the service-name (in your case <code>mongo</code> and <code>spring</code>) specified in your <code>docker-compose</code> file to allow for easy access to the containers inside of the network. </p>  <p>So, you should be able to change <code>spring.data.mongodb.uri=mongodb://localhost:27017/db</code>to <code>spring.data.mongodb.uri=mongodb://mongo:27017/db</code> and that should allow it to connect.  </p> "
  },
  {
    "Id": "58098979",
    "PostTypeId": "1",
    "AcceptedAnswerId": "58101472",
    "CreationDate": "2019-09-25T12:57:32.777",
    "Score": "8",
    "ViewCount": "16699",
    "Body": "<h1>Env</h1>  <p>Spring Boot 2.1.2. </p>  <p>2 environments: <code>local</code>(postgres 11) and <code>qa</code> (docker swarm with postgres 10 and application)</p>  <h1>Problem</h1>  <p>After <code>maxLifetime</code> passes, hikari recreates connections(closes old ones and creating new ones), but on <code>qa</code> environment connections are not getting closed: checking with <code>select * from pg_stat_activity wheredataname=...</code> and in logs we have:</p>  <pre><code>2019-09-25 12:00:20.694 DEBUG 6 --- [nnection closer] c.z.h.p.PoolBase                         : HikariPool-1 - Closing connection org.postgresql.jdbc.PgConnection@54d41592: (connection has passed maxLifetime) 2019-09-25 12:00:20.699 DEBUG 6 --- [onnection adder] c.z.h.p.HikariPool                       : HikariPool-1 - Added connection org.postgresql.jdbc.PgConnection@29e14ddb 2019-09-25 12:00:26.372 DEBUG 6 --- [nnection closer] c.z.h.p.PoolBase                         : HikariPool-1 - Closing connection org.postgresql.jdbc.PgConnection@11684c62: (connection has passed maxLifetime) 2019-09-25 12:00:26.376 DEBUG 6 --- [onnection adder] c.z.h.p.HikariPool                       : HikariPool-1 - Added connection org.postgresql.jdbc.PgConnection@453f8d6c 2019-09-25 12:00:28.130 DEBUG 6 --- [nnection closer] c.z.h.p.PoolBase                         : HikariPool-1 - Closing connection org.postgresql.jdbc.PgConnection@1b2ef2bc: (connection has passed maxLifetime) 2019-09-25 12:00:28.135 DEBUG 6 --- [onnection adder] c.z.h.p.HikariPool                       : HikariPool-1 - Added connection org.postgresql.jdbc.PgConnection@4bf86bbb 2019-09-25 12:00:28.459 DEBUG 6 --- [nnection closer] c.z.h.p.PoolBase                         : HikariPool-1 - Closing connection org.postgresql.jdbc.PgConnection@34fbeadd: (connection has passed maxLifetime) 2019-09-25 12:00:28.464 DEBUG 6 --- [onnection adder] c.z.h.p.HikariPool                       : HikariPool-1 - Added connection org.postgresql.jdbc.PgConnection@4fc7e61c 2019-09-25 12:00:31.962 DEBUG 6 --- [nnection closer] c.z.h.p.PoolBase                         : HikariPool-1 - Closing connection org.postgresql.jdbc.PgConnection@40771fc4: (connection has passed maxLifetime) 2019-09-25 12:00:31.966 DEBUG 6 --- [onnection adder] c.z.h.p.HikariPool                       : HikariPool-1 - Added connection org.postgresql.jdbc.PgConnection@ac56180 2019-09-25 12:00:35.600 DEBUG 6 --- [nnection closer] c.z.h.p.PoolBase                         : HikariPool-1 - Closing connection org.postgresql.jdbc.PgConnection@65cae248: (connection has passed maxLifetime) 2019-09-25 12:00:35.607 DEBUG 6 --- [onnection adder] c.z.h.p.HikariPool                       : HikariPool-1 - Added connection org.postgresql.jdbc.PgConnection@33a8d959 2019-09-25 12:00:35.649  WARN 6 --- [   scheduling-1] c.z.h.p.PoolBase                         : HikariPool-1 - Failed to validate connection org.postgresql.jdbc.PgConnection@15e91fa9 (This connection has been closed.). Possibly consider using a shorter maxLifetime value. 2019-09-25 12:00:35.650  WARN 6 --- [   scheduling-1] c.z.h.p.PoolBase                         : HikariPool-1 - Failed to validate connection org.postgresql.jdbc.PgConnection@11d699cc (This connection has been closed.). Possibly consider using a shorter maxLifetime value. 2019-09-25 12:00:35.651  WARN 6 --- [   scheduling-1] c.z.h.p.PoolBase                         : HikariPool-1 - Failed to validate connection org.postgresql.jdbc.PgConnection@3883b6a6 (This connection has been closed.). Possibly consider using a shorter maxLifetime value. 2019-09-25 12:00:35.652  WARN 6 --- [   scheduling-1] c.z.h.p.PoolBase                         : HikariPool-1 - Failed to validate connection org.postgresql.jdbc.PgConnection@230234a5 (This connection has been closed.). Possibly consider using a shorter maxLifetime value. 2019-09-25 12:00:35.657 DEBUG 6 --- [nnection closer] c.z.h.p.PoolBase                         : HikariPool-1 - Closing connection org.postgresql.jdbc.PgConnection@15e91fa9: (connection is dead) 2019-09-25 12:00:35.657 DEBUG 6 --- [nnection closer] c.z.h.p.PoolBase                         : HikariPool-1 - Closing connection org.postgresql.jdbc.PgConnection@11d699cc: (connection is dead) 2019-09-25 12:00:35.657 DEBUG 6 --- [nnection closer] c.z.h.p.PoolBase                         : HikariPool-1 - Closing connection org.postgresql.jdbc.PgConnection@3883b6a6: (connection is dead) 2019-09-25 12:00:35.658 DEBUG 6 --- [nnection closer] c.z.h.p.PoolBase                         : HikariPool-1 - Closing connection org.postgresql.jdbc.PgConnection@230234a5: (connection is dead) 2019-09-25 12:00:35.674 DEBUG 6 --- [onnection adder] c.z.h.p.HikariPool                       : HikariPool-1 - Added connection org.postgresql.jdbc.PgConnection@3b85c924 2019-09-25 12:00:35.678 DEBUG 6 --- [onnection adder] c.z.h.p.HikariPool                       : HikariPool-1 - Added connection org.postgresql.jdbc.PgConnection@4b022f4e 2019-09-25 12:00:35.686 DEBUG 6 --- [onnection adder] c.z.h.p.HikariPool                       : HikariPool-1 - Added connection org.postgresql.jdbc.PgConnection@6aea9ecf 2019-09-25 12:00:35.691 DEBUG 6 --- [onnection adder] c.z.h.p.HikariPool                       : HikariPool-1 - Added connection org.postgresql.jdbc.PgConnection@1ffdf0da </code></pre>  <h1>Question:</h1>  <p>Why connections are not getting closed?</p>  <p><strong>Edit:</strong> Hikari config:</p>  <pre><code> c.z.h.HikariConfig  : HikariPool-1 - configuration:  c.z.h.HikariConfig  : allowPoolSuspension.............false  c.z.h.HikariConfig  : autoCommit......................true  c.z.h.HikariConfig  : catalog.........................none  c.z.h.HikariConfig  : connectionInitSql...............none  c.z.h.HikariConfig  : connectionTestQuery.............none  c.z.h.HikariConfig  : connectionTimeout...............30000  c.z.h.HikariConfig  : dataSource......................none  c.z.h.HikariConfig  : dataSourceClassName.............none  c.z.h.HikariConfig  : dataSourceJNDI..................none  c.z.h.HikariConfig  : dataSourceProperties............{password=&lt;masked&gt;}  c.z.h.HikariConfig  : driverClassName.................'org.postgresql.Driver'  c.z.h.HikariConfig  : healthCheckProperties...........{}  c.z.h.HikariConfig  : healthCheckRegistry.............none  c.z.h.HikariConfig  : idleTimeout.....................600000  c.z.h.HikariConfig  : initializationFailTimeout.......1  c.z.h.HikariConfig  : isolateInternalQueries..........false  c.z.h.HikariConfig  : jdbcUrl.........................jdbc:postgresql://postgres/db  c.z.h.HikariConfig  : leakDetectionThreshold..........0  c.z.h.HikariConfig  : maxLifetime.....................1800000  c.z.h.HikariConfig  : maximumPoolSize.................10  c.z.h.HikariConfig  : metricRegistry..................none  c.z.h.HikariConfig  : metricsTrackerFactory...........none  c.z.h.HikariConfig  : minimumIdle.....................10  c.z.h.HikariConfig  : password........................&lt;masked&gt;  c.z.h.HikariConfig  : poolName........................'HikariPool-1'  c.z.h.HikariConfig  : readOnly........................false  c.z.h.HikariConfig  : registerMbeans..................false  c.z.h.HikariConfig  : scheduledExecutor...............none  c.z.h.HikariConfig  : schema..........................none  c.z.h.HikariConfig  : threadFactory...................internal  c.z.h.HikariConfig  : transactionIsolation............default  c.z.h.HikariConfig  : username........................'username'  c.z.h.HikariConfig  : validationTimeout...............5000  c.z.h.HikariDataSource  : HikariPool-1 - Starting...  c.z.h.p.HikariPool  : HikariPool-1 - Added connection org.postgresql.jdbc.PgConnection@53fd0d10  c.z.h.HikariDataSource  : HikariPool-1 - Start completed.  o.f.c.i.d.DatabaseFactory : Database: jdbc:postgresql://postgres/db (PostgreSQL 10.10) </code></pre> ",
    "OwnerUserId": "3575763",
    "LastEditorUserId": "3575763",
    "LastEditDate": "2019-09-25T13:52:04.660",
    "LastActivityDate": "2019-09-25T15:05:33.293",
    "Title": "Connections not being closed(HikariCP, Postgres)",
    "Tags": "<postgresql><spring-boot><docker-swarm><hikaricp>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p><em>Solved by setting <code>maxLifetime</code> to 10 minutes.</em> </p>  <p><strong>Explanation:</strong> It turns out docker swarm somehow drops idle connection. So, when hikari closes connection, nothing reaches postgres, so from postgres standpoint there is still a connection. 10 minutes is less that default docker idle connection timeout, so connections are closed properly.</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "60551591",
    "PostTypeId": "1",
    "AcceptedAnswerId": "60551704",
    "CreationDate": "2020-03-05T18:07:43.347",
    "Score": "8",
    "ViewCount": "23166",
    "Body": "<p>Before onboarding to the enterprise k8s / AWS EKS, I am using <code>docker-desktop</code> for local k8s testing on Mac with the following Dockerfile:</p> <pre><code>FROM openjdk:11-jre-slim ARG JAR_FILE=target/*.jar COPY ${JAR_FILE} app.jar ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] </code></pre> <p>with the following deployment steps to <code>docker-desktop</code>:</p> <pre><code>docker build . -t cpchung/rema  kubectl create deployment rema --image=cpchung/rema --dry-run -o=yaml &gt; deployment.yaml echo --- &gt;&gt; deployment.yaml kubectl create service clusterip rema --tcp=8080:8080 --dry-run -o=yaml &gt;&gt; deployment.yaml kubectl apply -f deployment.yaml </code></pre> <p>This generates the deployment.yaml:</p> <pre><code>apiVersion: apps/v1 kind: Deployment metadata:   creationTimestamp: null   labels:     app: rema   name: rema spec:   replicas: 1   selector:     matchLabels:       app: rema   strategy: {}   template:     metadata:       creationTimestamp: null       labels:         app: rema     spec:       containers:       - image: cpchung/rema         name: rema         resources: {} status: {} --- apiVersion: v1 kind: Service metadata:   creationTimestamp: null   labels:     app: rema   name: rema spec:   ports:   - name: 8080-8080     port: 8080     protocol: TCP     targetPort: 8080   selector:     app: rema   type: ClusterIP status:   loadBalancer: {} </code></pre> <p>and test the deployment with the following health check:</p> <pre><code>kubectl port-forward svc/rema 8080:8080 </code></pre> <pre><code>curl localhost:8080/actuator/health </code></pre> <p>But I am getting this error:</p> <pre><code>robinhood $ kubectl get all NAME                        READY   STATUS             RESTARTS   AGE pod/rema-57df6cf5fc-px8pc   0/1     ImagePullBackOff   0          4m29s  NAME                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE service/kubernetes   ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP    18h service/rema         ClusterIP   10.100.78.60   &lt;none&gt;        8080/TCP   152m  NAME                   READY   UP-TO-DATE   AVAILABLE   AGE deployment.apps/rema   0/1     1            0           4m29s  NAME                              DESIRED   CURRENT   READY   AGE replicaset.apps/rema-57df6cf5fc   1         1         0       4m29s   robinhood $ kubectl logs rema-57df6cf5fc-px8pc Error from server (BadRequest): container &quot;rema&quot; in pod &quot;rema-57df6cf5fc-px8pc&quot; is waiting to start: image can't be pulled </code></pre> <p>But I really have the image from dockers:</p> <pre><code>robinhood $ docker images REPOSITORY                                      TAG                 IMAGE ID            CREATED             SIZE cpchung/rema                                    latest              14a4957873cd        2 hours ago         224MB  </code></pre> <p>What could be wrong here?  I am using mac with docker-desktop.</p> ",
    "OwnerUserId": "1611102",
    "LastEditorUserId": "1611102",
    "LastEditDate": "2021-04-29T02:29:19.050",
    "LastActivityDate": "2021-04-29T02:29:19.050",
    "Title": "kubernetes: image can't be pulled",
    "Tags": "<java><spring-boot><docker><kubernetes>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p><a href='https://stackoverflow.com/a/52763242/3514300'>https://stackoverflow.com/a/52763242/3514300</a> should solve the issue for you</p>  <p>In your deployment add <code>imagePullPolicy: Never</code></p>  <p>By default for images tagged with no tag are given the <code>latest</code> tag in docker. Kubernetes by default tries to pull the images for <code>latest</code> tag and it wasn't able to find the image in dockerhub. <a href='https://kubernetes.io/docs/concepts/containers/images/#updating-images' rel='noreferrer'>https://kubernetes.io/docs/concepts/containers/images/#updating-images</a></p>  <p>Other way is to push your image to dockerhub too.</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "61019493",
    "PostTypeId": "1",
    "AcceptedAnswerId": "61153001",
    "CreationDate": "2020-04-03T19:55:56.580",
    "Score": "8",
    "ViewCount": "1703",
    "Body": "<p>In a Spring Boot 1.5.9 application I want to access static resources through HTTP using Google Chrome.</p>  <p>In Docker I have <strong><code>404</code> error</strong>, it worked fine in embedded tomcat.</p>  <h2>Configuration</h2>  <p>This is the <code>Dockerfile</code>:</p>  <pre><code>FROM openjdk:8-jre-alpine VOLUME /tmp  RUN addgroup -S spring --gid 13371 &amp;&amp; adduser -S spring -G spring --uid 13371 RUN mkdir -p /srv/upload RUN chown -R spring:spring /srv/upload  ADD *.jar app.jar RUN sh -c 'touch /app.jar'  USER spring:spring  ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-Duser.timezone=UTC','-jar','/app.jar'] </code></pre>  <p>This is how I configure the static resources:</p>  <pre class='lang-java prettyprint-override'><code>public class MyWebMvcConfigurerAdapter extends WebMvcConfigurerAdapter {      @Override     public void addResourceHandlers(ResourceHandlerRegistry registry) {         registry.addResourceHandler('/resources/**')                 .addResourceLocations('file:upload/images/')                 .setCachePeriod(0);     } } </code></pre>  <h2>Result</h2>  <p>This is the result log when I access the URL from chrome <strong>in docker</strong> <code>http://localhost:8080/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png</code></p>  <pre class='lang-sh prettyprint-override'><code>Counting up[http-nio-8080-Acceptor-0] latch=1 Socket: [org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper@45deea1:org.apache.tomcat.util.net.NioChannel@68f517c7:java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:47510]], Read from buffer: [0] Received [GET /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png HTTP/1.1 Host: localhost:8080 Connection: keep-alive Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36 Sec-Fetch-Dest: document Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Sec-Fetch-Site: none Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Accept-Encoding: gzip, deflate, br Accept-Language: en-US,en;q=0.9,fr-FR;q=0.8,fr;q=0.7,ru-RU;q=0.6,ru;q=0.5,vi-VN;q=0.4,vi;q=0.3  ] Security checking request GET /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png   No applicable constraints defined  Not subject to any constraint Bound request context to thread: org.springframework.session.web.http.SessionRepositoryFilter$SessionRepositoryRequestWrapper@1f960fc1 Trying to match using Ant [pattern='/oauth/token'] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/oauth/token' Trying to match using Ant [pattern='/oauth/token_key'] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/oauth/token_key' Trying to match using Ant [pattern='/oauth/check_token'] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/oauth/check_token' No matches found Trying to match using Ant [pattern='/favicon.ico'] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/favicon.ico' Trying to match using Ant [pattern='/favicon.png'] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/favicon.png' Trying to match using Ant [pattern='/login'] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/login' Trying to match using Ant [pattern='/logout'] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/logout' Trying to match using Ant [pattern='/ping'] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/ping' Trying to match using Ant [pattern='/oauth/authorize'] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/oauth/authorize' Trying to match using Ant [pattern='/cb/**'] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/cb/**' Trying to match using Ant [pattern='/'] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/' Trying to match using Ant [pattern='/public/**'] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/public/**' Trying to match using Ant [pattern='/resources/**'] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/resources/**' matched /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png at position 1 of 11 in additional filter chain; firing Filter: 'WebAsyncManagerIntegrationFilter' /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png at position 2 of 11 in additional filter chain; firing Filter: 'SecurityContextPersistenceFilter' Set encoding to ISO-8859-1 No HttpSession currently exists No SecurityContext was available from the HttpSession: null. A new one will be created. /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png at position 3 of 11 in additional filter chain; firing Filter: 'HeaderWriterFilter' Not injecting HSTS header since it did not match the requestMatcher org.springframework.security.web.header.writers.HstsHeaderWriter$SecureRequestMatcher@1877aac3 /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png at position 4 of 11 in additional filter chain; firing Filter: 'LogoutFilter' Trying to match using Ant [pattern='/logout', GET] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/logout' Trying to match using Ant [pattern='/logout', POST] Request 'GET /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png' doesn't match 'POST /logout Trying to match using Ant [pattern='/logout', PUT] Request 'GET /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png' doesn't match 'PUT /logout Trying to match using Ant [pattern='/logout', DELETE] Request 'GET /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png' doesn't match 'DELETE /logout No matches found /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png at position 5 of 11 in additional filter chain; firing Filter: 'UsernamePasswordAuthenticationFilter' Request 'GET /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png' doesn't match 'POST /login /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png at position 6 of 11 in additional filter chain; firing Filter: 'RequestCacheAwareFilter' /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png at position 7 of 11 in additional filter chain; firing Filter: 'SecurityContextHolderAwareRequestFilter' /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png at position 8 of 11 in additional filter chain; firing Filter: 'AnonymousAuthenticationFilter' Populated SecurityContextHolder with anonymous token: 'org.springframework.security.authentication.AnonymousAuthenticationToken@9055e4a6: Principal: anonymousUser; Credentials: [PROTECTED]; Authenticated: true; Details: org.springframework.security.web.authentication.WebAuthenticationDetails@957e: RemoteIpAddress: 127.0.0.1; SessionId: null; Granted Authorities: ROLE_ANONYMOUS' /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png at position 9 of 11 in additional filter chain; firing Filter: 'SessionManagementFilter' /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png at position 10 of 11 in additional filter chain; firing Filter: 'ExceptionTranslationFilter' /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png at position 11 of 11 in additional filter chain; firing Filter: 'FilterSecurityInterceptor' Trying to match using Ant [pattern='/logout', GET] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/logout' Trying to match using Ant [pattern='/logout', POST] Request 'GET /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png' doesn't match 'POST /logout Trying to match using Ant [pattern='/logout', PUT] Request 'GET /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png' doesn't match 'PUT /logout Trying to match using Ant [pattern='/logout', DELETE] Request 'GET /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png' doesn't match 'DELETE /logout No matches found Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/favicon.ico' Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/favicon.png' Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/ping' Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/public/**' Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/resources/**' Secure object: FilterInvocation: URL: /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png; Attributes: [permitAll] Previously Authenticated: org.springframework.security.authentication.AnonymousAuthenticationToken@9055e4a6: Principal: anonymousUser; Credentials: [PROTECTED]; Authenticated: true; Details: org.springframework.security.web.authentication.WebAuthenticationDetails@957e: RemoteIpAddress: 127.0.0.1; SessionId: null; Granted Authorities: ROLE_ANONYMOUS Voter: org.springframework.security.web.access.expression.WebExpressionVoter@6f01175d, returned: 1 Authorization successful RunAsManager did not change Authentication object /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png reached end of additional filter chain; proceeding with original chain DispatcherServlet with name 'dispatcherServlet' processing GET request for [/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png] Looking up handler method for path /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png looking up handler for path: /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png Did not find handler method for [/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png] Looking up handler method for path /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png Did not find handler method for [/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png] Looking up handler method for path /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png Did not find handler method for [/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png] Looking up handler method for path /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png Did not find handler method for [/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png] Looking up handler method for path /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png Did not find handler method for [/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png] Looking up handler method for path /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png Did not find handler method for [/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png] Matching patterns for request [/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png] are [/resources/**, /**] URI Template variables for request [/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png] are {} Mapping [/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png] to HandlerExecutionChain with handler [ResourceHttpRequestHandler [locations=[URL [file:upload/images/], class path resource [META-INF/resources/], class path resource [resources/], class path resource [static/], class path resource [public/]], resolvers=[org.springframework.web.servlet.resource.PathResourceResolver@6f49d153]]] and 1 interceptor Last-Modified value for [/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png] is: -1 SecurityContext is empty or contents are anonymous - context will not be stored in HttpSession. Null ModelAndView returned to DispatcherServlet with name 'dispatcherServlet': assuming HandlerAdapter completed request handling Successfully completed request Chain processed normally SecurityContextHolder now cleared, as request processing completed Cleared thread-bound request context: org.springframework.session.web.http.SessionRepositoryFilter$SessionRepositoryRequestWrapper@1f960fc1 Processing ErrorPage[errorCode=0, location=/error] DispatcherServlet with name 'dispatcherServlet' processing GET request for [/error] Looking up handler method for path /error looking up handler for path: /error Did not find handler method for [/error] Looking up handler method for path /error Did not find handler method for [/error] Looking up handler method for path /error Returning handler method [public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)] Returning cached instance of singleton bean 'basicErrorController' Last-Modified value for [/error] is: -1 Requested media types are [text/html, text/html;q=0.8] based on Accept header types and producible media types [text/html]) Returning cached instance of singleton bean 'error' Returning [org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration$SpelView@351e414e] based on requested media type 'text/html' Rendering view [org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration$SpelView@351e414e] in DispatcherServlet with name 'dispatcherServlet' Successfully completed request  Disabling the response for further output Socket: [org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper@45deea1:org.apache.tomcat.util.net.NioChannel@68f517c7:java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:47510]], Read from buffer: [0] Socket: [org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper@45deea1:org.apache.tomcat.util.net.NioChannel@68f517c7:java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:47510]], Status in: [OPEN_READ], State out: [OPEN]  </code></pre>  <h2>Expected</h2>  <p>This is what I expect (in the development environment) while accessing <code>http://localhost:8080/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg</code></p>  <pre class='lang-sh prettyprint-override'><code>Counting up[http-nio-8080-Acceptor-0] latch=1 Socket: [org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper@4d64a855:org.apache.tomcat.util.net.NioChannel@3eaf8ba0:java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:59330]], Read from buffer: [0] Received [GET /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg HTTP/1.1 Host: localhost:8080 Connection: keep-alive Pragma: no-cache Cache-Control: no-cache Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36 Sec-Fetch-Dest: document Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Sec-Fetch-Site: none Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Accept-Encoding: gzip, deflate, br Accept-Language: en-US,en;q=0.9,fr-FR;q=0.8,fr;q=0.7,ru-RU;q=0.6,ru;q=0.5,vi-VN;q=0.4,vi;q=0.3  ] Security checking request GET /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg   No applicable constraints defined  Not subject to any constraint Bound request context to thread: org.springframework.session.web.http.SessionRepositoryFilter$SessionRepositoryRequestWrapper@29e45b2 Trying to match using Ant [pattern='/'] Checking match of request : '/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg'; against '/' Trying to match using Ant [pattern='/public/**'] Checking match of request : '/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg'; against '/public/**' Trying to match using Ant [pattern='/resources/**'] Checking match of request : '/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg'; against '/resources/**' matched /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg at position 1 of 11 in additional filter chain; firing Filter: 'WebAsyncManagerIntegrationFilter' /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg at position 2 of 11 in additional filter chain; firing Filter: 'SecurityContextPersistenceFilter' Set encoding to ISO-8859-1 No HttpSession currently exists No SecurityContext was available from the HttpSession: null. A new one will be created. /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg at position 3 of 11 in additional filter chain; firing Filter: 'HeaderWriterFilter' Not injecting HSTS header since it did not match the requestMatcher org.springframework.security.web.header.writers.HstsHeaderWriter$SecureRequestMatcher@204c4db /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg at position 4 of 11 in additional filter chain; firing Filter: 'LogoutFilter' Trying to match using Ant [pattern='/logout', GET] Checking match of request : '/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg'; against '/logout' Trying to match using Ant [pattern='/logout', POST] Request 'GET /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg' doesn't match 'POST /logout Trying to match using Ant [pattern='/logout', PUT] Request 'GET /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg' doesn't match 'PUT /logout Trying to match using Ant [pattern='/logout', DELETE] Request 'GET /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg' doesn't match 'DELETE /logout No matches found /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg at position 5 of 11 in additional filter chain; firing Filter: 'UsernamePasswordAuthenticationFilter' Request 'GET /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg' doesn't match 'POST /login /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg at position 6 of 11 in additional filter chain; firing Filter: 'RequestCacheAwareFilter' /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg at position 7 of 11 in additional filter chain; firing Filter: 'SecurityContextHolderAwareRequestFilter' /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg at position 8 of 11 in additional filter chain; firing Filter: 'AnonymousAuthenticationFilter' Populated SecurityContextHolder with anonymous token: 'org.springframework.security.authentication.AnonymousAuthenticationToken@9055e4a6: Principal: anonymousUser; Credentials: [PROTECTED]; Authenticated: true; Details: org.springframework.security.web.authentication.WebAuthenticationDetails@957e: RemoteIpAddress: 127.0.0.1; SessionId: null; Granted Authorities: ROLE_ANONYMOUS' /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg at position 9 of 11 in additional filter chain; firing Filter: 'SessionManagementFilter' /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg at position 10 of 11 in additional filter chain; firing Filter: 'ExceptionTranslationFilter' /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg at position 11 of 11 in additional filter chain; firing Filter: 'FilterSecurityInterceptor' No matches found g/843291ef-2309-4809-9f37-38257e087a97.jpeg'; against '/public/**' Checking match of request : '/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg'; against '/resources/**' Secure object: FilterInvocation: URL: /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg; Attributes: [permitAll] Previously Authenticated: org.springframework.security.authentication.AnonymousAuthenticationToken@9055e4a6: Principal: anonymousUser; Credentials: [PROTECTED]; Authenticated: true; Details: org.springframework.security.web.authentication.WebAuthenticationDetails@957e: RemoteIpAddress: 127.0.0.1; SessionId: null; Granted Authorities: ROLE_ANONYMOUS Voter: org.springframework.security.web.access.expression.WebExpressionVoter@199cd81c, returned: 1 Authorization successful RunAsManager did not change Authentication object /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg reached end of additional filter chain; proceeding with original chain DispatcherServlet with name 'dispatcherServlet' processing GET request for [/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg] Looking up handler method for path /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg looking up handler for path: /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg Did not find handler method for [/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg] Looking up handler method for path /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg Did not find handler method for [/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg] Looking up handler method for path /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg Did not find handler method for [/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg] Looking up handler method for path /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg Did not find handler method for [/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg] Looking up handler method for path /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg Did not find handler method for [/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg] Looking up handler method for path /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg Did not find handler method for [/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg] Matching patterns for request [/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg] are [/resources/**, /**] URI Template variables for request [/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg] are {} Mapping [/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg] to HandlerExecutionChain with handler [ResourceHttpRequestHandler [locations=[URL [file:upload/images/], class path resource [META-INF/resources/], class path resource [resources/], class path resource [static/], class path resource [public/]], resolvers=[org.springframework.web.servlet.resource.PathResourceResolver@49a0fe14]]] and 1 interceptor Last-Modified value for [/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg] is: -1 SecurityContext is empty or contents are anonymous - context will not be stored in HttpSession. Null ModelAndView returned to DispatcherServlet with name 'dispatcherServlet': assuming HandlerAdapter completed request handling Successfully completed request </code></pre>  <h2>Investigation</h2>  <p>I have replicated the production environment locally and I used the same absolute path <code>file:/srv/upload/images</code> in development, I can confirm that status code are different within docker and without it:</p>  <ul> <li>In embedded tomcat: 200</li> <li>In docker: 404 </li> </ul>  <p>The problem is not related to the path being different but only because of docker.</p>  <h2>Question</h2>  <ul> <li>Is there a step I have forgotten?</li> </ul>  <p>Any hint would be much appreciated.</p> ",
    "OwnerUserId": "2127277",
    "LastEditorUserId": "2127277",
    "LastEditDate": "2020-04-06T19:23:26.033",
    "LastActivityDate": "2022-09-15T11:10:39.537",
    "Title": "Spring boot 1.5.9, 404 error while accessing resources images within Docker container",
    "Tags": "<spring><spring-boot><docker><spring-mvc><spring-security>",
    "AnswerCount": "1",
    "CommentCount": "10",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>I don't have enough reputation points to make a comment, so I write my comment as an answer :(</p>  <p>I had a similar issue with docker and resources, so I would like to help you.</p>  <p>Could you provide logs with <code>TRACE</code> level?  This level helps us to see what is going on inside <code>PathResourceResolver</code> and according to this <a href='https://github.com/spring-projects/spring-framework/blob/4.3.x/spring-webmvc/src/main/java/org/springframework/web/servlet/resource/PathResourceResolver.java' rel='noreferrer'>implementation</a> trace is used in most cases.</p>  <p>In my case, it was useful and helped me.</p>  <p>According to <a href='https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/html/boot-features-logging.html#boot-features-logging-console-output' rel='noreferrer'>this</a> </p>  <blockquote>   <p>You can enable a \u201ctrace\u201d mode by starting your application with a --trace flag (or trace=true in your application.properties)</p> </blockquote> ",
    "highest_rated_answer": null
  },
  {
    "Id": "62655110",
    "PostTypeId": "1",
    "AcceptedAnswerId": "62659993",
    "CreationDate": "2020-06-30T10:12:22.127",
    "Score": "8",
    "ViewCount": "7732",
    "Body": "<p>I'm trying to run spring-boot-admin on ECS Fargate - and after a few minutes the server dies and the logs are filled with 'too many open files in system' errors.</p> <p>I'm using spring-boot 2.3.1, and have tried 2.2.3 and the 2.3.0-SNAPSHOT of spring-boot-admin.  The jar is running on an ubuntu 20.04 base image with openjdk-11-jdk-headless installed.  The ECS service has 2gb RAM available, and I've increased Ulimits on nofile and nproc (100000)</p> <pre><code>      Ulimits:         - Name: nofile           HardLimit: 1000000           SoftLimit: 1000000         - Name: nproc           HardLimit: 1000000           SoftLimit: 1000000 </code></pre> <p>Stacktrace:</p> <p><code>2020-06-29 22:03:35.691 ERROR 6 --- [io-8080-exec-24] o.a.c.c.C.[.[.[/].[dispatcherServlet] : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is io.netty.channel.ChannelException: io.netty.channel.unix.Errors$NativeIoException: newSocketStream(..) failed: Too many open files in system] with root cause io.netty.channel.unix.Errors$NativeIoException: newSocketStream(..) failed: Too many open files in system 2020-06-29 22:03:36.345 ERROR 6 --- [io-8080-exec-14] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is io.netty.channel.ChannelException: io.netty.channel.unix.Errors$NativeIoException: newSocketStream(..) failed: Too many open files in system] with root cause io.netty.channel.unix.Errors$NativeIoException: newSocketStream(..) failed: Too many open files in system 2020-06-29 22:03:36.350 ERROR 6 --- [o-8080-Acceptor] org.apache.tomcat.util.net.Acceptor : Socket accept failed java.io.IOException: Too many open files in system at java.base/sun.nio.ch.ServerSocketChannelImpl.accept0(Native Method) ~[na:na] at java.base/sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:533) ~[na:na] at java.base/sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:285) ~[na:na] at org.apache.tomcat.util.net.NioEndpoint.serverSocketAccept(NioEndpoint.java:469) ~[tomcat-embed-core-9.0.36.jar!/:9.0.36] at org.apache.tomcat.util.net.NioEndpoint.serverSocketAccept(NioEndpoint.java:71) ~[tomcat-embed-core-9.0.36.jar!/:9.0.36] at org.apache.tomcat.util.net.Acceptor.run(Acceptor.java:95) ~[tomcat-embed-core-9.0.36.jar!/:9.0.36] at java.base/java.lang.Thread.run(Thread.java:834) ~[na:na]</code></p> <p>I've got a set of 8 microservices connected with the sba-client (no security at the moment) for 3 environments (24 instances in total).  Only settings in the client are:</p> <pre><code>spring.boot.admin.client.instance.prefer-ip=true spring.boot.admin.client.url=https://xxxxx.com spring.boot.admin.client.instance.name= spring.boot.admin.client.instance.metadata.tags.environment=${spring.profiles.active} </code></pre> <p>I've enabled prefer IP as the majority of these instances arent behind Eureka or a load balancer, and just process data off queues.</p> <p>The server only has <code>spring.boot.admin.ui.public-url</code> set.</p> <p>For the first few minutes everything works fine - but then these errors start occuring and everything falls over.  Cloudwatch metrics say the cpu shoot to 100%, then target-group healthchecks on sba fail and ECS restarts the task.  This currently takes about 30 minutes.</p> <p>Raising the ulimits from defaults has increased the time before the app falls over, but it still falls over eventually - as if its leaking sockets / connections.</p> <p>I've not had any experience running webflux / netty apps - is there something I'm missing?  Do I need to set a higher ulimit?</p> ",
    "OwnerUserId": "329028",
    "LastActivityDate": "2020-07-13T14:04:55.430",
    "Title": "Spring Boot Admin - Too Many open Files In System Error",
    "Tags": "<spring-boot><docker><amazon-ecs><spring-boot-admin>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>I was having the same problem, found out that there's a issue logged in spring boot about this: <a href='https://github.com/spring-projects/spring-boot/issues/21934' rel='noreferrer'>Many File Open Issue : Spring Boot 2.3.0 -&gt; Spring Boot 2.3.1 #21934</a></p> <p>Until a new version is out, bumping reactor-netty to 0.9.9.RELEASE should fix it, did for me!</p> ",
    "highest_rated_answer": "<p>I faced same issue, unfortunately updating reactor-netty to <code>0.9.9.RELEASE</code> did NOT fix the issue, but downgrading to <code>0.9.7.RELEASE</code>.</p> "
  },
  {
    "Id": "66138983",
    "PostTypeId": "1",
    "CreationDate": "2021-02-10T14:37:28.777",
    "Score": "8",
    "ViewCount": "9335",
    "Body": "<p>I am new to docker and try to run a mysql image using below command on a windows server.</p> <pre><code>docker run  -e MYSQL_ROOT_PASSWORD=sEe@21 -e MYSQL_DATABASE=emp_db -p 3306:3306 --name mysql_emp mysql </code></pre> <p>It successfully downloaded and configured. I am getting a log in the CMD which says</p> <pre><code>root@localhost is created with an empty password ! Please consider switching off the --initialize-insecure option. </code></pre> <p>I have already given the root password which I set to use by the application and hence I get an error saying that cannot connect to DB from the spring boot service. MySQL full log is as follows</p> <pre><code>2021-02-10 14:25:43+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.23-1debian10 started. 2021-02-10 14:25:43+00:00 [Note] [Entrypoint]: Switching to dedicated user 'mysql' 2021-02-10 14:25:43+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.23-1debian10 started. 2021-02-10 14:25:43+00:00 [Note] [Entrypoint]: Initializing database files 2021-02-10T14:25:43.801929Z 0 [System] [MY-013169] [Server] /usr/sbin/mysqld (mysqld 8.0.23) initializing of server in progress as process 43 2021-02-10T14:25:43.808218Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started. 2021-02-10T14:25:44.547274Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended. 2021-02-10T14:25:46.632843Z 6 [Warning] [MY-010453] [Server] root@localhost is created with an empty password ! Please consider switching off the --initialize-insecure option. 2021-02-10 14:25:51+00:00 [Note] [Entrypoint]: Database files initialized 2021-02-10 14:25:51+00:00 [Note] [Entrypoint]: Starting temporary server 2021-02-10T14:25:51.770335Z 0 [System] [MY-010116] [Server] /usr/sbin/mysqld (mysqld 8.0.23) starting as process 88 2021-02-10T14:25:51.804446Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started. 2021-02-10T14:25:52.039318Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended. 2021-02-10T14:25:52.169969Z 0 [System] [MY-011323] [Server] X Plugin ready for connections. Socket: /var/run/mysqld/mysqlx.sock 2021-02-10T14:25:52.299951Z 0 [Warning] [MY-010068] [Server] CA certificate ca.pem is self signed. 2021-02-10T14:25:52.300259Z 0 [System] [MY-013602] [Server] Channel mysql_main configured to support TLS. Encrypted connections are now supported for this channel. 2021-02-10T14:25:52.304466Z 0 [Warning] [MY-011810] [Server] Insecure configuration for --pid-file: Location '/var/run/mysqld' in the path is accessible to all OS users. Consider choosing a different directory. 2021-02-10T14:25:52.327240Z 0 [System] [MY-010931] [Server] /usr/sbin/mysqld: ready for connections. Version: '8.0.23'  socket: '/var/run/mysqld/mysqld.sock'  port: 0  MySQL Community Server - GPL. 2021-02-10 14:25:52+00:00 [Note] [Entrypoint]: Temporary server started. Warning: Unable to load '/usr/share/zoneinfo/iso3166.tab' as time zone. Skipping it. Warning: Unable to load '/usr/share/zoneinfo/leap-seconds.list' as time zone. Skipping it. Warning: Unable to load '/usr/share/zoneinfo/zone.tab' as time zone. Skipping it. Warning: Unable to load '/usr/share/zoneinfo/zone1970.tab' as time zone. Skipping it. 2021-02-10 14:25:58+00:00 [Note] [Entrypoint]: Creating database emp_db  2021-02-10 14:25:58+00:00 [Note] [Entrypoint]: Stopping temporary server 2021-02-10T14:25:58.448858Z 11 [System] [MY-013172] [Server] Received SHUTDOWN from user root. Shutting down mysqld (Version: 8.0.23). 2021-02-10T14:26:00.212816Z 0 [System] [MY-010910] [Server] /usr/sbin/mysqld: Shutdown complete (mysqld 8.0.23)  MySQL Community Server - GPL. 2021-02-10 14:26:00+00:00 [Note] [Entrypoint]: Temporary server stopped  2021-02-10 14:26:00+00:00 [Note] [Entrypoint]: MySQL init process done. Ready for start up.  2021-02-10T14:26:00.738118Z 0 [System] [MY-010116] [Server] /usr/sbin/mysqld (mysqld 8.0.23) starting as process 1 2021-02-10T14:26:00.763121Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started. 2021-02-10T14:26:00.999006Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended. 2021-02-10T14:26:01.135971Z 0 [System] [MY-011323] [Server] X Plugin ready for connections. Bind-address: '::' port: 33060, socket: /var/run/mysqld/mysqlx.sock 2021-02-10T14:26:01.269210Z 0 [Warning] [MY-010068] [Server] CA certificate ca.pem is self signed. 2021-02-10T14:26:01.269444Z 0 [System] [MY-013602] [Server] Channel mysql_main configured to support TLS. Encrypted connections are now supported for this channel. 2021-02-10T14:26:01.275037Z 0 [Warning] [MY-011810] [Server] Insecure configuration for --pid-file: Location '/var/run/mysqld' in the path is accessible to all OS users. Consider choosing a different directory. 2021-02-10T14:26:01.297388Z 0 [System] [MY-010931] [Server] /usr/sbin/mysqld: ready for connections. Version: '8.0.23'  socket: '/var/run/mysqld/mysqld.sock'  port: 3306  MySQL Community Server - GPL. </code></pre> <p>Would like to understand what is wrong I am doing ? any parameter is missing in the docker run command ?</p> ",
    "OwnerUserId": "5178586",
    "LastActivityDate": "2021-09-18T12:11:58.223",
    "Title": "Docker - mysql configured with empty password for the root user",
    "Tags": "<spring-boot><docker><mysql-8.0>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>It is just an example of misleading printing:</p> <blockquote> <p>That is just a warning printed by during database file initialization (mysqld --initialize-insecure). The root user with password is created later while the database is listening only on the unix socket.</p> </blockquote> <p>From <a href='https://github.com/docker-library/mysql/issues/307#issuecomment-313784886' rel='noreferrer'>https://github.com/docker-library/mysql/issues/307#issuecomment-313784886</a></p> "
  },
  {
    "Id": "67194033",
    "PostTypeId": "1",
    "CreationDate": "2021-04-21T10:29:53.577",
    "Score": "8",
    "ViewCount": "9415",
    "Body": "<p>I have a working Spring Boot 2.25 application built with mvn. As per <a href='https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/html/using-boot-devtools.html' rel='nofollow noreferrer'>this documentation</a> I add</p> <pre><code>&lt;dependencies&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;         &lt;optional&gt;true&lt;/optional&gt;     &lt;/dependency&gt; &lt;/dependencies&gt; </code></pre> <p>From the documentation:</p> <blockquote> <p>As DevTools monitors classpath resources, the only way to trigger a restart is to update the classpath. The way in which you cause the classpath to be updated depends on the IDE that you are using. In Eclipse, saving a modified file causes the classpath to be updated and triggers a restart. In IntelliJ IDEA, building the project (Build -&gt; Build Project) has the same effect.</p> </blockquote> <p>With the application running I tried a simple</p> <pre><code>touch /path/to/app.jar </code></pre> <p>expecting the application to restart but nothing happened.</p> <p>Okay, so maybe it's doing something smarter. I modified some source .java, recompiled the .jar, and <code>cp</code>'d it to replace the running .jar file and... nothing happened.</p> <p>Also from the documentation</p> <blockquote> <p>DevTools relies on the application context\u2019s shutdown hook to close it during a restart. It does not work correctly if you have disabled the shutdown hook (SpringApplication.setRegisterShutdownHook(false)).</p> </blockquote> <p>I am not doing this.</p> <blockquote> <p>DevTools needs to customize the ResourceLoader used by the ApplicationContext. If your application provides one already, it is going to be wrapped. Direct override of the getResource method on the ApplicationContext is not supported.</p> </blockquote> <p>I am not doing this.</p> <p>I am running this in a Docker container, if that matters. From the documentation:</p> <blockquote> <p>Developer tools are automatically disabled when running a fully packaged application. If your application is launched from java -jar or if it is started from a special classloader, then it is considered a \u201cproduction application\u201d. If that does not apply to you (i.e. if you run your application from a container), consider excluding devtools or set the -Dspring.devtools.restart.enabled=false system property.</p> </blockquote> <p>I don't understand what this means or if it is relevant.</p> <p>I want to recompile a .jar and replace it in the running docker container and trigger and application restart without restarting the container. How can I do this?</p> <p>EDIT: I am using <code>mvn</code> to rebuild the jar, then <code>docker cp</code> to replace it in the running container. (IntelliJ IDEA claims to rebuild the project, but the jar files are actually <em>not</em> touched, but that's another story.) I am looking for a non-IDE-specific solution.</p> ",
    "OwnerUserId": "458742",
    "LastEditorUserId": "13942448",
    "LastEditDate": "2021-07-17T13:35:04.823",
    "LastActivityDate": "2023-07-10T11:32:46.553",
    "Title": "spring-boot-devtools Automatic Restart not working",
    "Tags": "<java><spring-boot><docker><spring-boot-devtools>",
    "AnswerCount": "6",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>The Spring Boot Devtools offers for Spring Boot applications the functionality that usually is available in IDEs like IntelliJ in which you have the ability to, for example, <a href='https://docs.spring.io/spring-boot/docs/1.5.16.RELEASE/reference/html/using-boot-devtools.html#using-boot-devtools-restart' rel='noreferrer'>restart an application</a> or force a <a href='https://docs.spring.io/spring-boot/docs/1.5.16.RELEASE/reference/html/using-boot-devtools.html#using-boot-devtools-restart' rel='noreferrer'>live browser reload</a> when certain classes or resources change. This can be very useful in the development phase of your application.</p> <p>It is typically used in conjunction with an IDE in such a way that it will be launched with the rest of your application by Spring Boot when detected in the classpath and if it is not disabled.</p> <p>Although you can configure it to monitor further resources, it will usually look for changes in your application code, in your classes and resources.</p> <p>It is important to say that, AFAIK, Devtools will monitor your own classes and resources in an <em>exploded</em> way, I mean, the restart process will not work if you overwrite your whole application jar, only if you overwrite some resources in your <code>classes</code> directory.</p> <p>This functionality can be tested with Maven. Please, consider download a simple blueprint from <a href='https://start.spring.io' rel='noreferrer'>Spring Initializr</a>, with Spring Boot, Spring Boot Devtools and Spring Web, for example - in order to keep the application running. From a terminal, in the directory that contains the <code>pom.xml</code> file, run your application, for instance, with the help of the <code>spring-boot-maven-plugin</code> plugin included in the <code>pom.xml</code>:</p> <pre><code>mvn spring-boot:run </code></pre> <p>The command will download the project dependencies, compile and run your application.</p> <p>Now, perform any modification in your source code, either in your classes or in your resources and, from another terminal, in the same directory, recompile your resources:</p> <pre><code>mvn compile </code></pre> <p>If you look at the first terminal window you will see that the application is restarted to reflect the changes.</p> <p>If you are using docker for your application deployment, try reproducing this behavior can be tricky.</p> <p>On one hand, I do not know if it makes sense, but you can try creating a maven based image and run your code inside, just as described above. Your <code>Dockerfile</code> can look similar to this:</p> <pre><code>FROM maven:3.5-jdk-8 as maven  WORKDIR /app  # Copy project pom COPY ./pom.xml ./pom.xml  # Fetch (and cache) dependencies RUN mvn dependency:go-offline -B  # Copy source files COPY ./src ./src  # Run your application RUN mvn springboot:run </code></pre> <p>With this setup, you can copy with <code>docker cp</code> your resources to the <code>/app/target</code> directory and it will trigger an application restart. As an alternative, consider mounting a volume in your container instead of using <code>docker cp</code>.</p> <p><strong>Much better</strong>, and taking into account the fact that overwriting your application jar will probably not work, you can try to copy both your classes and library dependencies, and run your application in a exploded way. Consider the following <code>Dockerfile</code>:</p> <pre><code>FROM maven:3.5-jdk-8 as maven  WORKDIR /app  # Copy your project pom COPY ./pom.xml ./pom.xml  # Fetch (and cache) dependencies RUN mvn dependency:go-offline -B  # Copy source files COPY ./src ./src  # Compile application and library dependencies # The dependencies will, by default, be copied to target/dependency RUN mvn clean compile dependency:copy-dependencies -Dspring-boot.repackage.skip=true  # Final run image (based on https://stackoverflow.com/questions/53691781/how-to-cache-maven-dependencies-in-docker) FROM openjdk:8u171-jre-alpine # OPTIONAL: copy dependencies so the thin jar won't need to re-download them # COPY --from=maven /root/.m2 /root/.m2  # Change working directory WORKDIR /app  # Copy classes from maven image COPY --from=maven /app/target/classes ./classes  # Copy dependent libraries COPY --from=maven /app/target/dependency ./lib  EXPOSE 8080  # Please, modify your main class name as appropriate ENTRYPOINT [&quot;java&quot;, &quot;-cp&quot;, &quot;/app/classes:/app/lib/*&quot;, &quot;com.example.demo.DemoApplication&quot;] </code></pre> <p>The important line in the <code>Dockerfile</code> is this:</p> <pre><code>mvn clean compile dependency:copy-dependencies -Dspring-boot.repackage.skip=true </code></pre> <p>It will instruct maven to compile your resources and copy the required libraries. Although redundant for the typical Maven phase in which the <code>spring-boot-maven-plugin</code> <code>repackage</code> goal runs, the flag <code>spring-boot.repackage.skip=true</code> will instruct this plugin to not repackage the application.</p> <p>With this <code>Dockerfile</code>, build you image (let's tag it <code>devtools-demo</code>, for example):</p> <pre><code>docker build -t devtools-demo . </code></pre> <p>And run it:</p> <pre><code>docker run devtools-demo:latest </code></pre> <p>With this setup, if now you change your classes and/or resources, and run <code>mvn</code> locally:</p> <pre><code>mvn compile </code></pre> <p>you should be able to force the restart mechanism in your container with the following <code>docker cp</code> command:</p> <pre><code>docker cp classes &lt;container name&gt;:/app/classes </code></pre> <p>Please, again, consider mounting a volume in your container instead of using <code>docker cp</code>.</p> <p>I tested the setup and it worked properly.</p> <p>The important think to keep in mind is to replace your exploded resources, not the whole application jar.</p> <p>As another option, you can take an approach similar to the one indicated in your comments and run your Devtools in remote mode:</p> <pre><code>FROM maven:3.5-jdk-8 as maven  WORKDIR /app  # Copy project pom COPY ./pom.xml ./pom.xml  # Fetch (and cache) dependencies RUN mvn dependency:go-offline -B  # Copy source files COPY ./src ./src  # Build jar RUN mvn package &amp;&amp; cp target/your-app-version.jar app.jar  # Final run image (based on https://stackoverflow.com/questions/53691781/how-to-cache-maven-dependencies-in-docker) FROM openjdk:8u171-jre-alpine # OPTIONAL: copy dependencies so the thin jar won't need to re-download them # COPY --from=maven /root/.m2 /root/.m2  # Change working directory WORKDIR /app  # Copy artifact from the maven image COPY --from=maven /app/app.jar ./app.jar  ENV JAVA_DOCKER_OPTS &quot;-agentlib:jdwp=transport=dt_socket,server=y,address=*:8000,suspend=n&quot;  ENV JAVA_OPTS &quot;-Dspring.devtools.restart.enabled=true&quot;  EXPOSE 8000  EXPOSE 8080  ENTRYPOINT [&quot;/bin/bash&quot;, &quot;-lc&quot;, &quot;exec java $JAVA_DOCKER_OPTS $JAVA_OPTS -jar /app/app.jar&quot;] </code></pre> <p>For the Spring Boot Devtools remote mode to work properly, you need several things (some of them pointed out by Opri as well in his/her answer).</p> <p>First, you need to configure the <code>spring-boot-maven-plugin</code> to <a href='https://docs.spring.io/spring-boot/docs/1.5.16.RELEASE/reference/html/using-boot-devtools.html#using-boot-devtools-remote' rel='noreferrer'>include the devtools</a> in your application jar (it will be excluded otherwise, by default):</p> <pre class='lang-xml prettyprint-override'><code>&lt;plugin&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;   &lt;configuration&gt;     &lt;excludeDevtools&gt;false&lt;/excludeDevtools&gt;   &lt;/configuration&gt; &lt;/plugin&gt; </code></pre> <p>Then, you need to setup a value for the configuration property <code>spring.devtools.remote.secret</code>. This property has to do with the way remote debugging works in Spring Boot Devtools.</p> <p>The remote debugging functionality consists of two parts, a client and a server. Basically, the client is a copy of your server code, and it uses the value of the <code>spring.devtools.remote.secret</code> configuration property to authenticate itself against the server.</p> <p>This client code should be <a href='https://docs.spring.io/spring-boot/docs/1.5.16.RELEASE/reference/html/using-boot-devtools.html#_running_the_remote_client_application' rel='noreferrer'>run from an IDE</a>, and you attach your IDE debugging process to a local server exposed from that client.</p> <p>Every change performed in the client monitored resources, remember, the same as in your server, is pushed to the remote server and it will trigger a restart if necessary.</p> <p>As you can see, this functionality is again more appropriate from a development point of view.</p> <p>If you need to actually restart your application by overwriting your jar application file, maybe a better approach will be to configure your docker container to run a shell script in your <code>ENTRYPOINT</code> or <code>CMD</code>. This shell script will monitor a copy of your jar, in a certain directory. If that resource changes, as a consequence of your <code>docker cp</code>, this shell script will stop the current running application version - this application is supposed to run from a different location to avoid problems when updating the jar -, replace the current jar with the new one, and then start the new application version. Not the same, but please, consider read <a href='https://stackoverflow.com/questions/4002462/how-can-i-write-a-java-application-that-can-update-itself-at-runtime'>this related SO answer</a>.</p> <p>In any case, when you run an application in a container, you are trying to provide a consistent and platform independent way of deployment for it. From this perspective, instead of monitoring changes in your docker container, a more convenient approach may be to generate and to deploy a new version of your container image with those new changes. This process can be automated greatly using tools like Jenkins, Travis, etcetera. These tools allow you to define CI/CD pipelines that, in response to a code commit, for example, can generate on the fly a docker image with your code and, it configured accordingly, deploy later this image to services like some docker flavor or Kubernetes, on premises or in the cloud. Some of them, especially Kubernetes, but <a href='https://docs.docker.com/engine/swarm/swarm-tutorial/rolling-update/' rel='noreferrer'>swarm</a> an even <a href='https://stackoverflow.com/questions/49090395/how-to-achieve-a-rolling-update-with-docker-compose'>docker compose</a> as well, will allow you to perform rolling updates without or with minimal application service interruption.</p> <p>To conclude, probably it will not fit your needs, but be aware that you can use <a href='https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready' rel='noreferrer'><code>spring-boot-starter-actuator</code></a> directly or with <a href='https://github.com/codecentric/spring-boot-admin' rel='noreferrer'>Spring Boot Admin</a>, for instance, to restart your application.</p> <p>Finally, as already indicated in the Spring Boot Devtools documentation, you can try a different option, not based on restart but in application reload, in hot swapping. This functionality is offered by commercial products like <a href='https://www.jrebel.com/products/jrebel' rel='noreferrer'>JRebel</a> although there are some open sources alternatives as well, mainly <a href='https://dcevm.github.io' rel='noreferrer'>dcevm</a> and the <a href='https://github.com/HotswapProjects/HotswapAgent' rel='noreferrer'>HotswapAgent</a>. <a href='https://dzone.com/articles/hot-swap-java-bytecode-on-runtime' rel='noreferrer'>This related article</a> provides some insight in how these last two products work. <a href='https://github.com/HotswapProjects/hotswap-docklands' rel='noreferrer'>This Github project</a> provides complementary information about how to run it in docker containers.</p> "
  },
  {
    "Id": "70007676",
    "PostTypeId": "1",
    "AcceptedAnswerId": "70008049",
    "CreationDate": "2021-11-17T15:58:06.787",
    "Score": "8",
    "ViewCount": "5179",
    "Body": "<p>How do you inject Docker secrets (files/data from /run/secrets) into the application.properties files? Is it safe to use environment variables?</p> ",
    "OwnerUserId": "17439965",
    "LastEditorUserId": "466862",
    "LastEditDate": "2021-11-17T17:23:25.187",
    "LastActivityDate": "2022-12-13T20:55:44.510",
    "Title": "How to handle Docker-Secrets in application.properties files",
    "Tags": "<java><spring><spring-boot><docker><docker-secrets>",
    "AnswerCount": "4",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>First of all, usage of environment variables for secret data for the <code>application.properties</code> isn't safe.</p> <p>You have mainly two options when talking about Secrets.</p> <ol> <li><p>If you are using Docker Secrets <strong>without Docker Swarm</strong> then you can directly load the whole <code>application.properties</code> in a secret, mount it under <code>/run/secrets</code> and refer to it as configuration file with the Spring flags.</p> </li> <li><p>If you are using Docker Secrets <strong>with Docker Swarm</strong> then you can just store as secret the concrete fields that you're interested in and relate to them using the Configuration Templates of Swarm.</p> </li> </ol> <p>Example:</p> <pre><code>echo -n &quot;myUser&quot; | docker secret create db_user - echo -n &quot;myPass&quot; | docker secret create db_password - echo -n &quot;jdbc://...&quot; | docker secret create db_url - </code></pre> <p><strong>application.properties.tmpl</strong></p> <pre><code>spring.datasource.url={{ secret &quot;db_url&quot; }} spring.datasource.user={{ secret &quot;db_user&quot; }} spring.datasource.password={{ secret &quot;db_password&quot; }} </code></pre> <p><strong>docker-compose.yml</strong></p> <pre><code>version: '3.9' services:   api:     image: yourapp:1.0.0   configs:     - source: application.properties       target: /usr/app/config/application.properties   secrets:     - db_url     - db_user     - db_password  configs:   application.properties:     template_driver: golang     file: ./application.properties.tmpl     name: myapp.application.properties  secrets:   db_url:     external: true   db_user:     external: true   db_password:     external: true </code></pre> <p>When you deploy with <code>docker stack deploy -c docker-compose.yml myapp</code>, it will automatically populate the configuration with the contents of the secrets and it will mount it in the destination path.</p> ",
    "highest_rated_answer": "<p>The best way to use docker secrets in application.properties seems to be using configuration trees.</p> <p>If your docker secrets get mounted to /run/secrets (which is the default) then you just need to put <code>spring.config.import=optional:configtree:/run/secrets/</code> at the top of application.properties. Then you can use for example the docker secret <code>db_password</code> as <code>${db_password}</code>.</p> <p>See <a href='https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.external-config.files.configtree' rel='noreferrer'>https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.external-config.files.configtree</a></p> "
  },
  {
    "Id": "33660966",
    "PostTypeId": "1",
    "CreationDate": "2015-11-11T22:22:02.403",
    "Score": "7",
    "ViewCount": "1925",
    "Body": "<p>We've three Spring Boot applications:</p>  <ul> <li>Eureka Service</li> <li>Config Server</li> <li>Simple Web Service making use of Eureka and Config Server</li> </ul>  <p>I've set up the services so that we use a Eureka First Discovery, i.e. the simple web application finds out about the config server from the eureka service. </p>  <p>When started separately (either locally or by starting them as individual docker images) everything is ok, i.e. start config server after discovery service is running, and the Simple web service is started once the config server is running.</p>  <p>When docker-compose is used to start the services, they obviously start at the same time and essentially race to get up and running. This isn't an issue as we've added failFast: true and retry values to the simple web service and also have the docker container restarting so that the simple web service will eventually restart at a time when the discovery service and config server are both running but this doesn't feel optimal. </p>  <p>The unexpected behaviour we noticed was the following:</p>  <ul> <li>The simple web service reattempts a number of times to connect to the discovery service. This is sensible and expected</li> <li>At the same time the simple web service attempts to contact the config server. Because it cannot contact the discovery service, it retries to connect to a config server on localhost, e.g. logs show retries going to <a href='http://localhost:8888' rel='noreferrer'>http://localhost:8888</a>. This wasn't expected.</li> <li>The simple web service will eventually successfully connect to the discovery service but the logs show it stills tries to establish communication to the config server by going to <a href='http://localhost:8888' rel='noreferrer'>http://localhost:8888</a>. Again, this wasn't ideal.</li> </ul>  <p>Three questions/observations:</p>  <ul> <li>Is it a sensible strategy for the config client to fall back to trying localhost:8888 when it has been configured to use discovery to find the config server?</li> <li>When the eureka connections is established, should the retry mechanism not now switch to trying the config server endpoint as indicated by Eureka? Essentially putting in higher/longer retry intervals and periods for the config server connection is pointless in this case as it's never going to connect to it if it's looking at localhost so we're better just failing fast.</li> <li>Are there any properties that can override this behaviour?</li> </ul>  <p>I've created a sample github repo that demonstrates this behaviour:</p>  <p><a href='https://github.com/KramKroc/eurekafirstdiscovery/' rel='noreferrer'>https://github.com/KramKroc/eurekafirstdiscovery/tree/master</a></p> ",
    "OwnerUserId": "530846",
    "LastEditorUserId": "530846",
    "LastEditDate": "2015-11-12T15:51:39.393",
    "LastActivityDate": "2015-11-12T15:51:39.393",
    "Title": "Eureka First Discovery & Config Client Retry with Docker Compose",
    "Tags": "<spring-boot><spring-cloud><docker-compose><netflix-eureka>",
    "AnswerCount": "0",
    "CommentCount": "5",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": null
  },
  {
    "Id": "34449995",
    "PostTypeId": "1",
    "CreationDate": "2015-12-24T08:59:54.050",
    "Score": "7",
    "ViewCount": "2659",
    "Body": "<p>I am using spring boot to develop an app and I am using mysql as database.I have the below configuration in application.properties.</p>  <pre><code>server.port=8090 spring.datasource.url=jdbc:mysql://mysql:3306/sampleDB spring.datasource.username=root spring.datasource.password= spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.jpa.hibernate.dialect=org.hibernate.dialect.MySQLDialect spring.hibernate.dialect=org.hibernate.dialect.MySQLDialect spring.jpa.hibernate.show_sql=true spring.jpa.hibernate.ddl-auto=update spring.jpa.temp.use_jdbc_metadata_defaults=false logging.file=employee.log spring.datasource.testOnBorrow=true spring.datasource.validationQuery=SELECT 1 </code></pre>  <p>I have the respective DB in my local and it is working in my local. But as soon as I create a docker image and link to my mysql docker container it is throwing the below exception. </p>  <pre><code>org.hibernate.HibernateException: Access to DialectResolutionInfo cannot be null when 'hibernate.dialect' not set </code></pre>  <p>The container is not even building even for me to look into it.</p>  <pre><code>sudo docker run --name bootApp -d  --link mysql:mysql  springio/employeesecurity </code></pre>  <p>where <strong>springio/employeesecurity</strong> is my springBoot docker name and <strong>mysql</strong> is my msql container.</p> ",
    "OwnerUserId": "3828260",
    "LastActivityDate": "2022-04-15T05:43:11.233",
    "Title": "Spring Boot in Docker throwing an exception 'hibernate.dialect' not set",
    "Tags": "<hibernate><docker><spring-boot>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Probably your error is caused by not being able to connect to the db (deeper in your stack)</p>  <p>Have you tried not specifying the port in your connection string:</p>  <pre><code>spring.datasource.url=jdbc:mysql://mysql:3306/sampleDB </code></pre> "
  },
  {
    "Id": "37490324",
    "PostTypeId": "1",
    "AcceptedAnswerId": "37490325",
    "CreationDate": "2016-05-27T18:40:07.273",
    "Score": "7",
    "ViewCount": "8961",
    "Body": "<p>I've got a Spring Boot application implementing a service which I want to run in a Docker container. I've followed the guideline of the official <a href='https://spring.io/guides/gs/spring-boot-docker/' rel='nofollow noreferrer'>Spring docs</a> which suggest to create a DockerFile similar to this:</p>  <pre><code>FROM frolvlad/alpine-oraclejdk8:slim VOLUME /tmp ADD gs-spring-boot-docker-0.1.0.jar app.jar RUN sh -c 'touch /app.jar' ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre>  <p>Then once the image is pushed to Docker I use <a href='https://docs.docker.com/compose/' rel='nofollow noreferrer'>Docker Compose</a> to launch it this way:</p>  <pre><code>  spring-boot-docker:     ports:     - '80:80'     expose:     - '80'     image: my-repo/spring-boot-docker:0.1.0-SNAPSHOT     container_name: spring-boot-docker     environment:       JAVA_OPTS: '-Xmx64m' </code></pre>  <p>Here I've got the <code>JAVA_OPTS</code> variable which limits the memory allocation, however, when I execute <code>docker stats spring-boot-docker</code>, the memory taken by the container is excessive (I understand the total memory taken by the JVM might be much more than 64M, but in this case is totally boundless).</p>  <p>I've also tried with the <a href='https://stackoverflow.com/questions/28837544/can-i-use-mem-limit-in-docker-compose-and-how'><code>mem_limit</code> param</a>, but this slows down the application noticeably.</p> ",
    "OwnerUserId": "1199132",
    "LastEditorUserId": "-1",
    "LastEditDate": "2017-05-23T12:02:31.193",
    "LastActivityDate": "2016-05-29T07:48:44.820",
    "Title": "Limit JVM memory consumption in a Docker container",
    "Tags": "<java><docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>After struggling for a while, it seems the <code>JAVA_OPTS</code> variable can be passed to the container <a href='https://stackoverflow.com/a/29926938/1199132'>when it's based in a Tomcat image</a>, but Spring Boot uses Java itself as the base image.</p>  <p>I've found out <a href='https://medium.com/@cl4r1ty/docker-spring-boot-and-java-opts-ba381c818fa2#.ubbv3dcca' rel='nofollow noreferrer'>this tutorial</a> which solved the problem for me, just modifying the way the process is launched in the DockerFile and adding a JAVA_OPTS variable directly in the ENTRYPOINT:</p>  <pre><code>ENTRYPOINT exec java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app.jar </code></pre>  <p>This way, the JVM will pick the value from the command itself.</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "42175951",
    "PostTypeId": "1",
    "AcceptedAnswerId": "42175990",
    "CreationDate": "2017-02-11T12:38:20.267",
    "Score": "7",
    "ViewCount": "16754",
    "Body": "<p>I am setting up a Spring application to run using compose. The application needs to establish a connection to ActiveMQ either running locally for developers or to existing instances for staging/production.</p>  <p>I setup the following which is working great for local dev:</p>  <pre><code>amq:     image: rmohr/activemq:latest     ports:       - '61616:61616'       - '8161:8161' legacy-bridge:     image:  myco/myservice     links:       - amq </code></pre>  <p>and in the application configuration I am declaring the AMQ connection as </p>  <pre><code>broker-url=tcp://amq:61616 </code></pre>  <p>Running docker-compose up is working great, activeMQ is fired up locally and my application constiner starts and connects to it.</p>  <p>Now I need to set this up for staging/production where the ActiveMQ instances are running on existing hardware within the infrastructure. My thoughts are to either use spring profiles to handle a different configurations in which case the application configuration entry for 'broker-url=tcp://amq:61616' would become something like <code>broker-url=tcp://some.host.here:61616</code> or find some way to create a dns entry within my production docker-compose.yml which will point an <code>amq</code> dns entry to the associated staging or production queues.</p>  <p>What is the best approach here and if it is DNS, how to I set that up in compose?</p>  <p>Thanks!</p> ",
    "OwnerUserId": "1232376",
    "LastActivityDate": "2023-06-25T00:49:27.493",
    "Title": "How to configure dns entries for Docker Compose",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<h1>Using the <code>extra_hosts</code> flag</h1> <p>First thing that comes to mind is using <a href='https://docs.docker.com/compose/compose-file/#/extrahosts' rel='nofollow noreferrer'>Compose's <code>extra_hosts</code></a> flag:</p> <pre><code>legacy-bridge:   image:  myco/myservice   extra_hosts:     - &quot;amq:1.2.3.4&quot; </code></pre> <p>This will not create a DNS record, but an entry in the container's <code>/etc/hosts</code> file, effectively allowing you to continue using <code>tcp://amq:61616</code> as your broker URL in your application.</p> <h1>Using an ambassador container</h1> <p>If you're not content with directly specifying the production broker's IP address and would like to leverage existing DNS records, you can use the <a href='https://web.archive.org/web/20191127090430/https://docs.docker.com/v17.09/engine/admin/ambassador_pattern_linking/' rel='nofollow noreferrer'>ambassador pattern</a>:</p> <pre><code>amq-ambassador:   image: svendowideit/ambassador   command: [&quot;your-amq-dns-name&quot;, &quot;61616&quot;]   ports:     - 61616 legacy-bridge:   image:  myco/myservice   links:     - &quot;amq-ambassador:amq&quot; </code></pre> ",
    "highest_rated_answer": null
  },
  {
    "Id": "45996171",
    "PostTypeId": "1",
    "AcceptedAnswerId": "46000034",
    "CreationDate": "2017-09-01T08:32:44.300",
    "Score": "7",
    "ViewCount": "4794",
    "Body": "<p>I'm running Elasticsearch instance from Docker. The image is from jHipster docker hub repo: <a href='https://hub.docker.com/r/jhipster/jhipster-elasticsearch/' rel='noreferrer'>jhipster/jhipster-elasticsearch/</a> - I'm using image v1.3.2 because I need Elasticsearch 2.4.0 (to be in line with Spring Boot version of the project).</p>  <p>I'm starting ES container along with Logstash and Kibana images, with <code>docker-compose</code>. This are the settings for starting ES container:</p>  <pre><code>jhipster-elasticsearch:     image: jhipster/jhipster-elasticsearch:v1.3.2     ports:         - 9400:9200         - 9500:9300     volumes:        - ./log-es-config/elasticsearch_custom.yml:/usr/share/elasticsearch/config/elasticsearch.yml </code></pre>  <p>So I'm using 9400 for REST and 9500 for transport communication.</p>  <p>This is configuration inside <code>elasticsearch_custom.yml</code> that is mounted to ES config:</p>  <pre><code>cluster.name: 'log-cluster' node.name: 'log-node' http.host: 0.0.0.0 transport.host: 127.0.0.1 transport.tcp.port: 9500 transport.publish_port: 9500 </code></pre>  <p>When I start container, this is what I get from <code>http://localhost:9400/_nodes</code>:</p>  <pre><code>'cluster_name': 'log-cluster',   'nodes': {     'xLsGj2DyTdCF89I7sAToVw': {       'name': 'log-node',       'transport_address': '127.0.0.1:9500',       'host': '127.0.0.1',       'ip': '127.0.0.1',       'version': '2.4.0',       'build': 'ce9f0c7',       'http_address': '172.18.0.5:9200',       'settings': {         'cluster': {           'name': 'log-cluster'         },         ... (I can put all response if needed) </code></pre>  <p><strong>JAVA API:</strong></p>  <p>Now I'm trying to connect to this ES node like this:</p>  <pre><code>    @Bean     public ElasticsearchOperations logsElasticsearchOperations() throws UnknownHostException {         Settings settings = Settings.settingsBuilder()             .put('cluster.name', 'log-cluster')             .put('node.name', 'log-node')             .build();          Client client = TransportClient.builder()             .settings(settings)             .build()             .addTransportAddress(new InetSocketTransportAddress(new InetSocketAddress('127.0.0.1', 9500)));           ElasticsearchTemplate template = new ElasticsearchTemplate(client);         template.createIndex(ProcessLog.class);         log.debug('Elasticsearch for logs configured.');         return template;     } </code></pre>  <p>The error I'm getting is the most famous one:</p>  <p><strong><code>Caused by: org.elasticsearch.client.transport.NoNodeAvailableException: None of the configured nodes are available: [{#transport#-1}{127.0.0.1}{127.0.0.1:9500}]</code></strong></p>  <p>I googled and tried different config approaches, also with <code>client.transport.sniff</code> set to <code>false</code>, but non of those worked. Now I spent lots of time trying to configure this one and I'm still missing something.</p>  <p>Thanks in advance for help. </p>  <p><strong>UPDATE:</strong></p>  <p>There is also embedded ES instance running when I start the app. So host ports config is like this:</p>  <ul> <li>Embedded ES: 9200 (http), 9300 (tcp)</li> <li>Docker's ES: 9400 (http), 9500 (tcp)</li> </ul>  <p>Here is full <code>docker-compose.yml</code>:</p>  <pre><code>    version: '2'     services:     jhipster-elasticsearch:         # elasticsearch 2.4.0 - to be in line with spring boot version         image: jhipster/jhipster-elasticsearch:v1.3.2         ports:             - 9400:9200             - 9500:9300         volumes:            - ./log-es-config/elasticsearch_custom.yml:/usr/share/elasticsearch/config/elasticsearch.yml     jhipster-logstash:         image: jhipster/jhipster-logstash:v2.2.1         command: logstash -f /conf/logstash_custom.conf         ports:             - 5000:5000/udp             - 6000:6000/tcp         volumes:             - ./logstash-log-es-conf/:/conf     jhipster-console:         image: jhipster/jhipster-console:v2.0.1         ports:             - 5601:5601     jhipster-zipkin:         image: jhipster/jhipster-zipkin:v2.0.1         ports:             - 9411:9411         environment:             - ES_HOSTS=http://jhipster-elasticsearch:9400             - ZIPKIN_UI_LOGS_URL=http://localhost:5601/app/kibana#/dashboard/logs-dashboard?_g=(refreshInterval:(display:Off,pause:!f,value:0),time:(from:now-1h,mode:quick,to:now))&amp;_a=(filters:!(),options:(darkTheme:!f),panels:!((col:1,id:logs-levels,panelIndex:2,row:1,size_x:6,size_y:3,type:visualization),(col:7,columns:!(stack_trace),id:Stacktraces,panelIndex:7,row:1,size_x:4,size_y:3,sort:!('@timestamp',desc),type:search),(col:11,id:Log-forwarding-instructions,panelIndex:8,row:1,size_x:2,size_y:3,type:visualization),(col:1,columns:!(app_name,level,message),id:All-logs,panelIndex:9,row:4,size_x:12,size_y:7,sort:!('@timestamp',asc),type:search)),query:(query_string:(analyze_wildcard:!t,query:'{traceId}')),title:logs-dashboard,uiState:()) </code></pre> ",
    "OwnerUserId": "5250885",
    "LastEditorUserId": "5250885",
    "LastEditDate": "2017-09-01T09:04:49.137",
    "LastActivityDate": "2017-09-01T13:59:55.687",
    "Title": "Connecting to Docker Elasticsearch instance through Java/Spring Boot",
    "Tags": "<java><elasticsearch><docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>I managed to get this working by defining the <code>transport.host</code> as <code>0.0.0.0</code> inside <code>elasticsearch_custom.yml</code>, so the instance binds to the container's ip.</p>  <p>Maybe this should be also default setup for <code>elasticsearch.yml</code> on the project's github <a href='https://github.com/jhipster/jhipster-console/tree/master/jhipster-elasticsearch' rel='nofollow noreferrer'>repo</a>.</p> ",
    "highest_rated_answer": "<p>From your docker compose file, port 9500 on the host is mapped to port 9300 inside the container, i.e.:</p>  <pre><code>ports:     - 9500:9300 </code></pre>  <p>So since port 9500 is the TCP port outside of the Docker container, in your <code>elasticsearch_custom.yml</code> config file you should have this instead</p>  <pre><code>transport.tcp.port: 9300 transport.publish_port: 9300 </code></pre>  <p>or simply leave those two lines out since 9300 is the default TCP port.</p> "
  },
  {
    "Id": "47091229",
    "PostTypeId": "1",
    "CreationDate": "2017-11-03T08:19:32.310",
    "Score": "7",
    "ViewCount": "8474",
    "Body": "<p>I have a Spring-Boot Application with REST API (Maven build and MongoDB Database). I will also make a UI with Angular 2 on top of that (npm build). </p>  <p>What i would like to do is, to host this site, with its backend &amp; database on a server. Can i do that on my Synology NAS (DS216j)? Or should i better buy a small computer like Raspberry Pi 3?</p>  <p>I have heard somewhere that we can deploy our apps in Docker, and Synology has a docker app or sth? Will this help me reaching my goal? I would like to have a step by step guide from your similar setups. </p> ",
    "OwnerUserId": "2224454",
    "LastEditorUserId": "2224454",
    "LastEditDate": "2017-11-03T21:29:24.240",
    "LastActivityDate": "2017-11-03T21:29:24.240",
    "Title": "Can i deploy my Java Spring-Boot Application in my Synology NAS?",
    "Tags": "<java><docker><spring-boot><deployment><synology>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>As far as I understand, you only want to get your app running on your NAS, so using Docker would be an option, but no requirement.</p>  <p>According to the <a href='https://www.synology.com/en-global/support/download/DS216j#packages' rel='nofollow noreferrer'>model-specific download page</a>, your DS216j supports Java8. So what you have to do:</p>  <ol> <li>Install Java on your NAS</li> <li>Package your application as standalone jar-file: If not yet done, you can do that in your pom.xml (see <a href='https://docs.spring.io/spring-boot/docs/current/reference/html/build-tool-plugins-maven-plugin.html#build-tool-plugins-maven-packaging' rel='nofollow noreferrer'>Spring Boot documentation</a> for details; btw, this standalone mode is one of the best features of Spring Boot)</li> <li>Now you can upload the jar-file </li> <li>Run it via the <a href='https://www.synology.com/en-global/knowledgebase/DSM/help/DSM/AdminCenter/system_terminal' rel='nofollow noreferrer'>command line</a> with <code>java -jar &lt;jar-file-name&gt;.jar</code></li> </ol>  <p>Just make sure that the port of your app does not conflict with the ports used by your NAS.</p>  <p>You could also create a Docker image from your app and run it on your NAS, it seems like your model supports Docker: <a href='https://www.synology.com/en-us/dsm/packages/Docker' rel='nofollow noreferrer'>https://www.synology.com/en-us/dsm/packages/Docker</a>. But that would create some extra effort, but no added value, from my point of view.</p> "
  },
  {
    "Id": "48227857",
    "PostTypeId": "1",
    "AcceptedAnswerId": "48231206",
    "CreationDate": "2018-01-12T14:04:01.130",
    "Score": "7",
    "ViewCount": "27483",
    "Body": "<p>I'm trying to use <code>Spring Boot</code> with <code>Kafka</code> and <code>ZooKeeper</code> with <code>Docker</code> :</p>  <p><code>docker-compose.yml:</code></p>  <pre><code>version: '2'  services:  zookeeper:  image: wurstmeister/zookeeper  restart: always  ports:    - '2181:2181'  kafka:  image: wurstmeister/kafka  restart: always  ports:    - '9092:9092'  environment:    KAFKA_ADVERTISED_HOST_NAME: localhost    KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181 </code></pre>  <p><code>docker ps</code> output:</p>  <pre><code>CONTAINER ID        IMAGE                    COMMAND                            CREATED             STATUS              PORTS                                                        NAMES 980e6b09f4e3        wurstmeister/kafka       'start-kafka.sh'         29 minutes ago      Up 29 minutes       0.0.0.0:9092-&gt;9092/tcp                               samplespringkafkaproducerconsumermaster_kafka_1 64519d4808aa        wurstmeister/zookeeper   '/bin/sh -c '/usr/sb\u2026'   2 hours ago         Up 29 minutes       22/tcp, 2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp   samplespringkafkaproducerconsumermaster_zookeeper_1 </code></pre>  <p><code>docker-compose up</code> output log:</p>  <pre><code>kafka_1      | [2018-01-12 13:14:49,545] INFO Client environment:java.library.path=/usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib (org.apache.zookeeper.ZooKeeper) kafka_1      | [2018-01-12 13:14:49,546] INFO Client environment:java.io.tmpdir=/tmp (org.apache.zookeeper.ZooKeeper) kafka_1      | [2018-01-12 13:14:49,546] INFO Client environment:java.compiler=&lt;NA&gt; (org.apache.zookeeper.ZooKeeper) kafka_1      | [2018-01-12 13:14:49,547] INFO Client environment:os.name=Linux (org.apache.zookeeper.ZooKeeper) kafka_1      | [2018-01-12 13:14:49,547] INFO Client environment:os.arch=amd64 (org.apache.zookeeper.ZooKeeper) kafka_1      | [2018-01-12 13:14:49,548] INFO Client environment:os.version=4.9.60-linuxkit-aufs (org.apache.zookeeper.ZooKeeper) kafka_1      | [2018-01-12 13:14:49,548] INFO Client environment:user.name=root (org.apache.zookeeper.ZooKeeper) kafka_1      | [2018-01-12 13:14:49,549] INFO Client environment:user.home=/root (org.apache.zookeeper.ZooKeeper) kafka_1      | [2018-01-12 13:14:49,549] INFO Client environment:user.dir=/ (org.apache.zookeeper.ZooKeeper) kafka_1      | [2018-01-12 13:14:49,552] INFO Initiating client connection, connectString=zookeeper:2181 sessionTimeout=6000 watcher=org.I0Itec.zkclient.ZkClient@1534f01b (org.apache.zookeeper.ZooKeeper) kafka_1      | [2018-01-12 13:14:49,574] INFO Waiting for keeper state SyncConnected (org.I0Itec.zkclient.ZkClient) kafka_1      | [2018-01-12 13:14:49,578] INFO Opening socket connection to server samplespringkafkaproducerconsumermaster_zookeeper_1.samplespringkafkaproducerconsumermaster_default/192.168.32.2:2181. Will not attempt to authenticate using SASL (unknown error) (org.apache.zookeeper.ClientCnxn) zookeeper_1  | 2018-01-12 13:14:49,591 [myid:] - INFO  [NIOServerCxn.Factory:0.0.0.0/0.0.0.0:2181:NIOServerCnxnFactory@192] - Accepted socket connection from /192.168.32.3:51466 kafka_1      | [2018-01-12 13:14:49,593] INFO Socket connection established to samplespringkafkaproducerconsumermaster_zookeeper_1.samplespringkafkaproducerconsumermaster_default/192.168.32.2:2181, initiating session (org.apache.zookeeper.ClientCnxn) zookeeper_1  | 2018-01-12 13:14:49,600 [myid:] - INFO  [NIOServerCxn.Factory:0.0.0.0/0.0.0.0:2181:ZooKeeperServer@928] - Client attempting to establish new session at /192.168.32.3:51466 zookeeper_1  | 2018-01-12 13:14:49,603 [myid:] - INFO  [SyncThread:0:FileTxnLog@203] - Creating new log file: log.fd zookeeper_1  | 2018-01-12 13:14:49,613 [myid:] - INFO  [SyncThread:0:ZooKeeperServer@673] - Established session 0x160ea8232b00000 with negotiated timeout 6000 for client /192.168.32.3:51466 kafka_1      | [2018-01-12 13:14:49,616] INFO Session establishment complete on server samplespringkafkaproducerconsumermaster_zookeeper_1.samplespringkafkaproducerconsumermaster_default/192.168.32.2:2181, sessionid = 0x160ea8232b00000, negotiated timeout = 6000 (org.apache.zookeeper.ClientCnxn) kafka_1      | [2018-01-12 13:14:49,619] INFO zookeeper state changed (SyncConnected) (org.I0Itec.zkclient.ZkClient) kafka_1      | [2018-01-12 13:14:49,992] INFO Cluster ID = Fgy9ybPPQQ-QdLINzHpmVA (kafka.server.KafkaServer) kafka_1      | [2018-01-12 13:14:50,003] WARN No meta.properties file under dir /kafka/kafka-logs-980e6b09f4e3/meta.properties (kafka.server.BrokerMetadataCheckpoint) kafka_1      | [2018-01-12 13:14:50,065] INFO [ThrottledRequestReaper-Fetch]: Starting (kafka.server.ClientQuotaManager$ThrottledRequestReaper) kafka_1      | [2018-01-12 13:14:50,065] INFO [ThrottledRequestReaper-Produce]: Starting (kafka.server.ClientQuotaManager$ThrottledRequestReaper) kafka_1      | [2018-01-12 13:14:50,067] INFO [ThrottledRequestReaper-Request]: Starting (kafka.server.ClientQuotaManager$ThrottledRequestReaper) kafka_1      | [2018-01-12 13:14:50,167] INFO Log directory '/kafka/kafka-logs-980e6b09f4e3' not found, creating it. (kafka.log.LogManager) kafka_1      | [2018-01-12 13:14:50,183] INFO Loading logs. (kafka.log.LogManager) kafka_1      | [2018-01-12 13:14:50,199] INFO Logs loading complete in 15 ms. (kafka.log.LogManager) kafka_1      | [2018-01-12 13:14:50,283] INFO Starting log cleanup with a period of 300000 ms. (kafka.log.LogManager) kafka_1      | [2018-01-12 13:14:50,291] INFO Starting log flusher with a default period of 9223372036854775807 ms. (kafka.log.LogManager) kafka_1      | [2018-01-12 13:14:50,633] INFO Awaiting socket connections on 0.0.0.0:9092. (kafka.network.Acceptor) kafka_1      | [2018-01-12 13:14:50,639] INFO [SocketServer brokerId=1005] Started 1 acceptor threads (kafka.network.SocketServer) kafka_1      | [2018-01-12 13:14:50,673] INFO [ExpirationReaper-1005-Produce]: Starting (kafka.server.DelayedOperationPurgatory$ExpiredOperationReaper) kafka_1      | [2018-01-12 13:14:50,674] INFO [ExpirationReaper-1005-Fetch]: Starting (kafka.server.DelayedOperationPurgatory$ExpiredOperationReaper) kafka_1      | [2018-01-12 13:14:50,675] INFO [ExpirationReaper-1005-DeleteRecords]: Starting (kafka.server.DelayedOperationPurgatory$ExpiredOperationReaper) kafka_1      | [2018-01-12 13:14:50,691] INFO [LogDirFailureHandler]: Starting (kafka.server.ReplicaManager$LogDirFailureHandler) kafka_1      | [2018-01-12 13:14:50,753] INFO [ExpirationReaper-1005-topic]: Starting (kafka.server.DelayedOperationPurgatory$ExpiredOperationReaper) kafka_1      | [2018-01-12 13:14:50,757] INFO [ExpirationReaper-1005-Heartbeat]: Starting (kafka.server.DelayedOperationPurgatory$ExpiredOperationReaper) kafka_1      | [2018-01-12 13:14:50,762] INFO [ExpirationReaper-1005-Rebalance]: Starting (kafka.server.DelayedOperationPurgatory$ExpiredOperationReaper) kafka_1      | [2018-01-12 13:14:50,777] INFO Creating /controller (is it secure? false) (kafka.utils.ZKCheckedEphemeral) kafka_1      | [2018-01-12 13:14:50,791] INFO [GroupCoordinator 1005]: Starting up. (kafka.coordinator.group.GroupCoordinator) kafka_1      | [2018-01-12 13:14:50,791] INFO Result of znode creation is: OK (kafka.utils.ZKCheckedEphemeral) kafka_1      | [2018-01-12 13:14:50,793] INFO [GroupCoordinator 1005]: Startup complete. (kafka.coordinator.group.GroupCoordinator) kafka_1      | [2018-01-12 13:14:50,798] INFO [GroupMetadataManager brokerId=1005] Removed 0 expired offsets in 5 milliseconds. (kafka.coordinator.group.GroupMetadataManager) kafka_1      | [2018-01-12 13:14:50,811] INFO [ProducerId Manager 1005]: Acquired new producerId block (brokerId:1005,blockStartProducerId:5000,blockEndProducerId:5999) by writing to Zk with path version 6 (kafka.coordinator.transaction.ProducerIdManager) kafka_1      | [2018-01-12 13:14:50,848] INFO [TransactionCoordinator id=1005] Starting up. (kafka.coordinator.transaction.TransactionCoordinator) kafka_1      | [2018-01-12 13:14:50,850] INFO [Transaction Marker Channel Manager 1005]: Starting (kafka.coordinator.transaction.TransactionMarkerChannelManager) kafka_1      | [2018-01-12 13:14:50,850] INFO [TransactionCoordinator id=1005] Startup complete. (kafka.coordinator.transaction.TransactionCoordinator) kafka_1      | [2018-01-12 13:14:50,949] INFO Creating /brokers/ids/1005 (is it secure? false) (kafka.utils.ZKCheckedEphemeral) zookeeper_1  | 2018-01-12 13:14:50,952 [myid:] - INFO  [ProcessThread(sid:0 cport:2181)::PrepRequestProcessor@649] - Got user-level KeeperException when processing sessionid:0x160ea8232b00000 type:create cxid:0x70 zxid:0x102 txntype:-1 reqpath:n/a Error Path:/brokers Error:KeeperErrorCode = NodeExists for /brokers zookeeper_1  | 2018-01-12 13:14:50,952 [myid:] - INFO  [ProcessThread(sid:0 cport:2181)::PrepRequestProcessor@649] - Got user-level KeeperException when processing sessionid:0x160ea8232b00000 type:create cxid:0x71 zxid:0x103 txntype:-1 reqpath:n/a Error Path:/brokers/ids Error:KeeperErrorCode = NodeExists for /brokers/ids kafka_1      | [2018-01-12 13:14:50,957] INFO Result of znode creation is: OK (kafka.utils.ZKCheckedEphemeral) kafka_1      | [2018-01-12 13:14:50,959] INFO Registered broker 1005 at path /brokers/ids/1005 with addresses: EndPoint(localhost,9092,ListenerName(PLAINTEXT),PLAINTEXT) (kafka.utils.ZkUtils) kafka_1      | [2018-01-12 13:14:50,961] WARN No meta.properties file under dir /kafka/kafka-logs-980e6b09f4e3/meta.properties (kafka.server.BrokerMetadataCheckpoint) kafka_1      | [2018-01-12 13:14:50,992] INFO Kafka version : 1.0.0 (org.apache.kafka.common.utils.AppInfoParser) kafka_1      | [2018-01-12 13:14:50,993] INFO Kafka commitId : aaa7af6d4a11b29d (org.apache.kafka.common.utils.AppInfoParser) kafka_1      | [2018-01-12 13:14:51,004] INFO [KafkaServer id=1005] started (kafka.server.KafkaServer) zookeeper_1  | 2018-01-12 13:14:51,263 [myid:] - INFO  [ProcessThread(sid:0 cport:2181)::PrepRequestProcessor@649] - Got user-level KeeperException when processing sessionid:0x160ea8232b00000 type:delete cxid:0xe3 zxid:0x105 txntype:-1 reqpath:n/a Error Path:/admin/preferred_replica_election Error:KeeperErrorCode = NoNode for /admin/preferred_replica_election kafka_1      | [2018-01-12 13:24:50,793] INFO [GroupMetadataManager brokerId=1005] Removed 0 expired offsets in 0 milliseconds. (kafka.coordinator.group.GroupMetadataManager) kafka_1      | [2018-01-12 13:34:50,795] INFO [GroupMetadataManager brokerId=1005] Removed 0 expired offsets in 0 milliseconds. (kafka.coordinator.group.GroupMetadataManager) </code></pre>  <p><code>Kafka</code> maven dependency in <code>Producer</code> and <code>Consumer</code>:</p>  <pre><code> &lt;parent&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;      &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;      &lt;relativePath/&gt;  &lt;/parent&gt;   &lt;dependency&gt;      &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;      &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;  &lt;/dependency&gt; </code></pre>  <p><code>application.properties</code> in <code>Producer</code>:</p>  <pre><code> spring.kafka.producer.bootstrap-servers=0.0.0.0:9092   spring.kafka.consumer.topic=kafka_topic  server.port=8080 </code></pre>  <p><code>application.properties</code> in <code>Consumer</code>:</p>  <pre><code> spring.kafka.consumer.bootstrap-servers=0.0.0.0:9092  spring.kafka.consumer.group-id=WorkUnitApp   spring.kafka.consumer.topic=kafka_topic  server.port=8081 </code></pre>  <p><code>Consumer</code>:</p>  <pre><code>@Component  public class Consumer {  private static final Logger LOGGER = LoggerFactory.getLogger(Consumer.class);  @KafkaListener(topics = '${spring.kafka.consumer.topic}')  public void receive(ConsumerRecord&lt;?, ?&gt; consumerRecord) {  LOGGER.info('received payload='{}'', consumerRecord.toString());  } } </code></pre>  <p><code>Producer</code>:</p>  <pre><code>@Component public class Producer {  private static final Logger LOGGER = LoggerFactory.getLogger(Producer.class);  @Autowired private KafkaTemplate&lt;String, String&gt; kafkaTemplate;  public void send(String topic, String payload) {  LOGGER.info('sending payload='{}' to topic='{}'', payload, topic);  kafkaTemplate.send(topic, payload);  } } </code></pre>  <p><code>ConsumerConfig</code> log:</p>  <pre><code>2018-01-12 15:25:48.220  INFO 20919 --- [           main] o.a.k.clients.consumer.ConsumerConfig    : ConsumerConfig values:  auto.commit.interval.ms = 5000 auto.offset.reset = latest bootstrap.servers = [0.0.0.0:9092] check.crcs = true client.id = consumer-1 connections.max.idle.ms = 540000 enable.auto.commit = true exclude.internal.topics = true fetch.max.bytes = 52428800 fetch.max.wait.ms = 500 fetch.min.bytes = 1 group.id = WorkUnitApp heartbeat.interval.ms = 3000 interceptor.classes = null key.deserializer = class org.apache.kafka.common.serialization.StringDeserializer max.partition.fetch.bytes = 1048576 max.poll.interval.ms = 300000 max.poll.records = 500 metadata.max.age.ms = 300000 metric.reporters = [] metrics.num.samples = 2 metrics.sample.window.ms = 30000 partition.assignment.strategy = [class org.apache.kafka.clients.consumer.RangeAssignor] receive.buffer.bytes = 65536 reconnect.backoff.ms = 50 request.timeout.ms = 305000 retry.backoff.ms = 100 sasl.kerberos.kinit.cmd = /usr/bin/kinit sasl.kerberos.min.time.before.relogin = 60000 sasl.kerberos.service.name = null sasl.kerberos.ticket.renew.jitter = 0.05 sasl.kerberos.ticket.renew.window.factor = 0.8 sasl.mechanism = GSSAPI security.protocol = PLAINTEXT send.buffer.bytes = 131072 session.timeout.ms = 10000 ssl.cipher.suites = null ssl.enabled.protocols = [TLSv1.2, TLSv1.1, TLSv1] ssl.endpoint.identification.algorithm = null ssl.key.password = null ssl.keymanager.algorithm = SunX509 ssl.keystore.location = null ssl.keystore.password = null ssl.keystore.type = JKS ssl.protocol = TLS ssl.provider = null ssl.secure.random.implementation = null ssl.trustmanager.algorithm = PKIX ssl.truststore.location = null ssl.truststore.password = null ssl.truststore.type = JKS value.deserializer = class org.apache.kafka.common.serialization.StringDeserializer </code></pre>  <p><code>ProducerConfig</code> log:</p>  <pre><code>2018-01-12 15:26:27.956  INFO 20924 --- [nio-8080-exec-1] o.a.k.clients.producer.ProducerConfig    : ProducerConfig values:  acks = 1 batch.size = 16384 block.on.buffer.full = false bootstrap.servers = [0.0.0.0:9092] buffer.memory = 33554432 client.id = producer-1 compression.type = none connections.max.idle.ms = 540000 interceptor.classes = null key.serializer = class org.apache.kafka.common.serialization.StringSerializer linger.ms = 0 max.block.ms = 60000 max.in.flight.requests.per.connection = 5 max.request.size = 1048576 metadata.fetch.timeout.ms = 60000 metadata.max.age.ms = 300000 metric.reporters = [] metrics.num.samples = 2 metrics.sample.window.ms = 30000 partitioner.class = class org.apache.kafka.clients.producer.internals.DefaultPartitioner receive.buffer.bytes = 32768 reconnect.backoff.ms = 50 request.timeout.ms = 30000 retries = 0 retry.backoff.ms = 100 sasl.kerberos.kinit.cmd = /usr/bin/kinit sasl.kerberos.min.time.before.relogin = 60000 sasl.kerberos.service.name = null sasl.kerberos.ticket.renew.jitter = 0.05 sasl.kerberos.ticket.renew.window.factor = 0.8 sasl.mechanism = GSSAPI security.protocol = PLAINTEXT send.buffer.bytes = 131072 ssl.cipher.suites = null ssl.enabled.protocols = [TLSv1.2, TLSv1.1, TLSv1] ssl.endpoint.identification.algorithm = null ssl.key.password = null ssl.keymanager.algorithm = SunX509 ssl.keystore.location = null ssl.keystore.password = null ssl.keystore.type = JKS ssl.protocol = TLS ssl.provider = null ssl.secure.random.implementation = null ssl.trustmanager.algorithm = PKIX ssl.truststore.location = null ssl.truststore.password = null ssl.truststore.type = JKS timeout.ms = 30000 value.serializer = class org.apache.kafka.common.serialization.StringSerializer </code></pre>  <p>When i try to send a message I get an exception:</p>  <p><code>producer.send('kafka_topic', 'test')</code> </p>  <p>exception log:</p>  <pre><code>2018-01-12 15:26:27.975  INFO 20924 --- [nio-8080-exec-1]    o.a.kafka.common.utils.AppInfoParser     : Kafka version : 0.10.1.1 2018-01-12 15:26:27.975  INFO 20924 --- [nio-8080-exec-1] o.a.kafka.common.utils.AppInfoParser     : Kafka commitId : f10ef2720b03b247 2018-01-12 15:26:58.152 ERROR 20924 --- [ad | producer-1] o.s.k.support.LoggingProducerListener    : Exception thrown when sending a message with key='null' and payload='test' to topic kafka_topic:  org.apache.kafka.common.errors.TimeoutException: Expiring 1 record(s) for kafka_topic-0 due to 30033 ms has passed since batch creation plus linger time </code></pre>  <p>How to fix it ?</p> ",
    "OwnerUserId": "8112217",
    "LastActivityDate": "2021-09-13T15:03:17.070",
    "Title": "Spring Boot & Kafka, Producer thrown exception with key='null'",
    "Tags": "<docker><spring-boot><apache-kafka>",
    "AnswerCount": "4",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>Problem is not with sending <code>key</code> as <code>null</code>, Connection to a broker may not be established</p>  <ul> <li><p>try using local Kafka installation.</p></li> <li><p>If you are using mac Docker for mac having some networking limitations <a href='https://docs.docker.com/docker-for-mac/networking/#known-limitations-use-cases-and-workarounds' rel='noreferrer'>https://docs.docker.com/docker-for-mac/networking/#known-limitations-use-cases-and-workarounds</a></p></li> </ul> ",
    "highest_rated_answer": "<p>i ran into the same issue. the issue was with my dockercompose file.  not 100% but i think <em>KAFKA_ADVERTISED_HOST_NAME</em> and <em>KAFKA_ADVERTISED_LISTENERS</em> both need to refernce localhost.  my working compose file.</p> <pre><code>version: '2'  networks:   sb_net:     driver: bridge  services:   zookeeper:     image: confluentinc/cp-zookeeper:latest     hostname: zookeeper     networks:      - sb_net     ports:       - &quot;2181:2181&quot;     environment:       ZOOKEEPER_CLIENT_PORT: 2181       ZOOKEEPER_TICK_TIME: 2000    kafka:     image: confluentinc/cp-kafka:latest     depends_on:       - zookeeper     networks:      - sb_net     ports:       - &quot;9092:9092&quot;     environment:       KAFKA_BROKER_ID: 1       KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181       KAFKA_ADVERTISED_HOST_NAME: localhost       KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092       KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1 </code></pre> "
  },
  {
    "Id": "50035024",
    "PostTypeId": "1",
    "AcceptedAnswerId": "50035102",
    "CreationDate": "2018-04-26T04:48:51.413",
    "Score": "7",
    "ViewCount": "4801",
    "Body": "<p>I'm trying to pass environment variables to a Spring Boot application but it doesn't seem to be working.</p>  <p>Docker run command:</p>  <pre><code>docker run my-image -e TEST_VAR='testing' </code></pre>  <p>Spring Boot main():</p>  <pre><code>@SpringBootApplication public class MyApplication {      public static void main(String[] args) {         ApplicationContext ctx = SpringApplication.run(MyApplication.class, args);          //Read environmental variables:         Map&lt;String, String&gt; env = System.getenv();         System.out.println('TEST_VAR: '+env.get('TEST_VAR'));       } } </code></pre>  <p>Output:</p>  <pre><code>TEST_VAR: null </code></pre>  <p>How can I successfully pass environmental variables with Docker? </p> ",
    "OwnerUserId": "3564870",
    "LastActivityDate": "2018-04-26T11:30:35.793",
    "Title": "Passing Environment Variables With Docker to Spring Boot Application Not Working",
    "Tags": "<docker><spring-boot>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p><a href='https://docs.docker.com/engine/reference/run/#env-environment-variables' rel='noreferrer'><code>docker run</code></a> does mention</p> <blockquote> <p>Additionally, the operator can set any environment variable in the container by using one or more -e flags, even overriding those mentioned above, or already defined by the developer with a Dockerfile ENV.</p> <p>If the operator names an environment variable without specifying a value, then the current value of the named variable is propagated into the container\u2019s environment:</p> </blockquote> <p>But the example is:</p> <pre><code>docker run -e &quot;deep=purple&quot; -e today --rm alpine env </code></pre> <p>So check your quotes, and parameters order (as <a href='https://stackoverflow.com/users/596285/bmitch'>BMitch</a> observes, any parameter done <em>after</em> the image name would be passed as <code>CMD</code> to your image ENTRYPOINT command, which is not what you want):</p> <pre><code>docker run -e &quot;TEST_VAR=testing&quot; my-image  </code></pre> ",
    "highest_rated_answer": "<p>The order of options is important on the docker command line. There are flags you can pass before the run command, flags you can pass to the run command, and args that get passed to the image as your command to run. In your example:</p>  <pre><code>docker run my-image -e TEST_VAR='testing' </code></pre>  <p>The <code>-e TEST_VAR='testing'</code> gets passed on as the new value of <code>CMD</code> for the container to run (or argument to your entrypoint).</p>  <p>By reordering your command, you will tell <code>run</code> to pass the environment variable to the container as desired:</p>  <pre><code>docker run -e TEST_VAR='testing' my-image </code></pre> "
  },
  {
    "Id": "51710753",
    "PostTypeId": "1",
    "AcceptedAnswerId": "51724659",
    "CreationDate": "2018-08-06T15:11:59.427",
    "Score": "7",
    "ViewCount": "13215",
    "Body": "<p>Good day collegues. I developed an application based on sparkLauncher that run an executable jar where are 5 operations. Each operation depending on the specific variable. I have a main hadoop cluster spark2.3.0-hadoop2.6.5. It works good on it. Part of my working code:</p>  <pre><code> private void runSparkJob(String pathToJar, final LocalDate startDate, final LocalDate endDate) {         if (executionInProgress.get()) {             LOGGER.warn('Execution already in progress');             return;         }         Process sparkProcess = null;         try {             LOGGER.info('Create SparkLauncher. SparkHome: [{}]. JarPath: [{}].', sparkHome, vmJarPath);             executionInProgress.set(true);             sparkProcess = new SparkLauncher()                     .setAppName(activeOperationProfile)                     .setSparkHome(sparkHome) //sparkHome folder on main cluster                     .setAppResource(pathToJar) // jar with 5 operation                     .setConf(SparkLauncher.DRIVER_EXTRA_JAVA_OPTIONS,                             String.format('-Drunner.operation-profile=%1$s -Doperation.startDate=%2$s -Doperation.endDate=%3$s', activeOperationProfile, startDate,endDate))                     .setConf(SparkLauncher.DRIVER_MEMORY, '12G')                     .redirectToLog(LOGGER.getName())                     .setMaster('yarn')                     .launch();              sparkProcess.waitFor();             int exitCode = sparkProcess.exitValue();             if (exitCode != 0) {                 throw new RuntimeException('Illegal exit code. Expected: [0]. Actual: [' + exitCode + ']');             }          } catch (IOException | InterruptedException e) {             LOGGER.error('Error occurred while running SparkApplication.', e);             throw new RuntimeException(e);         } finally {             if (sparkProcess != null &amp;&amp; sparkProcess.isAlive()) {                 LOGGER.warn('Process still alive. Try to kill');                 sparkProcess.destroy();             }             executionInProgress.set(false);         }     } </code></pre>  <p>I have started a docker container, where is a downloaded spark 2.3.0-hadoop6. This container needed for testers. <strong>I changed master to .setMaster('local'), put new profile with paths to sparkHome, jarsWithOpertations</strong> and packaged jar without shade(tried with shade and it doesn't work for me). When i tried to run my sparkLaunch app i have an exception now:</p>  <blockquote>   <p>2018-08-06 14:47:53,150 INFO    [n.m.m.b.r.SparkBaseOperationsRunner.runSparkJob] 105 : Create   SparkLauncher. SparkHome:   [/opt/bigtv/spark/spark-2.3.0-bin-hadoop2.6]. JarPath:   [/opt/bigtv/bin/multirating-bigdata-operations-MASTER-SNAPSHOT.jar].   2018-08-06 14:47:54,905 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 : 2018-08-06   14:47:54 WARN  NativeCodeLoader:62 - Unable to load native-hadoop   library for your platform... using builtin-java classes where   applicable 2018-08-06 14:47:57,042 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 : 2018-08-06   14:47:57 ERROR SpringApplication:842 - Application run failed   2018-08-06 14:47:57,043 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :   <strong>java.lang.NoSuchMethodError:   org.yaml.snakeyaml.Yaml.(Lorg/yaml/snakeyaml/constructor/BaseConstructor;Lorg/yaml/snakeyaml/representer/Representer;Lorg/yaml/snakeyaml/DumperOptions;Lorg/yaml/snakeyaml/LoaderOptions;Lorg/yaml/snakeyaml/resolver/Resolver;)V</strong>   2018-08-06 14:47:57,043 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.env.OriginTrackedYamlLoader.createYaml(OriginTrackedYamlLoader.java:70)   2018-08-06 14:47:57,043 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.beans.factory.config.YamlProcessor.process(YamlProcessor.java:139)   2018-08-06 14:47:57,044 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.env.OriginTrackedYamlLoader.load(OriginTrackedYamlLoader.java:75)   2018-08-06 14:47:57,044 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.env.YamlPropertySourceLoader.load(YamlPropertySourceLoader.java:50)   2018-08-06 14:47:57,044 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.context.config.ConfigFileApplicationListener$Loader.loadDocuments(ConfigFileApplicationListener.java:547)   2018-08-06 14:47:57,044 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.context.config.ConfigFileApplicationListener$Loader.load(ConfigFileApplicationListener.java:517)   2018-08-06 14:47:57,045 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.context.config.ConfigFileApplicationListener$Loader.loadForFileExtension(ConfigFileApplicationListener.java:496)   2018-08-06 14:47:57,045 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.context.config.ConfigFileApplicationListener$Loader.load(ConfigFileApplicationListener.java:464)   2018-08-06 14:47:57,045 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.context.config.ConfigFileApplicationListener$Loader.lambda$null$6(ConfigFileApplicationListener.java:446)   2018-08-06 14:47:57,046 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   java.lang.Iterable.forEach(Iterable.java:75) 2018-08-06 14:47:57,046   INFO  [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.context.config.ConfigFileApplicationListener$Loader.lambda$load$7(ConfigFileApplicationListener.java:445)   2018-08-06 14:47:57,046 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   java.lang.Iterable.forEach(Iterable.java:75) 2018-08-06 14:47:57,046   INFO  [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.context.config.ConfigFileApplicationListener$Loader.load(ConfigFileApplicationListener.java:442)   2018-08-06 14:47:57,046 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.context.config.ConfigFileApplicationListener$Loader.load(ConfigFileApplicationListener.java:330)   2018-08-06 14:47:57,047 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.context.config.ConfigFileApplicationListener.addPropertySources(ConfigFileApplicationListener.java:212)   2018-08-06 14:47:57,047 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.context.config.ConfigFileApplicationListener.postProcessEnvironment(ConfigFileApplicationListener.java:195)   2018-08-06 14:47:57,047 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.context.config.ConfigFileApplicationListener.onApplicationEnvironmentPreparedEvent(ConfigFileApplicationListener.java:182)   2018-08-06 14:47:57,047 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.context.config.ConfigFileApplicationListener.onApplicationEvent(ConfigFileApplicationListener.java:168)   2018-08-06 14:47:57,048 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172)   2018-08-06 14:47:57,048 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165)   2018-08-06 14:47:57,048 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139)   2018-08-06 14:47:57,048 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:127)   2018-08-06 14:47:57,049 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.context.event.EventPublishingRunListener.environmentPrepared(EventPublishingRunListener.java:74)   2018-08-06 14:47:57,049 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.SpringApplicationRunListeners.environmentPrepared(SpringApplicationRunListeners.java:54)   2018-08-06 14:47:57,049 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.SpringApplication.prepareEnvironment(SpringApplication.java:358)   2018-08-06 14:47:57,049 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.SpringApplication.run(SpringApplication.java:317)   2018-08-06 14:47:57,050 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.SpringApplication.run(SpringApplication.java:1255)   2018-08-06 14:47:57,050 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.SpringApplication.run(SpringApplication.java:1243)   2018-08-06 14:47:57,050 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   net.mediascope.multirating.bigdata.operations.OperationRunner.main(OperationRunner.java:21)   2018-08-06 14:47:57,050 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 2018-08-06   14:47:57,050 INFO  [o.a.spark.launcher.OutputRedirector.redirect] 63 :   at   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   2018-08-06 14:47:57,051 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   2018-08-06 14:47:57,051 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   java.lang.reflect.Method.invoke(Method.java:498) 2018-08-06   14:47:57,051 INFO  [o.a.spark.launcher.OutputRedirector.redirect] 63 :   at   org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:48)   2018-08-06 14:47:57,051 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.loader.Launcher.launch(Launcher.java:87)   2018-08-06 14:47:57,052 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.loader.Launcher.launch(Launcher.java:50)   2018-08-06 14:47:57,052 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:51)   2018-08-06 14:47:57,052 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 2018-08-06   14:47:57,052 INFO  [o.a.spark.launcher.OutputRedirector.redirect] 63 :   at   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   2018-08-06 14:47:57,053 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   2018-08-06 14:47:57,053 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   java.lang.reflect.Method.invoke(Method.java:498) 2018-08-06   14:47:57,053 INFO  [o.a.spark.launcher.OutputRedirector.redirect] 63 :   at   org.apache.spark.deploy.JavaMainApplication.start(SparkApplication.scala:52)   2018-08-06 14:47:57,053 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.apache.spark.deploy.SparkSubmit$.org$apache$spark$deploy$SparkSubmit$$runMain(SparkSubmit.scala:879)   2018-08-06 14:47:57,054 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.apache.spark.deploy.SparkSubmit$.doRunMain$1(SparkSubmit.scala:197)   2018-08-06 14:47:57,054 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.apache.spark.deploy.SparkSubmit$.submit(SparkSubmit.scala:227)   2018-08-06 14:47:57,054 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.apache.spark.deploy.SparkSubmit$.main(SparkSubmit.scala:136)   2018-08-06 14:47:57,054 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.apache.spark.deploy.SparkSubmit.main(SparkSubmit.scala) 2018-08-06   14:47:57,058 INFO  [o.a.spark.launcher.OutputRedirector.redirect] 63 :   2018-08-06 14:47:57 INFO  ShutdownHookManager:54 - Shutdown hook   called 2018-08-06 14:47:57,060 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 : 2018-08-06   14:47:57 INFO  ShutdownHookManager:54 - Deleting directory   /tmp/spark-55b54924-e628-43fe-9e43-ed34d7f35a8b 2018-08-06   14:47:57,151 INFO    [o.s.b.a.l.ConditionEvaluationReportLoggingListener.logAutoConfigurationReport]   101 :</p>      <p>Error starting ApplicationContext. To display the conditions report   re-run your application with 'debug' enabled.</p> </blockquote>  <p>In my project i have snake yaml 1.19 from spring 5.0 and no others dependicies. I can not understand what the problem is, perhaps when I put it into docker container manual it was necessary to install something else besides the spark. </p>  <p>Pom from module with operations:</p>  <pre><code>&lt;dependencies&gt;         &lt;dependency&gt;             &lt;groupId&gt;net.mediascope&lt;/groupId&gt;             &lt;artifactId&gt;multirating-bigdata-core&lt;/artifactId&gt;             &lt;version&gt;${project.version}&lt;/version&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;!-- Data Base --&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.jdbi&lt;/groupId&gt;             &lt;artifactId&gt;jdbi&lt;/artifactId&gt;             &lt;version&gt;2.71&lt;/version&gt;         &lt;/dependency&gt;          &lt;dependency&gt;             &lt;groupId&gt;com.microsoft.sqlserver&lt;/groupId&gt;             &lt;artifactId&gt;sqljdbc42&lt;/artifactId&gt;             &lt;version&gt;4.2&lt;/version&gt;         &lt;/dependency&gt;          &lt;dependency&gt;             &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;             &lt;artifactId&gt;spark-core_2.11&lt;/artifactId&gt;             &lt;exclusions&gt;                 &lt;exclusion&gt;                     &lt;groupId&gt;org.slf4j&lt;/groupId&gt;                     &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;                 &lt;/exclusion&gt;                 &lt;exclusion&gt;                     &lt;groupId&gt;org.codehaus.janino&lt;/groupId&gt;                     &lt;artifactId&gt;commons-compiler&lt;/artifactId&gt;                 &lt;/exclusion&gt;             &lt;/exclusions&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;             &lt;artifactId&gt;spark-sql_2.11&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;net.sourceforge.jtds&lt;/groupId&gt;             &lt;artifactId&gt;jtds&lt;/artifactId&gt;             &lt;version&gt;1.3.1&lt;/version&gt;         &lt;/dependency&gt;     &lt;/dependencies&gt;      &lt;profiles&gt;         &lt;profile&gt;             &lt;id&gt;local&lt;/id&gt;             &lt;build&gt;                 &lt;plugins&gt;                     &lt;plugin&gt;                         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                         &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                         &lt;configuration&gt;                             &lt;profiles&gt;                                 &lt;profile&gt;${profile.active}&lt;/profile&gt;                             &lt;/profiles&gt;                             &lt;executable&gt;true&lt;/executable&gt;                         &lt;/configuration&gt;                     &lt;/plugin&gt;                 &lt;/plugins&gt;             &lt;/build&gt;         &lt;/profile&gt;         &lt;profile&gt;             &lt;id&gt;hadoop&lt;/id&gt;             &lt;build&gt;                 &lt;!--\u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0434\u043b\u044f \u0430\u0434\u0430\u043f\u0442\u0430\u0446\u0438\u0438 Spring-Boot \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u043f\u043e\u0434 \u0437\u0430\u043f\u0443\u0441\u043a \u0447\u0435\u0440\u0435\u0437 Spark--&gt;                 &lt;plugins&gt;                     &lt;plugin&gt;                         &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                         &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;                         &lt;version&gt;2.3&lt;/version&gt;                         &lt;executions&gt;                             &lt;execution&gt;                                 &lt;phase&gt;package&lt;/phase&gt;                                 &lt;goals&gt;                                     &lt;goal&gt;shade&lt;/goal&gt;                                 &lt;/goals&gt;                                 &lt;configuration&gt;                                     &lt;transformers&gt;                                         &lt;transformer                                                 implementation='org.apache.maven.plugins.shade.resource.AppendingTransformer'&gt;                                             &lt;resource&gt;META-INF/spring.handlers&lt;/resource&gt;                                         &lt;/transformer&gt;                                         &lt;transformer                                                 implementation='org.apache.maven.plugins.shade.resource.AppendingTransformer'&gt;                                             &lt;resource&gt;META-INF/spring.schemas&lt;/resource&gt;                                         &lt;/transformer&gt;                                         &lt;transformer                                                 implementation='org.apache.maven.plugins.shade.resource.AppendingTransformer'&gt;                                             &lt;resource&gt;META-INF/spring.provides&lt;/resource&gt;                                         &lt;/transformer&gt;                                         &lt;transformer                                                 implementation='org.springframework.boot.maven.PropertiesMergingResourceTransformer'&gt;                                             &lt;resource&gt;META-INF/spring.factories&lt;/resource&gt;                                         &lt;/transformer&gt;                                         &lt;transformer                                                 implementation='org.apache.maven.plugins.shade.resource.ManifestResourceTransformer'&gt;                                             &lt;mainClass&gt;${start-class}&lt;/mainClass&gt;                                         &lt;/transformer&gt;                                     &lt;/transformers&gt;                                 &lt;/configuration&gt;                             &lt;/execution&gt;                         &lt;/executions&gt;                     &lt;/plugin&gt;                 &lt;/plugins&gt;             &lt;/build&gt;         &lt;/profile&gt;     &lt;/profiles&gt;I </code></pre> ",
    "OwnerUserId": "7576157",
    "LastActivityDate": "2023-04-20T04:19:52.560",
    "Title": "SparkLauncher. java.lang.NoSuchMethodError: org.yaml.snakeyaml.Yaml.<init>",
    "Tags": "<java><docker><apache-spark><spring-boot><yaml>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>I have found solution. Origin spark package has folder jars where is snakeyml 1.15, i changed it to 1.19 and all work now.</p> ",
    "highest_rated_answer": "<p>I could fix by downgrading version of snakeyml to 1.33, Spark provided version as 2.0 and with 1.33 I get this fixed.</p> "
  },
  {
    "Id": "52069406",
    "PostTypeId": "1",
    "CreationDate": "2018-08-29T04:17:55.510",
    "Score": "7",
    "ViewCount": "2219",
    "Body": "<p>I created spring boot project, it works well if I run locally. However, when I dockerize this app and run it inside Docker container. The problems occurs with <code>Error creating bean with name 'org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration'</code></p>  <p>application.properties</p>  <pre><code>spring.datasource.jdbc-url=xxx spring.datasource.username=xxx spring.datasource.password=xxx spring.datasource.driver-class-name=org.postgresql.Driver spring.datasource.maximum-pool-size=100 spring.datasource.testWhileIdle=true spring.datasource.validationQuery=SELECT 1 spring.jpa.hibernate.naming.implicit-strategy=org.hibernate.boot.model.naming.ImplicitNamingStrategyLegacyHbmImpl spring.jpa.hibernate.naming.physical-strategy=org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy spring.jpa.hibernate.ddl-auto=update spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect spring.jpa.generate-ddl=true spring.jpa.show-sql=true spring.jpa.properties.hibernate.default_schema=public spring.jpa.properties.hibernate.temp.use_jdbc_metadata_defaults=false </code></pre>  <p>Dockerfile</p>  <pre><code>FROM openjdk:8-jdk COPY target/app-*.jar /app.jar EXPOSE 8080/tcp ENTRYPOINT ['java', '-jar', '/app.jar'] </code></pre>  <p>Errors:</p>  <pre><code>2018-08-29 03:56:06.093  WARN 1 --- [           main] ConfigServletWebServerApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaConfiguration': Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'authorizationServerConfiguration': Unsatisfied dependency expressed through field 'authenticationManager'; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'webSecurityConfiguration': Unsatisfied dependency expressed through field 'partyPlusUserDetailsService'; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'partyPlusUserDetailsService' defined in URL [jar:file:/app.jar!/BOOT-INF/classes!/com/datnt/pplus/service/user/PartyPlusUserDetailsService.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'userRepository': Cannot create inner bean '(inner bean)#71238fc2' of type [org.springframework.orm.jpa.SharedEntityManagerCreator] while setting bean property 'entityManager'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name '(inner bean)#71238fc2': Cannot resolve reference to bean 'entityManagerFactory' while setting constructor argument; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'entityManagerFactory': Requested bean is currently in creation: Is there an unresolvable circular reference? 2018-08-29 03:56:06.099  INFO 1 --- [           main] o.apache.catalina.core.StandardService   : Stopping service [Tomcat] 2018-08-29 03:56:06.140  INFO 1 --- [           main] ConditionEvaluationReportLoggingListener :  </code></pre>  <p>Could anyone help me to solve this issues?</p> ",
    "OwnerUserId": "3007695",
    "LastEditorUserId": "3007695",
    "LastEditDate": "2019-01-17T07:51:38.570",
    "LastActivityDate": "2019-01-31T09:12:12.040",
    "Title": "Error creating bean with name 'org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration' when run on Docker container",
    "Tags": "<java><spring><docker><spring-boot>",
    "AnswerCount": "1",
    "CommentCount": "10",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Check the 'application.properties' and place it in the folder 'src/main/resources'</p> "
  },
  {
    "Id": "53093020",
    "PostTypeId": "1",
    "AcceptedAnswerId": "53227196",
    "CreationDate": "2018-10-31T22:52:44.750",
    "Score": "7",
    "ViewCount": "5006",
    "Body": "<p>We have around of 10 different applications that are Spring Boot projects with Groovy.</p>  <p>All of our projects build correctly in all developer work stations and they were running correctly until yesterday, however suddenly all of them stopped working today only in our GitLab CI pipelines with below error:</p>  <pre><code>[INFO] Tests run: 0, Failures: 0, Errors: 0, Skipped: 0 [INFO]  [INFO] ------------------------------------------------------------------------ [INFO] BUILD FAILURE [INFO] ------------------------------------------------------------------------ [INFO] Total time: 01:37 min [INFO] Finished at: 2018-10-31T17:49:11Z [INFO] ------------------------------------------------------------------------ [ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.21.0:test (default-test) on project ctg-oms-component: There are test failures. [ERROR]  [ERROR] Please refer to /builds/ctg-integrations/ctg-oms-component/target/surefire-reports for the individual test results. [ERROR] Please refer to dump files (if any exist) [date]-jvmRun[N].dump, [date].dumpstream and [date]-jvmRun[N].dumpstream. [ERROR] ExecutionException The forked VM terminated without properly saying goodbye. VM crash or System.exit called? </code></pre>  <p>I've pulled the same docker image that is using our GitLab CI pipeline, tested building the project and everything works correctly. However, the error occurs only in GitLab CI.</p>  <p>After an investigation looks like surefire is creating a fork that makes GitLab CI docker crash. In order to fix this, I've added below explicit configuration to avoid forked VM and this got rid of above error.</p>  <pre><code>&lt;!-- Needed only for GitLab CI --&gt; &lt;plugin&gt;     &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;     &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;     &lt;configuration&gt;         &lt;forkCount&gt;0&lt;/forkCount&gt;     &lt;/configuration&gt; &lt;/plugin&gt; </code></pre>  <p>Do you know why this is occurring? Is there another way to fix GitLab CI to avoid this issue? I don't really like this workaround, since it is just a way to avoid GitLab CI to explode but don't know how Docker is handled behind the scenes in Gitlab.</p> ",
    "OwnerUserId": "710099",
    "LastActivityDate": "2019-12-05T08:17:01.517",
    "Title": "GitLab CI is failing due to maven-surefire-plugin with VM crash",
    "Tags": "<docker><spring-boot><gitlab><gitlab-ci><maven-surefire-plugin>",
    "AnswerCount": "5",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>The issues are related to the latest maven docker images. </p>  <p>There is an open github issue where people reported the same problem: <a href='https://github.com/carlossg/docker-maven/issues/90' rel='noreferrer'>https://github.com/carlossg/docker-maven/issues/90</a></p>  <p>After an investigation I could sort out the problem using <code>alpine</code> version that saved me of adding the <code>maven-surefire-plugin</code> workaround. It's important to mention that using the surefire workaround brings another problem such as plugins like jacoco don't run since they need the VM fork.</p>  <p>So, these images work seamlessly (no surefire workaround was needed): </p>  <ul> <li>maven:3.3.9-jdk-8</li> <li>maven:3.5.3-jdk-8</li> <li>maven:3.5.4-jdk-8-alpine </li> <li>maven:3.6.0-jdk-8-alpine</li> </ul>  <p>However if we use the non alpine version the issue persists.</p> ",
    "highest_rated_answer": "<p>I had the same issue</p>  <p>You can find here the issue I created on gitlab for this, with detailed explanations : <a href='https://gitlab.com/gitlab-org/gitlab-ce/issues/53734' rel='nofollow noreferrer'>https://gitlab.com/gitlab-org/gitlab-ce/issues/53734</a></p>  <p>Also, I found a 'workaround'. <code>maven:3.5.3-jdk-8</code> as the docker image on which the build is executing. Or, the <code>forkCount=0</code> property on maven-surefire-plugin.</p>  <p>But this is disturbing. How, out of a sudden, builds start to fail? Don't know, and I don't think I have the experience necessary to solve this.</p>  <p>Till then, maybe this helps you</p> "
  },
  {
    "Id": "53152471",
    "PostTypeId": "1",
    "CreationDate": "2018-11-05T10:25:04.230",
    "Score": "7",
    "ViewCount": "7176",
    "Body": "<p>is there a way to choose if I want to have a logback appender or not, via environment variable?<br> <br> I have a dockerized spring boot Microservice and added now the ELK stack.<br> That works fine so far.<br> But now if I want to start my service without ELK stack, the application throws an error, that it doesn't know the host of Logstash:</p>  <pre><code>app | 10:09:23,537 |-ERROR in ch.qos.logback.classic.net.SyslogAppender[SYSLOG] - Could not create SyslogWriter java.net.UnknownHostException: logstash: Name or service not known app |   at java.net.UnknownHostException: logstash: Name or service not known </code></pre>  <p>Here is my logback.xml file:</p>  <pre><code>&lt;?xml version='1.0' encoding='UTF-8'?&gt; &lt;configuration&gt;      &lt;appender name='SYSLOG' class='ch.qos.logback.classic.net.SyslogAppender'&gt;         &lt;syslogHost&gt;logstash&lt;/syslogHost&gt;         &lt;port&gt;5000&lt;/port&gt;         &lt;facility&gt;LOCAL1&lt;/facility&gt;         &lt;suffixPattern&gt;[%thread] %logger %msg&lt;/suffixPattern&gt;     &lt;/appender&gt;      &lt;root level='INFO'&gt;         &lt;appender-ref ref='SYSLOG'/&gt;     &lt;/root&gt;  &lt;/configuration&gt; </code></pre>  <p>I know this is a very simple version, but I am new in logging with logback/ELK stack.<br> <br> So is there a way to inject something with an environment variable like in yaml files e.g. <code>active=${LOGBACK_ACTIVE:false}</code> like I can do it with my prometheus metrics?</p> ",
    "OwnerUserId": "8344100",
    "LastEditorUserId": "8344100",
    "LastEditDate": "2018-11-05T10:27:43.633",
    "LastActivityDate": "2020-05-25T18:10:37.513",
    "Title": "How can I dynamically (by env variable) activate/deactivate logback or logback appender?",
    "Tags": "<spring-boot><logging><docker-compose><logback><elastic-stack>",
    "AnswerCount": "2",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>In your logback.xml you could use the <code>&lt;if&gt;</code> construct to enable the <code>SYSLOG</code> appender when a named JVM parameter is present. </p>  <p>In the following example if you run your application with <code>-Dsyslog</code> then your <code>SYSLOG</code> appender will be engaged otherwise it will be ignored and the default appender, <code>CONSOLE</code>, will be engaged:</p>  <pre><code>&lt;if condition='isDefined('syslog')'&gt;   &lt;then&gt;     &lt;appender name='SYSLOG' class='ch.qos.logback.classic.net.SyslogAppender'&gt;       ...     &lt;/appender&gt;      &lt;root level='INFO'&gt;       &lt;appender-ref ref='SYSLOG' /&gt;     &lt;/root&gt;   &lt;/then&gt;   &lt;else&gt;     &lt;appender name='CONSOLE' class='ch.qos.logback.core.ConsoleAppender'&gt;       ...     &lt;/appender&gt;      &lt;root level='INFO'&gt;       &lt;appender-ref ref='CONSOLE' /&gt;     &lt;/root&gt;   &lt;/else&gt; &lt;/if&gt; </code></pre>  <p>This requires some duplication of the <code>root</code> declaration but since you need to conditionally prevent the SYSLOG appender from being <strong>instantiated</strong> I think this might be your only option.</p> "
  },
  {
    "Id": "53227826",
    "PostTypeId": "1",
    "AcceptedAnswerId": "57970111",
    "CreationDate": "2018-11-09T14:39:07.137",
    "Score": "7",
    "ViewCount": "22750",
    "Body": "<p>I have a spring boot java application running inside a docker container. I configured logback in the application. Where i can access the generated logs? The configured path is:</p>  <pre><code>&lt;property name='LOG_PATH' value='logs'/&gt; </code></pre>  <p>I am currently checking logs using: docker logs containerName --follow  But this command return the current logs from the last time the application was started. How can i check the rolling logs or archived ones.</p>  <p>Is there a way to create a volume for logback logs?</p> ",
    "OwnerUserId": "8294118",
    "LastActivityDate": "2019-09-17T08:17:59.290",
    "Title": "Spring boot - Docker logs",
    "Tags": "<java><linux><spring-boot><docker>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>I am using the following way: in logback.xml:</p>  <pre><code>&lt;?xml version='1.0' encoding='UTF-8'?&gt; </code></pre>  <p></p>  <pre><code>&lt;property name='LOG_PATH' value='logs'/&gt; &lt;timestamp key='currentTimestamp' datePattern='yyyy-MM-dd'_'HH'/&gt;  &lt;appender name='STDOUT' class='ch.qos.logback.core.ConsoleAppender'&gt;     &lt;encoder&gt;         &lt;pattern&gt;             %d{dd-MM-yyyy HH:mm:ss.SSS} %magenta([%thread]) %highlight(%-5level) %logger.%M\\(%line\\) - %msg%n         &lt;/pattern&gt;     &lt;/encoder&gt; &lt;/appender&gt;  &lt;appender name='SAVE-TO-FILE'           class='ch.qos.logback.core.rolling.RollingFileAppender'&gt;     &lt;file&gt;${LOG_PATH}/appName.log&lt;/file&gt;     &lt;encoder class='ch.qos.logback.classic.encoder.PatternLayoutEncoder'&gt;         &lt;Pattern&gt;             %d{dd-MM-yyyy HH:mm:ss.SSS} [%thread] %-5level %logger{36}.%M - %msg%n         &lt;/Pattern&gt;     &lt;/encoder&gt;      &lt;rollingPolicy class='ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy'&gt;         &lt;!-- the rollover occurs when the active log file reaches the maximum file size before the end of the time period. --&gt;         &lt;!-- The rollover period is inferred from the smallest date unit value of fileNamePattern --&gt;         &lt;!-- each file should be at most [maxFileSize], keep [maxHistory] days worth of history, but at most [totalSizeCap] --&gt;         &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;         &lt;fileNamePattern&gt;             ${LOG_PATH}/archived/appName.%d{yyyy-MM-dd}.%i.log         &lt;/fileNamePattern&gt;         &lt;maxHistory&gt;30&lt;/maxHistory&gt;         &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt;     &lt;/rollingPolicy&gt; &lt;/appender&gt;   &lt;root level='INFO'&gt;     &lt;appender-ref ref='STDOUT'/&gt;     &lt;appender-ref ref='SAVE-TO-FILE'/&gt; &lt;/root&gt; </code></pre>  <p></p>  <p>In docker run :</p>  <pre><code>docker run --network name-network --restart=unless-stopped --name name-java-container  --hostname valueOfHostname -d -p 8080:8080 \\ -v /data/nameFolderForLogs:/logs \\ imageName </code></pre> ",
    "highest_rated_answer": "<p>Try to implement your file-appender with</p>  <pre><code>&lt;configuration&gt;     ...     &lt;property name='LOG_PATH' value=/var/app&gt;     ...     &lt;appender name='FILE' class='ch.qos.logback.core.rolling.RollingFileAppender'&gt;          &lt;file&gt;${LOG_PATH}/spring.log&lt;/file&gt;         ...        &lt;/appender&gt; &lt;/configuration&gt; </code></pre>  <p>And after this you can run the next command:</p>  <pre><code>docker exec -it containerName cat /var/app/spring.log &gt; $HOME/spring.log </code></pre>  <p>or make volume with <code>(docker run ... -v '$HOME/app:/var/app')</code></p> "
  },
  {
    "Id": "53429062",
    "PostTypeId": "1",
    "CreationDate": "2018-11-22T10:38:36.987",
    "Score": "7",
    "ViewCount": "14310",
    "Body": "<p>I am building my first Springboot 2.0 application. I am trying to put my Springboot application into one docker container and my PostgresDB into another container.  </p>  <p><strong>My Dockerfile</strong></p>  <pre><code>    FROM frolvlad/alpine-oraclejdk8:slim     VOLUME /tmp     ADD springboot-api-demo-0.1*.jar app.jar     RUN sh -c 'touch /app.jar'     EXPOSE 9443     ENTRYPOINT [ 'sh', '-c', 'java $JAVA_OPTS -Djava.security.egd=file:/dev/urandom -jar /app.jar' ] </code></pre>  <p><strong>My docker-compose.yml file</strong></p>  <pre><code>version: '2.1'  services:   springboot-api-demo:     image: 'fw/springboot-api-demo'     mem_limit: 1024m     ports:       - '8080:8080'     environment:       - SPRING_PROFILES_ACTIVE=local       - AWS_REGION=local       - ENVIRONMENT=local       - AUTH_ENABLED=false   postgres:     container_name: pgdb     image: postgres:9.6-alpine     environment:     - 'POSTGRES_ROOT_PASSWORD=postgres'     - 'POSTGRES_USER=postgres'     - 'POSTGRES_PASSWORD=postgres'     ports:     - '54321:5432' </code></pre>  <p>I am using Springboot JPA Data 2.0 with below config data in my <strong>application.properties</strong></p>  <pre><code>spring.datasource.url= jdbc:postgresql://localhost:54321/java_learning spring.datasource.username=postgres spring.datasource.password=postgres </code></pre>  <p>I can test that Both of the Images are up. Also from docker log and docker events, I see that postgres  Container is running fine, even I can access it and also created a DB too. But springboot container started but i died because it could not connect to postgress and throwing error below. </p>  <blockquote>   <p>Unable to obtain connection from database: The connection attempt   failed</p> </blockquote>  <p>Note that my host machine already has Postgres on port 5432 thats why I did a port mapping ofr 54321:5432 on my postgres container. Here is Proof :) -</p>  <pre><code>\u279c  springboot-api-demo git:(master) \u2717 lsof -i:54321               COMMAND     PID             USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME com.docke 44345 shailendra.singh   18u  IPv4 0xf62897fbdd69e31d      0t0  TCP *:54321 (LISTEN) com.docke 44345 shailendra.singh   21u  IPv6 0xf62897fbdd119975      0t0  TCP localhost:54321 (LISTEN)  \u279c  springboot-api-demo git:(master) \u2717 lsof -i:5432  COMMAND  PID             USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME postgres 715 shailendra.singh    5u  IPv6 0xf62897fbb43e03b5      0t0  TCP localhost:postgresql (LISTEN) postgres 715 shailendra.singh    6u  IPv4 0xf62897fbbaeea9bd      0t0  TCP localhost:postgresql (LISTEN) </code></pre>  <p>I am not sure what is the problem. But my Springboot application is not able to connect my postgres container which is running fine with proper creadentials. </p> ",
    "OwnerUserId": "3511619",
    "LastEditorUserId": "2275818",
    "LastEditDate": "2018-11-22T10:52:45.053",
    "LastActivityDate": "2022-06-09T04:12:13.973",
    "Title": "Docker: Springboot container can not connect to PostgreSql Container Connection error",
    "Tags": "<postgresql><spring-boot><docker><docker-compose>",
    "AnswerCount": "4",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Try with :</p>  <pre><code>spring.datasource.url= jdbc:postgresql://pgdb:5432/java_learning </code></pre>  <p>The postgres database is not running on localhost, it's running in the other container which has an other IP (yet unknown). </p>  <p>Thanksfully, docker-compose automatically create a network shared among all the containers in the docker-compose.yml (unless explicitly said to do not), as a result you can magically use the <strong>service name as an hostname</strong>.</p>  <p>Also, you have a typo in the port, Postgres use <code>5432</code> by default, not <code>54321</code></p> "
  },
  {
    "Id": "53959448",
    "PostTypeId": "1",
    "CreationDate": "2018-12-28T13:37:30.923",
    "Score": "7",
    "ViewCount": "22712",
    "Body": "<p>Request execution error. endpoint=DefaultEndpoint{ serviceUrl='<a href='http://localhost:8761/eureka/' rel='noreferrer'>http://localhost:8761/eureka/</a>} is giving when I am running in docker windows but It is registering with eureka server when I am running in spring boot app in STS.</p>  <p>for server i run in docker     docker run -p 8761:8080 serverimagename     for services I run in docker     docker run -p 8762:8080 servicesimagename     server app.properties</p>  <pre><code>DOCKER_HOST=tcp://127.0.0.1:2375 eureka.instance.hostname=localhost eureka.instance.secure-port-enabled= true #eureka.instance.statusPageUrl: https://${eureka.hostname}:${eureka.instance.secure-port} #eureka.instance.service-url.defaultZone: https://localhost:8761/eureka eureka.client.register-with-eureka=false eureka.client.fetch-registry=false and services app.properties spring.application.name=demo1 DOCKER_HOST=tcp://127.0.0.1:2375 eureka.client.register-with-eureka=true eureka.client.fetch-registry=true spring.thymeleaf.prefix=/WEB-INF/ spring.thymeleaf.suffix=.jsp     </code></pre>  <p>ERROR 1 --- [tbeatExecutor-0] c.n.d.s.t.d.RedirectingEurekaHttpClient  : Request execution error. endpoint=DefaultEndpoint{ serviceUrl='<a href='http://localhost:8761/eureka/' rel='noreferrer'>http://localhost:8761/eureka/</a>}</p>  <pre><code>com.sun.jersey.api.client.ClientHandlerException: java.net.ConnectException: Connection refused (Connection refused)         at com.sun.jersey.client.apache4.ApacheHttpClient4Handler.handle(ApacheHttpClient4Handler.java:187) ~[jersey-apache-client4-1.19.1.jar!/:1.19.1]         at com.sun.jersey.api.client.filter.GZIPContentEncodingFilter.handle(GZIPContentEncodingFilter.java:123) ~[jersey-client-1.19.1.jar!/:1.19.1]         at com.netflix.discovery.EurekaIdentityHeaderFilter.handle(EurekaIdentityHeaderFilter.java:27) ~[eureka-client-1.9.8.jar!/:1.9.8]         at com.sun.jersey.api.client.Client.handle(Client.java:652) ~[jersey-client-1.19.1.jar!/:1.19.1]         at com.sun.jersey.api.client.WebResource.handle(WebResource.java:682) ~[jersey-client-1.19.1.jar!/:1.19.1]         at com.sun.jersey.api.client.WebResource.access$200(WebResource.java:74) ~[jersey-client-1.19.1.jar!/:1.19.1]         at com.sun.jersey.api.client.WebResource$Builder.put(WebResource.java:529) ~[jersey-client-1.19.1.jar!/:1.19.1]         at com.netflix.discovery.shared.transport.jersey.AbstractJerseyEurekaHttpClient.sendHeartBeat(AbstractJerseyEurekaHttpClient.java:102) ~[eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92) [eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.shared.transport.decorator.MetricsCollectingEurekaHttpClient.execute(MetricsCollectingEurekaHttpClient.java:73) ~[eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89) [eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92) [eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:118) ~[eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:79) ~[eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89) [eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92) [eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120) [eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89) [eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92) [eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77) [eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89) [eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:846) [eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1405) [eureka-client-1.9.8.jar!/:1.9.8]         at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [na:1.8.0_111]         at java.util.concurrent.FutureTask.run(FutureTask.java:266) [na:1.8.0_111]         at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_111]         at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_111]         at java.lang.Thread.run(Thread.java:745) [na:1.8.0_111] Caused by: java.net.ConnectException: Connection refused (Connection refused)         at java.net.PlainSocketImpl.socketConnect(Native Method) ~[na:1.8.0_111]         at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350) ~[na:1.8.0_111]         at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206) ~[na:1.8.0_111]         at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188) ~[na:1.8.0_111]         at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392) ~[na:1.8.0_111]         at java.net.Socket.connect(Socket.java:589) ~[na:1.8.0_111]         at org.apache.http.conn.scheme.PlainSocketFactory.connectSocket(PlainSocketFactory.java:121) ~[httpclient-4.5.6.jar!/:4.5.6]         at org.apache.http.impl.conn.DefaultClientConnectionOperator.openConnection(DefaultClientConnectionOperator.java:180) ~[httpclient-4.5.6.jar!/:4.5.6]         at org.apache.http.impl.conn.AbstractPoolEntry.open(AbstractPoolEntry.java:144) ~[httpclient-4.5.6.jar!/:4.5.6]         at org.apache.http.impl.conn.AbstractPooledConnAdapter.open(AbstractPooledConnAdapter.java:134) ~[httpclient-4.5.6.jar!/:4.5.6]         at org.apache.http.impl.client.DefaultRequestDirector.tryConnect(DefaultRequestDirector.java:610) ~[httpclient-4.5.6.jar!/:4.5.6]         at org.apache.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:445) ~[httpclient-4.5.6.jar!/:4.5.6]         at org.apache.http.impl.client.AbstractHttpClient.doExecute(AbstractHttpClient.java:835) ~[httpclient-4.5.6.jar!/:4.5.6]         at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:118) ~[httpclient-4.5.6.jar!/:4.5.6]         at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56) ~[httpclient-4.5.6.jar!/:4.5.6]         at com.sun.jersey.client.apache4.ApacheHttpClient4Handler.handle(ApacheHttpClient4Handler.java:173) ~[jersey-apache-client4-1.19.1.jar!/:1.19.1]         ... 27 common frames omitted </code></pre> ",
    "OwnerUserId": "10389158",
    "LastEditorUserId": "4370109",
    "LastEditDate": "2019-03-08T22:22:53.207",
    "LastActivityDate": "2022-04-15T11:23:28.073",
    "Title": "Eureka services giving Request execution error?",
    "Tags": "<spring-boot><docker><netflix-eureka>",
    "AnswerCount": "4",
    "CommentCount": "8",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>For STS:<br /> I was getting the same error, My mistake was I had both configuration files-<br /> <code>application.properties</code> and <code>application.yml</code> in the eureka server project/microservice.<br /> (added as part of experiment but got lost)<br /> When I removed <code>application.yml</code> then it started working all fine.<br /> application.properties has these working entries</p> <pre><code>server.port=8761 eureka.client.register-with-eureka=false eureka.client.fetch-registry=false </code></pre> "
  },
  {
    "Id": "54692666",
    "PostTypeId": "1",
    "AcceptedAnswerId": "54692798",
    "CreationDate": "2019-02-14T14:24:02.643",
    "Score": "7",
    "ViewCount": "14653",
    "Body": "<p>I have to consume an external rest API(using restTemplate.exchange) with Spring Boot. My rest API is running on port 8083 with URL <a href='http://localhost:8083/myrest' rel='noreferrer'>http://localhost:8083/myrest</a> (Docker command : <code>docker run -p 8083:8083 myrest-app</code>)</p>  <p>External API is available in form of public docker image and after running below command , I am able to pull and run it locally.</p>  <pre><code> docker pull dockerExternalId/external-rest-api docker     run -d -p 3000:3000 dockerExternalId/external-rest-api </code></pre>  <p>a) If I enter external rest API URL, for example <a href='http://localhost:3000/externalrestapi/testresource' rel='noreferrer'>http://localhost:3000/externalrestapi/testresource</a> directly in chrome, then I get valid JSON data.</p>  <p>b) If I invoke it with myrest application from eclipse(Spring Boot Application), still I am getting valid JSON Response. (I am using Windows Platform to test this)</p>  <p>c) But if I run it on Docker and execute myrest service (say <a href='http://localhost:8083/myrest' rel='noreferrer'>http://localhost:8083/myrest</a>), then i am facing <code>java.net.ConnectException: Connection refused</code> </p>  <p><strong>More details :</strong> </p>  <pre><code>org.springframework.web.client.ResourceAccessException: I/O error on GET request for 'http://localhost:3000/externalrestapi/testresource': Connection refused (Connection refused); nested exception is java.net.ConnectException: Connection refused (Connection refused) </code></pre>  <p><strong>P.S -  I am using Docker on Windows.</strong></p> ",
    "OwnerUserId": "1064076",
    "LastEditorUserId": "1064076",
    "LastEditDate": "2019-02-14T14:45:27.173",
    "LastActivityDate": "2019-02-15T07:57:50.560",
    "Title": "Docker : java.net.ConnectException: Connection refused - Application running at port 8083 is not able to access other application on port 3000",
    "Tags": "<rest><spring-boot><docker><dockerfile>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p><strike># The problem</p>  <p>You run with:</p>  <pre><code>docker run -p 8083:8083 myrest-app </code></pre>  <p>But you need to run like:</p>  <pre><code>docker run --network 'host' --name 'app' myrest-app </code></pre>  <p>So passing the flag <code>--network</code> with value <code>host</code> will allow you container to access your computer network. </strike></p>  <p>Please ignore my first approach, instead use a better alternative that does not expose the container to the entire host network... is possible to make it work, but is not a best practice.</p>  <h2>A Better Alternative</h2>  <p>Create a network to be used by both containers:</p>  <pre><code>docker network create external-api </code></pre>  <p>Then run both containers with the flag <code>--network external-api</code>.</p>  <pre><code>docker run --network 'external-api' --name 'app' -p 8083:8083 myrest-app </code></pre>  <p>and</p>  <pre><code>docker run -d --network 'external-api' --name 'api' -p 3000:3000 dockerExternalId/external-rest-api </code></pre>  <p>The use of flag  <code>-p</code> to publish the ports for the <code>api</code> container are only necessary if you want to access it from your computers browser, otherwise just leave them out, because they aren't needed for 2 containers to communicate in the <code>external-api</code> network.</p>  <blockquote>   <p><strong>TIP</strong>: docker pull is not necessary, once docker run will try to pull the image if does not found it in your computer.   Let me know how it went...</p> </blockquote>  <h1>Call the External API</h1>  <p>So in both solutions I have added the <code>--name</code> flag so that we can reach the other container in the network.</p>  <p>So to reach the external api from my rest app you need to use the url <code>http://api:3000/externalrestapi/testresource</code>.</p>  <p>Notice how I have replaced <code>localhost</code> by <code>api</code> that matches the value for <code>--name</code> flag in the docker run command for your external api.</p> ",
    "highest_rated_answer": "<p>From your <code>myrest-app</code> container if you try to access <code>http://localhost:3000/externalrestapi/testresource</code>, it will try to access <code>3000</code> port of the same <code>myrest-app container</code>. </p>  <p>Because each container is a separate running Operating System and it has its own network interface, file system, etc.</p>  <p><code>Docker is all about Isolation</code>.</p>  <p>There are 3 ways by which you can access an API from another container.</p>  <ol> <li>Instead of <code>localhost</code>, provide the IP address of the external host machine (i.e the IP address of your machine on which docker is running)</li> <li><a href='https://docs.docker.com/engine/reference/commandline/network_create/' rel='nofollow noreferrer'>Create</a> a docker network and <a href='https://docs.docker.com/engine/reference/commandline/network_connect/' rel='nofollow noreferrer'>attach</a> these two containers. Then you can provide the <code>container_name</code> instead of <code>localhost</code>. </li> <li>Use <a href='https://docs.docker.com/network/links/' rel='nofollow noreferrer'>--link</a> while starting the container (deprecated)</li> </ol> "
  },
  {
    "Id": "54896064",
    "PostTypeId": "1",
    "AcceptedAnswerId": "54896158",
    "CreationDate": "2019-02-27T00:00:09.977",
    "Score": "7",
    "ViewCount": "4380",
    "Body": "<p>I'm trying to load a file in a spring boot application that is running inside a Docker container but I'm getting the following exception:</p>  <pre><code>java.nio.file.FileSystemNotFoundException   at com.sun.nio.zipfs.ZipFileSystemProvider.getFileSystem(ZipFileSystemProvider.java:171) ~[zipfs.jar:1.8.0_191]     at com.sun.nio.zipfs.ZipFileSystemProvider.getPath(ZipFileSystemProvider.java:157) ~[zipfs.jar:1.8.0_191]   at java.nio.file.Paths.get(Paths.java:143) ~[?:1.8.0_191]   at app.metrics.collector.util.FileUtils.getContentAsSingleLine(FileUtils.java:17) ~[classes!/:?]       at app.metrics.collector.jobs.DbQueryJob.generatePreparedStatement(DbQueryJob.java:54) ~[classes!/:?]  at app.metrics.collector.jobs.DbQueryJob.execute(DbQueryJob.java:36) ~[classes!/:?]    at org.quartz.core.JobRunShell.run(JobRunShell.java:202) [quartz-2.3.0.jar!/:?]  </code></pre>  <p>The error does not appears when I execute the jar outside the container.</p>  <p>Here is the Dockerfile:</p>  <pre><code>FROM openjdk:8-jdk-alpine ADD build/app.jar app.jar ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','app.jar'] </code></pre>  <p>And here is the method that loads the file:</p>  <pre><code>    public static String getContentAsSingleLine(String fileName) throws URISyntaxException, IOException {     String data;     Path path = Paths.get(FileUtils.class.getClassLoader().getResource(fileName).toURI());     Stream&lt;String&gt; lines = Files.lines(path);     data = lines.collect(Collectors.joining(StringUtils.SPACE));     lines.close();     return data; } </code></pre>  <p>The file is located in the resource folder: </p>  <pre><code>/src/main/resources/database/file.sql </code></pre>  <p>and the argument passed to the method is:</p>  <pre><code>'database/file.sql' </code></pre>  <ul> <li>Does anyone have an idea of the cause of the issue and its possible solution ?</li> </ul> ",
    "OwnerUserId": "3490266",
    "LastActivityDate": "2024-01-19T23:51:37.417",
    "Title": "FileSystemNotFoundException in a Dockerized Spring Boot Application",
    "Tags": "<java><spring-boot><docker>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>I think by execute the jar outside the container you mean running the project in your IDE. Then <code>database/file.sql</code> is actually available as a file.</p>  <p>In the jar, the file is not available for Paths.get() to actually handle.</p>  <p>When trying to access the resource you should use     </p>  <pre><code>InputStream in = getClass().getResourceAsStream(fileName); </code></pre>  <p>you can then use <code>java.util.Scanner</code> to collect the lines:</p>  <pre><code>String data = new Scanner(in)  .useDelimiter('\\n')  .tokens()  .collect(Collectors.joining(StringUtils.SPACE)); </code></pre> ",
    "highest_rated_answer": "<p>The exception looks to be dealing with zip / archive file, please ensure once that whether it is while loading sql or any other file?</p> "
  },
  {
    "Id": "55322488",
    "PostTypeId": "1",
    "CreationDate": "2019-03-24T09:46:35.973",
    "Score": "7",
    "ViewCount": "6791",
    "Body": "<p>I developed a java program which is supposed to run in docker. However, I encountered a lot of pains when debugging my java program running in docker. </p>  <p>I searched on Internet, some tutorials proposed tools like spring-dev-tools (as my java program is a spring-boot-based program).</p>  <p><a href='https://www.youtube.com/watch?v=sz5Zv5QQ5ek' rel='noreferrer'>https://www.youtube.com/watch?v=sz5Zv5QQ5ek</a></p>  <p>Based on thoses tutorials, debugging is ok, such as setting breakpoint and variable watching, however, when I update my code (for instance, some classes), thoses changes cannot be reflected immediately in the program running in docker, the programm behaves as old code. </p>  <p>Can anybody give some hints ?</p> ",
    "OwnerUserId": "5663160",
    "LastEditorUserId": "3664714",
    "LastEditDate": "2019-06-07T13:55:59.170",
    "LastActivityDate": "2019-06-07T13:55:59.170",
    "Title": "hot reload java program running in docker",
    "Tags": "<java><spring-boot><docker>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>I have managed to make this work by doing the following:</p>  <ol> <li>Mount the source code into the container at runtime</li> <li>Connect using a remote debugger</li> </ol>  <p>Here is my dockerfile:</p>  <pre><code>FROM gradle:5.4-jdk12 WORKDIR /app EXPOSE 8080 5005 </code></pre>  <p>and here is my docker-compose.yml:</p>  <pre><code>version: '3' services:   app:     build:       context: .     ports:       - 5005:5005       - 8080:8080     volumes:       - .:/app     command: ['gradle', 'bootRun'] </code></pre>  <p>when I run this using <code>docker-compose up</code> and then connect a remote debugger, the hot reloading works.</p>  <p>I am connecting from Intellij so I have to rebuild the project for the hot reloading to work.</p> "
  },
  {
    "Id": "56284845",
    "PostTypeId": "1",
    "AcceptedAnswerId": "56285260",
    "CreationDate": "2019-05-24T01:42:29.300",
    "Score": "7",
    "ViewCount": "16500",
    "Body": "<p>I have a multi-module maven project. Parent pom looks like this:</p>  <pre><code>&lt;project&gt;     ...     &lt;packaging&gt;pom&lt;/packaging&gt;        &lt;modules&gt;         &lt;module&gt;common&lt;/module&gt;         &lt;module&gt;a&lt;/module&gt;         &lt;module&gt;b&lt;/module&gt;     &lt;/modules&gt; &lt;/project&gt; </code></pre>  <p><code>common</code> builds a jar, which is added as dependency in the other modules, like this:</p>  <pre><code>&lt;dependency&gt;     &lt;groupId&gt;my.project&lt;/groupId&gt;     &lt;artifactId&gt;common&lt;/artifactId&gt;     &lt;version&gt;${module.common.version}&lt;/version&gt; &lt;/dependency&gt; </code></pre>  <p>Modules <code>a</code> and <code>b</code> are Spring Boot projects having the <a href='https://github.com/spotify/dockerfile-maven' rel='noreferrer'>spotify docker plugin</a>.</p>  <p>I need to be able to run <code>mvn deploy</code> in order to get the spotify plugin push the docker image.</p>  <p><code>mvn install</code> works fine, which builds the docker images. But in order to push them, when I run <code>mvn deploy</code>, it throws error for the <code>common</code> module:</p>  <blockquote>   <p>[ERROR] Failed to execute goal   org.apache.maven.plugins:maven-deploy-plugin:2.7:deploy   (default-deploy) on project common: Deployment failed: repository   element was not specified in the POM inside distributionManagement   element or in -DaltDeploymentRepository=id::layout::url parameter</p> </blockquote>  <p>Searching for this error, <a href='https://stackoverflow.com/questions/27153024/repository-element-was-not-specified-in-the-pom-inside-distributionmanagement-el?rq=1'>this answer</a> suggests adding the repository url in the <code>distributionManagement</code> section. But I don't want to deploy <code>common</code>. I just want to build it, so it gets injected as dependency in the other modules and deploy those other modules. How can I do that?</p>  <p>I tried to deploy only <code>a</code> and <code>b</code> using this command, but it gives the same error for <code>common</code>:</p>  <pre><code>mvn clean \\    -DdockerRegistryHost=123.dkr.ecr.us-west-1.amazonaws.com/test1 \\    --projects a,b \\    --also-make \\    deploy </code></pre> ",
    "OwnerUserId": "1039555",
    "LastActivityDate": "2019-05-24T02:54:57.943",
    "Title": "Skip maven deploy for one module",
    "Tags": "<java><maven><spring-boot><docker><spotify-docker-client>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>You can accomplish what you want by configuring the <code>maven-deploy-plugin</code>.</p>  <p>Try adding the following to your parent pom:</p>  <pre><code>&lt;build&gt;     ...     &lt;pluginManagement&gt;         &lt;plugins&gt;             &lt;plugin&gt;                 &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;                 &lt;version&gt;3.0.0-M1&lt;/version&gt;                 &lt;configuration&gt;                     &lt;skip&gt;true&lt;/skip&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt;         &lt;/plugins&gt;     &lt;/pluginManagement&gt;     ...  &lt;/build&gt; </code></pre>  <p>or add <code>-Dmaven.deploy.skip=true</code> to your command line.</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "58217665",
    "PostTypeId": "1",
    "CreationDate": "2019-10-03T10:55:54.487",
    "Score": "7",
    "ViewCount": "45680",
    "Body": "<p>I have my spring boot application running on Openshift as container built using docker Image. I have enabled the logging in my application and prints all the logs.  Now i want to examine the log files of the POD to check for any errors, since one my request is failing.  I do know about the command line option <code>oc logs -f &lt;podname&gt;</code> That just prints the log into cmd prompt, but i want whole log to be copied from server to local file. So that i can find some particular lines or errors. Is is possible?</p> ",
    "OwnerUserId": "3346416",
    "LastEditorUserId": "3346416",
    "LastEditDate": "2019-10-03T12:16:32.290",
    "LastActivityDate": "2023-07-04T06:15:33.230",
    "Title": "How to get the logs of a POD in openshift to local file",
    "Tags": "<java><spring-boot><docker><openshift>",
    "AnswerCount": "10",
    "CommentCount": "2",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>You can copy files in and out of pods using the <a href='https://docs.openshift.com/enterprise/3.1/dev_guide/copy_files_to_container.html' rel='nofollow noreferrer'>rsync</a> command.</p>  <p>Or use the <code>logs</code> command like you are and just redirect to a file so you can edit it locally:</p>  <pre><code>oc logs  &lt;podname&gt; &amp;&gt; /path/to/file </code></pre> "
  },
  {
    "Id": "59299794",
    "PostTypeId": "1",
    "AcceptedAnswerId": "59327134",
    "CreationDate": "2019-12-12T07:40:51.737",
    "Score": "7",
    "ViewCount": "10125",
    "Body": "<p>I have a simple Gradle Spring Boot Java application, where I am trying to get some properties value from  &quot;application.properties&quot; and &quot;application-dev.properties&quot; using spring boot profiling. It is working fine and Spring Boot profile is loading when I try to run application on the local machine, but when when I try to run same application on the Docker, suddenly an error pops up which says that application is not able to find resources on the classpath.</p> <p>Below is the project structure:</p> <p><a href='https://i.stack.imgur.com/4bm3I.png' rel='nofollow noreferrer'><img src='https://i.stack.imgur.com/4bm3I.png' alt='Project structure of the application' /></a></p> <p>In the App.Config class I have the following code. As you can see I am trying to get property value from application.properties file.</p> <pre><code>@Component @PropertySource(&quot;classpath:application.properties&quot;) public class AppConfig {  @Value(&quot;${host}&quot;) private String host; @Value(&quot;${map}&quot;) private String map;  public String getHost() {     return host; }  public void setHost(String host) {     this.host = host; }  public String getMap() {     return map; }  public void setMap(String map) {     this.map = map; } } </code></pre> <p>application.properties contains following code:</p> <pre><code>map = Main-Map  spring.profiles.active=${profile} </code></pre> <p>application-dev.properties contains following code:</p> <pre><code>host = Development-host </code></pre> <p>As you can see I am setting profile value in application.properties from outside. That's what I am trying to inject through docker</p> <p>Dockerfile contain following code:</p> <pre><code>FROM java:8  VOLUME /tmp  ENV tom=dev  ADD build/libs/demo-0.0.1-SNAPSHOT.jar /app/app.jar  ADD build/resources/main/application.properties /app/application.properties  ADD build/resources/main/application-dev.properties /app/application-dev.properties  WORKDIR /app  ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-  Dprofile=${tom}&quot;,&quot;-jar&quot;,&quot;app.jar&quot;, &quot;-  -spring.config.location=/app/application.properties, /app/application-  dev.properties&quot;] </code></pre> <p>I build Docker image using following command:</p> <pre><code>docker build -t demo:latest . </code></pre> <p>I run Docker using following command:</p> <pre><code>docker run -p 8083:8080 demo:latest </code></pre> <p>When I run <code>docker run</code> command, so comes below exception:</p> <pre><code>2019-12-12 07:09:50.405  INFO 1 --- [           main] com.example.demo.DemoApplication         :  Starting DemoApplication on ed7cb11b8a34 with PID 1 (/app/app.jar started by root in /app) 2019-12-12 07:09:50.407  INFO 1 --- [           main] com.example.demo.DemoApplication         : The  following profiles are active: dev 2019-12-12 07:09:50.603  WARN 1 --- [           main] ConfigServletWebServerApplicationContext :  Exception encountered during context initialization - cancelling refresh attempt:  org.springframework.beans.factory.BeanDefinitionStoreException: Failed to parse configuration class  [com.example.demo.DemoApplication]; nested exception is java.io.FileNotFoundException: class path  resource [application.properties] cannot be opened because it does not exist 2019-12-12 07:09:50.712 ERROR 1 --- [           main] o.s.boot.SpringApplication               :  Application run failed  org.springframework.beans.factory.BeanDefinitionStoreException: Failed to parse configuration class [   com.example.demo.DemoApplication]; nested exception is java.io.FileNotFoundException: class path  resource [ application.properties] cannot be opened because it does not exist     at  </code></pre> <p>What can I try to resolve this?</p> ",
    "OwnerUserId": "3661407",
    "LastEditorUserId": "472495",
    "LastEditDate": "2023-02-08T19:03:06.900",
    "LastActivityDate": "2023-02-08T19:03:06.900",
    "Title": "Docker cannot find Resource on classpath",
    "Tags": "<java><spring><spring-boot><dockerfile>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>It has nothing to do with the docker. Have you tried building the jar file and running it by <code>java -jar</code>.</p>  <pre><code>ADD build/resources/main/application.properties /app/application.properties  ADD build/resources/main/application-dev.properties /app/application-dev.properties </code></pre>  <p>These are unnecessary too. When you create your artifact as fat/uber/Shadow jar, you will have your properties packaged in jar.</p>  <h2>How to build fat/uber/Shadow Jar (Spring boot Gradle)</h2>  <p><a href='https://plugins.gradle.org/plugin/org.springframework.boot' rel='nofollow noreferrer'>https://plugins.gradle.org/plugin/org.springframework.boot</a> (<a href='https://stackoverflow.com/questions/33578495/gradle-build-fat-jar-with-spring-boot-dependencies'>Gradle: Build &#39;fat jar&#39; with Spring Boot Dependencies</a>)</p>  <p><strong>Alternative</strong></p>  <p><a href='https://imperceptiblethoughts.com/shadow/' rel='nofollow noreferrer'>https://imperceptiblethoughts.com/shadow/</a> (<a href='https://github.com/johnrengelman/shadow' rel='nofollow noreferrer'>https://github.com/johnrengelman/shadow</a> )</p> ",
    "highest_rated_answer": "<p>Seems like you aren't building Fat Jar. You can utilize <code>spring-boot-maven-plugin</code> for that. </p>  <pre><code>&lt;plugin&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;     &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;/plugin&gt; </code></pre>  <p>Then change your <code>Dockerfile</code> like:</p>  <pre><code>FROM java:8 VOLUME /tmp ENV tom=dev COPY build/libs/demo-0.0.1-SNAPSHOT.jar /app/app.jar WORKDIR /app ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-Dprofile=${tom}','-jar','app.jar'] </code></pre> "
  },
  {
    "Id": "59564269",
    "PostTypeId": "1",
    "AcceptedAnswerId": "59566367",
    "CreationDate": "2020-01-02T13:34:50.143",
    "Score": "7",
    "ViewCount": "2410",
    "Body": "<p>I used to configure <code>-Djava.security.egd=file:/dev/./urandom</code> in my Dockerfile for Spring Boot applications.</p> <p>In <a href='https://spring.io/guides/gs/spring-boot-docker/' rel='nofollow noreferrer'>https://spring.io/guides/gs/spring-boot-docker/</a> (or GitHub <a href='https://github.com/dsyer/gs-spring-boot-docker' rel='nofollow noreferrer'>https://github.com/dsyer/gs-spring-boot-docker</a>) a comment was added that this is not required any more for newer versions:</p> <blockquote> <p>To reduce Tomcat startup time we added a system property pointing to &quot;/dev/urandom&quot; as a source of entropy. This is not necessary with more recent versions of Spring Boot, if you use the &quot;standard&quot; version of Tomcat (or any other web server).</p> </blockquote> <p>I am looking for any references for this change in Tomcat or Spring Boot repos, and which Spring Boot versions are affected.</p> ",
    "OwnerUserId": "5444798",
    "LastEditorUserId": "482717",
    "LastEditDate": "2023-07-24T18:25:55.070",
    "LastActivityDate": "2023-07-24T18:25:55.070",
    "Title": "Deprecated java.security.egd=file:/dev/./urandom for Spring Boot applications?",
    "Tags": "<spring-boot><docker><tomcat>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>This problem should have been resolved by the JDK Enhancement Proposal : <a href='http://openjdk.java.net/jeps/123' rel='noreferrer'>JEP 123, Configurable Secure Random-Number Generation</a>.</p>  <p>According to the <a href='https://docs.oracle.com/javase/8/docs/technotes/guides/security/enhancements-8.html' rel='noreferrer'>JDK 8 Security Enhancements</a> official Oracle document, the <code>/dev/./urandom</code> workaround is no more necessary from JDK 8.</p>  <blockquote>   <p>SHA1PRNG and NativePRNG were fixed to properly respect the SecureRandom seed source properties in the java.security file. (The obscure workaround using file:///dev/urandom and file:/dev/./urandom is no longer required.)</p> </blockquote> ",
    "highest_rated_answer": null
  },
  {
    "Id": "63789255",
    "PostTypeId": "1",
    "CreationDate": "2020-09-08T07:40:03.367",
    "Score": "7",
    "ViewCount": "2997",
    "Body": "<p>My Spring Boot project contains the Spring Boot Maven Plugin which I use for building a Docker image by running <code>mvn spring-boot:build-image</code>.</p> <pre class='lang-xml prettyprint-override'><code>&lt;plugin&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;     &lt;executions&gt;         &lt;execution&gt;             &lt;phase&gt;package&lt;/phase&gt;             &lt;goals&gt;                 &lt;goal&gt;build-image&lt;/goal&gt;             &lt;/goals&gt;         &lt;/execution&gt;     &lt;/executions&gt; &lt;/plugin&gt; </code></pre> <p>When deploying this image to a Docker stack I need to run a healthcheck using the <code>curl</code> command but unfortunately <code>curl</code> is not installed by the default buildpack.</p> <p>Is it possible to further tweak the image building process so that <code>curl</code> gets installed into the iamge? I couldn't find the necessary information</p> ",
    "OwnerUserId": "478406",
    "LastEditorUserId": "478406",
    "LastEditDate": "2020-09-08T07:47:11.900",
    "LastActivityDate": "2023-02-25T12:59:25.103",
    "Title": "Install package in Docker image created by Spring Boot Maven plugin",
    "Tags": "<spring-boot><docker><spring-boot-maven-plugin>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p><strong>TLDR;</strong></p> <p>Install <code>curl</code> into the build image with:</p> <pre><code>docker run --user=&quot;root&quot; --entrypoint launcher my-app:0.0.1-SNAPSHOT &quot;apt-get update &amp;&amp; apt-get install curl -y&quot; </code></pre> <p>Grab container id of the stopped container with <code>docker ps -a</code>:</p> <pre><code>$ docker ps -a CONTAINER ID   IMAGE                                  COMMAND                  CREATED          STATUS                       PORTS     NAMES 2ff7db32825f   my-app:0.0.1-SNAPSHOT   &quot;launcher 'apt-get u\u2026&quot;   44 minutes ago   Exited (0) 44 minutes ago              reverent_swanson </code></pre> <p>Create a new container image based on the one we installed <code>curl</code> into with:</p> <pre><code>docker commit 2ff7db32825f my-app-with-curl </code></pre> <p>Fire up a new container defining the correct <code>ENTRYPOINT</code> to start Spring Boot app:</p> <pre><code>docker run --rm -p 8080:8080 --user=&quot;cnb&quot; --entrypoint /cnb/process/web my-app-with-curl </code></pre> <p>Now <code>curl</code> should be ready inside your container.</p> <hr /> <p><strong>Details of the solution:</strong></p> <p>The reasoning behind Cloud Native Buildpacks (CNBs) &amp; Paketo.io, which are basically abstracted away by the <code>spring-boot-maven-plugin</code>s <code>build-image</code> goal, is to free us from the need to write/maintain our own <code>Dockerfiles</code>. So the inversion of this is: It's easy to configure the build process, but it is not easy to change things like installed packages.</p> <p>The reason is, that those packages are maintained in a so called <a href='https://buildpacks.io/docs/concepts/components/stack/' rel='nofollow noreferrer'>stack</a>, that manages the used <code>build</code>-time and <code>run</code>-time images. And if the stack doesn't define a <a href='https://buildpacks.io/docs/concepts/components/stack/#mixins' rel='nofollow noreferrer'>Mixin for your OS-level dependency</a>, then you can't simply add another package. It would also <strong>not suffice</strong> to <a href='https://buildpacks.io/docs/buildpack-author-guide/create-buildpack/' rel='nofollow noreferrer'>create your own simple buildpack</a> (I tried this approach). And creating your own stacks, buildpacks and/or builders would also negate the huge benefits that Cloud Native Buildpacks provide! Amongst other things we would be also forced to keep the images updated ourselves...</p> <p><strong>But there's another solution.</strong> As we don't want to create our own stacks/buildpacks, we can tweak the container image which has been created by CNBs/<code>spring-boot-maven-plugin</code>. Because the official docs show us <a href='https://buildpacks.io/docs/app-developer-guide/run-an-app/#user-provided-shell-process' rel='nofollow noreferrer'>how to hook into the startup process of the produced containers</a> and run shell scripts for example. Let's assume our <code>mvn spring-boot:build-image</code> command produced a container image called <code>my-app:0.0.1-SNAPSHOT</code>.</p> <p>Then first we install <code>curl</code> into the image with:</p> <pre><code>docker run --user=&quot;root&quot; --entrypoint launcher my-app:0.0.1-SNAPSHOT &quot;apt-get update &amp;&amp; apt-get install curl -y&quot; </code></pre> <p>We need to use <code>--user=&quot;root&quot;</code> here in order that the command <code>apt-get update &amp;&amp; apt-get install curl -y</code> will run successfully (otherwise we would run into errors like <code>List directory /var/lib/apt/lists/partial is missing. - Acquire (13: Permission denied)</code>). This will install curl, but we shouldn't use the resulting container in production. Because our Spring Boot app would run using the root user, which would introduce a variety of security problems. Also we've overwritten the <code>ENTRYPOINT</code> of our container, so it wouldn't be able to start our app.</p> <p>Therefore we simply <a href='https://stackoverflow.com/a/39329138/4964553'>start this stopped container with a new command</a>, entrypoint &amp; user! Simply grab the container ID of the stopped container with <code>docker ps -a</code>:</p> <pre><code>$ docker ps -a CONTAINER ID   IMAGE                                  COMMAND                  CREATED          STATUS                       PORTS     NAMES 2ff7db32825f   my-app:0.0.1-SNAPSHOT   &quot;launcher 'apt-get u\u2026&quot;   44 minutes ago   Exited (0) 44 minutes ago              reverent_swanson </code></pre> <p>And <strong>create a new container image</strong> based on the one we installed <code>curl</code> into with:</p> <pre><code>docker commit 2ff7db32825f my-app-with-curl </code></pre> <p>Finally <strong>fire up a new container</strong> based on this new image, defining the correct <code>ENTRYPOINT</code> to start our Spring Boot app and also using the <code>cnb</code> user again (as defined in the Cloud Native Buildpacks):</p> <pre><code>docker run --rm -p 8080:8080 --user=&quot;cnb&quot; --entrypoint /cnb/process/web my-app-with-curl </code></pre> <hr /> <p><strong>Off topic but relevant</strong>:</p> <p>There are ongoing discussions if it is desired to install curl in a production container. <a href='https://blog.sixeyed.com/docker-healthchecks-why-not-to-use-curl-or-iwr/' rel='nofollow noreferrer'>See this post for example</a>.</p> "
  },
  {
    "Id": "64591075",
    "PostTypeId": "1",
    "CreationDate": "2020-10-29T12:25:09.843",
    "Score": "7",
    "ViewCount": "3527",
    "Body": "<p>I run my docker-compose file mysql last version in windows. But i want to run mysql version5.7 and i am getting an error.</p> <blockquote> <p>InnoDB: Table flags are 0 in the data dictionary but the flags in file ./ibdata1 are 0x4000!</p> </blockquote> <p><strong>docker-compose.yaml</strong></p> <pre><code>version: '3' services:   mysql:     image: mysql:5.7     volumes:       - db_data:/var/lib/mysql     restart: always     environment:       MYSQL_ROOT_PASSWORD: password     ports:       - 3306:3306  volumes:   db_data: </code></pre> <p><strong>application.yaml</strong></p> <pre><code>spring:   datasource:     type: com.zaxxer.hikari.HikariDataSource     url: &amp;connectionUrl jdbc:mysql://${DB_CONNECTION_IP:localhost}:${DB_CONNECTION_PORT:3306}/masa?createDatabaseIfNotExist=true&amp;useSSL=false&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC&amp;zeroDateTimeBehavior=convertToNull&amp;useUnicode=true&amp;characterEncoding=UTF-8     username: &amp;username ${DB_CONNECTION_USERNAME:root}     password: &amp;password ${DB_CONNECTION_PASSWORD:root}   jpa:     show-sql: true </code></pre> <p>How can I solve this problem?</p> ",
    "OwnerUserId": "4204154",
    "LastActivityDate": "2020-10-29T12:25:09.843",
    "Title": "InnoDB: Table flags are 0 in the data dictionary but the flags in file ./ibdata1 are 0x4000",
    "Tags": "<mysql><windows><spring-boot><docker>",
    "AnswerCount": "0",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": null
  },
  {
    "Id": "64774067",
    "PostTypeId": "1",
    "AcceptedAnswerId": "64775095",
    "CreationDate": "2020-11-10T17:46:14.350",
    "Score": "7",
    "ViewCount": "9755",
    "Body": "<p>I'm building a java spring boot app docker container on Azure DevOps using the spring boot maven plugin. After that I want to push it to an azure container registry. But it fails with</p> <blockquote> <p>An image does not exist locally with the tag: ***/my/container</p> </blockquote> <p>Unfortunately the start of the container uri is masked with <code>***</code>. But as you can see in the output of <code>/usr/bin/docker images</code> below, the container is registered. I tried to follow this example: <a href='https://medium.com/@TimvanBaarsen/build-your-spring-boot-project-using-azure-pipelines-in-azure-devops-3305977991d' rel='noreferrer'>https://medium.com/@TimvanBaarsen/build-your-spring-boot-project-using-azure-pipelines-in-azure-devops-3305977991d</a></p> <p><strong>Pipeline steps</strong></p> <pre class='lang-yaml prettyprint-override'><code>steps: - task: Maven@3   displayName: &quot;Build Docker image&quot;   inputs:     mavenPomFile: 'pom.xml'     goals: 'spring-boot:build-image'     publishJUnitResults: false     jdkVersionOption: '1.11'     mavenOptions: '-Xmx3072m -Dspring-boot.build-image.imageName=acr-foobar.azurecr.io/my/container'  - task: Docker@2   displayName: Push Docker image   inputs:     containerRegistry: 'acr-foobar.azurecr.io'     repository: 'my/container'     command: 'push'     tags: 'latest' </code></pre> <p><strong>Output Maven Task</strong></p> <pre><code>[INFO] Successfully built image 'acr-***/my/container:latest' </code></pre> <p><strong>Output Docker Task</strong></p> <pre><code>Starting: Push Docker image ============================================================================== Task         : Docker Description  : Build or push Docker images, login or logout, start or stop containers, or run a Docker command Version      : 2.176.0 Author       : Microsoft Corporation Help         : https://aka.ms/azpipes-docker-tsg ============================================================================== /usr/bin/docker images /usr/bin/docker push ***/my/container:latest REPOSITORY                                             TAG                     IMAGE ID            CREATED             SIZE paketobuildpacks/run                                   base-cnb                523e5e0ad089        6 days ago          87.2MB node                                                   10                      2457d5f85d32        13 days ago         911MB node                                                   10-alpine               b328632eb00c        13 days ago         83.6MB node                                                   12                      1f560ce4ce7e        4 weeks ago         918MB buildpack-deps                                         stretch                 b39de549c36a        4 weeks ago         835MB buildpack-deps                                         buster                  f3f98451c17d        4 weeks ago         804MB debian                                                 9                       c4ccba324c9c        4 weeks ago         101MB debian                                                 8                       091099bf65ad        4 weeks ago         129MB node                                                   12-alpine               d8b74300d554        4 weeks ago         89.6MB ubuntu                                                 14.04                   df043b4f0cf1        7 weeks ago         197MB jekyll/builder                                         latest                  a8007cad4069        2 months ago        677MB alpine                                                 3.9                     78a2ce922f86        6 months ago        5.55MB alpine                                                 3.10                    be4e4bea2c2e        6 months ago        5.58MB alpine                                                 3.8                     c8bccc0af957        9 months ago        4.41MB alpine                                                 3.7                     6d1ef012b567        20 months ago       4.21MB mcr.microsoft.com/azure-pipelines/node8-typescript     latest                  9a948d360778        2 years ago         595MB gcr.io/paketo-buildpacks/builder                       base-platform-api-0.3   6248029341bb        40 years ago        568MB acr-***/my/container   latest                  61477479d5e0        40 years ago        283MB The push refers to repository [***/my/container] An image does not exist locally with the tag: ***/my/container ##[error]An image does not exist locally with the tag: ***/my/container ##[error]The process '/usr/bin/docker' failed with exit code 1 Finishing: Push Docker image </code></pre> <p>What's wrong here?</p> ",
    "OwnerUserId": "1489968",
    "LastActivityDate": "2021-09-25T10:21:39.750",
    "Title": "Azure Devops Docker Push: An image does not exist locally with the tag",
    "Tags": "<spring-boot><docker><azure-devops><azure-container-registry>",
    "AnswerCount": "2",
    "CommentCount": "2",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>It looks like the container built container image tag is <code>acr-***/my/container</code> and the image tag you are trying to push is <code>***/my/container</code> So for some reason, it is cutting off the <code>acr-</code> from the tag name.</p> <p>This is probably because there is an issue with the name of your Azure Container Registry. It should not allow a hyphen in its name.</p> <p><a href='https://i.stack.imgur.com/sCzNX.png' rel='noreferrer'><img src='https://i.stack.imgur.com/sCzNX.png' alt='enter image description here' /></a></p> <p>Are you sure, that your container registry is called <code>acr-foobar.azurecr.io</code>?</p> ",
    "highest_rated_answer": "<p>In my case</p> <p>I noticed that in the build and publish tasks specify a registry name if the <code>containerRegistry</code> value is set or the service connection exists. My publish step was specifying this attribute, but my build step was not.</p> <p>I changed the build step to also pass in this parameter, and the correct tags were created across both steps to resolve the issue.</p> <p>Can try this hope it may help you.</p> "
  },
  {
    "Id": "64849028",
    "PostTypeId": "1",
    "AcceptedAnswerId": "64958942",
    "CreationDate": "2020-11-15T19:43:42.410",
    "Score": "7",
    "ViewCount": "4410",
    "Body": "<p>Using Spring Boot 2.4.0, I'm trying to configure the <code>spring-boot:build-image</code> task to push an image to my private GitHub container registry.</p> <p>I used <a href='https://docs.spring.io/spring-boot/docs/2.4.0/maven-plugin/reference/htmlsingle/#build-image-example-publish' rel='noreferrer'>these instructions</a> to configure my POM as follows:</p> <pre class='lang-xml prettyprint-override'><code>            &lt;plugin&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                 &lt;configuration&gt;                     &lt;image&gt;                         &lt;name&gt;ghcr.io/abc/${project.artifactId}:${project.version}&lt;/name&gt;                         &lt;publish&gt;true&lt;/publish&gt;                     &lt;/image&gt;                     &lt;docker&gt;                         &lt;publishRegistry&gt;                             &lt;username&gt;abc&lt;/username&gt;                             &lt;token&gt;mytoken&lt;/token&gt;                             &lt;url&gt;https://ghcr.io&lt;/url&gt;                         &lt;/publishRegistry&gt;                     &lt;/docker&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt; </code></pre> <p>When I execute the <code>spring-boot:build-image</code> task, it builds the image but I get the following error when it tries to push:</p> <pre><code>[INFO] Successfully built image 'ghcr.io/abc/def:1.5.0' [INFO] [INFO]  &gt; Pushing image 'ghcr.io/abc/def:1.5.0' 100% Execution default-cli of goal org.springframework.boot:spring-boot-maven-plugin:2.4.0:build-image failed: Error response received when pushing image: error parsing HTTP 405 response body: unexpected end of JSON input: &quot;&quot; -&gt; [Help 1] </code></pre> <p>I can manually push the image using <code>docker push</code>, and I have tried doing a <code>docker login</code> which doesn't help either. I am also not behind any firewall or proxy.</p> ",
    "OwnerUserId": "657224",
    "LastEditorUserId": "657224",
    "LastEditDate": "2020-11-16T00:50:21.490",
    "LastActivityDate": "2020-11-22T20:04:35.763",
    "Title": "Maven Spring Boot Cannot Push Docker Image",
    "Tags": "<spring-boot><docker><spring-boot-maven-plugin>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>In case anyone else finds this, the problem ended up being a typo in the maven plugin configuration. I was using <code>&lt;token&gt;</code> instead of <code>&lt;password&gt;</code>. Below is the correct XML that works:</p> <pre><code>                &lt;docker&gt;                     &lt;publishRegistry&gt;                         &lt;username&gt;abc&lt;/username&gt;                         &lt;password&gt;mytoken&lt;/password&gt;                         &lt;url&gt;https://ghcr.io&lt;/url&gt;                     &lt;/publishRegistry&gt;                 &lt;/docker&gt; </code></pre> ",
    "highest_rated_answer": null
  },
  {
    "Id": "46057625",
    "PostTypeId": "1",
    "AcceptedAnswerId": "46058046",
    "CreationDate": "2017-09-05T14:37:02.553",
    "Score": "66",
    "ViewCount": "161735",
    "Body": "<p>In my Spring Boot app I want to externalise the properties to run in a Docker container.  When first deployed, the properties that are currently in <code>my-server/src/main/resources/application.yml</code> are loaded and used by the application as expected.  All works fine.</p>  <p>However, my problem is that I need these properties to be updatable as needed, so I need access to the <code>application.yml</code> file once on the Docker container.  But at this point, it's not included in the <code>build/docker/</code> directory before running the <code>buildDocker</code> task, so won't be copied over or accessible after first deployment.</p>  <p>So, what I have tried is to copy the Yaml file into the <code>docker/</code> build directory, copy it to an accessible directory (<code>/opt/meanwhileinhell/myapp/conf</code>), and use the <code>spring.config.location</code> property to pass a location of the config to the Jar in my Dockerfile:</p>  <pre><code>ENTRYPOINT  ['java',\\ ... '-jar', '/app.jar',\\ '--spring.config.location=classpath:${configDirectory}'] </code></pre>  <p>Looking at the Command running on the Docker container I can see that this is as expected:</p>  <pre><code>/app.jar --spring.config.location=classpath:/opt/meanwhileinhell/myapp/conf] </code></pre>  <p>However, when I update a property in this file and restart the Docker container, it isn't picking up the changes.  File permissions are:</p>  <pre><code>-rw-r--r-- 1 root root  618 Sep  5 13:59 application.yml </code></pre>  <p>The <a href='https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html' rel='noreferrer'>documentation</a> states: </p>  <blockquote>   <p>When custom config locations are configured, they are used in addition   to the default locations. Custom locations are searched before the   default locations.</p> </blockquote>  <p>I can't seem to figure out what I'm doing wrong or misinterpreting, but probably more importantly, is this the correct way to externalise the config for this type of Docker scenario?</p> ",
    "OwnerUserId": "575596",
    "LastEditorUserId": "1839360",
    "LastEditDate": "2019-05-02T15:35:30.690",
    "LastActivityDate": "2023-06-10T15:22:46.843",
    "Title": "Externalising Spring Boot properties when deploying to Docker",
    "Tags": "<docker><spring-boot><dockerfile><spring-boot-configuration>",
    "AnswerCount": "7",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p><strong>DOCKER IMAGE CONFIGURATION</strong></p> <p>If you look to <a href='https://spring.io/guides/gs/spring-boot-docker/' rel='noreferrer'>the way Spring recommends</a> to launch a Spring Boot powered docker container, that's what you find:</p> <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ARG JAR_FILE COPY ${JAR_FILE} app.jar ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] </code></pre> <p>That means your image extends openjdk and your container has its own environment. If you're doing like that, it would be enough to declare what you want to override as <strong>environment properties</strong> and Spring Boot will fetch them, since <a href='https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html' rel='noreferrer'>environment variables take precedence</a> over the yml files.</p> <p>Environment variables can be passed in your docker command too, to launch the container with your desired configuration. If you want to set some limit for the JVM memory, see the link below.</p> <hr /> <p><strong>DOCKER COMPOSE SAMPLE</strong></p> <p>Here you have an example of how I launch a simple app environment with docker compose. As you see, I declare the <code>spring.datasource.url</code> property here as an environment variable, so it overrides whatever you've got in your <code>application.yml</code> file.</p> <pre class='lang-yaml prettyprint-override'><code>version: '2' services:     myapp:         image: mycompany/myapp:1.0.0         container_name: myapp         depends_on:         - mysql         environment:             - SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/myapp?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false         ports:             - 8080:8080      mysql:         image: mysql:5.7.19         container_name: mysql         volumes:             - /home/docker/volumes/myapp/mysql/:/var/lib/mysql/         environment:             - MYSQL_USER=root             - MYSQL_ALLOW_EMPTY_PASSWORD=yes             - MYSQL_DATABASE=myapp         command: mysqld --lower_case_table_names=1 --skip-ssl --character_set_server=utf8 </code></pre> <p><strong>See also:</strong></p> <ul> <li><a href='https://stackoverflow.com/questions/30494050/how-do-i-pass-environment-variables-to-docker-containers'>How do I pass environment variables to Docker containers?</a></li> <li><a href='https://stackoverflow.com/questions/37490324/limit-jvm-memory-consumption-in-a-docker-container'>Limit JVM memory consumption in a Docker container</a></li> </ul> ",
    "highest_rated_answer": "<p>I personally would consider two options:</p>  <ol> <li><p>Using an environment variable per config</p>  <pre><code>app:   image: my-app:latest   ports:     - '8080:8080'   environment:      SPRING_DATASOURCE_URL=jdbc:mysql://db:3306/table </code></pre></li> <li><p>Using <code>SPRING_APPLICATION_JSON</code></p>  <pre><code>app:   image: my-app:latest   ports:     - '8080:8080'   environment:     SPRING_APPLICATION_JSON: '{       'spring.datasource.url': 'jdbc:mysql://db:3306/table',     }' </code></pre></li> </ol> "
  },
  {
    "Id": "29201262",
    "PostTypeId": "1",
    "AcceptedAnswerId": "29297790",
    "CreationDate": "2015-03-22T23:45:19.500",
    "Score": "64",
    "ViewCount": "118658",
    "Body": "<p>I am pretty new to Tomcat and Docker - so I am probably missing a Tomcat fundamental somewhere in this question.</p>  <p>What I am trying to do is build a Docker container that runs a SpringBoot Restful web service that just returns some static data. This is all running on OSX so I am using Boot2Docker as well.</p>  <p>I've written my own Dockerfile to build the container that my app runs in:</p>  <pre><code>FROM tomcat:8.0.20-jre8  RUN mkdir /usr/local/tomcat/webapps/myapp  COPY /1.0-SNAPSHOT/my-app-1.0-SNAPSHOT.war /usr/local/tomcat/webapps/myapp/ </code></pre>  <p>This Dockerfile works fine and I am able to start the container from the created image. </p>  <pre><code>docker build -t myapp .  docker run -it --rm -p 8888:8080 myapp </code></pre>  <p>This container starts correctly and outputs no errors and displays the message saying my app was deployed.</p>  <pre><code>22-Mar-2015 23:07:21.217 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory  Deploying web application directory /usr/local/tomcat/webapps/myapp </code></pre>  <p>The container also correctly has the myapp.war copied to the path described in the Dockerfile. Moreover I am able to navigate to Tomcat default page to confirm that Tomcat is running, I can also hit all the examples, etc.</p>  <p>To the problem, when I navigate to <a href='http://192.168.59.103:8888/myapp/getData'>http://192.168.59.103:8888/myapp/getData</a> I get a 404. I can't quite figure out why. Am I missing something regarding a .war deploy to Tomcat?</p> ",
    "OwnerUserId": "1100640",
    "LastActivityDate": "2019-08-13T16:20:01.843",
    "Title": "Deploying Java webapp to Tomcat 8 running in Docker container",
    "Tags": "<java><tomcat><docker><spring-boot><war>",
    "AnswerCount": "3",
    "CommentCount": "7",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>You are trying to copy the <code>war</code> file to a directory below <code>webapps</code>. The war file should be copied into the <code>webapps</code> directory.</p>  <p>Remove the mkdir command, and copy the <code>war</code> file like this:</p>  <pre><code>COPY /1.0-SNAPSHOT/my-app-1.0-SNAPSHOT.war /usr/local/tomcat/webapps/myapp.war </code></pre>  <p>Tomcat will extract the war if <code>autodeploy</code> is turned on.</p> ",
    "highest_rated_answer": "<p>There's a oneliner for this one.</p>  <p>You can simply run,</p>  <pre><code>docker run -v /1.0-SNAPSHOT/my-app-1.0-SNAPSHOT.war:/usr/local/tomcat/webapps/myapp.war -it -p 8080:8080 tomcat </code></pre>  <p>This will copy the war file to webapps directory and get your app running in no time.</p> "
  },
  {
    "Id": "26937810",
    "PostTypeId": "1",
    "CreationDate": "2014-11-14T19:53:35.787",
    "Score": "6",
    "ViewCount": "11228",
    "Body": "<p>I have a new Spring Boot application that I just finished and am trying to deploy it to Docker. Inside the container the application works fine. It uses ports 9000 for user facing requests and 9100 for administrative tasks like health checks. When I start a docker instance and try to access port 9000 I get the following error:</p>  <pre><code>curl: (56) Recv failure: Connection reset by peer </code></pre>  <p>After a lot of experimentation (via curl), I confirmed in with several different configurations that the application functions fine inside the container, but when I try to map ports to the host it doesn't connect. I've tried starting it with the following commands. None of them allow me to access the ports from the host.</p>  <pre><code>docker run -P=true my-app docker run -p 9000:9000 my-app </code></pre>  <h1>The workaround</h1>  <p>The only approach that <a href='https://stackoverflow.com/questions/26543787/docker-mule-server-curl-56-recv-failure-connection-reset-by-peer'>works</a> is using the <a href='https://docs.docker.com/articles/networking/#container-networking' rel='nofollow noreferrer'>--net host option</a>, but this doesn't allow me to run more than one container on that host.</p>  <pre><code>docker run -d --net=host my-app </code></pre>  <h1>Experiments with ports and expose</h1>  <p>I've used various versions of the Dockerfile exposing different ports such as 9000 and 9100 or just 9000. None of that helped. Here's my latest version:</p>  <pre><code>FROM ubuntu MAINTAINER redacted  RUN apt-get update RUN apt-get install openjdk-7-jre-headless -y RUN mkdir -p /opt/app  WORKDIR /opt/app  ADD ./target/oauth-authentication-1.0.0.jar /opt/app/service.jar ADD config.properties /opt/app/config.properties  EXPOSE 9000 ENTRYPOINT java -Dext.properties.dir=/opt/app -jar /opt/app/service.jar </code></pre>  <h1>Hello World works</h1>  <p>To make sure I can run a Spring Boot application, I tried <a href='https://github.com/Barlog-M/Simplest-Spring-Boot-MVC-HelloWorld' rel='nofollow noreferrer'>Simplest-Spring-Boot-MVC-HelloWorld</a> and it worked fine.</p>  <h1>Netstat Results</h1>  <p>I've used netstat to do port scans from the host and from the container:</p>  <h3>From the host</h3>  <pre><code>root@my-docker-host:~# nmap 172.17.0.71 -p9000-9200  Starting Nmap 6.40 ( http://nmap.org ) at 2014-11-14 19:19 UTC Nmap scan report for my-docker-host (172.17.0.71) Host is up (0.0000090s latency). Not shown: 200 closed ports PORT     STATE SERVICE 9100/tcp open  jetdirect MAC Address: F2:1A:ED:F4:07:7A (Unknown)  Nmap done: 1 IP address (1 host up) scanned in 1.48 seconds </code></pre>  <h3>From the container</h3>  <pre><code>root@80cf20c0c1fa:/opt/app# nmap 127.0.0.1 -p9000-9200  Starting Nmap 6.40 ( http://nmap.org ) at 2014-11-14 19:20 UTC Nmap scan report for localhost (127.0.0.1) Host is up (0.0000070s latency). Not shown: 199 closed ports PORT     STATE SERVICE 9000/tcp open  cslistener 9100/tcp open  jetdirect  Nmap done: 1 IP address (1 host up) scanned in 2.25 seconds </code></pre>  <p>The container is using Ubuntu The hosts I've replicated this are Centos and Ubuntu.</p>  <p><a href='https://stackoverflow.com/questions/26537652/docker-port-mapping-isnt-working-as-expected-with-osgi-servlet'>This SO question</a> seems similar but had very few details and no answers, so I thought I'd try to document my scenario a bit more.</p> ",
    "OwnerUserId": "122277",
    "LastEditorUserId": "-1",
    "LastEditDate": "2017-05-23T11:46:25.597",
    "LastActivityDate": "2015-06-25T01:31:24.647",
    "Title": "Docker port isn't accessible from host",
    "Tags": "<java><linux><curl><docker><spring-boot>",
    "AnswerCount": "2",
    "CommentCount": "4",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>I had a similar problem, in which specifying a host IP address as '127.0.0.1' wouldn't properly forward the port to the host.</p>  <p>Setting the web server's IP to '0.0.0.0' fixes the problem</p>  <p>eg - for my Node app - the following <strong>doesn't</strong> work</p>  <pre><code>app.listen(3000, '127.0.0.1') </code></pre>  <p>Where as the following <strong>does</strong> work:</p>  <pre><code>app.listen(3000, '0.0.0.0') </code></pre>  <p>Which I guess means that docker, by default, is exposing 0.0.0.0:containerPort -> local port</p> "
  },
  {
    "Id": "37191662",
    "PostTypeId": "1",
    "CreationDate": "2016-05-12T15:42:21.597",
    "Score": "6",
    "ViewCount": "2178",
    "Body": "<p>I've got a Spring Boot project which I want to built an image from and push to a Docker private registry. I've followed <a href='https://spring.io/guides/gs/spring-boot-docker/' rel='nofollow'>Spring Boot official docs</a> for that, using the <a href='https://github.com/spotify/docker-maven-plugin' rel='nofollow'>Spotify Docker Maven plugin</a>. That worked well when publishing my image to a docker local instance using Boot2Docker.</p>  <p>Now I'm trying to do the same with a remote private repo (an unsecured one) and I'm struggling with it. I've followed the plugin documentation for that and that's how my configuration looks like:</p>  <pre><code>&lt;build&gt;     &lt;plugins&gt;         &lt;plugin&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;         &lt;/plugin&gt;         &lt;plugin&gt;             &lt;groupId&gt;com.spotify&lt;/groupId&gt;             &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;             &lt;version&gt;0.4.9&lt;/version&gt;             &lt;configuration&gt;                 &lt;imageName&gt;service-discovery&lt;/imageName&gt;                 &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt;                 &lt;resources&gt;                     &lt;resource&gt;                         &lt;targetPath&gt;/&lt;/targetPath&gt;                         &lt;directory&gt;${project.build.directory}&lt;/directory&gt;                         &lt;include&gt;${project.build.finalName}.war&lt;/include&gt;                     &lt;/resource&gt;                 &lt;/resources&gt;             &lt;/configuration&gt;               &lt;executions&gt;                 &lt;execution&gt;                   &lt;id&gt;build-image&lt;/id&gt;                   &lt;phase&gt;package&lt;/phase&gt;                   &lt;goals&gt;                     &lt;goal&gt;build&lt;/goal&gt;                   &lt;/goals&gt;                 &lt;/execution&gt;                 &lt;execution&gt;                   &lt;id&gt;tag-image&lt;/id&gt;                   &lt;phase&gt;package&lt;/phase&gt;                   &lt;goals&gt;                     &lt;goal&gt;tag&lt;/goal&gt;                   &lt;/goals&gt;                   &lt;configuration&gt;                     &lt;image&gt;service-discovery&lt;/image&gt;                     &lt;newName&gt;develop01.mycompany.com:5000/service-discovery&lt;/newName&gt;                   &lt;/configuration&gt;                 &lt;/execution&gt;               &lt;/executions&gt;         &lt;/plugin&gt;     &lt;/plugins&gt; &lt;/build&gt; </code></pre>  <p>My registry is accessible through <code>http://develop01.mycompany.com:5000</code>, but the docker plugin seems not to be able to find it.</p>  <p>Executing <em>mvn clean install</em> throws:</p>  <blockquote>   <p>[ERROR] Failed to execute goal com.spotify:docker-maven-plugin:0.4.9:build (buil   d-image) on project service-discovery: Exception caught: java.util.concurrent.Ex   ecutionException: com.spotify.docker.client.shaded.javax.ws.rs.ProcessingExcepti   on: org.apache.http.conn.HttpHostConnectException: Connect to localhost:2375 [lo   calhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: connec   t -> [Help 1]</p> </blockquote>  <p>Executing <em>mvn docker:tag -DpushImage</em> throws:</p>  <blockquote>   <p>[ERROR] Failed to execute goal com.spotify:docker-maven-plugin:0.4.9:tag (defaul   t-cli) on project service-discovery: The parameters 'image', 'newName' for goal   com.spotify:docker-maven-plugin:0.4.9:tag are missing or invalid -> [Help 1]</p> </blockquote>  <p>So the plugin seems not to recognize the parameters into the image goal (in fact, it looks like it's trying to connect to a local Docker instance when executing <em>mvn clean install</em>).</p>  <p><strong>Software:</strong></p>  <ul> <li>docker version: Server: 1.11.0</li> <li>docker-maven-plugin version: 0.4.9</li> <li>maven version: 3.2.3</li> </ul>  <p>A link to the <a href='https://github.com/spotify/docker-maven-plugin/issues/227' rel='nofollow'>GitHub issue</a> I created</p>  <hr>  <p><strong>Update</strong></p>  <p>I have set my DOCKER_HOST environment variable to <code>tcp://develop01.mycompany.com:5000</code> and now the plugin seems to pick it. Still don't understand why I have to do it through an environment variable, when I'm declaring the server name in the execution configuration. All in all, that's the error I'm getting right now:</p>  <blockquote>   <p>[ERROR] Failed to execute goal   com.spotify:docker-maven-plugin:0.4.9:build (buil d-image) on project   service-discovery: Exception caught: Request error: GET http   ://develop01.mycompany.com:5000/version: 404: HTTP 404 Not Found ->   [Help 1]</p> </blockquote>  <p>In fact, the /version endpoint of my registry returns 404. The /v2 endpoint however, returns an empty JSON. Is the plugin trying to deal with a previous docker version API?</p> ",
    "OwnerUserId": "1199132",
    "LastEditorUserId": "482717",
    "LastEditDate": "2016-09-21T16:14:33.497",
    "LastActivityDate": "2016-09-21T16:14:33.497",
    "Title": "Cannot push to remote repo using the (spotify) Docker maven plugin",
    "Tags": "<maven><docker><spring-boot>",
    "AnswerCount": "0",
    "CommentCount": "1",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": null
  },
  {
    "Id": "37301460",
    "PostTypeId": "1",
    "CreationDate": "2016-05-18T13:43:13.540",
    "Score": "6",
    "ViewCount": "13846",
    "Body": "<p>i cannot configure a Dockerfile for use external properties file with Spring Boot. This is my Dockerfile:</p>  <pre><code>FROM java:8-jre  VOLUME /tmp /var/gpm/config ADD gpm-web-1.0.jar app.jar RUN bash -c 'touch /app.jar' ENTRYPOINT ['java','-cp','/var/gpm/config','-Dspring.config.location=classpath:application.properties','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre>  <p>And in my host i have this path to properties file : /var/gpm/config/application.properties</p>  <p>But, don't works.</p>  <p><strong>UPDATE</strong></p>  <p>i change Dockerfile by this:</p>  <pre><code>FROM java:8-jre VOLUME /tmp ADD gpm-web-1.0.jar app.jar RUN bash -c 'touch /app.jar' ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar','--spring.config.location=file:/conf/application.properties'] </code></pre>  <p>And run with this:</p>  <pre><code>docker run -d -p 8080:8080 -v /opt/gpm/config/application.properties:/conf/application.properties --name gpm gpm-web:1.0 </code></pre>  <p>But, the file is take it like a folder:</p>  <pre><code>root@b7349202b6d3:/# ls -la /conf/ total 8 drwxr-xr-x  3 root root  4096 May 18 16:43 . drwxr-xr-x 74 root root  4096 May 18 16:55 .. drwxr-sr-x  2 root staff   40 May 18 16:43 application.properties  </code></pre> ",
    "OwnerUserId": "4633335",
    "LastEditorUserId": "4633335",
    "LastEditDate": "2016-05-18T16:58:37.310",
    "LastActivityDate": "2017-05-04T07:35:27.217",
    "Title": "External properties file using Spring Boot and Docker",
    "Tags": "<java><docker><spring-boot><dockerfile>",
    "AnswerCount": "2",
    "CommentCount": "12",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>I think you only need to mount the volume to the conf folder e.g.</p>  <p>docker run -d -p 8080:8080 -v /opt/gpm/config:/conf --name gpm gpm-web:1.0</p> "
  },
  {
    "Id": "37976796",
    "PostTypeId": "1",
    "AcceptedAnswerId": "37978018",
    "CreationDate": "2016-06-22T19:34:26.803",
    "Score": "6",
    "ViewCount": "3846",
    "Body": "<p>I've a little problem with run my spring boot application in docker.</p>  <p>stack: maven 3+, spring boot(jpa/rest/jetty) - mysql - deploy in docker</p>  <p>So, i've have in my pom file</p>  <pre><code>&lt;parent&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;     &lt;version&gt;1.4.0.M3&lt;/version&gt;     &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt;  &lt;properties&gt;     &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;     &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt;  &lt;dependencies&gt;     &lt;!-- SPRING BOOT DEPENDENCIES --&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;         &lt;artifactId&gt;lombok&lt;/artifactId&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;         &lt;!-- add for exlude tomcat --&gt;         &lt;exclusions&gt;             &lt;exclusion&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;             &lt;/exclusion&gt;         &lt;/exclusions&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;         &lt;scope&gt;test&lt;/scope&gt;     &lt;/dependency&gt;     &lt;!-- END SPRING BOOT DEPENDENCIES--&gt;     &lt;!-- Jetty (tomcat replacement) --&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;     &lt;/dependency&gt;     &lt;!-- mysql connector --&gt;     &lt;dependency&gt;         &lt;groupId&gt;mysql&lt;/groupId&gt;         &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;         &lt;scope&gt;runtime&lt;/scope&gt;     &lt;/dependency&gt;     &lt;!-- optional dependency javax.el --&gt;     &lt;dependency&gt;         &lt;groupId&gt;javax.el&lt;/groupId&gt;         &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt;         &lt;version&gt;3.0.0&lt;/version&gt;     &lt;/dependency&gt;     &lt;!-- google http client --&gt;     &lt;dependency&gt;         &lt;groupId&gt;com.google.http-client&lt;/groupId&gt;         &lt;artifactId&gt;google-http-client&lt;/artifactId&gt;         &lt;version&gt;1.21.0&lt;/version&gt;     &lt;/dependency&gt;     &lt;!-- google http jackson --&gt;     &lt;dependency&gt;         &lt;groupId&gt;com.google.http-client&lt;/groupId&gt;         &lt;artifactId&gt;google-http-client-jackson2&lt;/artifactId&gt;         &lt;version&gt;1.21.0&lt;/version&gt;     &lt;/dependency&gt; &lt;/dependencies&gt; </code></pre>  <p>Environment: Ubuntu 16.04 x64 The problem: Locally: I try to run my app with follow command in terminal</p>  <pre><code>user$ java -Xmx768m -jar /mnf-backend.jar --spring.datasource.url=jdbc:mysql://$MYSQL_PORT_3306_TCP_ADDR/app_1?autoReconnect=true&amp;useSSL=false user$ #&lt;--- LOOK AT THIS jvm has return of control with 1 status (or same status but not negative)  :: Spring Boot ::             (v1.4.0.M3) # &lt;--- spring boot starts by itself. HOW???? </code></pre>  <p>it's not good by i can tolerate it. But not docker. When commands above will be run in docker then docker stop container (because -> app exit with status 1)</p>  <pre><code>ENTRYPOINT ['java', '-Xmx768m', '-jar', '/mnf-backend.jar', '--spring.datasource.url=jdbc:mysql://$MYSQL_PORT_3306_TCP_ADDR/app_1?autoReconnect=true&amp;useSSL=false'] </code></pre>  <p>Docker will start container 1 second and immediately stop container because java return control. I look for method which allow me to configure spring app for predictable behavior or any ideas how to improve my docker instructions. my dockerfile content:</p>  <pre><code>FROM frolvlad/alpine-oraclejdk8:slim  ENV MNFB_ENV production ENV SERVER_PORT 9000  ADD ./builds/mnf-latest.jar mnf-backend.jar  EXPOSE 9000    ENTRYPOINT ['java', '-Xmx768m', '-jar', '/mnf-backend.jar', '--spring.datasource.url=jdbc:mysql://$MYSQL_PORT_3306_TCP_ADDR/minifinance?autoReconnect=true&amp;useSSL=false'] </code></pre>  <p>docker logs of a container <a href='https://i.stack.imgur.com/gnEbI.png' rel='noreferrer'><img src='https://i.stack.imgur.com/gnEbI.png' alt='enter image description here'></a></p>  <p>For example: when i've start nodejs app control not return until application not finished</p>  <pre><code>user$ node ./server.js [...here program output and stdout strings] [... it may be stopped by ctrl+c for example] </code></pre> ",
    "OwnerUserId": "4917670",
    "LastEditorUserId": "4917670",
    "LastEditDate": "2016-06-22T20:40:54.130",
    "LastActivityDate": "2017-11-01T13:18:11.603",
    "Title": "spring-boot cannot start in docker",
    "Tags": "<java><spring><shell><docker><spring-boot>",
    "AnswerCount": "2",
    "CommentCount": "5",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>I think the problem is the ampersand (&amp;) in your command line:</p>  <p><code>--spring.datasource.url=jdbc:mysql://$MYSQL_PORT_3306_TCP_ADDR/app_1?autoReconnect=true&amp;useSSL=false']</code></p>  <p>Try to escape it:</p>  <p><code>--spring.datasource.url=jdbc:mysql://$MYSQL_PORT_3306_TCP_ADDR/app_1?autoReconnect=true\\&amp;useSSL=false']</code></p>  <p>The ampersand denotes the shell to start your process in the background. That's exactly what's happening on your local machine. If you start your jar, the process should start in foreground... and the prompt shouldn't return directly.</p> ",
    "highest_rated_answer": "<p>To keep it simple and clean, we have added database properties in the database.properties</p>  <h1>mongo db database configuration</h1>  <pre><code>spring.data.mongodb.database=abc-auth spring.data.mongodb.host=192.168.2.2 spring.data.mongodb.port=27017 spring.data.mongodb.password=abc234quth spring.data.mongodb.username=abc-auth </code></pre>  <p>We push this file while running the Docker, so only database properties will get override with the existing application.properties</p>  <pre><code>ENTRYPOINT ['java','-jar','/home/docker/service/abc.jar','--spring.config.location=application.properties'] </code></pre> "
  },
  {
    "Id": "39126226",
    "PostTypeId": "1",
    "CreationDate": "2016-08-24T14:33:41.383",
    "Score": "6",
    "ViewCount": "17129",
    "Body": "<p>I am trying to figure out how to build a spring boot docker image using fabric8 docker-maven-plugin. The documentation contains bit and bytes and I'm obviously missing something. Does anyone have a full pom.xml example for it?</p> ",
    "OwnerUserId": "200937",
    "LastActivityDate": "2020-10-14T14:16:55.040",
    "Title": "fabric8 springboot full example",
    "Tags": "<docker><spring-boot><spring-boot-docker-plugin>",
    "AnswerCount": "5",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>The fabric8-maven-plugin documentation is pretty hard to dig through if you just want to get started quickly, so here's a quick example for everything you need to get a Docker image built.</p>  <p>First, make sure <code>docker</code> is on your path and the Docker daemon is running. Run <code>docker ps</code> and ensure a response like this:</p>  <pre><code>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES </code></pre>  <p>Add this to your pom.xml and run this with <code>mvn clean package docker:build</code></p>  <pre class='lang-xml prettyprint-override'><code>&lt;build&gt;     &lt;plugins&gt;         &lt;plugin&gt;             &lt;groupId&gt;io.fabric8&lt;/groupId&gt;             &lt;artifactId&gt;fabric8-maven-plugin&lt;/artifactId&gt;             &lt;configuration&gt;                 &lt;verbose&gt;true&lt;/verbose&gt;                 &lt;images&gt;                     &lt;image&gt;                         &lt;!-- Replace your-project-name --&gt;                         &lt;name&gt;your-project-name:${project.version}&lt;/name&gt;                          &lt;build&gt;                              &lt;!-- This is the same FROM used in a Dockerfile --&gt;                             &lt;from&gt;vixns/java8&lt;/from&gt;                              &lt;!-- This is the same ENTRYPOINT used in a Dockerfile --&gt;                             &lt;entryPoint&gt;                                 &lt;exec&gt;                                     &lt;arg&gt;java&lt;/arg&gt;                                     &lt;!-- This extra argument is so Tomcat can start faster due to lack of entropy --&gt;                                     &lt;arg&gt;-Djava.security.egd=file:/dev/./urandom&lt;/arg&gt;                                     &lt;arg&gt;-jar&lt;/arg&gt;                                     &lt;!-- /maven/ is the default dir that the plugin copies your artifact to --&gt;                                     &lt;arg&gt;/maven/${project.artifactId}.${project.packaging}&lt;/arg&gt;                                 &lt;/exec&gt;                             &lt;/entryPoint&gt;                              &lt;assembly&gt;                                 &lt;!-- This is a predefined assembly.xml that will only copy your final artifact to the Docker image --&gt;                                 &lt;descriptorRef&gt;artifact&lt;/descriptorRef&gt;                             &lt;/assembly&gt;                         &lt;/build&gt;                     &lt;/image&gt;                 &lt;/images&gt;             &lt;/configuration&gt;         &lt;/plugin&gt;     &lt;/plugins&gt; &lt;/build&gt; </code></pre>  <p>Note: you'll need additional setup if you want to use the <code>mvn docker:start</code> command. You don't have to use it, you can use the standard <code>docker</code> command if you'd like.</p> "
  },
  {
    "Id": "39424559",
    "PostTypeId": "1",
    "AcceptedAnswerId": "39427400",
    "CreationDate": "2016-09-10T09:16:30.690",
    "Score": "6",
    "ViewCount": "10589",
    "Body": "<p>I quick started with Redis on Windows PC with</p>  <pre><code>docker run -p 6379:6379 redis </code></pre>  <p>(Redis does not have Windows distribution, <a href='https://github.com/MSOpenTech/redis' rel='noreferrer'>fork for Windows</a> is not the latest version )</p>  <pre><code>1:C 10 Sep 08:17:03.635 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf                 _._            _.-``__ ''-._       _.-``    `.  `_.  ''-._           Redis 3.2.3 (00000000/0) 64 bit   .-`` .-```.  ```\\/    _.,_ ''-._  (    '      ,       .-`  | `,    )     Running in standalone mode  |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379  |    `-._   `._    /     _.-'    |     PID: 1   `-._    `-._  `-./  _.-'    _.-'  |`-._`-._    `-.__.-'    _.-'_.-'|  |    `-._`-._        _.-'_.-'    |           http://redis.io   `-._    `-._`-.__.-'_.-'    _.-'  |`-._`-._    `-.__.-'    _.-'_.-'|  |    `-._`-._        _.-'_.-'    |   `-._    `-._`-.__.-'_.-'    _.-'       `-._    `-.__.-'    _.-'           `-._        _.-'               `-.__.-'  ... 1:M 10 Sep 08:17:03.644 * The server is now ready to accept connections on port 6379 </code></pre>  <p>Then however I can't connect from Spring Boot app. With <code>application.properties</code> like</p>  <pre><code>spring.redis.host=localhost spring.redis.port=6379 </code></pre>  <p>got error</p>  <pre><code>Caused by: redis.clients.jedis.exceptions.JedisConnectionException: java.net.ConnectException: Connection refused: connect     at redis.clients.jedis.Connection.connect(Connection.java:164) ~[jedis-2.8.2.jar:na]     at redis.clients.jedis.BinaryClient.connect(BinaryClient.java:80) ~[jedis-2.8.2.jar:na]     at redis.clients.jedis.BinaryJedis.connect(BinaryJedis.java:1677) ~[jedis-2.8.2.jar:na]     at redis.clients.jedis.JedisFactory.makeObject(JedisFactory.java:87) ~[jedis-2.8.2.jar:na]     at org.apache.commons.pool2.impl.GenericObjectPool.create(GenericObjectPool.java:868) ~[commons-pool2-2.4.2.jar:2.4.2]     at org.apache.commons.pool2.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:435) ~[commons-pool2-2.4.2.jar:2.4.2]     at org.apache.commons.pool2.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:363) ~[commons-pool2-2.4.2.jar:2.4.2]     at redis.clients.util.Pool.getResource(Pool.java:49) ~[jedis-2.8.2.jar:na]     ... 23 common frames omitted Caused by: java.net.ConnectException: Connection refused: connect     at java.net.DualStackPlainSocketImpl.waitForConnect(Native Method) ~[na:1.8.0_45]     at java.net.DualStackPlainSocketImpl.socketConnect(DualStackPlainSocketImpl.java:85) ~[na:1.8.0_45]     at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:345) ~[na:1.8.0_45]     at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206) ~[na:1.8.0_45]     at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188) ~[na:1.8.0_45]     at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:172) ~[na:1.8.0_45]     at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392) ~[na:1.8.0_45]     at java.net.Socket.connect(Socket.java:589) ~[na:1.8.0_45]     at redis.clients.jedis.Connection.connect(Connection.java:158) ~[jedis-2.8.2.jar:na]     ... 30 common frames omitted </code></pre>  <p>When trying to use Node.js with <a href='https://github.com/NodeRedis/node_redis' rel='noreferrer'>node_redis</a> example,  I got</p>  <pre><code>Error Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED </code></pre> ",
    "OwnerUserId": "482717",
    "LastEditorUserId": "482717",
    "LastEditDate": "2016-09-11T04:38:46.080",
    "LastActivityDate": "2021-02-04T12:26:23.953",
    "Title": "Check/connect to Redis running within docker from Java(Spring Boot) or Node.js",
    "Tags": "<node.js><docker><spring-boot><redis>",
    "AnswerCount": "3",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>As you mentioned (in the comments), redis bundled their image with <code>protected-mode</code> set to yes (<a href='http://redis.io/topics/security' rel='nofollow noreferrer'>see here</a>).</p>  <p><strong>How to go around protected-mode</strong></p>  <ul> <li>1) Disable protected mode sending the command 'CONFIG SET protected-mode no' from the loopback interface by connecting to Redis from the same host the server is running, however MAKE SURE Redis is not publicly accessible from internet if you do so. Use CONFIG REWRITE to make this change permanent. </li> <li>2) Alternatively you can disable the protected mode by editing the Redis configuration file, and setting the protected mode option to 'no', and then restarting the server. </li> <li>3) If you started the server manually (perhaps for testing), restart it with the '--protected-mode no' option. </li> <li>4) Setup a bind address or an authentication password.</li> </ul>  <p>source: <a href='https://github.com/docker-library/redis/issues/58' rel='nofollow noreferrer'>redis-github</a></p>  <p><strong>Build your own image</strong></p>  <ul> <li>You could create your own image by pulling redis's and ADDing your own redis.conf to the image ? </li> <li>Or update the start command in the Dockerfile to disable protected-mode: <code>CMD [ 'redis-server', '--protected-mode', 'no' ]</code></li> </ul>  <p><strong>You can also take a look at this Dockerfile which contains the modification suggested above</strong> (last line): <a href='https://github.com/docker-library/redis/blob/23b10607ef1810379d16664bcdb43723aa007266/3.2/Dockerfile' rel='nofollow noreferrer'>https://github.com/docker-library/redis/blob/23b10607ef1810379d16664bcdb43723aa007266/3.2/Dockerfile</a></p>  <p>This Dockerfile is provided in a <a href='https://github.com/docker-library/redis/issues/58' rel='nofollow noreferrer'>Redis issue on github</a>, it replaces the startup command with <code>CMD [ 'redis-server', '--protected-mode', 'no' ]</code>.  You could just download this Dockerfile and type:</p>  <pre><code>$ docker build -t redis-unprotected:latest . $ docker run -p 6379:6379 redis-unprotected </code></pre> ",
    "highest_rated_answer": "<p>Ran into a similar problem today. Using the redis container's IP address for the <code>JedisConnectionFactory</code> solved the issue for me.</p> <p><strong>Docker command:</strong></p> <pre><code>docker inspect --format '{{ .NetworkSettings.IPAddress }}' some-redis-instance </code></pre> "
  },
  {
    "Id": "41983989",
    "PostTypeId": "1",
    "CreationDate": "2017-02-01T15:48:41.657",
    "Score": "6",
    "ViewCount": "2808",
    "Body": "<p>The backend runs in a docker container. It runs with spring boot &amp; security and works fine. The frontend runs in another container as well. All works fine until out of nowhere this exception is thrown. I only noticed this exception after I idled a few minutes (normaly between 5 and 10 min).</p>  <blockquote>   <p>WARN 1 --- [nio-8080-exec-2] o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Error: 0, SQLState: 08S01<br>   ERROR 1 --- [nio-8080-exec-2] o.h.engine.jdbc.spi.SqlExceptionHelper   : I/O Error: Connection reset <br>    ERROR 1 --- [nio-8080-exec-2] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.dao.DataAccessResourceFailureException: could not extract ResultSet; nested exception is org.hibernate.exception.JDBCConnectionException: could not extract ResultSet] with root cause<br><br>   java.net.SocketException: Connection reset           at java.net.SocketInputStream.read(SocketInputStream.java:209) ~[na:1.8.0_111-internal]           at java.net.SocketInputStream.read(SocketInputStream.java:141) ~[na:1.8.0_111-internal]           at java.io.DataInputStream.readFully(DataInputStream.java:195) ~[na:1.8.0_111-internal]<br>   .....</p> </blockquote>  <p>The connection to the Database is available all the time. The weird thing is, that this error is only thrown when I run my project with docker. If I run it with eclipse &amp; node.js the error don't occurs. The only thing I noticed was, that a few minutes after I loged in and idled, I got automaticly loged out when I tried to do something. I don't know if this has any connection with the orgiginal error.</p>  <p>application.properties</p>  <pre><code>spring.datasource.url=databaseURL spring.datasource.username=SQLusername spring.datasource.password=Password spring.datasource.driver-class-name=net.sourceforge.jtds.jdbc.Driver spring.datasource.initialSize=100 spring.datasource.minIdle=10  spring.jpa.hibernate.naming_strategy=org.hibernate.cfg.EJB3NamingStrategy spring.jpa.hibernate.naming.implicit-strategy=org.hibernate.boot.model.naming.ImplicitNamingStrategyLegacyJpaImpl spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl  spring.datasource.tomcat.max-active=250 spring.datasource.tomcat.max-wait=30000 spring.datasource.test-on-borrow=true spring.datasource.test-while-idle=true spring.datasource.minEvictableIdleTimeMillis=21600000 spring.datasource.timeBetweenEvictionRunsMillis=43200000   spring.datasource.connection-test-query=SELECT 1 spring.datasource.validationQuery=SELECT 1 </code></pre>  <p>I'm glad for every suggestion that could help to fix this proplem.</p> ",
    "OwnerUserId": "7113955",
    "LastActivityDate": "2021-05-06T00:08:58.013",
    "Title": "Spring boot connection reset after a few minutes in docker container",
    "Tags": "<java><spring><docker><spring-boot><datasource>",
    "AnswerCount": "1",
    "CommentCount": "1",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>I had the same problem months ago! This happens because the jvm doesn\u2019t have memory enough to accept this request!</p> <p>This error is intermittent and is very difficult to find your root cause!</p> <p>Try this: Put in your Dockerfile some flags to solve it</p> <pre><code>ENTRYPOINT [&quot;java&quot;,&quot;-XX:+TieredCompilation&quot;,&quot;-XX:TieredStopAtLevel=1&quot;, &quot;-jar&quot;,&quot;yourJar.jar&quot;] </code></pre> <p>More details here: <a href='https://jpbempel.github.io/2020/05/22/startup-containers-tieredcompilation.html' rel='nofollow noreferrer'>https://jpbempel.github.io/2020/05/22/startup-containers-tieredcompilation.html</a></p> <p>Sometimes the problem can be memory. When you start your container with java, the jvm default heap memory is 1/4 of total memory of container. Then you can use the flag <em><strong>-XX:MaxRAMFraction</strong></em> where your value has a range 1 to 4.</p> <p>More details here: <a href='https://merikan.com/2019/04/jvm-in-a-container/#java-8u131-and-java-9' rel='nofollow noreferrer'>https://merikan.com/2019/04/jvm-in-a-container/#java-8u131-and-java-9</a></p> <p>Good luck!</p> "
  },
  {
    "Id": "42759587",
    "PostTypeId": "1",
    "CreationDate": "2017-03-13T08:52:31.810",
    "Score": "6",
    "ViewCount": "3922",
    "Body": "<p>Im trying to use Spring Boot Dev tools (Spring Remote), and automatically upload recompiled files to my docker container.</p>  <p>I keep receiving  <code>Unexpected 404 response uploading class files</code></p>  <p>This is my docker file:</p>  <pre><code>FROM java:8 WORKDIR /first ADD ./build/libs/first.jar /first/first.jar EXPOSE 8080 RUN bash -c 'touch /first/first.jar' ENTRYPOINT ['java','-Dspring.data.mongodb.uri=mongodb://mongodb/micros', '-Djava.security.egd', '-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005','-jar', 'first.jar'] </code></pre>  <p>This is my configuration and the configuration <a href='https://i.stack.imgur.com/26mbW.png' rel='noreferrer'><img src='https://i.stack.imgur.com/26mbW.png' alt='enter image description here'></a></p>  <p>And this is the error I'm receiving:</p>  <p><a href='https://i.stack.imgur.com/rt9fJ.png' rel='noreferrer'><img src='https://i.stack.imgur.com/rt9fJ.png' alt='enter image description here'></a></p> ",
    "OwnerUserId": "659431",
    "LastActivityDate": "2018-02-28T23:28:24.480",
    "Title": "Intellij, Spring dev tools remote, Docker, error Unexpected 404 response uploading class files",
    "Tags": "<spring><docker><intellij-idea><spring-boot><spring-tool-suite>",
    "AnswerCount": "3",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>As of Spring Boot 1.5.0, devtools defaults were changed to exclude the devtools from fat jars.</p>  <p>If you want to include them, you have to set the <code>excludeDevtools</code> flag to false.</p>  <p>However, the devtools documentation doesn't explain how to do this. The necessary documentation is actually in the spring-boot-gradle-plugin documentation.</p>  <p>To do it, you can put this snippet of code in your build.gradle file:</p>  <pre><code>bootRepackage {     excludeDevtools = false } </code></pre>  <p>Unfortunately, this was buggy at first and had no effect as of Spring Boot 1.5.0. The workaround was to do this instead:</p>  <pre><code>springBoot {     excludeDevtools = false } </code></pre>  <p>However, I have verified that the <code>bootRepackage</code> approach works for Spring Boot 1.5.8 .</p> "
  },
  {
    "Id": "44019007",
    "PostTypeId": "1",
    "CreationDate": "2017-05-17T08:06:21.810",
    "Score": "6",
    "ViewCount": "8681",
    "Body": "<p>I have a docker image of tomcat with my spring boot web app inside tomcat /webapps folder. The app has its own application.properties file packed in the folder.  I want to give the option for anyone running the docker image to mount it's own <strong>external application.properties file</strong> for the spring boot web app to run by. </p>  <p>How can this by accomplished? thank you very much</p> ",
    "OwnerUserId": "7499004",
    "LastActivityDate": "2018-01-17T06:45:03.797",
    "Title": "add external application.properties file to a dockerized spring boot web app inside tomcat",
    "Tags": "<spring><tomcat><docker><spring-boot>",
    "AnswerCount": "3",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Similar answer to agnul, you can mount an volume from the docker engine's host, see <a href='https://docs.docker.com/engine/tutorials/dockervolumes/#locate-a-volume' rel='noreferrer'>here</a></p>  <p>Something like:</p>  <pre><code>docker run -d -P --name web -v /config:/config ... </code></pre>  <p>When you start your JVM you give the system property to /config</p>  <pre><code>java -jar myproject.jar --spring.config.location=file:/config/application.properties </code></pre> "
  },
  {
    "Id": "44537781",
    "PostTypeId": "1",
    "CreationDate": "2017-06-14T07:06:10.760",
    "Score": "6",
    "ViewCount": "1250",
    "Body": "<p>My application uses some additional files which I have inside the resource folder. When I do the regular build with Maven and package my app into JAR, I can see all my resources in case I unzip this archive. </p>  <p>But when I create a docker image I use spring-boot-maven-plugin to make my JAR archive executable. For some reason <strong>my resources aren't being added to the new repacked JAR</strong>. Moreover I <strong>can not even unzip it</strong> because it is corrupted.</p>  <p>Here is the way I set the repackage goal in my pom.xml:</p>  <pre><code>&lt;id&gt;prod&lt;/id&gt;         &lt;build&gt;             &lt;plugins&gt;                 &lt;plugin&gt;                     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                     &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                     &lt;version&gt;1.5.3.RELEASE&lt;/version&gt;                     &lt;configuration&gt;                         &lt;mainClass&gt;ApplicationName&lt;/mainClass&gt;                         &lt;executable&gt;true&lt;/executable&gt;                         &lt;arguments&gt;                             &lt;argument&gt;--spring.profiles.active=prod&lt;/argument&gt;                         &lt;/arguments&gt;                         &lt;!--&lt;addResources&gt;true&lt;/addResources&gt;--&gt;                     &lt;/configuration&gt;                     &lt;executions&gt;                         &lt;execution&gt;                             &lt;goals&gt;                                 &lt;goal&gt;repackage&lt;/goal&gt;                             &lt;/goals&gt;                             &lt;configuration&gt;                                 &lt;!--&lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt;--&gt;                                 &lt;!--&lt;layout&gt;JAR&lt;/layout&gt;--&gt;                             &lt;/configuration&gt;                         &lt;/execution&gt;                     &lt;/executions&gt;                 &lt;/plugin&gt;             &lt;/plugins&gt;         &lt;/build&gt; </code></pre>  <p>I want to add that when I run my image in docker it works fine <strong>but all the needed resources are missing</strong>.</p>  <p>Has anyone run into the same problem? Or maybe you can suggest how to fix it.</p> ",
    "OwnerUserId": "4624052",
    "LastActivityDate": "2017-06-14T07:06:10.760",
    "Title": "Resources are missing from JAR file after repackage with spring boot maven plugin",
    "Tags": "<maven><docker><spring-boot><spring-boot-maven-plugin><docker-maven-plugin>",
    "AnswerCount": "0",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": null
  },
  {
    "Id": "44667063",
    "PostTypeId": "1",
    "AcceptedAnswerId": "44694167",
    "CreationDate": "2017-06-21T04:49:23.627",
    "Score": "6",
    "ViewCount": "14268",
    "Body": "<p>I have a very simple demo of using Spring Boot + Docker Compose + Eureka. </p>  <p>My server runs on port 8671 with the following application properties:</p>  <pre><code>server:   port: 8761 eureka:   instance:     prefer-ip-address: true   client:     registerWithEureka: false     fetchRegistry: false   server:     waitTimeInMsWhenSyncEmpty: 0 </code></pre>  <p>My Eureka client runs on port 9000 with the following application properties:</p>  <pre><code>server:   port: 9000 spring:   application:     name: user-registration eureka:   client:     registerWithEureka: true     fetchRegistry: true     serviceUrl:       defaultZone: http://localhost:8761/eureka/   instance:     prefer-ip-address: true </code></pre>  <p>When I start up my docker.compose file in the parent maven project, this is the contents of my docker-compose file:</p>  <pre><code>eureka-server:   image: rosenthal/eureka-server ports:    - '8761:8761' user-registration:   image: rosenthal/user-registration   ports:    - '9000:9000'   links:    - eureka-server </code></pre>  <p>When I run my application by first starting the eureka server, following by the client via </p>  <pre><code>mvn spring-boot:run  </code></pre>  <p>The server successfully registers my client (I call it user-registration).</p>  <p>When I run my application through docker-compose, the client fails to register with the following output:</p>  <pre><code> DiscoveryClient_USER-REGISTRATION/0fd640cbc3ba:user-registration:9000:   registering service...  user-registration_1  | 2017-06-21 04:36:05.120 ERROR 1 --- [nfoReplicator-0]          c.n.d.s.t.d.RedirectingEurekaHttpClient  : Request execution error  user-registration_1  |   user-registration_1  | com.sun.jersey.api.client.ClientHandlerException:   java.net.ConnectException: Connection refused (Connection refused) </code></pre>  <p>My first assumption was that running docker-compose ran into a race condition on waiting for the server to start, but my eureka client seems to have a heartbeat trying to call home to the server it's configured with. This means it's just not able to find the Eureka server I have registered (and is running, I can navigate to it on localhost:8671).</p>  <p>What am I missing here? Everything runs fine running locally with spring-boot starting up with it's own embedded tomcat containers. As soon as I start to do it with docker-compose, it doesn't want to work.</p>  <h2>EDIT</h2>  <p>I realized my problem, I believe. So docker doesn't run on localhost, it runs on the public IP it is assigned when I start up docker. Navigating to this ip + port shows my service running for Eureka Server. The client still doesn't register.</p>  <p>SO, I made changes to the application.yml file for my eureka client to:</p>  <pre><code>serviceUrl:   defaultZone: http://192.168.59.103:8761/eureka/ </code></pre>  <p>That IP is the one my docker daemon is running under. Now, it misses the first registration when I do docker-compose, but the second heartbeat picks up my client. </p>  <p>How can I ensure the client waits until the server is FULLY up? I used the proper docker 'links' field in my docket compose file, but it didn't work as I hoped. Additionally, how can I see the defaultZone file to be my DOCKER_HOST IP?</p>  <h2>Final result</h2>  <p>The resulting docker-compose file that got everything working for me was:</p>  <pre><code>eureka-server:   image: thorrism/eureka-server   ports:    - '8761:8761' user-registration:   image: thorrism/user-registration   ports:    - '9000:9000'   links:    - eureka-server   environment:     EUREKA_CLIENT_SERVICEURL_DEFAULTZONE: http://eureka-server:8761/eureka </code></pre> ",
    "OwnerUserId": "5203863",
    "LastEditorUserId": "5203863",
    "LastEditDate": "2017-06-21T16:52:46.653",
    "LastActivityDate": "2021-12-23T15:35:28.220",
    "Title": "Docker and Eureka with Spring Boot failing to register clients",
    "Tags": "<java><spring><maven><docker><spring-boot>",
    "AnswerCount": "5",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>If useful for you, that's in some way how I configure it for my production environment (docker-compose file version 2):</p>  <pre><code>version: '2' services:   eureka-server:     image: rosenthal/eureka-server     expose:     - '8761'   user-registration:     image: rosenthal/user-registration     container_name: user-registration     ports:     - '9000:8080'     environment:       server.port: 8080       eureka.client.enabled: 'true'       eureka.host: eureka-server       eureka.instance.preferIpAddress: 'true' </code></pre>  <p>From the <a href='https://docs.docker.com/compose/compose-file/#service-configuration-reference' rel='nofollow noreferrer'>docs</a> that's what <code>expose</code> does:</p>  <blockquote>   <p>Expose ports without publishing them to the host machine - they\u2019ll only be accessible to linked services. Only the internal port can be specified.</p> </blockquote>  <p>As you've got everything in the same network, containers can see each other with no links between them.</p>  <p><strong>SIDE NOTE</strong></p>  <p>Keep in mind that with this configuration port 9000 will be publicly accessible at the host machine, and mapped to the 8080 port of the user-registration container.</p> ",
    "highest_rated_answer": "<p>Set an environment property to override the <code>eureka.client.serviceUrl.defaultZone</code> to match the service name in your docker compose file.</p>  <pre><code>eureka-server:   image: rosenthal/eureka-server   ports:    - '8761:8761' user-registration:   image: rosenthal/user-registration   ports:    - '9000:9000'   environment:    - EUREKA_CLIENT_SERVICEURL_DEFAULTZONE: http://eureka-server:8761/eureka </code></pre>  <p>This will override the property from the packaged <code>application.properties</code>. </p>  <p><strong>NOTE:</strong> As mentioned in the comments you don't need the <code>links</code> section in the compose file. I removed is as such. See <a href='https://docs.docker.com/compose/networking/' rel='noreferrer'>https://docs.docker.com/compose/networking/</a> for info on that.</p> "
  },
  {
    "Id": "51877246",
    "PostTypeId": "1",
    "AcceptedAnswerId": "51878212",
    "CreationDate": "2018-08-16T12:35:35.970",
    "Score": "6",
    "ViewCount": "6393",
    "Body": "<p>i have a Problem Running Spring Boot and Keycloak both in docker containers.</p>  <p>I started with Keycloak with mysql as db running in docker.</p>  <pre><code>services:   mysql:     image: mysql:5.7     container_name: mysql     volumes:       - mysql_data:/var/lib/mysql     environment:       MYSQL_ROOT_PASSWORD: root       MYSQL_DATABASE: keycloak       MYSQL_USER: keycloak       MYSQL_PASSWORD: password     networks:       - testNetwork    keycloak:     image: jboss/keycloak     container_name: keycloak     restart: on-failure     volumes:       - ./config:/config/     environment:       DB_VENDOR: MYSQL       DB_ADDR: mysql       DB_DATABASE: keycloak       DB_USER: keycloak       DB_PASSWORD: password       KEYCLOAK_USER: xxx       KEYCLOAK_PASSWORD: yyy       KEYCLOAK_IMPORT_REALM: /keycloak/import/realm-import.json     ports:       - 8180:8080     depends_on:       - mysql     networks:       - testNetwork </code></pre>  <p>Then i added my realm (SpringBootKeycloak), my client (testclient), and a user with role 'user'. After that i added spring-security to my Spring-boot-application. And edited my application.yml</p>  <pre><code>spring:   main:     banner-mode: 'off'   application:     name: testclient     version: @project.version@   jpa:     hibernate:       ddl-auto: create   datasource:     url: jdbc:h2:mem:testclient;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE     username: xxx     password: xxx keycloak:   auth-server-url: http://localhost:8180/auth   realm: SpringBootKeycloak   resource: testclient   public-client: true   principal-attribute: preferred_username   security-constraints:     - authRoles:       - user       securityCollections:         - patterns:           - /* server:   port: ${port:8090}   rest:     path: testclient </code></pre>  <p>accoring to that i added my SecurityConfig:</p>  <pre><code>  /**    * Secure appropriate endpoints    */   @Override   protected void configure(HttpSecurity http) throws Exception {     super.configure(http);     http.authorizeRequests()         .antMatchers('/*').hasRole('user') // only user with role user are allowed to access         .anyRequest().permitAll();   } </code></pre>  <p>Running my SpringBoot-Application locally is working fine. I have to login with keycloak and get redirected to localhost:8090. But when i add my SpringBoot-Application to my docker-compose and start it in a container i get still to keycloak for login, but when i should redirect i get a 403.</p>  <pre><code>  testclient:     image: testclient     container_name: testclient     environment:       JAVA_OPTS: '-agentlib:jdwp=transport=dt_socket,address=5005,server=y,suspend=n'     build:       context: testclient-application     ports:       - 8090:8090       - 5006:5005     networks:       - testNetwork </code></pre>  <p>with following container log:</p>  <pre><code>{'@timestamp':'2018-08-16T11:50:11.530+00:00','@version':'1','message':'failed to turn code into token','logger_name':'org.keycloak.adapters.OAuthRequestAuthenticator','thread_name':'http-nio-8090-exec-6','level':'ERROR','level_value':40000,'stack_trace':'java.net.ConnectException: Connection refused (Connection refused)\\n\\tat java.net.PlainSocketImpl.socketConnect(Native Method)\\n\\tat java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\\n\\tat java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\\n\\tat java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\\n\\tat java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)\\n\\tat java.net.Socket.connect(Socket.java:589)\\n\\tat org.apache.http.conn.scheme.PlainSocketFactory.connectSocket(PlainSocketFactory.java:121)\\n\\tat org.apache.http.impl.conn.DefaultClientConnectionOperator.openConnection(DefaultClientConnectionOperator.java:180)\\n\\tat org.apache.http.impl.conn.AbstractPoolEntry.open(AbstractPoolEntry.java:144)\\n\\tat org.apache.http.impl.conn.AbstractPooledConnAdapter.open(AbstractPooledConnAdapter.java:134)\\n\\tat org.apache.http.impl.client.DefaultRequestDirector.tryConnect(DefaultRequestDirector.java:610)\\n\\tat org.apache.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:445)\\n\\tat org.apache.http.impl.client.AbstractHttpClient.doExecute(AbstractHttpClient.java:835)\\n\\tat org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)\\n\\tat org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:108)\\n\\tat org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)\\n\\tat org.keycloak.adapters.ServerRequest.invokeAccessCodeToToken(ServerRequest.java:111)\\n\\tat org.keycloak.adapters.OAuthRequestAuthenticator.resolveCode(OAuthRequestAuthenticator.java:336)\\n\\tat org.keycloak.adapters.OAuthRequestAuthenticator.authenticate(OAuthRequestAuthenticator.java:281)\\n\\tat org.keycloak.adapters.RequestAuthenticator.authenticate(RequestAuthenticator.java:139)\\n\\tat org.keycloak.adapters.tomcat.AbstractKeycloakAuthenticatorValve.authenticateInternal(AbstractKeycloakAuthenticatorValve.java:203)\\n\\tat org.keycloak.adapters.tomcat.KeycloakAuthenticatorValve.authenticate(KeycloakAuthenticatorValve.java:50)\\n\\tat org.keycloak.adapters.tomcat.KeycloakAuthenticatorValve.doAuthenticate(KeycloakAuthenticatorValve.java:57)\\n\\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:575)\\n\\tat org.keycloak.adapters.tomcat.AbstractKeycloakAuthenticatorValve.invoke(AbstractKeycloakAuthenticatorValve.java:181)\\n\\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140)\\n\\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81)\\n\\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87)\\n\\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)\\n\\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:800)\\n\\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)\\n\\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:800)\\n\\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1471)\\n\\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\\n\\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\\n\\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\\n\\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\\n\\tat java.lang.Thread.run(Thread.java:748)\\n','app':'testclient','version':'1.0.0-SNAPSHOT'} </code></pre>  <p>I can't figure out how to solve this...</p>  <p>EDIT 1:  One more information: I'm running docker on Windows.</p>  <p><strong>EDIT 2: A SOLUTION</strong></p>  <p>My Working solution contains following:</p>  <ol> <li>Step, add keycloak as hosts</li> </ol>  <blockquote>   <p>To make things work, you\u2019ll need to make sure to add the following to your hosts file (/etc/hosts on Mac/Linux, c:\\Windows\\System32\\Drivers\\etc\\hosts on Windows).</p>      <p>127.0.0.1 keycloak</p>      <p>This is because you will access your application with a browser on your machine (which name is localhost, or 127.0.0.1), but inside Docker it will run in its own container, which name is keycloak.</p> </blockquote>  <ol start='2'> <li>Step</li> </ol>  <p>Inner Docker port and published port needs to be same:</p>  <pre><code>services:   mysql:     image: mysql:5.7     container_name: mysql     volumes:       - mysql_data:/var/lib/mysql     environment:       MYSQL_ROOT_PASSWORD: root       MYSQL_DATABASE: keycloak       MYSQL_USER: keycloak       MYSQL_PASSWORD: password     networks:       - testNetwork    keycloak:     image: jboss/keycloak     container_name: keycloak     restart: on-failure     volumes:       - ./config:/config/     environment:       DB_VENDOR: MYSQL       DB_ADDR: mysql       DB_DATABASE: keycloak       DB_USER: keycloak       DB_PASSWORD: password       KEYCLOAK_USER: xxx       KEYCLOAK_PASSWORD: yyy       KEYCLOAK_IMPORT_REALM: /keycloak/import/realm-import.json     ports:       - 8080:8080   &lt;--- edited     depends_on:       - mysql     networks:       - testNetwork </code></pre>  <p>Step 3: keycloak definition in application.yml for Spring boot edited auth-server-url:</p>  <pre><code>    keycloak:   realm: SpringBootKeycloak   auth-server-url: http://keycloak:8080/auth   &lt;--- edited   resource: testclient   public-client: true   security-constraints:     - authRoles:       - user       securityCollections:         - patterns:           - /*   ssl-required: external   confidential-port: 0 </code></pre>  <p>The ugly thing coming with this solution: You cant map your Docker Port onto another port to access from url.   ports:      - 8080:8080 i spend a lot of time testing other combinations, with the result that the access url port has to be the same as inner docker port (8080 in my case).</p>  <p>EDIT 4:</p>  <p><strong><em>Same thing is working with Thorntail.</em></strong></p>  <p>To change the port for Keycloak add...</p>  <pre><code>environment:   JAVA_OPTS: '-Djboss.socket.binding.port-offset=10 -Xms64m -Xmx512m -XX:MetaspaceSize=96M -XX:MaxMetaspaceSize=256m   -Djava.net.preferIPv4Stack=true -Djboss.modules.system.pkgs=org.jboss.byteman -Djava.awt.headless=true' </code></pre>  <p>... for keycloak in docker-compose. -Djboss.socket.binding.port-offset=10 sets default port (8080) + offset (10) The rest are default values for keycloak. Don't forget to edit 'ports' and 'auth-server-url'</p> ",
    "OwnerUserId": "11091154",
    "LastEditorUserId": "11091154",
    "LastEditDate": "2018-08-17T13:22:40.160",
    "LastActivityDate": "2023-03-03T13:44:01.373",
    "Title": "Docker (Spring Boot or Thorntail) and Keycloak",
    "Tags": "<java><docker><spring-boot><keycloak><thorntail>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>I think your problem is <code>auth-server-url: http://localhost:8180/auth</code>. That <code>localhost</code> effectively has a different meaning when your app is running inside a docker container.</p> <p>Inside the container it needs to be the name of the container i.e. <code>keycloak</code>. This is a bit awkward as when you connect to keycloak from your host machine you'd want to use <code>localhost</code> but the token issuer url needs to match to the url on which the token was requested (otherwise the token is rejected) so you end up having to put <code>keycloak</code> into your etc/hosts file.</p> <p>You are in good company with this problem - I've encountered this <a href='https://github.com/Activiti/activiti-cloud-examples/tree/7-201712-EA' rel='noreferrer'>working with Activiti</a>. And you can find the <a href='https://www.jhipster.tech/docker-compose/#7' rel='noreferrer'>JHipster project dealing with it in the same way</a> - they say:</p> <blockquote> <p>To make things work, you\u2019ll need to make sure to add the following to your hosts file (<code>/etc/hosts</code> on Mac/Linux, <code>c:\\Windows\\System32\\Drivers\\etc\\hosts</code> on Windows).</p> <p><code>127.0.0.1 keycloak</code></p> <p>This is because you will access your application with a browser on your machine (which name is <code>localhost</code>, or <code>127.0.0.1</code>), but inside Docker it will run in its own container, which name is <code>keycloak</code>.</p> </blockquote> ",
    "highest_rated_answer": "<p>Thank you for the question and the answer! I was struggling with this for quite sometime and getting connection refused error. The reason was because I was mapping 8180:8080, and as soon as I mapped <strong>8080:8080</strong> everything started working! Thanks again!</p> "
  },
  {
    "Id": "51929777",
    "PostTypeId": "1",
    "AcceptedAnswerId": "51930037",
    "CreationDate": "2018-08-20T11:26:59.097",
    "Score": "6",
    "ViewCount": "15685",
    "Body": "<p>Reading a classpath resource as,</p>  <pre><code>    try {         final ClassPathResource classPathResource = new ClassPathResource(format('location%sGeoLite2-City.mmdb', File.separator));         final File database = classPathResource.getFile();         dbReader = new DatabaseReader.Builder(database).build();     } catch (Exception e) {         System.out.println('Exception: ' + e);     } </code></pre>  <p>I've packaged this with docker using following Dockerfile,</p>  <pre><code>FROM java:8 ADD build/libs/*.jar App.jar CMD java -jar App.jar </code></pre>  <p>But while running this application as <strong>docker run -p 8080:8080 app-image</strong> I can hit the application endpoint and from application logs I can see it fails to read this file (following is from logs),</p>  <pre><code>Exception: java.io.FileNotFoundException: class path resource [location/GeoLite2-City.mmdb] cannot be resolved to absolute file path because it does not reside in the file system: jar:file:/App.jar!/BOOT-INF/classes!/location/GeoLite2-City.mmdb </code></pre>  <p>Would appreciate any comment, Things to know before you comment,</p>  <p>**- Running on windows 10, intellij 2018.2, jdk 8<br>  - Can run application successfully with intellij as well as command line  - File exists in jar (I did extract jar and checked ) **</p> ",
    "OwnerUserId": "1446358",
    "LastEditorUserId": "1446358",
    "LastEditDate": "2018-08-20T21:06:30.773",
    "LastActivityDate": "2022-04-17T09:19:43.987",
    "Title": "Docker: Can't read class path resource from spring boot application",
    "Tags": "<docker><spring-boot><java-8><windows-10><dockerfile>",
    "AnswerCount": "3",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>It is not a good approach to use slashes.</p>  <p>Always use File Seperators as they work irrespective of System OS.</p>  <p>Change </p>  <pre><code>(location\\\\GeoLite2-City.mmdb) </code></pre>  <p>to</p>  <pre><code>('location'+ File.separator +'GeoLite2-City.mmdb') </code></pre>  <p>Refer this for more.</p>  <p><a href='https://www.journaldev.com/851/java-file-separator-separatorchar-pathseparator-pathseparatorchar' rel='nofollow noreferrer'>https://www.journaldev.com/851/java-file-separator-separatorchar-pathseparator-pathseparatorchar</a></p>  <p><a href='https://stackoverflow.com/questions/2417485/difference-between-file-separator-and-slash-in-paths'>Difference between File.separator and slash in paths</a></p> ",
    "highest_rated_answer": "<p>Since you are using springboot you can try to use the following annotation for loading your classpath resource. Worked for me because I had the same exception. Be aware that the directory 'location' must be under the <code>src/main/resources</code> folder:</p>  <pre><code>@Value('classpath:/location/GeoLite2-City.mmdb') private Resource geoLiteCity; </code></pre>  <p>Without springboot you could try:</p>  <pre><code>try (InputStream inputStream = getClass().getClassLoader().getResourceAsStream('/location/GeoLite2-City.mmdb')) { ... //convert to file and other stuff } </code></pre>  <p>Also the answers before were correct as the use of '/' is not good at all and <code>File.separator</code> would be the best choice.</p> "
  },
  {
    "Id": "52265028",
    "PostTypeId": "1",
    "AcceptedAnswerId": "53190424",
    "CreationDate": "2018-09-10T20:28:44.570",
    "Score": "6",
    "ViewCount": "3489",
    "Body": "<p>I have a docker image running on Google Compute Engine. The image contains a Spring Boot application running on port 9000.</p>  <p>It is exposes on <code>http://&lt;ip&gt;:9000</code> and I can access is without any problems. I am trying to configure the exposed port to be <code>80</code> in order to configure DNS record to point just to the IP address.</p>  <p>My question is how to achieve that because the documentation left me confused. I am using the online GCP console (web interface) for the deployment and there is no field to specify <code>docker run -p 9000:80</code> command which would solve my issue (if there is, please correct me).</p>  <p>So do I need to remap the port in the Spring Boot settings? Or inside the Docker container? Or am I suppose to configure some forwarding rules in GCP? Thanks for the clarification!</p>  <p>My <code>DOCKER</code> file looks as follows:</p>  <pre><code>FROM gcr.io/distroless/java VOLUME /tmp ADD build/libs/*.jar app.jar ENV JAVA_OPTS='' ENTRYPOINT ['java','-jar','app.jar'] </code></pre>  <p>I am using the Container optimized OS from GCP.</p> ",
    "OwnerUserId": "1262024",
    "LastEditorUserId": "1262024",
    "LastEditDate": "2018-09-10T21:11:23.307",
    "LastActivityDate": "2020-03-11T16:43:16.470",
    "Title": "Mapping ports in Compute Engine with Docker",
    "Tags": "<docker><spring-boot><google-cloud-platform><google-compute-engine>",
    "AnswerCount": "4",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>I solved my issue by mapping the Spring Boot port to port 80 in the production profile.</p>  <p>This allows me to map the DNS records to raw IP address without having to do any extra configuration.</p> ",
    "highest_rated_answer": "<p>tldr : you can't</p>  <p>When you deploy a container in compute engine in this way, docker network is in <code>host network mode</code>, which means that (<a href='https://cloud.google.com/compute/docs/containers/configuring-options-to-run-containers#publishing_container_ports' rel='nofollow noreferrer'>doc</a>) : <code>a container shares the host's network stack and all interfaces from the host are available to the container.</code></p>  <p>So compute engine will directly expose container port, on his own interface. So you have to configure your container to expose correct port.</p> "
  },
  {
    "Id": "52375789",
    "PostTypeId": "1",
    "AcceptedAnswerId": "52793937",
    "CreationDate": "2018-09-17T21:15:03.683",
    "Score": "6",
    "ViewCount": "3089",
    "Body": "<p>I have a Spring Boot application that is running on 9000 port locally (not in container). The application has configured actuator with Prometheus micrometer and the whole stats is available by URL localhost:9000/actuator/prometheus.</p>  <p>I run Prometheus in Docker container using the following command:</p>  <pre><code>docker run --name spring_boot_prometheus -p 9090:9090 -p 9000:9000 -v /Users/xyz/docker/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus </code></pre>  <p><strong>prometheus.yml</strong></p>  <pre><code>global:   scrape_interval:     5s   evaluation_interval: 5s scrape_configs: - job_name: 'users-app'   metrics_path: '/actuator/prometheus'   static_configs:   - targets: ['localhost:9000'] </code></pre>  <p>The command <code>docker ps</code> returns the following:</p>  <pre><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                            NAMES 1568ec9e8353        prom/prometheus     '/bin/prometheus --c\u2026'   10 seconds ago      Up 9 seconds        0.0.0.0:9000-&gt;9000/tcp, 0.0.0.0:9090-&gt;9090/tcp   spring_boot_prometheus </code></pre>  <p>The UI says that prometheus can't connect to spring boot endpoint but it's available. If I click on endpoint it redirects me to <code>1568ec9e8353:9000</code> instead of <code>localhost:9000</code> <a href='https://i.stack.imgur.com/sYcwd.png' rel='noreferrer'><img src='https://i.stack.imgur.com/sYcwd.png' alt='enter image description here'></a></p>  <p>How can I fix the problem?</p>  <p>Appreciate for your help!</p> ",
    "OwnerUserId": "5651359",
    "LastEditorUserId": "5651359",
    "LastEditDate": "2018-09-18T12:49:25.227",
    "LastActivityDate": "2018-11-08T10:06:33.140",
    "Title": "Prometheus in Docker container can't reach Spring Boot application",
    "Tags": "<docker><spring-boot><prometheus>",
    "AnswerCount": "2",
    "CommentCount": "2",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>In <strong>prometheus.yml</strong>, instead of <code>localhost:9000</code> put the specific name of the container: <code>spring_boot_prometheus:9000</code>.</p>  <p><strong><em>Docker best practice</em></strong> is to use container names instead of container IP addresses.</p> ",
    "highest_rated_answer": "<p>For the prometheus docker container 'localhost' means local. So prometheus tries to connect within the container to port 9000. This will not work.</p>  <p>Also, within the prometheus container does not run a service on port 9000 as far as I can know from your post.</p>  <p><strong>If both apps are in a docker container:</strong></p>  <p>The target container has it's own IP address within your docker installation. Typically 172.17.y.z. </p>  <p>A simple docker network is necessary and after that you run both you containers with that:</p>  <pre><code>$ docker network create mynet  $ docker run --name foo --net mynet img  $ docker run --name bar --net mynet img </code></pre>  <p>Found here: <a href='https://forums.docker.com/t/how-to-reach-a-container-from-another-container-without-ip-of-dockernat/21083/3' rel='nofollow noreferrer'>forums.docker.com</a></p>  <p><strong>If you have the service (9000) running on your machine without docker:</strong></p>  <blockquote>   <p>This is not a standard use case</p> </blockquote>  <p>Read <a href='https://forums.docker.com/t/accessing-host-machine-from-within-docker-container/14248/5' rel='nofollow noreferrer'>here</a> how to set this up.</p>  <p>You have to obtain the IP address of your physical computer. For example 192.168.0.10. This is then the target for prometheus. </p> "
  },
  {
    "Id": "52630362",
    "PostTypeId": "1",
    "CreationDate": "2018-10-03T15:16:21.517",
    "Score": "6",
    "ViewCount": "3873",
    "Body": "<p>Currently I have the following in a datasource.properties file to connect to the datasource locally...</p>  <pre><code>//datasource.properties spring.datasource.password=${DB_PASSWORD} </code></pre>  <p>This worked great for local but now I am trying to create a docker image. To store the data I would rather use a secret than an environment variable (Or maybe even the secret then the env var where not found). I have the secret currently set up in my local docker image but I can't figure out how to set the spring.datasource.password using code instead of the properties.</p>  <p>How would I set 'spring.datasource.password' using a docker secret?</p> ",
    "OwnerUserId": "125212",
    "LastEditorUserId": "125212",
    "LastEditDate": "2018-10-03T15:28:01.550",
    "LastActivityDate": "2022-09-25T13:41:25.593",
    "Title": "How would I set 'spring.datasource.password' using a docker secret?",
    "Tags": "<spring><docker><spring-boot><spring-data-jpa><docker-secrets>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>With the help of a <a href='https://github.com/kwonghung-YIP/spring-boot-docker-secret' rel='nofollow noreferrer'>customized implementation</a> of the EnvironmentPostProcessor interface, the 'spring.datasource.password' can be set as following in application.yml</p>  <pre><code>   spring:      datasource:        password: ${docker-secret-my-db-passwd} </code></pre>  <p>The docker secrets bind within the container are presented as files under the /run/secrets folder. The EnvironmentPostProcessor implementation load these file as the environment properties.</p>  <p>The idea has also been introduced in <a href='https://docs.spring.io/spring-boot/docs/2.1.4.RELEASE/reference/htmlsingle/#howto-customize-the-environment-or-application-context' rel='nofollow noreferrer'>Spring boot reference - Encrypted Properties</a></p> "
  },
  {
    "Id": "52851274",
    "PostTypeId": "1",
    "CreationDate": "2018-10-17T09:15:15.473",
    "Score": "6",
    "ViewCount": "993",
    "Body": "<p>I have a SpringBoot app and I want to conncct to rabbit mq and read some messages. However I do have an issue that when I deploy the app, sometimes it connects to rabbit instantly and starts working but more often It only tries to connect and tries and finally I recive timeout exception just like that:</p>  <pre><code>2018-10-17 09:03:54.460 ERROR 15 --- [ main] o.s.a.r.l.SimpleMessageListenerContainer : Consumer failed to start in 60000 milliseconds; does the task executor have enough threads to support the container concurrency? </code></pre>  <p>I use AWS ECS so my app is running in docker container. Could it be related ?</p>  <p>Here is my configuration where all those environment variables are valid</p>  <pre><code>spring.rabbitmq.host=${RABBIT_HOST} spring.rabbitmq.port=${RABBIT_PORT} spring.rabbitmq.username=${RABBIT_USERNAME} spring.rabbitmq.password=${RABBIT_PASSWORD} spring.rabbitmq.virtualHost=${RABBIT_HOST} rabbitmq.queues=myQueue </code></pre>  <p>And my code</p>  <pre><code>@Component @Slf4j @RequiredArgsConstructor final class ListingMessageListener {      private final BackOfficeService backOfficeService;      @RabbitListener(queues = '${rabbitmq.queues}')     public void receiveMessage(final ListingMessage listingMessage) {         final String listingId = listingMessage.getMessage().getListingId();         log.info('Received listingId= {}', listingId);             Optional.ofNullable(backOfficeService.getOfferById(Long.valueOf(listingId))).ifPresent(offer -&gt; log.info(offer.getName()));      } } </code></pre> ",
    "OwnerUserId": "10088866",
    "LastActivityDate": "2018-10-17T09:15:15.473",
    "Title": "SpringBoot AMPQ on Docker cannot always connect to the queue",
    "Tags": "<java><docker><spring-boot><rabbitmq><spring-amqp>",
    "AnswerCount": "0",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": null
  },
  {
    "Id": "52892488",
    "PostTypeId": "1",
    "AcceptedAnswerId": "52942964",
    "CreationDate": "2018-10-19T12:37:00.097",
    "Score": "6",
    "ViewCount": "2290",
    "Body": "<p>I'm trying to build/deploy a spring boot in a docker container.</p>  <pre><code>FROM maven:3.5.3-jdk-8-slim AS build COPY ./pom.xml /app/pom.xml RUN cd /app RUN mvn -f /app/pom.xml -s /usr/share/maven/ref/settings-docker.xml dependency:go-offline dependency:resolve-plugins -B COPY . /app RUN mvn -f /app/pom.xml -s /usr/share/maven/ref/settings-docker.xml --batch-mode package -DskipTests </code></pre>  <p>As you can see, I'm caching all dependencies with the first mvn command so that every change in my code app will not trigger a new bulk of dependencies downloads. It works for most of the dependencies but some are still downloaded (even if cached). This is the log of the second mvn command (package):</p>  <pre><code>[INFO] Scanning for projects... [INFO]  [INFO] ----------------------&lt; xxx:xxx &gt;---------------------- [INFO] Building xxxx 0.0.0 [INFO] --------------------------------[ jar ]--------------------------------- [INFO]  [INFO] --- apt-maven-plugin:1.1.3:process (default) @ vsol-java --- [INFO] Downloading from spring-releases: https://repo.spring.io/libs-release/org/apache/commons/commons-io/1.3.2/commons-io-1.3.2.pom [INFO] Downloaded from spring-releases: https://repo.spring.io/libs-release/org/apache/commons/commons-io/1.3.2/commons-io-1.3.2.pom (0 B at 0 B/s) [INFO] Downloading from spring-releases: https://repo.spring.io/libs-release/commons-io/commons-io/1.3.2/commons-io-1.3.2.pom [INFO] Downloaded from spring-releases: https://repo.spring.io/libs-release/commons-io/commons-io/1.3.2/commons-io-1.3.2.pom (0 B at 0 B/s) [INFO] Downloading from spring-releases: https://repo.spring.io/libs-release/org/apache/commons/commons-parent/3/commons-parent-3.pom [INFO] Downloaded from spring-releases: https://repo.spring.io/libs-release/org/apache/commons/commons-parent/3/commons-parent-3.pom (0 B at 0 B/s) [INFO] Downloading from spring-releases: https://repo.spring.io/libs-release/org/sonatype/plexus/plexus-build-api/0.0.7/plexus-build-api-0.0.7.jar ... </code></pre>  <p>(BTW, the (0 B at 0 B/s) is a little bit strange...just a check?)</p>  <p>If I launch a container based on the step after the first maven command (mvn dependency:...) (the one that should cached all dependencies) </p>  <pre><code>root@3281a837a236:/usr/share/maven/ref/repository# ls -lh org/codehaus/plexus/plexus-utils/1.5.15 total 244K -rw-r--r-- 1 root root  202 Oct 19 12:07 _remote.repositories -rw-r--r-- 1 root root 223K Oct 19 12:07 plexus-utils-1.5.15.jar -rw-r--r-- 1 root root   40 Oct 19 12:07 plexus-utils-1.5.15.jar.sha1 -rw-r--r-- 1 root root 6.7K Oct 19 12:07 plexus-utils-1.5.15.pom -rw-r--r-- 1 root root   40 Oct 19 12:07 plexus-utils-1.5.15.pom.sha1 </code></pre>  <p>The lib seems to be there but, I can see this in the log from mvn package:</p>  <p>[INFO] Downloading from spring-releases: <a href='https://repo.spring.io/libs-release/org/codehaus/plexus/plexus-utils/1.5.15/plexus-utils-1.5.15.jar' rel='noreferrer'>https://repo.spring.io/libs-release/org/codehaus/plexus/plexus-utils/1.5.15/plexus-utils-1.5.15.jar</a></p>  <p>If I run mvn package in offline mode, it fails because it can't reach <a href='https://repo.spring.io/libs-release' rel='noreferrer'>https://repo.spring.io/libs-release</a>.</p>  <p>So it looks like it is cached but maven still try to download this file. I've tried this in my pom.xml</p>  <pre><code>        &lt;pluginRepository&gt;             &lt;id&gt;spring-releases&lt;/id&gt;             &lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt;             &lt;snapshots&gt;                 &lt;enabled&gt;true&lt;/enabled&gt;                 &lt;updatePolicy&gt;never&lt;/updatePolicy&gt;             &lt;/snapshots&gt;             &lt;releases&gt;                 &lt;enabled&gt;true&lt;/enabled&gt;                 &lt;updatePolicy&gt;never&lt;/updatePolicy&gt;             &lt;/releases&gt;         &lt;/pluginRepository&gt; </code></pre>  <p>But no effect.</p>  <p>Any idea? Thanks!</p> ",
    "OwnerUserId": "2813807",
    "LastEditorUserId": "2813807",
    "LastEditDate": "2018-10-19T12:43:47.393",
    "LastActivityDate": "2018-10-23T06:59:56.110",
    "Title": "Maven/Docker: cache all dependencies",
    "Tags": "<maven><docker><spring-boot>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>I finally find the solution by using go-offline-maven-plugin.</p>  <pre><code>         &lt;plugin&gt;             &lt;groupId&gt;de.qaware.maven&lt;/groupId&gt;             &lt;artifactId&gt;go-offline-maven-plugin&lt;/artifactId&gt;             &lt;version&gt;1.0.0&lt;/version&gt;             &lt;configuration&gt;                 &lt;dynamicDependencies&gt;                     &lt;DynamicDependency&gt;                         &lt;groupId&gt;org.apache.maven.surefire&lt;/groupId&gt;                         &lt;artifactId&gt;surefire-junit4&lt;/artifactId&gt;                         &lt;version&gt;2.20.1&lt;/version&gt;                         &lt;repositoryType&gt;PLUGIN&lt;/repositoryType&gt;                     &lt;/DynamicDependency&gt;                 &lt;/dynamicDependencies&gt;             &lt;/configuration&gt;         &lt;/plugin&gt; </code></pre>  <p>And trying to get all dependencies using:</p>  <pre><code>mvn de.qaware.maven:go-offline-maven-plugin:resolve-dependencies </code></pre> ",
    "highest_rated_answer": null
  },
  {
    "Id": "52993672",
    "PostTypeId": "1",
    "CreationDate": "2018-10-25T16:04:28.760",
    "Score": "6",
    "ViewCount": "793",
    "Body": "<p>I have a spring boot service running in a docker container. I am using HttpServletRequest to get the remote IP address from incoming client request. This works as intended locally but once the service is running in a Docker container the IP that is grab is the Docker container IP instead of the clients IP. Is there a way to get around this and get the actual client IP? Any help would be most appreciated.</p>  <p>Here's more programmatic detail:</p>  <pre><code>@GetMapping('/foo) public ResponseEntity requestBar(HttpServletRequest request) {     String clientIp = request.getRemoteAddr();     //DO STUFF WITH IP } </code></pre>  <p>Above is an example GET request for 'bar'. Using HttpServletRequest you can get the remote address of the machine making the request. Running this locally (on a local machine non dockerized) the above works perfectly. The service obtains the client IP and I can verify that the IP is correct. Hosting the same service in Docker, calling getRemoteAddr() will give the containers default gateway IP. I hope this further explanation provides more clarity of what I'm trying to accomplish. As always, any and all help will be most appreciated.</p>  <p>UPDATE: Just clarify a few tidbits, the Spring Boot(v1.5.13) service runs on a Docker Host (Docker version 18.06.1-ce, build e68fc7a). What I mean by running locally is when I am starting up the service on my local machine during development. I use the latest version of Intellij for all my Java dev work. The service can be spun up using Intellij on my development machine.</p> ",
    "OwnerUserId": "4659255",
    "LastEditorUserId": "4659255",
    "LastEditDate": "2018-10-26T13:12:09.467",
    "LastActivityDate": "2020-09-28T10:59:54.620",
    "Title": "Spring Boot v1.5.13 Docker: Getting Docker IP instead of Client IP From Request",
    "Tags": "<docker><spring-boot>",
    "AnswerCount": "0",
    "CommentCount": "1",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": null
  },
  {
    "Id": "53089486",
    "PostTypeId": "1",
    "AcceptedAnswerId": "53093678",
    "CreationDate": "2018-10-31T18:00:47.703",
    "Score": "6",
    "ViewCount": "9229",
    "Body": "<p>I'm running kafka locally via:</p>  <p>docker-compose.yml</p>  <pre><code>  zookeeper:     image: 'bitnami/zookeeper:latest'     ports:       - 2181:2181     environment:       - ALLOW_ANONYMOUS_LOGIN=yes   kafka:     image: 'bitnami/kafka:latest'     ports:       - 9092:9092     environment:       - KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181       - ALLOW_PLAINTEXT_LISTENER=yes       - KAFKA_ADVERTISED_PORT=9092       - KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://localhost:9092 </code></pre>  <p>My Spring Boot application is run with:</p>  <p>application.yml:</p>  <pre><code>spring:   application:     name: testkafka   kafka:     bootstrap-servers: localhost:9092  server:   port: 8080 </code></pre>  <p>When I run it and it tries to send to a topic on kafka, I get:</p>  <pre><code>org.springframework.kafka.KafkaException: Reply timed out     at org.springframework.kafka.requestreply.ReplyingKafkaTemplate.lambda$sendAndReceive$0(ReplyingKafkaTemplate.java:196) ~[spring-kafka-2.1.10.RELEASE.jar:2.1.10.RELEASE]     at org.springframework.scheduling.support.DelegatingErrorHandlingRunnable.run(DelegatingErrorHandlingRunnable.java:54) ~[spring-context-5.0.10.RELEASE.jar:5.0.10.RELEASE]     at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515) ~[na:na]     at java.base/java.util.concurrent.FutureTask.run$$$capture(FutureTask.java:264) ~[na:na]     at java.base/java.util.concurrent.FutureTask.run(FutureTask.java) ~[na:na]     at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304) ~[na:na]     at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) ~[na:na]     at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) ~[na:na]     at java.base/java.lang.Thread.run(Thread.java:834) ~[na:na] </code></pre>  <p>If I run the spring boot from inside a docker container (using one docker compose file), then it <em>does</em> work:</p>  <p>Running Both in the Same Compose:</p>  <pre><code>version: '3.0' services:   service1:     build: ./Service     ports:       - 8080:8080       - 5005:5005     links:       - zookeeper       - kafka   zookeeper:     image: 'bitnami/zookeeper:latest'     ports:       - 2181:2181     environment:       - ALLOW_ANONYMOUS_LOGIN=yes   kafka:     image: 'bitnami/kafka:latest'     ports:       - 9092:9092     environment:       - KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181       - ALLOW_PLAINTEXT_LISTENER=yes       - KAFKA_ADVERTISED_PORT=9092       - KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://localhost:9092 </code></pre>  <p>How can I get the kafka container to allow connections from outside itself/docker?</p>  <p><strong>EDIT: Tried these changes:</strong></p>  <pre><code>kafka:   image: 'bitnami/kafka:latest'   ports:     - 9092:9092   environment:     - KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181     - ALLOW_PLAINTEXT_LISTENER=yes     - KAFKA_ADVERTISED_PORT=9092     - KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://kafka:9092 </code></pre>  <p>and:</p>  <pre><code>spring:   application:     name: testkafka   kafka:     bootstrap-servers: kafka:9092  server:   port: 8080 </code></pre>  <p>This still times out</p> ",
    "OwnerUserId": "857025",
    "LastEditorUserId": "2308683",
    "LastEditDate": "2018-11-01T16:46:30.220",
    "LastActivityDate": "2021-02-11T18:00:21.373",
    "Title": "Unable to connect to Kafka run in container from Spring Boot app run outside container",
    "Tags": "<java><docker><spring-boot><apache-kafka><spring-kafka>",
    "AnswerCount": "1",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ClosedDate": "2022-10-18T07:34:11.593",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<blockquote> <p>If I run the spring boot from inside a docker container (using one docker compose file), then it does work</p> </blockquote> <p>It shouldn't work, actually. Kafka isn't running as part of the application, so this section is not pointing at the Kafka container.</p> <pre><code>kafka:     bootstrap-servers: localhost:9092 </code></pre> <p>It would need to be <code>kafka:9092</code> within the Docker network.</p> <blockquote> <p>and ... <code>bootstrap-servers: kafka:9092</code> ... still times out</p> </blockquote> <p>That's because you still have <code>KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://localhost:9092</code></p> <hr /> <p>Both inside and outside of Docker network, by specifying <code>KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://localhost:9092</code>, you're saying that your clients receive the Kafka bootstrap connection as <code>localhost:9092</code>, which would work outside of the Docker network only because you have made both a port forwarding and your container is running on localhost, however, inside the Docker network, as mentioned, localhost would mean <em>that</em> application container, not the broker.</p> <p>The solution would be to create two port mappings via that property, as discussed in length by <a href='https://rmoff.net/2018/08/02/kafka-listeners-explained/' rel='nofollow noreferrer'>this blog post</a></p> <p>Plus, <a href='https://github.com/confluentinc/cp-docker-images/blob/5.0.0-post/examples/cp-all-in-one/docker-compose.yml' rel='nofollow noreferrer'>Confluent provides a fully configured Docker Compose</a> with appropriate mappings that'll work inside and out of Docker</p> <pre class='lang-yaml prettyprint-override'><code>    ports:       - &quot;9092:9092&quot;       - &quot;29092:29092&quot;     environment:       KAFKA_BROKER_ID: 1       KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'       ALLOW_PLAINTEXT_LISTENER: &quot;yes&quot;       KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT       KAFKA_LISTENERS: PLAINTEXT://:9092,PLAINTEXT_HOST://0.0.0.0:29092       KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092,PLAINTEXT_HOST://localhost:29092 </code></pre> <p>For applications within Docker network, use <code>kafka:9092</code>, for applications outside, use <strong><code>localhost:29092</code></strong></p> <p><strong>EDIT</strong> The bitnami config variables have changed. Refer this section of the README</p> <p><a href='https://github.com/bitnami/bitnami-docker-kafka/blob/master/README.md#accessing-kafka-with-internal-and-external-clients' rel='nofollow noreferrer'>https://github.com/bitnami/bitnami-docker-kafka/blob/master/README.md#accessing-kafka-with-internal-and-external-clients</a></p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "54713829",
    "PostTypeId": "1",
    "CreationDate": "2019-02-15T16:56:49.570",
    "Score": "6",
    "ViewCount": "1668",
    "Body": "<p>I have a Java application (oracle JDK 8u191) with SpringBoot version 2.1.1.RELEASE and I'm experiencing a weird memory usage (don't thinks this is related to spring).</p>  <p>The sum of the HEAP and NONHEAP values provided by the application is much lower the real memory usage reported by Docker.</p>  <p>I know that Java has others memory areas than HEAP and NONHEAP, but I don't know how to measure them and if the current behavior is normal.</p>  <p>Curently my applications is reporting the following (after 3 days running in production):</p>  <pre><code>           Init       Used       Committed       Max        HEAP:      250M       79M        250M            800M       NONHEAP:   2M         192M       201M            0M      </code></pre>  <p>The actuator endpoint <code>/metrics</code> for springBoot reports the same memory usage.</p>  <p>But the docker stats commands reports this (inside the container <code>smem</code> reports the same value for the java process):</p>  <pre><code>MEM USAGE / LIMIT 750.2MiB / 1.172GiB </code></pre>  <p>The difference between the heap+nonheap and the current used memory are <code>299,2mb</code>.</p>  <p>I was not expecting this 300mb the first time we put this service in production it caused a lot of OOM until we found the rigth configuration.</p>  <p>This 'unregistered memory usage' seems to only go up and never shrink, even after GC.</p>  <p>If I restart my aplication the difference between the heap+nonheap withe the real usage is about 100mb.</p>  <p>My Dockerfile starts the application this way:</p>  <p><code>ENTRYPOINT ['java', '-Xms250m', '-Xmx800m', '-XX:+UseG1GC', '-Djava.security.egd=file:/dev/./urandom', '-jar', '/app.jar']</code></p>  <p>I also have a scheduled rotine that runs <code>System.gc()</code> every hour to shrink back the commited memory because this service have small spikes over the day and I want unused memory to be free for another services.</p>  <p>I want to know if this behavior is normal. And how can I measure what is using so much memory? visualvm and jconsole only show the heap and nonheap. Seems there is no metrics in springBoot actuator to measure this too.</p>  <p>How much memory should I left free in my container for this type of usage? I couldn't find any helpful article about it.</p>  <p><strong>Edit1:</strong></p>  <p>After 7 days, the difference between (heap+nonheap)-total became 550mb, leaving my container without any memory left.</p>  <p><strong>Edit2:</strong></p>  <p>Things starting making sense after digging into this articles:</p>  <p><a href='https://stackoverflow.com/questions/47591343/java-process-memory-usage-deviation-from-jcmd-committed-memory?rq=1'>Java process memory usage deviation from jcmd committed memory</a></p>  <p><a href='https://stackoverflow.com/questions/44284911/where-do-these-java-native-memory-allocated-from'>Where do these java native memory allocated from?</a></p>  <p><a href='https://stackoverflow.com/questions/39684464/java-process-memory-usage-jcmd-vs-pmap'>Java process memory usage (jcmd vs pmap)</a></p>  <p>And indeed we are using a third party library with reports of memory leaks: <code>compile('axis:axis-wsdl4j:1.5.1')</code></p>  <p>I'll try upgrade to Axis2 and will post the results here.</p> ",
    "OwnerUserId": "9697259",
    "LastEditorUserId": "9697259",
    "LastEditDate": "2019-02-18T15:27:34.353",
    "LastActivityDate": "2019-02-18T15:27:34.353",
    "Title": "Java memory usage much higher than heap+nonheap",
    "Tags": "<java><spring-boot><docker><memory><heap-memory>",
    "AnswerCount": "0",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ClosedDate": "2019-03-11T13:04:56.300",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": null
  },
  {
    "Id": "55954588",
    "PostTypeId": "1",
    "AcceptedAnswerId": "64225753",
    "CreationDate": "2019-05-02T14:26:07.327",
    "Score": "6",
    "ViewCount": "1704",
    "Body": "<p>Currently running SpringBoot applications in a containerised environment (ECS) and I've observed scenarios in which the container gets terminated during start-up and while it's still holding the Liquibase changelock.</p>  <p>This leads to issues in all containers that are spun afterwards and ends up requiring manual intervention.</p>  <p><strong>Is it possible to ensure that if the process receives a SIGTERM, it will gracefully handle termination and release the lock?</strong></p>  <p>I've already ensured that the container is receiving the signals by enabling via InitProcessEnabled (in the CloudFormation template) and use of 'exec java ...' as a java agent we use does gracefully shutdown on this circumstances.</p> ",
    "OwnerUserId": "6800894",
    "LastActivityDate": "2021-02-15T23:13:33.230",
    "Title": "Ensuring spring boot and liquibase receive and handle SIGTERM",
    "Tags": "<java><spring-boot><docker><liquibase><amazon-ecs>",
    "AnswerCount": "1",
    "CommentCount": "4",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>Heyo,</p> <p>As mentioned in the GitHub issue I have a workaround. A solution is yet to be implemented.</p> <p>You can manually register a shutdown hook before running spring boot.. That hook should assure that the Termination is postponed until liquibase is done.</p> <pre class='lang-java prettyprint-override'><code>package dang;  import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.builder.SpringApplicationBuilder; import org.springframework.data.jpa.repository.config.EnableJpaRepositories;   @EnableJpaRepositories @SpringBootApplication public class DangApplication {   public static void main(String[] args) throws InterruptedException {     Thread thread = new GracefulShutdownHook();     Runtime.getRuntime().addShutdownHook(thread);      new SpringApplicationBuilder(DangApplication.class)             .registerShutdownHook(true)             .logStartupInfo(true)             .build()             .run();     Runtime.getRuntime().removeShutdownHook(thread);   } }  </code></pre> <p>And the hook:</p> <pre class='lang-java prettyprint-override'><code>package dang;  import lombok.SneakyThrows; import lombok.extern.slf4j.Slf4j;  import java.util.Map;  @Slf4j public class GracefulShutdownHook extends Thread {   @SneakyThrows   @Override   public void run() {       super.run();     log.info(&quot;Shutdown Signal received.. Searching for Liquibase instances!&quot;);     boolean liquibaseIsRunning = true;     while (liquibaseIsRunning) {        Map&lt;Thread,StackTraceElement[]&gt; stackTraces = Thread.getAllStackTraces();       for(Map.Entry&lt;Thread, StackTraceElement[]&gt; entry : stackTraces.entrySet()) {         StackTraceElement[] stackTraceElements = entry.getValue();         for (StackTraceElement stackTraceElement : stackTraceElements) {           if (stackTraceElement.getClassName().contains(&quot;liquibase&quot;) &amp;&amp; stackTraceElement.getMethodName().contains(&quot;update&quot;)) {             try {               log.warn(&quot;Liquibase is currently updating&quot;);               entry.getKey().join();               liquibaseIsRunning = false;             } catch (InterruptedException e) {               log.error(&quot;Shutdown Hook was interrupted.. Fatal databaselock may be imminent&quot;, e);               if (Thread.interrupted()) {                 throw e;               }             }           }         }       }     }   } } </code></pre> <p><strong>EDIT</strong></p> <p>After implementing my workaround a contributor of liquibase shared a different solution (It's actually the same solution just through Spring functionality) which is much better than what I did:</p> <pre class='lang-java prettyprint-override'><code>package dang;  import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.builder.SpringApplicationBuilder; import org.springframework.data.jpa.repository.config.EnableJpaRepositories;   @EnableJpaRepositories @SpringBootApplication public class DangApplication {   public static void main(String[] args) throws InterruptedException {     new SpringApplicationBuilder(DangApplication.class)             .initializers(ConfigurableApplicationContext::registerShutdownHook) // Registers application hook before liquibase executes.             .logStartupInfo(true)             .build()             .run();   } }  </code></pre> ",
    "highest_rated_answer": null
  },
  {
    "Id": "57366246",
    "PostTypeId": "1",
    "AcceptedAnswerId": "57366462",
    "CreationDate": "2019-08-05T21:22:24.043",
    "Score": "6",
    "ViewCount": "5998",
    "Body": "<p>I\u2019m trying to build a Docker image from my DockerFile but  keep getting an error like it can't find the parent <code>pom.xml</code> to perform a maven command in the docker file and build the project. Ive been looking around and you see what people do is the add to the child <code>pom.xml</code> a reference to the parent pom.xml y tried adding a <code>relativePath&gt;.. /pom.xml/relativePath&gt;</code> to the child but still won't work.</p>  <h2>Maven-multimodule project</h2>  <p>[<img src='https://i.stack.imgur.com/koK4I.png' alt='project structure[1]'></p>  <h2>DockerFile</h2>  <pre><code>FROM alpine/git as clone WORKDIR /app RUN git clone https://github.com/RicardoVargasLeslie/manager.git  FROM openjdk:8-jdk-alpine as build WORKDIR /workspace/app  COPY mvnw . COPY .mvn .mvn COPY pom.xml . COPY src src  RUN ./mvnw install -DskipTests  ENTRYPOINT ['java','-jar','/Web-0.0.1-SNAPSHOT.jar'] </code></pre>  <h2>Child-pom.xml(Web)</h2>  <pre><code>&lt;project xmlns='http://maven.apache.org/POM/4.0.0'     xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'     xsi:schemaLocation='http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd'&gt;     &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;     &lt;parent&gt;         &lt;groupId&gt;com.imricki.manager&lt;/groupId&gt;         &lt;artifactId&gt;core&lt;/artifactId&gt;         &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;         &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt;     &lt;/parent&gt;     &lt;artifactId&gt;Web&lt;/artifactId&gt;     &lt;name&gt;Web&lt;/name&gt;     &lt;description&gt;Web Module&lt;/description&gt; </code></pre>  <h2>Parent-pom.xml(Core)</h2>  <pre><code>&lt;?xml version='1.0' encoding='UTF-8'?&gt; &lt;project xmlns='http://maven.apache.org/POM/4.0.0'     xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'     xsi:schemaLocation='http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd'&gt;     &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;     &lt;parent&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;         &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;         &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt;     &lt;/parent&gt;     &lt;groupId&gt;com.imricki.manager&lt;/groupId&gt;     &lt;artifactId&gt;core&lt;/artifactId&gt;     &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;     &lt;name&gt;Core&lt;/name&gt;     &lt;description&gt;Core Module&lt;/description&gt;     &lt;packaging&gt;pom&lt;/packaging&gt; </code></pre>  <h3>Docker comand to build image</h3>  <pre><code>docker build -t rest-api . </code></pre>  <h2>Comand-line Trace</h2>  <pre><code>$ docker build -t rest-api . Sending build context to Docker daemon  42.92MB Step 1/11 : FROM alpine/git as clone  ---&gt; a1d22e4b51ad Step 2/11 : WORKDIR /app  ---&gt; Using cache  ---&gt; e53f5b4941b5 Step 3/11 : RUN git clone https://github.com/RicardoVargasLeslie/manager.git  ---&gt; Using cache  ---&gt; 490b2afea22c Step 4/11 : FROM openjdk:8-jdk-alpine as build  ---&gt; a3562aa0b991 Step 5/11 : WORKDIR /workspace/app  ---&gt; Using cache  ---&gt; 0b7c106319e9 Step 6/11 : COPY mvnw .  ---&gt; Using cache  ---&gt; 2c7ab0b79d25 Step 7/11 : COPY .mvn .mvn  ---&gt; Using cache  ---&gt; eb9ec36b737a Step 8/11 : COPY pom.xml .  ---&gt; Using cache  ---&gt; 2296a5fbd6ae Step 9/11 : COPY src src  ---&gt; Using cache  ---&gt; 022a609f4376 Step 10/11 : RUN ./mvnw install -DskipTests  ---&gt; Running in 897cff2e3c3b [INFO] Scanning for projects... [ERROR] [ERROR] Some problems were encountered while processing the POMs: [FATAL] Non-resolvable parent POM for com.imricki.manager:Web:[unknown-version]: Could not find artifact com.imricki.manager:core:pom:0.0.1-SNAPSHOT and 'parent.relativePath' points at wrong local POM @ line 5, column 10  @ [ERROR] The build could not read 1 project -&gt; [Help 1] [ERROR] [ERROR]   The project com.imricki.manager:Web:[unknown-version] (/workspace/app/pom.xml) has 1 error [ERROR]     Non-resolvable parent POM for com.imricki.manager:Web:[unknown-version]: Could not find artifact com.imricki.manager:core:pom:0.0.1-SNAPSHOT and 'parent.relativePath' points at wrong local POM @ line 5, column 10 -&gt; [Help 2] [ERROR] [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch. [ERROR] Re-run Maven using the -X switch to enable full debug logging. [ERROR] [ERROR] For more information about the errors and possible solutions, please read the following articles: [ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/ProjectBuildingException [ERROR] [Help 2] http://cwiki.apache.org/confluence/display/MAVEN/UnresolvableModelException The command '/bin/sh -c ./mvnw install -DskipTests' returned a non-zero code: 1 </code></pre>  <p>I\u2019m  not sure what wron or how to make the build work,thanks for any help.</p> ",
    "OwnerUserId": "4814583",
    "LastActivityDate": "2023-07-04T07:32:10.747",
    "Title": "Non-resolvable parent POM on Docker Build",
    "Tags": "<java><maven><spring-boot><docker><pom.xml>",
    "AnswerCount": "2",
    "CommentCount": "4",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>Maven is a tool that enables a declarative way of managing your project's dependencies. It does that by standardising the way jar and pom files (artifacts) are shared by projects and uses maven coordinates to declare a project dependency (groupId, artifactId and version) which are then looked up in a large public maven repository of jar and pom files called Maven Central.</p>  <p>In order to have your jar/pom files (like your core for example) managed as a maven artifact, you need to deploy your artifact to either the Maven Central (public repository accessible by anyone) or a private repository some where in your private network (or even on the internet, and maybe with authentication). In the case of a private repository, you need to include the you private repository so that your maven execution not only looks for artifacts in Maven Central, but also in your private repository. You can achieve this by adding the following to your <code>settings.xml</code> file:</p>  <pre class='lang-xml prettyprint-override'><code>&lt;!-- Authentication here --&gt; &lt;servers&gt;   &lt;server&gt;       &lt;id&gt;nexus&lt;/id&gt;       &lt;username&gt;some_username&lt;/username&gt;       &lt;password&gt;some_passowrd&lt;/password&gt;     &lt;/server&gt; &lt;/servers&gt; ...  &lt;profiles&gt;     &lt;profile&gt;       &lt;id&gt;nexus&lt;/id&gt;       &lt;!--Override the repository (and pluginRepository) 'central' from the    Maven Super POM --&gt;       &lt;repositories&gt;         &lt;repository&gt;           &lt;id&gt;nexus-release&lt;/id&gt;           &lt;name&gt;nexus-release&lt;/name&gt;           &lt;url&gt;http://hostname_or_ip_address/content/repositories/releases&lt;/url&gt;         &lt;/repository&gt;         &lt;repository&gt;           &lt;id&gt;nexus-thirdparty&lt;/id&gt;           &lt;name&gt;nexus-thirdparty&lt;/name&gt;           &lt;url&gt;http://hostname_or_ip_address/content/repositories/thirdparty&lt;/url&gt;         &lt;/repository&gt;       &lt;/repositories&gt;       &lt;pluginRepositories&gt;         &lt;pluginRepository&gt;           &lt;id&gt;nexus-plugin-release&lt;/id&gt;           &lt;name&gt;nexus-plugin-release&lt;/name&gt;           &lt;url&gt;http://hostname_or_ip_address/content/repositories/releases/&lt;/url&gt;         &lt;/pluginRepository&gt;         &lt;pluginRepository&gt;           &lt;id&gt;nexus-plugin-third-party&lt;/id&gt;           &lt;name&gt;nexus-plugin-third-party&lt;/name&gt;           &lt;url&gt;http://hostname_or_ip_address/content/repositories/thirdparty/&lt;/url&gt;         &lt;/pluginRepository&gt;       &lt;/pluginRepositories&gt;     &lt;/profile&gt;   &lt;/profiles&gt; ... </code></pre>  <p>I noticed your child <code>pom.xml</code> file references a custom parent module. You need to make sure that your parent module is in a maven repository (Nexus/Artifactory) and that you supply a <code>settings.xml</code> file with the repository settings for the Docker container to be able to pull the parent pom.</p> ",
    "highest_rated_answer": "<p>In my case i was getting this due to the fact that apparently the Dockerfile instructions as copy can not see the parent folders !</p> <p>meaning if you have a structure :</p> <pre><code>ParentProject |  --&gt; Child Module A  --&gt; pom.xml --&gt; DockerFile |  --&gt; Child Module B   --&gt; pom.xml --&gt; DockerFile | -&gt; pom.xml </code></pre> <p>the Dockerfiles inside the modules can't perform actions like :</p> <pre><code>COPY ../pom.xml / </code></pre> <p>because it can't access localSystem &quot;..&quot; !! the solution was to move the Dockerfiles to the parent folder like this :</p> <pre><code>ParentProject |  --&gt; Child Module A  --&gt; pom.xml |  --&gt; Child Module B   --&gt; pom.xml | --&gt; DockerFileA --&gt; DockerFileB -&gt; pom.xml </code></pre> <p>and then i was just doing something like this :</p> <pre><code>WORKDIR /app  COPY ./pom.xml /app  COPY ./ChildA/pom.xml /app/child-project/ </code></pre> <p>It took me tons of times to figure this out, i needed to create a container just with COPY instructions without running maven , and then i drilled into the container files and found that the pom parent was not copied and actually somehow the docker copied the child pom as the parent pom for this instruction :</p> <pre><code>COPY ../pom.xml / </code></pre> <p>so you should know that when building docker , you can't copy files from parent folders in your localMachine since it does not have access to it. and it will execute the same command on the current folder, which makes it really hard to detect since no error is thrown upon it scenario.</p> "
  },
  {
    "Id": "59330607",
    "PostTypeId": "1",
    "AcceptedAnswerId": "59339438",
    "CreationDate": "2019-12-13T22:32:51.567",
    "Score": "6",
    "ViewCount": "8806",
    "Body": "<p>My web app can't connect to the MongoDB container</p> <p>here are my application.yml</p> <pre class='lang-yaml prettyprint-override'><code>spring:   data:     mongodb:       uri: mongodb://mongo:27017       host: mongo       port: 27017       database: my-db-name </code></pre> <p>and this is my Docker-Compose</p> <pre class='lang-yaml prettyprint-override'><code>version: &quot;3&quot; services:    java:     build:       context: ./     ports:       - &quot;8080:8080&quot;     links:       - mongo     depends_on:       - mongo     networks:       - shared-net    mongo:     image: 'mongo'     ports:       - 27017:27017     hostname: mongo     volumes:       - ./data/db:/data/db     networks:       - shared-net  networks:   shared-net:     driver: bridge </code></pre> <p>and this is the Dockerfile wrote for running java</p> <pre><code>FROM openjdk:11 COPY ./code/lemon-backend/target/lemon-0.0.1-SNAPSHOT.jar /usr/src/ WORKDIR /usr/src/ EXPOSE 8080 CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;lemon-0.0.1-SNAPSHOT.jar&quot;] </code></pre> <p>I can't even build the application using these options I get this exception:</p> <p><code>org.mongodb.driver.cluster: Exception in monitor thread while connecting to server mongo:27017</code></p> <p>if possible try giving solutions with docker-compose, thanks</p> ",
    "OwnerUserId": "9614342",
    "LastEditorUserId": "9614342",
    "LastEditDate": "2021-01-23T14:16:50.327",
    "LastActivityDate": "2021-01-23T14:35:11.350",
    "Title": "Connect To Docker Compose MongoDb Via Spring boot application",
    "Tags": "<java><mongodb><spring-boot><docker><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p><strong>OLD VERSION ANSWER</strong></p> <p><strong>IMPORTANT NOTE:</strong> older versions of MongoDB ignore this configuration in <code>application.properties</code>, proceed ahead &amp; use the new solutions I added</p> <hr/> <p>This workaround is used for old versions of spring and mongo that ignore the normal configuration (other than uri)</p> <p>. <em>I had a warning that this property cant be resolved but hopefully, it worked :)</em></p> <pre><code>dockerspring.data.mongodb.uri= mongodb://&lt;your_mongodb_container_name&gt;:27017/&lt;name_of_your_db&gt; </code></pre> <p><em>the mongodb part is not changeable but mongo before the port number is actually the name of the container witch you have specified in your docker-compose</em></p> <hr/> <p><strong>SPRING BOOT SOLUTION</strong></p> <pre class='lang-yaml prettyprint-override'><code>spring:   data:     mongodb:       host: &lt;mongo-db-container-name&gt;       port: &lt;mongo-db-port&gt;       database: &lt;database-name&gt; </code></pre> <hr/> <p><strong>DOCKER SOLUTION</strong></p> <p>In Your Dockerfile Add This Option For Executing Java</p> <pre><code>ENTRYPOINT [\u201cjava\u201d,\u201d-Dspring.data.mongodb.uri=mongodb://mongo:27017/name_of_your_db\u201d, \u201c-Djava.security.egd=file:/dev/./urandom\u201d,\u201d-jar\u201d,\u201d/&lt;name_of_your_app&gt;.jar\u201d] </code></pre> <hr/> <p><strong>Linking Java And Mongo Containers + Giving Them Names</strong></p> <p>here this is my final docker-compose.yml, I hope that it helps you</p> <pre class='lang-yaml prettyprint-override'><code>version: &quot;3&quot; services:    java:     build:       context: ./     ports:       - &quot;8080:8080&quot;     container_name: java     links:       - mongo     depends_on:       - mongo     networks:       - shared-net    mongo:     image: 'mongo'     ports:       - 27017:27017     container_name: mongo     volumes:       - /home/sinoed/data/db:/data/db     networks:       - shared-net  networks:   shared-net:     driver: bridge </code></pre> <p><strong>Compare this version and the one specified in the question carefully</strong></p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "60109556",
    "PostTypeId": "1",
    "CreationDate": "2020-02-07T08:21:38.050",
    "Score": "6",
    "ViewCount": "6444",
    "Body": "<p>I need multiple instance of same application, for that I am using  <code>server.port=0</code> to run application in random port.  my question is how can I map randomly generated port to docker-compose.yml to create multiple instances.  I am using spring boot at the back-end. I am unable to find any solution.  Any help much appreciated. </p> ",
    "OwnerUserId": "8133014",
    "LastActivityDate": "2020-02-07T10:16:29.903",
    "Title": "Expose random port to docker-compose.yml",
    "Tags": "<java><spring><spring-boot><docker><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Each Docker container runs a single process in an isolated network namespace, so this isn't necessary.  Pick a fixed port.  For HTTP services, common port numbers include 80, 3000, 8000, and 8080, depending on permissions and the language runtime (80 requires elevated privileges, 3000 is Node's default, and so on).  The exact port number doesn't matter.</p>  <p>You access the port from outside Docker space using a published port.  If you're running multiple containers, there is the potential for conflict if multiple services use the same host port, which is probably what you're trying to avoid.  In the <a href='https://docs.docker.com/engine/reference/commandline/run/#publish-or-expose-port--p---expose' rel='noreferrer'><code>docker run -p</code></a> option or the Docker Compose <a href='https://docs.docker.com/compose/compose-file/#ports' rel='noreferrer'><code>ports:</code></a> setting, it's possible to list only the port running inside the container, and Docker will choose a host port for you.</p>  <pre class='lang-yaml prettyprint-override'><code>version: '3' services:   web:     image: ...     ports:       - '8000'                       # no explicit host port     command: ... -Dserver.port=8000  # fixed container port </code></pre>  <p><a href='https://docs.docker.com/compose/reference/port/' rel='noreferrer'><code>docker-compose port</code></a> <code>web 8000</code> will tell you what the host (public) port number is.  For communication between containers in the same <code>docker-compose.yml</code> file, you can use the service name and the (fixed, known) internal port, <code>http://web:8000</code>.</p> "
  },
  {
    "Id": "60945565",
    "PostTypeId": "1",
    "AcceptedAnswerId": "60961132",
    "CreationDate": "2020-03-31T07:40:57.793",
    "Score": "6",
    "ViewCount": "3085",
    "Body": "<p>This is my docker-compose.yaml:</p>  <pre><code>version: '2.0' services:   mongo_container:     image: mongo:latest     environment:       MONGO_INITDB_ROOT_USERNAME: root       MONGO_INITDB_ROOT_PASSWORD: example       MONGO_INITDB_DATABASE: testdb     ports:       - '27017:27017'     volumes:       - ./mongodata:/data/db </code></pre>  <p>And this in my spring configuration:</p>  <pre><code>spring.data.mongodb.host=localhost spring.data.mongodb.port=27017 spring.data.mongodb.username=root spring.data.mongodb.password=example spring.data.mongodb.database=testdb </code></pre>  <p>But everytime when I try to connect my app to Mongo I get following error in Docker console:</p>  <pre><code>mongo_container_1  | 2020-03-31T07:37:24.803+0000 I  ACCESS   [conn2] SASL SCRAM-SHA-1 authentication failed for root on testdb from client 172.29.0.1:36628 ; UserNotFound: Could not find user 'root' for db 'testdb' </code></pre>  <p>What am I doing wrong? I tried to remove all containers with <code>docker system prune</code> and run it again but it still gives the same error.</p> ",
    "OwnerUserId": "4650497",
    "LastEditorUserId": "4650497",
    "LastEditDate": "2020-03-31T07:46:33.423",
    "LastActivityDate": "2020-03-31T22:49:43.027",
    "Title": "Mongodb with docker-compose - create user",
    "Tags": "<mongodb><spring-boot><docker><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>You need to add the following line in your application.properties :</p> <pre><code>spring.data.mongodb.authentication-database=admin </code></pre> <p><a href='https://hub.docker.com/_/mongo' rel='nofollow noreferrer'>From docker-hub mongodb readme</a> :</p> <blockquote> <p>MONGO_INITDB_ROOT_USERNAME, MONGO_INITDB_ROOT_PASSWORD</p> <p>These variables, used in conjunction, create a new user and set that user's password. <strong>This user is created in the admin authentication database</strong> and given the role of root, which is a &quot;superuser&quot; role.</p> </blockquote> <p>And for database :</p> <blockquote> <p>MONGO_INITDB_DATABASE This variable allows you to specify the name of a database to be used for creation scripts in /docker-entrypoint-initdb.d/*.js ... MongoDB is fundamentally designed for &quot;create on first use&quot;, <strong>so if you do not insert data with your JavaScript files, then no database is created.</strong></p> </blockquote> <p>In MongoDB, when authentication is enabled you allways authenticate against a particular database (by default admin), then connect and use another one. That's why there are two different properties : authentication-database (to authenticate against) and database (the one to use)</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "62367429",
    "PostTypeId": "1",
    "AcceptedAnswerId": "62367684",
    "CreationDate": "2020-06-14T01:29:48.643",
    "Score": "6",
    "ViewCount": "2625",
    "Body": "<p>I want to monitor internals of JVM for my Spring Boot application inside a Docker which is running as a pod in a Kubernetes cluster. But I couldn't find satisfactory answer anywhere even after spending considerable time.  I tried referring the accepted answer on <a href='https://stackoverflow.com/questions/31257968/how-to-access-jmx-interface-in-docker-from-outside'>this</a> but it was connecting only when my docker was running locally, and ceased to connect while behind a Kubernetes cluster. </p> ",
    "OwnerUserId": "12218581",
    "LastActivityDate": "2020-06-14T02:23:11.353",
    "Title": "Monitor dockerised Spring Boot application internals via JMX behind a Kubernetes cluster with VisualVM",
    "Tags": "<spring-boot><docker><kubernetes><jmx><visualvm>",
    "AnswerCount": "1",
    "CommentCount": "1",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>Assume I wanted to monitor on port 8001 while my app was serving on 8000.  Adding these to my VM options worked fine(VisualVM was showing this process for monitoring) while running Docker locally and mapping port 8001 from my local to Docker(-p 8001:8001)</p>  <pre><code>-Dcom.sun.management.jmxremote \\ -Djava.rmi.server.hostname=localhost \\ -Dcom.sun.management.jmxremote.port=8001 \\ -Dcom.sun.management.jmxremote.rmi.port=8001 \\ -Dcom.sun.management.jmxremote.local.only=false \\ -Dcom.sun.management.jmxremote.authenticate=false \\ -Dcom.sun.management.jmxremote.ssl=false </code></pre>  <p>But it didn't work on a pod in remote Kubernetes Cluster. I found <a href='https://medium.com/cloud-native-the-gathering/remotely-connecting-through-kubernetes-to-a-jmx-agent-in-a-spring-boot-1-x-cf83bb83f499' rel='noreferrer'>this</a> but my requirement was to monitor without going via Service and then by reading couple of other articles I got it working, so collating those steps below for saving someone's time:-</p>  <ol> <li>Removed VM options mentioned above in the startup script</li> <li>Updated my application.yaml as below where I enabled jmx and added url for running JMXMP Connector server</li> </ol>  <pre><code>spring:   application:     name: stack-application   jmx:     enabled: true     url: service:jmx:jmxmp://localhost:8001/ server:   port: 8000 </code></pre>  <ol start='3'> <li>Updated my Kubernetes deployment YAML under Deployment block as:</li> </ol>  <pre><code>apiVersion: apps/v1 kind: Deployment ----your content----           ports:             - name: stack-app-port               containerPort: 8000             - name: stack-jmx-port               containerPort: 8001 </code></pre>  <ol start='4'> <li>Added following dependency to my pom.xml for downloading <a href='https://docs.oracle.com/cd/E19698-01/816-7609/connectors-116/index.html' rel='noreferrer'>JMXMP</a> as after my research I concluded that JMX monitoring over RMI is a tough job and hence JMXMP is everyone's recommendation.</li> </ol>  <pre><code>        &lt;dependency&gt;             &lt;groupId&gt;org.glassfish.main.external&lt;/groupId&gt;             &lt;artifactId&gt;jmxremote_optional-repackaged&lt;/artifactId&gt;             &lt;version&gt;5.0&lt;/version&gt;         &lt;/dependency&gt; </code></pre>  <ol start='5'> <li>Created a new class <code>ConnectorServiceFactoryBeanProvider</code> which fetches URL from our application.yaml</li> </ol>  <pre><code>@Configuration public class ConnectorServiceFactoryBeanProvider {     @Value('${spring.jmx.url}')     private String url;      @Bean     public ConnectorServerFactoryBean connectorServerFactoryBean() throws Exception {         final ConnectorServerFactoryBean connectorServerFactoryBean = new ConnectorServerFactoryBean();         connectorServerFactoryBean.setServiceUrl(url);         return connectorServerFactoryBean;     } } </code></pre>  <ol start='6'> <li>Build and deploy your docker on Kubernetes and find out the IP address of the pod. You may use <code>kubectl describe pod</code> for that on CLI</li> <li>Now to start VisualVM, we also need to add the JMXMP jar downloaded above in classpath. I created an alias to do the same, and since the JAR was downloaded in my local .m2 directory the command looked like this:- </li> </ol>  <pre><code>alias viz='jvisualvm -cp '$JAVA_HOME:~/.m2/repository/org/glassfish/main/external/jmxremote_optional-repackaged/5.0/jmxremote_optional-repackaged-5.0.jar'' </code></pre>  <ol start='8'> <li>Now, execute 'viz' or your alias, it'll start the Visual VM application shipped with your Java. </li> <li>Click on the +JMX icon in the toolbar of VisualVM or go to (File -> Add JMX Connection...) add the link </li> </ol>  <pre><code>service:jmx:jmxmp://&lt;IP address obtained in step 6 above&gt;:8001 </code></pre>  <p>and Check 'Do not require SSL connection'. Once you hit OK, you should see your remote application internals on VisualVM in a while. Screenshot attached below. </p>  <p><a href='https://i.stack.imgur.com/544OE.png' rel='noreferrer'>VisualVM screenshot monitoring remote app on 8001</a></p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "63492180",
    "PostTypeId": "1",
    "CreationDate": "2020-08-19T17:33:30.387",
    "Score": "6",
    "ViewCount": "1459",
    "Body": "<p>I am trying to build a docker image for my basic Spring Boot application using the spring-boot-maven-plugin:build-image goal.</p> <p>It fails with the below error:</p> <pre><code>[ERROR] Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:2.4.0-M2:build-image (default-cli) on project spring-docker: Execution default-cli of goal org.springframework.boot:spring-boot-maven-plugin:2.4.0-M2:build-image failed: **Docker API call to 'localhost/v1.24/containers/eaaba1e2a727547ae53df3c1f7c4420ba821914b4392ea12ff47326ee03eeaa5/start' failed with status code 400 &quot;Bad Request&quot;** -&gt; [Help 1] </code></pre> <p>I have tried with both <strong>Spring Boot 2.3.3.RELEASE</strong> as well as <strong>2.4.0-M2</strong> and I get the same error.</p> <p>I have Docker Desktop running on a Windows 10 machine.</p> <p><code>$ docker version</code></p> <pre><code>**Client: Docker Engine - Community  Version:           19.03.12  API version:       1.40**  Go version:        go1.13.10  Git commit:        48a66213fe  Built:             Mon Jun 22 15:43:18 2020  OS/Arch:           windows/amd64  Experimental:      false  **Server: Docker Engine - Community  Engine:   Version:          19.03.12   API version:      1.40 (minimum version 1.12)**   Go version:       go1.13.10   Git commit:       48a66213fe   Built:            Mon Jun 22 15:49:27 2020   OS/Arch:          linux/amd64   Experimental:     false  containerd:   Version:          v1.2.13   GitCommit:        7ad184331fa3e55e52b890ea95e65ba581ae3429  runc:   Version:          1.0.0-rc10   GitCommit:        dc9208a3303feef5b3839f4323d9beb36df0a9dd  docker-init:   Version:          0.18.0   GitCommit:        fec3683 </code></pre> <p>Full stack trace:</p> <pre><code>[ERROR] Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:2.4.0-M2:build-image (default-cli) on project spring-docker: Execution default-cli of goal org.springframework.boot:spring-boot-maven-plugin:2.4.0-M2:build-image failed: Docker API call to 'localhost/v1.24/containers/cbdb316cb8cb0fbdf641bc7347f56701429d7a887fb240768e8710d36ca5f836/start' failed with status code 400 &quot;Bad Request&quot; -&gt; [Help 1] org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:2.4.0-M2:build-image (default-cli) on project spring-docker: Execution default-cli of goal org.springframework.boot:spring-boot-maven-plugin:2.4.0-M2:build-image failed: Docker API call to 'localhost/v1.24/containers/cbdb316cb8cb0fbdf641bc7347f56701429d7a887fb240768e8710d36ca5f836/start' failed with status code 400 &quot;Bad Request&quot;     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:215)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)     at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)     at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)     at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)     at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)     at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)     at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)     at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)     at jdk.internal.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)     at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke (Method.java:566)     at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:289)     at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:229)     at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:415)     at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:356) Caused by: org.apache.maven.plugin.PluginExecutionException: Execution default-cli of goal org.springframework.boot:spring-boot-maven-plugin:2.4.0-M2:build-image failed: Docker API call to 'localhost/v1.24/containers/cbdb316cb8cb0fbdf641bc7347f56701429d7a887fb240768e8710d36ca5f836/start' failed with status code 400 &quot;Bad Request&quot;     at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:148)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)     at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)     at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)     at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)     at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)     at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)     at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)     at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)     at jdk.internal.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)     at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke (Method.java:566)     at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:289)     at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:229)     at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:415)     at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:356) Caused by: org.springframework.boot.buildpack.platform.docker.transport.DockerEngineException: Docker API call to 'localhost/v1.24/containers/cbdb316cb8cb0fbdf641bc7347f56701429d7a887fb240768e8710d36ca5f836/start' failed with status code 400 &quot;Bad Request&quot;     at org.springframework.boot.buildpack.platform.docker.transport.HttpClientTransport.execute (HttpClientTransport.java:136)     at org.springframework.boot.buildpack.platform.docker.transport.HttpClientTransport.post (HttpClientTransport.java:82)     at org.springframework.boot.buildpack.platform.docker.DockerApi$ContainerApi.start (DockerApi.java:264)     at org.springframework.boot.buildpack.platform.build.Lifecycle.run (Lifecycle.java:148)     at org.springframework.boot.buildpack.platform.build.Lifecycle.execute (Lifecycle.java:113)     at org.springframework.boot.buildpack.platform.build.Builder.executeLifecycle (Builder.java:133)     at org.springframework.boot.buildpack.platform.build.Builder.build (Builder.java:72)     at org.springframework.boot.maven.BuildImageMojo.buildImage (BuildImageMojo.java:152)     at org.springframework.boot.maven.BuildImageMojo.execute (BuildImageMojo.java:144)     at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)     at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)     at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)     at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)     at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)     at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)     at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)     at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)     at jdk.internal.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)     at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke (Method.java:566)     at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:289)     at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:229)     at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:415)     at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:356) </code></pre> ",
    "OwnerUserId": "11447153",
    "LastEditorUserId": "3630528",
    "LastEditDate": "2020-08-19T20:34:08.647",
    "LastActivityDate": "2020-08-19T22:25:05.167",
    "Title": "spring-boot-maven-plugin:build-image fails with 400 Bad Request",
    "Tags": "<spring-boot><docker><maven>",
    "AnswerCount": "1",
    "CommentCount": "6",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Doing</p> <p>docker volume prune</p> <p>was resolved my issue.</p> "
  },
  {
    "Id": "64215516",
    "PostTypeId": "1",
    "CreationDate": "2020-10-05T20:09:46.790",
    "Score": "6",
    "ViewCount": "7907",
    "Body": "<p>I'm using the GitHub action &quot;<a href='https://github.com/marketplace/actions/build-and-push-docker-images' rel='noreferrer'>Build and push Docker images</a>&quot; as it's from Docker and a top rated verified action.</p> <p>The relevant snippet of my YAML file is as follows</p> <pre class='lang-yaml prettyprint-override'><code>  - name: Set up QEMU     uses: docker/setup-qemu-action@v1   - name: Set up Docker Buildx     uses: docker/setup-buildx-action@v1   - name: Login to DockerHub     uses: docker/login-action@v1     with:       username: ${{ secrets.DOCKERHUB_USERNAME }}       password: ${{ secrets.DOCKERHUB_ACCESS_TOKEN }}   - name: Build and push     id: docker_build     uses: docker/build-push-action@v2     with:       push: true       tags: user/app:latest   - name: Image digest     run: echo ${{ steps.docker_build.outputs.digest }} </code></pre> <p><a href='https://github.com/marketplace/actions/build-and-push-docker-images#git-context' rel='noreferrer'>Just as it was shown in the example</a>. When the workflow runs, I consistently see the error</p> <pre><code>10 [stage-1 2/2] COPY --from=build /workspace/target/*.jar app.jar #10 DONE 0.9s  #12 exporting to image #12 exporting layers #12 exporting layers 4.3s done #12 exporting manifest sha256:dafb0869387b325491aed0cdc10c2d0206aca28006b300554f48e4c389fc3bf1 done #12 exporting config sha256:f64316c3b529b43a6cfcc933656c77e556fea8e5600b6d0cce8dc09f775cf107 done #12 pushing layers #12 pushing layers 0.8s done #12 ERROR: server message: insufficient_scope: authorization failed ------  &gt; exporting to image: ------ failed to solve: rpc error: code = Unknown desc = server message: insufficient_scope: authorization failed Error: The process '/usr/bin/docker' failed with exit code 1 </code></pre> <p>The contents of my Dockerfile for a standard spring-boot application is as shown below</p> <pre><code>FROM maven:3.6.3-jdk-11-slim AS build RUN mkdir -p /workspace WORKDIR /workspace COPY pom.xml /workspace COPY src /workspace/src RUN mvn -B -f pom.xml clean package -DskipTests  FROM openjdk:11-jdk-slim COPY --from=build /workspace/target/*.jar app.jar EXPOSE 8080 ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;app.jar&quot;] </code></pre> <p>Any clue how this can be fixed?</p> <p>I'm able to publish to docker-hub when using a different GitHub action as shown below</p> <pre><code>  - name: Build and push docker image     uses: elgohr/Publish-Docker-Github-Action@master     with:       name: bloque/sales-lead-management       username: ${{ secrets.DOCKERHUB_USERNAME }}       password: ${{ secrets.DOCKERHUB_ACCESS_TOKEN }} </code></pre> ",
    "OwnerUserId": "1971503",
    "LastEditorUserId": "1971503",
    "LastEditDate": "2020-10-05T20:49:58.647",
    "LastActivityDate": "2022-05-20T08:31:38.790",
    "Title": "Github action: Build and push docker image fails. server message: insufficient_scope: authorization failed",
    "Tags": "<spring-boot><docker><github-actions><docker-push>",
    "AnswerCount": "1",
    "CommentCount": "7",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>You need to set a path context while using the Docker's <code>build-push-action</code>. It should look something like this:</p> <pre class='lang-yaml prettyprint-override'><code> - name: Build and push    id: docker_build    uses: docker/build-push-action@v2    with:      context: .      file: Dockerfile      push: true      tags: user/app:latest </code></pre> <p>The <code>file</code> option is entirely optional, but if left out it will find the Dockerfile inside the root directory.</p> <p>It's also recommended to use the <a href='https://github.com/docker/metadata-action' rel='nofollow noreferrer'>metadata action</a> that provides more relevant metadata and tags for your Docker image.</p> <p>Here is an example of how I did it for Spring Boot apps in few of my projects: <a href='https://github.com/moja-global/FLINT.Reporting/blob/d7504909f8f101054e503a2993f4f70ca92c2577/.github/workflows/docker.yml#L153' rel='nofollow noreferrer'>https://github.com/moja-global/FLINT.Reporting/blob/d7504909f8f101054e503a2993f4f70ca92c2577/.github/workflows/docker.yml#L153</a></p> "
  },
  {
    "Id": "65143023",
    "PostTypeId": "1",
    "CreationDate": "2020-12-04T11:48:09.693",
    "Score": "6",
    "ViewCount": "791",
    "Body": "<p>I would like to run a container with testcontainers on a network. My containers contains a spring application, which has an actuator endpoint to express its state, it is on:</p> <pre><code>/actuator/health </code></pre> <p>My container looks like the following:</p> <pre><code>private final static Network network = Network.newNetwork();  private static final GenericContainer&lt;?&gt; myContainer = new GenericContainer&lt;&gt;(&quot;mycontainer:latest&quot;)             .withExposedPorts(8443)             .withNetwork(network)             .withNetworkAliases(&quot;myContainer&quot;)             .withClasspathResourceMapping(&quot;certs&quot;, &quot;/app/certs&quot;, BindMode.READ_ONLY)             .withClasspathResourceMapping(&quot;config&quot;, &quot;/app/config&quot;, BindMode.READ_ONLY)             .withLogConsumer(new Slf4jLogConsumer(log))             .waitingFor(Wait.forHttp(&quot;/actuator/health&quot;).usingTls()); </code></pre> <p>But when i start this container I get the following error:</p> <pre><code>Caused by: org.testcontainers.containers.ContainerLaunchException: Timed out waiting for URL to be accessible (https://localhost:33092/actuator/health should return HTTP [200])     at org.testcontainers.containers.wait.strategy.HttpWaitStrategy.waitUntilReady(HttpWaitStrategy.java:214)     at org.testcontainers.containers.wait.strategy.AbstractWaitStrategy.waitUntilReady(AbstractWaitStrategy.java:35)     at org.testcontainers.containers.GenericContainer.waitUntilContainerStarted(GenericContainer.java:890)     at org.testcontainers.containers.GenericContainer.tryStart(GenericContainer.java:441)     ... 68 more </code></pre> <p>But if I curl this url (in this example: <code>https://localhost:33092/actuator/health</code>) while after the application inside the container has started but I am waiting for the evaulation, I get something like this:</p> <pre><code>HTTP Status Code: 200 {     &quot;status&quot;: &quot;UP&quot; } </code></pre> <p>What am I missing? Any ideas? Is it a bug?</p> ",
    "OwnerUserId": "9387519",
    "LastActivityDate": "2020-12-04T18:30:16.450",
    "Title": "Testcontainers with Spring actuator",
    "Tags": "<java><spring-boot><docker><testcontainers>",
    "AnswerCount": "1",
    "CommentCount": "4",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Ok, so you'll have to decompose the problem.</p> <p>I just built an example Spring Boot app with dependencies and packed it in an image:</p> <pre><code>implementation 'org.springframework.boot:spring-boot-starter-actuator' implementation 'org.springframework.boot:spring-boot-starter-web' </code></pre> <p>Nothing else, I downloaded it from <a href='https://start.spring.io/' rel='nofollow noreferrer'>https://start.spring.io/</a></p> <p>The following test class works (I took your code as an example):</p> <pre><code>import lombok.extern.slf4j.Slf4j; import org.junit.jupiter.api.Test; import org.testcontainers.containers.GenericContainer; import org.testcontainers.containers.output.Slf4jLogConsumer; import org.testcontainers.containers.wait.strategy.Wait;  @Slf4j public class TestcontainersWithSpringActuator {      private static final GenericContainer&lt;?&gt; myContainer = new GenericContainer&lt;&gt;(&quot;docker.io/vcvitaly/test_sb:latest&quot;)             .withExposedPorts(8080)             .withNetworkAliases(&quot;myContainer&quot;)             .withLogConsumer(new Slf4jLogConsumer(log))             .waitingFor(Wait.forHttp(&quot;/actuator/health&quot;));      @Test     void name() {         myContainer.start();         System.out.println();     } } </code></pre> <p>I can also put a break on System.out.println and while it's suspended curl also works</p> <pre><code>~  curl http://localhost:32776/actuator/health {&quot;status&quot;:&quot;UP&quot;}\u23ce </code></pre> <p>I don't really have a straight guess right now what is happening in your case, but you have to decompose you problem layer by layer (getting rid of tls, network, etc) or build it up starting from scratch with the most simple image and adding features one by one.</p> "
  },
  {
    "Id": "65320552",
    "PostTypeId": "1",
    "CreationDate": "2020-12-16T09:28:21.043",
    "Score": "6",
    "ViewCount": "1436",
    "Body": "<p>I've got a Gradle project with Spring Boot plugin and am trying to publish the image built by the plugin: <code>gradle bootBuildImage --publishImage</code></p> <p>The problem is to publish &quot;either token or username/password must be provided&quot; and we can't do that since we have different authentication mechanism in different environments. For example on local machine we're using <code>ecr-credentials-helper</code> and the pipeline uses <code>aws ecr get-login-token | docker login</code>.</p> <p>Is there any way to force the plugin to let the docker handles the authentication? (I'm assuming the plugin uses the docker daemon on the host).</p> <p>Currently I wrote a task to generate a token file using <code>aws ecr get-login-token</code> and read the token file in <code>bootBuildImage</code> task. But I don't like this solution, due to security reasons.</p> ",
    "OwnerUserId": "2194119",
    "LastActivityDate": "2023-08-14T10:09:53.853",
    "Title": "Publish Docker images using Spring Boot Plugin without credentials",
    "Tags": "<docker><amazon-ecr><spring-boot-gradle-plugin>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Here's a solution that replicates <a href='https://awscli.amazonaws.com/v2/documentation/api/latest/reference/ecr/get-login-password.html' rel='nofollow noreferrer'><code>aws ecr get-login-password</code></a> within Gradle, using the AWS Java SDK. Although you could instead invoke the CLI directly from Gradle, this makes the build script more fragile, as it then depends on having a certain version of the CLI installed. Particularly so since ecr login was a <a href='https://docs.aws.amazon.com/cli/latest/userguide/cliv2-migration.html#cliv2-migration-ecr-get-login' rel='nofollow noreferrer'>breaking change</a> between v1 and v2 of the CLI.</p> <p>This assumes you have your AWS credentials set up in some standard way that the <a href='https://docs.aws.amazon.com/sdk-for-java/latest/developer-guide/credentials.html#credentials-chain' rel='nofollow noreferrer'>default credentials provider</a> in the SDK will locate.</p> <pre class='lang-groovy prettyprint-override'><code>import software.amazon.awssdk.services.ecr.EcrClient  buildscript {     repositories {         mavenCentral()     }     dependencies {         classpath platform(&quot;software.amazon.awssdk:bom:2.17.19&quot;)         classpath &quot;software.amazon.awssdk:ecr&quot;         classpath &quot;software.amazon.awssdk:sts&quot; // sts is required to use roleArn in aws profiles     } }  plugins {     id &quot;java&quot;     id &quot;org.springframework.boot&quot; }  dependencies {     implementation platform(&quot;org.springframework.boot:spring-boot-dependencies:2.5.3&quot;)     implementation &quot;org.springframework.boot:spring-boot-starter&quot;     // Rest of app dependencies }  bootBuildImage {     doFirst {         String base64Token = EcrClient.create().getAuthorizationToken().authorizationData()[0].authorizationToken()         String[] auth = new String( base64Token.decodeBase64() ).split(&quot;:&quot;, 2)          docker {             publishRegistry {                 username = auth[0]                 password = auth[1]             }         }     } } </code></pre> "
  },
  {
    "Id": "71377911",
    "PostTypeId": "1",
    "CreationDate": "2022-03-07T07:55:05.240",
    "Score": "6",
    "ViewCount": "5132",
    "Body": "<p>I am working on Spring Boot Application that contains unit and integration test cases to check functionalities.</p> <p>Docker is running with Podman and it working fine.</p> <p>I am using POSTGRES database server that configured on my machine. But while running Integration test, the test are getting ignored with the error : CIRCULAR REFERENCE:io.zonky.test.db.provider.ProviderException: Unexpected error when preparing a database cluster; nested exception is java.lang.IllegalStateException: Could not find a valid Docker environment. Please see logs and check configuration</p> <p><strong>Detailed Stack Trace :</strong></p> <pre><code>java.lang.IllegalStateException: Failed to load ApplicationContext      at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:132)     at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:123)     at io.zonky.test.db.EmbeddedDatabaseTestExecutionListener.forEachDatabase(EmbeddedDatabaseTestExecutionListener.java:90)     at io.zonky.test.db.EmbeddedDatabaseTestExecutionListener.resetDatabases(EmbeddedDatabaseTestExecutionListener.java:58)     at io.zonky.test.db.EmbeddedDatabaseTestExecutionListener.beforeTestClass(EmbeddedDatabaseTestExecutionListener.java:34)     at org.springframework.test.context.TestContextManager.beforeTestClass(TestContextManager.java:213)     at org.springframework.test.context.junit.jupiter.SpringExtension.beforeAll(SpringExtension.java:77)     at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$invokeBeforeAllCallbacks$7(ClassBasedTestDescriptor.java:355)     at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)     at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.invokeBeforeAllCallbacks(ClassBasedTestDescriptor.java:355)     at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.before(ClassBasedTestDescriptor.java:189)     at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.before(ClassBasedTestDescriptor.java:77)     at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:132)     at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)     at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)     at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)     at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)     at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)     at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)     at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)     at java.base/java.util.ArrayList.forEach(ArrayList.java:1541)     at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)     at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)     at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)     at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)     at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)     at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)     at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)     at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)     at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)     at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32)     at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)     at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51)     at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:229)     at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$6(DefaultLauncher.java:197)     at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:211)     at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:191)     at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:128)     at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:71)     at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33)     at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:235)     at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:54)     Suppressed: java.lang.IllegalStateException: Failed to load ApplicationContext         at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:132)         at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:123)         at io.zonky.test.db.EmbeddedDatabaseTestExecutionListener.forEachDatabase(EmbeddedDatabaseTestExecutionListener.java:90)         at io.zonky.test.db.EmbeddedDatabaseTestExecutionListener.resetDatabases(EmbeddedDatabaseTestExecutionListener.java:58)         at io.zonky.test.db.EmbeddedDatabaseTestExecutionListener.afterTestClass(EmbeddedDatabaseTestExecutionListener.java:54)         at org.springframework.test.context.TestContextManager.afterTestClass(TestContextManager.java:488)         at org.springframework.test.context.junit.jupiter.SpringExtension.afterAll(SpringExtension.java:86)         at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$invokeAfterAllCallbacks$13(ClassBasedTestDescriptor.java:421)         at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)         at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$invokeAfterAllCallbacks$14(ClassBasedTestDescriptor.java:421)         at java.base/java.util.ArrayList.forEach(ArrayList.java:1541)         at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.invokeAfterAllCallbacks(ClassBasedTestDescriptor.java:421)         at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.after(ClassBasedTestDescriptor.java:213)         at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.after(ClassBasedTestDescriptor.java:77)         at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:145)         at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)         at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:145)         ... 27 more     Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'entityManagerFactory' defined in class path resource [org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaConfiguration.class]: Invocation of init method failed; nested exception is io.zonky.test.db.shaded.com.google.common.util.concurrent.UncheckedExecutionException: io.zonky.test.db.provider.ProviderException: Unexpected error when preparing a database cluster; nested exception is java.lang.IllegalStateException: Could not find a valid Docker environment. Please see logs and check configuration         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1796)         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:595)         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517)         at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323)         at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222)         at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321)         at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)         at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1108)         at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:868)         at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:550)         at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:141)         at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:747)         at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397)         at org.springframework.boot.SpringApplication.run(SpringApplication.java:315)         at org.springframework.boot.test.context.SpringBootContextLoader.loadContext(SpringBootContextLoader.java:125)         at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContextInternal(DefaultCacheAwareContextLoaderDelegate.java:99)         at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:124)         ... 43 more     Caused by: io.zonky.test.db.shaded.com.google.common.util.concurrent.UncheckedExecutionException: io.zonky.test.db.provider.ProviderException: Unexpected error when preparing a database cluster; nested exception is java.lang.IllegalStateException: Could not find a valid Docker environment. Please see logs and check configuration         at io.zonky.test.db.shaded.com.google.common.util.concurrent.Futures.wrapAndThrowUnchecked(Futures.java:1571)         at io.zonky.test.db.shaded.com.google.common.util.concurrent.Futures.getUnchecked(Futures.java:1556)         at io.zonky.test.db.context.DefaultDatabaseContext.awaitDatabase(DefaultDatabaseContext.java:282)         at io.zonky.test.db.context.DefaultDatabaseContext.getDatabase(DefaultDatabaseContext.java:126)         at io.zonky.test.db.context.DatabaseTargetSource.getTarget(DatabaseTargetSource.java:32)         at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:192)         at com.sun.proxy.$Proxy206.toString(Unknown Source)         at java.base/java.lang.String.valueOf(String.java:2951)         at java.base/java.lang.StringBuilder.append(StringBuilder.java:168)         at org.hibernate.jpa.internal.util.LogHelper.logPersistenceUnitInformation(LogHelper.java:53)         at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.&lt;init&gt;(EntityManagerFactoryBuilderImpl.java:191)         at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.&lt;init&gt;(EntityManagerFactoryBuilderImpl.java:168)         at org.springframework.orm.jpa.vendor.SpringHibernateJpaPersistenceProvider.createContainerEntityManagerFactory(SpringHibernateJpaPersistenceProvider.java:52)         at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.createNativeEntityManagerFactory(LocalContainerEntityManagerFactoryBean.java:365)         at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.buildNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:391)         at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.afterPropertiesSet(AbstractEntityManagerFactoryBean.java:378)         at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.afterPropertiesSet(LocalContainerEntityManagerFactoryBean.java:341)         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1855)         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1792)         ... 59 more     Caused by: io.zonky.test.db.provider.ProviderException: Unexpected error when preparing a database cluster; nested exception is java.lang.IllegalStateException: Could not find a valid Docker environment. Please see logs and check configuration         at io.zonky.test.db.provider.postgres.DockerPostgresDatabaseProvider.createDatabase(DockerPostgresDatabaseProvider.java:117)         at io.zonky.test.db.provider.postgres.DockerPostgresDatabaseProvider.createTemplate(DockerPostgresDatabaseProvider.java:102)         at io.zonky.test.db.provider.common.TemplatingDatabaseProvider.createTemplate(TemplatingDatabaseProvider.java:129)         at io.zonky.test.db.provider.common.TemplatingDatabaseProvider.lambda$createTemplateIfPossible$1(TemplatingDatabaseProvider.java:171)         at io.zonky.test.db.provider.common.TemplatingDatabaseProvider$TemplateWrapper.loadTemplate(TemplatingDatabaseProvider.java:294)         at io.zonky.test.db.provider.common.TemplatingDatabaseProvider$TemplateWrapper.access$200(TemplatingDatabaseProvider.java:224)         at io.zonky.test.db.provider.common.TemplatingDatabaseProvider.createTemplateIfPossible(TemplatingDatabaseProvider.java:171)         at io.zonky.test.db.provider.common.TemplatingDatabaseProvider.createDatabase(TemplatingDatabaseProvider.java:112)         at io.zonky.test.db.provider.common.TemplatingDatabaseProvider.createDatabase(TemplatingDatabaseProvider.java:104)         at io.zonky.test.db.provider.common.PrefetchingDatabaseProvider$PrefetchingTask.lambda$forPreparer$0(PrefetchingDatabaseProvider.java:391)         at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)         at io.zonky.test.db.provider.common.PrefetchingDatabaseProvider$PrefetchingTask.run(PrefetchingDatabaseProvider.java:420)         at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)         at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)         at java.base/java.lang.Thread.run(Thread.java:834)     Caused by: java.lang.IllegalStateException: Could not find a valid Docker environment. Please see logs and check configuration         at org.testcontainers.dockerclient.DockerClientProviderStrategy.lambda$getFirstValidStrategy$7(DockerClientProviderStrategy.java:215)         at java.base/java.util.Optional.orElseThrow(Optional.java:408)         at org.testcontainers.dockerclient.DockerClientProviderStrategy.getFirstValidStrategy(DockerClientProviderStrategy.java:207)         at org.testcontainers.DockerClientFactory.getOrInitializeStrategy(DockerClientFactory.java:136)         at org.testcontainers.DockerClientFactory.client(DockerClientFactory.java:178)         at org.testcontainers.LazyDockerClient.getDockerClient(LazyDockerClient.java:14)         at org.testcontainers.LazyDockerClient.authConfig(LazyDockerClient.java:12)         at org.testcontainers.containers.GenericContainer.start(GenericContainer.java:310)         at io.zonky.test.db.provider.postgres.DockerPostgresDatabaseProvider$DatabaseInstance.&lt;init&gt;(DockerPostgresDatabaseProvider.java:173)         at io.zonky.test.db.provider.postgres.DockerPostgresDatabaseProvider$DatabaseInstance.&lt;init&gt;(DockerPostgresDatabaseProvider.java:137)         at io.zonky.test.db.provider.postgres.DockerPostgresDatabaseProvider$1.load(DockerPostgresDatabaseProvider.java:77)         at io.zonky.test.db.provider.postgres.DockerPostgresDatabaseProvider$1.load(DockerPostgresDatabaseProvider.java:75)         at io.zonky.test.db.shaded.com.google.common.cache.LocalCache$LoadingValueReference.loadFuture(LocalCache.java:3708)         at io.zonky.test.db.shaded.com.google.common.cache.LocalCache$Segment.loadSync(LocalCache.java:2416)         at io.zonky.test.db.shaded.com.google.common.cache.LocalCache$Segment.lockedGetOrLoad(LocalCache.java:2299)         at io.zonky.test.db.shaded.com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2212)         at io.zonky.test.db.shaded.com.google.common.cache.LocalCache.get(LocalCache.java:4147)         at io.zonky.test.db.shaded.com.google.common.cache.LocalCache.getOrLoad(LocalCache.java:4151)         at io.zonky.test.db.shaded.com.google.common.cache.LocalCache$LocalLoadingCache.get(LocalCache.java:5140)         at io.zonky.test.db.provider.postgres.DockerPostgresDatabaseProvider.createDatabase(DockerPostgresDatabaseProvider.java:113)         ... 14 more Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'entityManagerFactory' defined in class path resource [org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaConfiguration.class]: Invocation of init method failed; nested exception is io.zonky.test.db.shaded.com.google.common.util.concurrent.UncheckedExecutionException: io.zonky.test.db.provider.ProviderException: Unexpected error when preparing a database cluster; nested exception is java.lang.IllegalStateException: Could not find a valid Docker environment. Please see logs and check configuration     at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1796)     at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:595)     at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517)     at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323)     at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222)     at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321)     at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)     at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1108)     at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:868)     at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:550)     at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:141)     at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:747)     at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397)     at org.springframework.boot.SpringApplication.run(SpringApplication.java:315)     at org.springframework.boot.test.context.SpringBootContextLoader.loadContext(SpringBootContextLoader.java:125)     at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContextInternal(DefaultCacheAwareContextLoaderDelegate.java:99)     at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:124)     ... 41 more Caused by: io.zonky.test.db.shaded.com.google.common.util.concurrent.UncheckedExecutionException: io.zonky.test.db.provider.ProviderException: Unexpected error when preparing a database cluster; nested exception is java.lang.IllegalStateException: Could not find a valid Docker environment. Please see logs and check configuration     at io.zonky.test.db.shaded.com.google.common.util.concurrent.Futures.wrapAndThrowUnchecked(Futures.java:1571)     at io.zonky.test.db.shaded.com.google.common.util.concurrent.Futures.getUnchecked(Futures.java:1556)     at io.zonky.test.db.context.DefaultDatabaseContext.awaitDatabase(DefaultDatabaseContext.java:282)     at io.zonky.test.db.context.DefaultDatabaseContext.getDatabase(DefaultDatabaseContext.java:126)     at io.zonky.test.db.context.DatabaseTargetSource.getTarget(DatabaseTargetSource.java:32)     at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:192)     at com.sun.proxy.$Proxy187.toString(Unknown Source)     at java.base/java.lang.String.valueOf(String.java:2951)     at java.base/java.lang.StringBuilder.append(StringBuilder.java:168)     at org.hibernate.jpa.internal.util.LogHelper.logPersistenceUnitInformation(LogHelper.java:53)     at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.&lt;init&gt;(EntityManagerFactoryBuilderImpl.java:191)     at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.&lt;init&gt;(EntityManagerFactoryBuilderImpl.java:168)     at org.springframework.orm.jpa.vendor.SpringHibernateJpaPersistenceProvider.createContainerEntityManagerFactory(SpringHibernateJpaPersistenceProvider.java:52)     at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.createNativeEntityManagerFactory(LocalContainerEntityManagerFactoryBean.java:365)     at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.buildNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:391)     at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.afterPropertiesSet(AbstractEntityManagerFactoryBean.java:378)     at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.afterPropertiesSet(LocalContainerEntityManagerFactoryBean.java:341)     at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1855)     at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1792)     ... 57 more     [CIRCULAR REFERENCE:io.zonky.test.db.provider.ProviderException: Unexpected error when preparing a database cluster; nested exception is java.lang.IllegalStateException: Could not find a valid Docker environment. Please see logs and check configuration] </code></pre> <p>I have tried many solution like updated to latest version on zonky :</p> <pre><code>&lt;dependency&gt;     &lt;groupId&gt;io.zonky.test&lt;/groupId&gt;     &lt;artifactId&gt;embedded-database-spring-test&lt;/artifactId&gt;     &lt;version&gt;2.1.1&lt;/version&gt;     &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt;      &lt;groupId&gt;io.zonky.test&lt;/groupId&gt;      &lt;artifactId&gt;embedded-postgres&lt;/artifactId&gt;      &lt;version&gt;1.2.6&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; </code></pre> <p>But it didn't worked.</p> <p>Tried <code>@AutoConfigureEmbeddedDatabase(type = AutoConfigureEmbeddedDatabase.DatabaseType.POSTGRES, provider = ZONKY)</code></p> <p>Then also it throwing same error : CIRCULAR REFERENCE:io.zonky.test.db.provider.ProviderException: Unexpected error when preparing a database cluster</p> <p><strong>Detailed Stack trace</strong></p> <pre><code>Caused by: io.zonky.test.db.shaded.com.google.common.util.concurrent.UncheckedExecutionException: io.zonky.test.db.provider.ProviderException: Unexpected error when preparing a database cluster; nested exception is java.lang.IllegalStateException: Process [C:\\Users\\NEELAM~1.SHA\\AppData\\Local\\Temp\\embedded-pg\\PG-aaa7d03a0c0eb51f9510c27dc059d022\\bin\\initdb.exe, -A, trust, -U, postgres, -D, C:\\Users\\NEELAM~1.SHA\\AppData\\Local\\Temp\\epg14265419788948759198, -E, UTF-8] failed     at io.zonky.test.db.shaded.com.google.common.util.concurrent.Futures.wrapAndThrowUnchecked(Futures.java:1571)     at io.zonky.test.db.shaded.com.google.common.util.concurrent.Futures.getUnchecked(Futures.java:1556)     at io.zonky.test.db.context.DefaultDatabaseContext.awaitDatabase(DefaultDatabaseContext.java:282)     at io.zonky.test.db.context.DefaultDatabaseContext.getDatabase(DefaultDatabaseContext.java:126)     at io.zonky.test.db.context.DatabaseTargetSource.getTarget(DatabaseTargetSource.java:32)     at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:192)     at com.sun.proxy.$Proxy187.toString(Unknown Source)     at java.base/java.lang.String.valueOf(String.java:2951)     at java.base/java.lang.StringBuilder.append(StringBuilder.java:168)     at org.hibernate.jpa.internal.util.LogHelper.logPersistenceUnitInformation(LogHelper.java:53)     at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.&lt;init&gt;(EntityManagerFactoryBuilderImpl.java:191)     at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.&lt;init&gt;(EntityManagerFactoryBuilderImpl.java:168)     at org.springframework.orm.jpa.vendor.SpringHibernateJpaPersistenceProvider.createContainerEntityManagerFactory(SpringHibernateJpaPersistenceProvider.java:52)     at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.createNativeEntityManagerFactory(LocalContainerEntityManagerFactoryBean.java:365)     at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.buildNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:391)     at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.afterPropertiesSet(AbstractEntityManagerFactoryBean.java:378)     at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.afterPropertiesSet(LocalContainerEntityManagerFactoryBean.java:341)     at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1855)     at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1792)     ... 57 more     [CIRCULAR REFERENCE:io.zonky.test.db.provider.ProviderException: Unexpected error when preparing a database cluster; nested exception is java.lang.IllegalStateException: Process [C:\\Users\\NEELAM~1.SHA\\AppData\\Local\\Temp\\embedded-pg\\PG-aaa7d03a0c0eb51f9510c27dc059d022\\bin\\initdb.exe, -A, trust, -U, postgres, -D, C:\\Users\\NEELAM~1.SHA\\AppData\\Local\\Temp\\epg14265419788948759198, -E, UTF-8] failed] </code></pre> <p>What can be more possible way to resolve the issue of tests?</p> ",
    "OwnerUserId": "1053182",
    "LastActivityDate": "2024-01-18T20:28:58.603",
    "Title": "Spring Boot Integration test error of CIRCULAR REFERENCE :io.zonky.test.db.provider.ProviderException",
    "Tags": "<postgresql><spring-boot><docker><integration-testing>",
    "AnswerCount": "2",
    "CommentCount": "4",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>upgrading embedded-postgres to 2.0.0 should fix the issue</p> <pre><code>   &lt;dependency&gt;      &lt;groupId&gt;io.zonky.test&lt;/groupId&gt;      &lt;artifactId&gt;embedded-postgres&lt;/artifactId&gt;      &lt;version&gt;2.0.0&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt; </code></pre> "
  },
  {
    "Id": "77385146",
    "PostTypeId": "1",
    "AcceptedAnswerId": "77393967",
    "CreationDate": "2023-10-29T20:48:18.027",
    "Score": "6",
    "ViewCount": "2443",
    "Body": "<p>I tried to remake a SpringBoot project from scratch, and i met this error <code>spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning</code> and nothing that i found online worked. I tried to reinstall docker and now all of my projects wont start. i always get this error in my terminal:</p> <pre><code>Cannot invoke &quot;org.springframework.boot.docker.compose.core.DockerCliInspectResponse.hostConfig()&quot; because &quot;inspectResponse&quot; is null     at org.springframework.boot.docker.compose.core.DefaultConnectionPorts.isHostNetworkMode(DefaultConnectionPorts.java:56) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.core.DefaultConnectionPorts.&lt;init&gt;(DefaultConnectionPorts.java:47) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.core.DefaultRunningService.&lt;init&gt;(DefaultRunningService.java:55) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.core.DefaultDockerCompose.getRunningServices(DefaultDockerCompose.java:83) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.lifecycle.DockerComposeLifecycleManager.start(DockerComposeLifecycleManager.java:120) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.lifecycle.DockerComposeListener.onApplicationEvent(DockerComposeListener.java:53) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.lifecycle.DockerComposeListener.onApplicationEvent(DockerComposeListener.java:35) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) ~[spring-context-6.0.11.jar:6.0.11]     at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) ~[spring-context-6.0.11.jar:6.0.11]     at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:143) ~[spring-context-6.0.11.jar:6.0.11]     at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:131) ~[spring-context-6.0.11.jar:6.0.11]     at org.springframework.boot.context.event.EventPublishingRunListener.multicastInitialEvent(EventPublishingRunListener.java:136) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.context.event.EventPublishingRunListener.contextLoaded(EventPublishingRunListener.java:98) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplicationRunListeners.lambda$contextLoaded$4(SpringApplicationRunListeners.java:72) ~[spring-boot-3.1.2.jar:3.1.2]     at java.base/java.lang.Iterable.forEach(Iterable.java:75) ~[na:na]     at org.springframework.boot.SpringApplicationRunListeners.doWithListeners(SpringApplicationRunListeners.java:118) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplicationRunListeners.doWithListeners(SpringApplicationRunListeners.java:112) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplicationRunListeners.contextLoaded(SpringApplicationRunListeners.java:72) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplication.prepareContext(SpringApplication.java:416) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplication.run(SpringApplication.java:311) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295) ~[spring-boot-3.1.2.jar:3.1.2]     at com.example.springboot3jwtauthenticationserver.SpringBoot3JwtAuthenticationServerApplication.main(SpringBoot3JwtAuthenticationServerApplication.java:10) ~[classes/:na]     at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]     at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) ~[na:na]     at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]     at java.base/java.lang.reflect.Method.invoke(Method.java:568) ~[na:na]     at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:50) ~[spring-boot-devtools-3.1.2.jar:3.1.2] </code></pre> <p>Does anyone have a solution?</p> ",
    "OwnerUserId": "13436670",
    "LastActivityDate": "2023-11-09T19:34:18.873",
    "Title": "Springboot-docker error: cannot invoke 'DockerCliInspectResponse.hostConfig()' because 'inspectResponse' is null",
    "Tags": "<spring-boot><docker><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>Today I encountered the same problem: <a href='https://github.com/spring-projects/spring-boot/issues/37982' rel='noreferrer'>issue</a> on this topic has already been created on GitHub. This is caused by updating Docker Compose to version 2.23.0; Spring boot does not yet work with this version.</p> <p>You need to either downgrade docker compose to 2.20.3 or wait for Spring Boot update, I think this will be fixed in next version</p> ",
    "highest_rated_answer": "<p>I'm trying to downgrade docker-compose to 2.20.3 on Mac m1 but I can't, I've tried several ways:</p> <pre><code>brew install docker-compose@2.20.4 </code></pre> <p>reinstall docker, but it installs in the latest version which is 2.23.0</p> "
  },
  {
    "Id": "33445718",
    "PostTypeId": "1",
    "CreationDate": "2015-10-30T22:20:24.903",
    "Score": "5",
    "ViewCount": "3006",
    "Body": "<p>I'm trying to setup development environment for spring-boot project based on docker and vagrant. I'm using IntelliJ running on windows to write code and vagrant to be able to run project in docker containers on any system. I'm building project with maven. Currently I'm able to run application packaged in jar in docker container running in ubuntu on virtualbox via vagrant. I cannot figure it out how to debug my application in IntelliJ, I start application with remote debugging on, correctly (or at least I think I'm doing it right) configure port forwarding, but IntelliJ still tells me 'Connection reset' and cannot connect to debugger.</p>  <p>Here is my Dockerfile:</p>  <pre><code>FROM java:8 VOLUME /tmp ADD test-1.0-SNAPSHOT.jar app.jar ENTRYPOINT ['java', '-Djava.security.egd=file:/dev/./urandom', '-Xdebug -Xrunjdwp:server=y,transport=dt_socket,suspend=n,address=8000', '-jar', '/app.jar'] </code></pre>  <p>Vagrantfile:</p>  <pre><code>ENV['VAGRANT_DEFAULT_PROVIDER'] = 'docker'  Vagrant.configure('2') do |config|   config.vm.define 'app' do |a|     a.vm.provider 'docker' do |d|       d.vagrant_machine = 'dockerhost'       d.vagrant_vagrantfile = './Vagrant_docker_wrapper'       d.build_dir = '.'       d.build_args = ['-t=app']       d.ports = ['8080:8080', '8000:8000']        d.name = 'app'       d.remains_running = true       d.has_ssh = true       d.cmd = ['run']     end   end end </code></pre>  <p>And Vagrant_docker_wrapper:</p>  <pre><code>Vagrant.configure('2') do |config|    config.vm.provision 'docker'    config.vm.provision 'shell', inline: 'ps aux | grep 'sshd:' | awk '{print $2}' | xargs kill'    config.vm.define 'dockerhost'   config.vm.box = 'ubuntu/trusty64'   config.vm.network 'forwarded_port', guest: 8080, host: 9080   config.vm.network 'forwarded_port', guest: 8000, host: 9081    config.vm.provider :virtualbox do |vb|       vb.name = 'dockerhost'   end  end </code></pre>  <p>I created this files with help of <a href='http://blog.zenika.com/2014/10/07/Setting-up-a-development-environment-using-Docker-and-Vagrant/' rel='noreferrer'>http://blog.zenika.com/2014/10/07/Setting-up-a-development-environment-using-Docker-and-Vagrant/</a> and <a href='https://spring.io/guides/gs/spring-boot-docker/' rel='noreferrer'>https://spring.io/guides/gs/spring-boot-docker/</a></p>  <p>In IntelliJ I added new remote debug configuration and set port to 9081. If anyone has any ideas how I should configure this environment to work in debug mode I will be glad for any help.</p>  <p>If I manage to connect with debugger to my app, I also want to have some hot swap and static resources reload functionallity without need to recompile with maven and restart docker. So any help in this area also will be great but it isn't must to have.</p> ",
    "OwnerUserId": "1895422",
    "LastActivityDate": "2015-11-01T20:08:57.287",
    "Title": "debug spring boot in vagrant and docker",
    "Tags": "<docker><spring-boot><vagrant><remote-debugging>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Ok, I found my error, in vagrant file I has only port 8080 exposed from docker container. I has also two options -Xdebug -Xrunjdwp defined as single option in docker entrypoint. Correct Docker file looks like this:</p>  <pre><code>FROM java:8 VOLUME /tmp ADD simple-test-1.0-SNAPSHOT.jar app.jar ENTRYPOINT ['java', '-Djava.security.egd=file:/dev/./urandom', '-Xdebug', '-Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n', '-jar', '/app.jar'] </code></pre>  <p>And correct vagrant file:</p>  <pre><code>ENV['VAGRANT_DEFAULT_PROVIDER'] = 'docker'  Vagrant.configure('2') do |config|   config.vm.define 'app' do |a|     a.vm.provider 'docker' do |d|       d.vagrant_machine = 'dockerhost'       d.vagrant_vagrantfile = './Vagrant_docker_wrapper'       d.build_dir = '.'       d.build_args = ['-t=app']       d.ports = ['8080:8080', '8000:8000']       d.name = 'app'       d.remains_running = true       d.cmd = ['run']     end   end end </code></pre>  <p>Also, when I'm now connected via debugger to the server, I can hot swap java classes without problems (I didn't check static resources yet).</p> "
  },
  {
    "Id": "34534079",
    "PostTypeId": "1",
    "AcceptedAnswerId": "34598179",
    "CreationDate": "2015-12-30T17:19:16.623",
    "Score": "5",
    "ViewCount": "1495",
    "Body": "<p>I am docker file like this:</p>  <pre><code>FROM anapsix/alpine-java:jre8  ADD service-god-sac-1.0.0-SNAPSHOT.jar app.jar  ENTRYPOINT ['java', '-Xmx64m', '-XX:MaxMetaspaceSize=64m', '-jar', '/app.jar'] </code></pre>  <p>When I compile and deploy the app settint the time using this:</p>  <blockquote>   <p>-v /etc/localtime:/etc/localtime:ro</p> </blockquote>  <p>I notice that the host time and containter time are syncronized, but the logs of the app shows a diferent time, the UTC time. How can I sync the host machine, the container and the java app with the same time?</p> ",
    "OwnerUserId": "2217011",
    "LastEditorUserId": "2217011",
    "LastEditDate": "2015-12-30T17:37:08.843",
    "LastActivityDate": "2016-01-04T19:14:02.780",
    "Title": "How to sync the time of a java application running on docker container?",
    "Tags": "<java><docker><spring-boot><dockerfile><microservices>",
    "AnswerCount": "1",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>Mapping localtime and timezone works perfectly.</p>  <p>Example:</p>  <blockquote>   <p>docker run -d -v /var/lib/elasticsearch:/var/lib/elasticsearch -v   /etc/localtime:/etc/localtime:ro -v   /usr/share/zoneinfo/America/Buenos_Aires:/etc/timezone:ro -p 80:80/tcp   -p 9200:9200/tcp -p 514:514/udp petergrace/elk</p> </blockquote> ",
    "highest_rated_answer": null
  },
  {
    "Id": "38222513",
    "PostTypeId": "1",
    "AcceptedAnswerId": "38225027",
    "CreationDate": "2016-07-06T11:05:59.910",
    "Score": "5",
    "ViewCount": "3124",
    "Body": "<p>I'm trying to setup remote spring-boot environment using spring <a href='http://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html' rel='noreferrer'>devtools</a>, docker and IntelliJ. All started with this <a href='https://medium.com/@lhartikk/development-environment-in-spring-boot-with-docker-734ad6c50b34#.z27jyzita' rel='noreferrer'>article</a>. Unfortunately it randomly fails with an exception. Below the configuration:</p>  <p><strong>Dockerfile</strong></p>  <pre><code>FROM        java:8  EXPOSE      8888  WORKDIR     /app  ADD         build.gradle    /app/build.gradle ADD         gradlew         /app/gradlew ADD         gradle          /app/gradle  ADD         src             /app/src  RUN         ['chmod', '+x', '/app/gradlew'] </code></pre>  <p><strong>docker-compose.yml</strong></p>  <pre><code>backend:   build: .   env_file: environment   ports:     - '8888:8888'   volumes:     - ./.gradle-docker:/root/.gradle   command: '/app/gradlew clean bootRun'   links:     - db  db:   image:  postgres:9.5.3   env_file: environment   ports:     - '5454:5432' </code></pre>  <p>The whole application is started from command line with: <code>docker-compose build</code> and <code>docker-compose up</code> commands.</p>  <p>In IntelliJ I've prepared the following java application configuration: <a href='https://i.stack.imgur.com/v3Ucw.png' rel='noreferrer'><img src='https://i.stack.imgur.com/v3Ucw.png' alt='configuration'></a></p>  <p>where <code>docker:8888</code> is the IP of the docker-machine and port that is used by spring application. After the configuration is run is the following output:</p>  <pre><code>/\\\\ / ___'_ __ _ _(_)_ __  __ _          ___               _      \\ \\ \\ \\ ( ( )\\___ | '_ | '_| | '_ \\/ _` |        | _ \\___ _ __  ___| |_ ___ \\ \\ \\ \\ \\\\/  ___)| |_)| | | | | || (_| []::::::[]   / -_) '  \\/ _ \\  _/ -_) ) ) ) )  '  |____| .__|_| |_|_| |_\\__, |        |_|_\\___|_|_|_\\___/\\__\\___|/ / / / =========|_|==============|___/===================================/_/_/_/ :: Spring Boot Remote ::  (v1.3.5.RELEASE)  2016-07-06 12:48:51.997  INFO 17731 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Starting RemoteSpringApplication v1.3.5.RELEASE on opal-mac.local with PID 17731 (/Users/opal/.gradle/caches/modules-2/files-2.1/org.springframework.boot/spring-boot-devtools/1.3.5.RELEASE/ab035bdc1e6297ff4c8676edd93ed307b11353c2/spring-boot-devtools-1.3.5.RELEASE.jar started by opal in /Users/opal/projects/backend) 2016-07-06 12:48:52.013  INFO 17731 --- [           main] o.s.b.devtools.RemoteSpringApplication   : No active profile set, falling back to default profiles: default 2016-07-06 12:48:52.106  INFO 17731 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@441772e: startup date [Wed Jul 06 12:48:52 CEST 2016]; root of context hierarchy 2016-07-06 12:48:54.016  WARN 17731 --- [           main] o.s.b.d.r.c.RemoteClientConfiguration    : The connection to http://docker:8888 is insecure. You should use a URL starting with 'https://'. 2016-07-06 12:48:54.419  WARN 17731 --- [           main] o.s.b.d.a.OptionalLiveReloadServer       : Unable to start LiveReload server 2016-07-06 12:48:54.499  INFO 17731 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Started RemoteSpringApplication in 3.793 seconds (JVM running for 5.004) </code></pre>  <p>Unfortunately after some change is made to the code, the following exception occurs:</p>  <pre><code>2016-07-06 12:49:29.141  INFO 17731 --- [   File Watcher] o.s.b.d.r.c.ClassPathChangeUploader      : Uploaded 1 class resource 2016-07-06 12:49:31.056  INFO 17731 --- [   File Watcher] o.s.b.d.r.c.ClassPathChangeUploader      : Uploaded 1 class resource Exception in thread 'File Watcher' java.lang.IllegalStateException: java.net.ConnectException: Connection refused     at org.springframework.boot.devtools.remote.client.ClassPathChangeUploader.onApplicationEvent(ClassPathChangeUploader.java:107)     at org.springframework.boot.devtools.remote.client.ClassPathChangeUploader.onApplicationEvent(ClassPathChangeUploader.java:56)     at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:166)     at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:138)     at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:381)     at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:335)     at org.springframework.boot.devtools.classpath.ClassPathFileChangeListener.publishEvent(ClassPathFileChangeListener.java:68)     at org.springframework.boot.devtools.classpath.ClassPathFileChangeListener.onChange(ClassPathFileChangeListener.java:64)     at org.springframework.boot.devtools.filewatch.FileSystemWatcher.fireListeners(FileSystemWatcher.java:230)     at org.springframework.boot.devtools.filewatch.FileSystemWatcher.updateSnapshots(FileSystemWatcher.java:223)     at org.springframework.boot.devtools.filewatch.FileSystemWatcher.scan(FileSystemWatcher.java:183)     at org.springframework.boot.devtools.filewatch.FileSystemWatcher.access$100(FileSystemWatcher.java:41)     at org.springframework.boot.devtools.filewatch.FileSystemWatcher$1.run(FileSystemWatcher.java:150) Caused by: java.net.ConnectException: Connection refused     at java.net.PlainSocketImpl.socketConnect(Native Method)     at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)     at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)     at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)     at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)     at java.net.Socket.connect(Socket.java:589)     at java.net.Socket.connect(Socket.java:538)     at sun.net.NetworkClient.doConnect(NetworkClient.java:180)     at sun.net.www.http.HttpClient.openServer(HttpClient.java:432)     at sun.net.www.http.HttpClient.openServer(HttpClient.java:527)     at sun.net.www.http.HttpClient.&lt;init&gt;(HttpClient.java:211)     at sun.net.www.http.HttpClient.New(HttpClient.java:308)     at sun.net.www.http.HttpClient.New(HttpClient.java:326)     at sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1169)     at sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1105)     at sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:999)     at sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:933)     at org.springframework.http.client.SimpleBufferingClientHttpRequest.executeInternal(SimpleBufferingClientHttpRequest.java:80)     at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)     at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:53)     at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:93)     at org.springframework.boot.devtools.remote.client.HttpHeaderInterceptor.intercept(HttpHeaderInterceptor.java:57)     at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:85)     at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:69)     at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)     at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:53)     at org.springframework.boot.devtools.remote.client.ClassPathChangeUploader.onApplicationEvent(ClassPathChangeUploader.java:102)     ... 12 more </code></pre>  <p>In docker and IntelliJ:</p>  <pre><code>2016-07-06 12:49:29.141  INFO 17731 --- [   File Watcher] o.s.b.d.r.c.ClassPathChangeUploader      : Uploaded 1 class resource </code></pre>  <p>logs I see that the context is reloaded. What may be the problem? </p> ",
    "OwnerUserId": "542270",
    "LastActivityDate": "2016-07-06T13:15:47.817",
    "Title": "Exception on reloading remote spring boot application with Intellij IDEA",
    "Tags": "<macos><intellij-idea><docker><spring-boot><docker-machine>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>There's a <a href='https://github.com/spring-projects/spring-boot/issues/6339' rel='noreferrer'>bug</a> in Spring boot's DevTools which means that if you make a change to your application while the restart that was triggered by the previous change is still in progress, the attempt to upload the changes will fail. I think we probably need to update DevTools to retry the upload attempt.</p>  <p>In the meantime, the only 'solution' is to stop and restart your <code>RemoteSpringApplication</code> whenever you see the failure due to <code>java.net.ConnectException: Connection refused</code>.</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "39913816",
    "PostTypeId": "1",
    "CreationDate": "2016-10-07T09:22:58.077",
    "Score": "5",
    "ViewCount": "2572",
    "Body": "<p>At the moment I'm working on an application which will be based on the <strong>Micro Service architecture</strong>. As main technologies we planned to use <strong>Spring Boot and Docker</strong> for each Micro Service development. One of the goals is to provide Zero Downtime Deployment feature for the users. </p>  <p>I spent some time trying to found some solution and know about <code>Blue Green Deployment (BGD)</code> but some aspects is still not clear for me. The main problem is DataBase state and version compatibility. </p>  <blockquote>   <p>For example if <code>BGD</code> is used how to migrate all the data changes from   Green to Blue contour after successful deployment?</p> </blockquote>  <p>I found interesting approach in Spring's <a href='https://spring.io/blog/2016/05/31/zero-downtime-deployment-with-a-database' rel='noreferrer'>Zero Downtime Deployment with a Database</a> article, but I think that such approach has too complicated Application Versions and Releases Planing process and backward compatibility requirements.</p>  <p>So my I want to ask following questions:</p>  <ol> <li>Any suggestions on the Zero Downtime Deployment process concept, backed by real  experience using  it?</li> <li>Is there any Out Of The box solutions (Paid or Free)  that provide Zero Downtime Deployment feature for applications with Relational Data Base?</li> </ol>  <p><strong>PS</strong></p>  <p><em>It is interesting how Zero Downtime Deployment works in StackOverflow.com if it is?</em></p> ",
    "OwnerUserId": "6825250",
    "LastEditorUserId": "6825250",
    "LastEditDate": "2016-10-07T10:02:28.747",
    "LastActivityDate": "2016-10-07T10:15:37.193",
    "Title": "Zero Downtime Deployment for Micro Service architecture",
    "Tags": "<java><database><docker><spring-boot><microservices>",
    "AnswerCount": "1",
    "CommentCount": "4",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>From that article:</p>  <blockquote>   <ul>   <li>maintain two copies of your production environment (\u201cblue\u201d and \u201cgreen\u201d) </li>   <li>route all traffic to the the blue environment by mapping production URLs to it; </li>   <li>deploy and test any changes to the application in the green environment; </li>   <li>\u201cflip the switch\u201d by mapping URLs onto green and unmapping them from blue.</li>   </ul> </blockquote>  <p>It's actually not that difficult if you have the equipment and a good deployment process set up. If you've set up your security mechanisms so that the user doesn't need to start a new session in blue environment, the pain is almost entirely in the provisioning and ensuring the blue environment is in as perfect of a state as you want it to be. After that, it's just a matter of getting into your load balancer's configuration and flipping the settings to point to the blue environment.</p>  <p>But once you have 'green' and 'blue' up and running, you can flip back and forth. Ideally, once blue is verified, immediately upgrade green. Also, make sure you are sharing database operations between the two environments so green can also be a fallback for blue if blue fails.</p>  <p>Granted, my experience planning and helping with this was on Hadoop where you often have a formal data ingestion pipeline that can easily be configured to feed all new data to two completely separate environments.</p> "
  },
  {
    "Id": "39967945",
    "PostTypeId": "1",
    "CreationDate": "2016-10-10T22:53:52.573",
    "Score": "5",
    "ViewCount": "4195",
    "Body": "<p>I have a spring-boot app which talks to couchbase. I build the spring app as a docker image. There are some preconditions that need to be fulfilled in couchbase set up in order for the app to run. When I run my couchbase image first and then run my spring-boot app image everything runs fine. However, I need this to be automated and run from a docker-compose file meaning by a single docker-compose up command I should be able to run the couchbase image first, configure it with all presettings and then start to run the spring-boot app. I ran into quite a few discussion threads, but unfortunately I am not able to make it work somehow. I tried using cmd and entrypoint, but without success. Here is my docker-compose file</p>  <pre><code>version: '2' services:   expensetracker-cb:     image: chakrar27/expensetracker-cb     command: sh test_hello.sh     ports:       - 8080:8080     depends_on:       - mycouchbase    mycouchbase:     image: chakrar27/couchbase_new_10_08_2016     ports:       - 8091:8091       - 8092:8092        - 8093:8093        - 8094:8094       - 11210:11210 </code></pre>  <p>In fact it doesn't trigger the test_hello.sh at all. Here's the dockerfile for the spring-boot expensetracker app</p>  <pre><code>FROM frolvlad/alpine-oraclejdk8:slim VOLUME /tmp ADD expensetracker-cb-0.1.0.jar app.jar RUN sh -c 'touch /app.jar' ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre>  <p>Can someone please help? </p> ",
    "OwnerUserId": "2943994",
    "LastEditorUserId": "5237",
    "LastEditDate": "2019-11-12T16:07:07.140",
    "LastActivityDate": "2019-11-12T16:07:07.140",
    "Title": "How do i wait for a db container to be up before my spring-boot app starts",
    "Tags": "<spring-boot><docker><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Ok...I could get it working by including the script in the Dockerfile of the app container. Not the best solution because I feel waiting code should not be part of the container itself. Also, I need to find a way to wait for the couchbase cluster to be up and running with sample buckets and include that in the script or the couchbase container itself. For now though this work-around works for me. Here's the dockerfile contents</p>  <pre><code>FROM frolvlad/alpine-oraclejdk8:slim VOLUME /tmp ADD expensetracker-cb-0.1.0.jar app.jar RUN sh -c 'touch /app.jar' ADD test_hello.sh . RUN chmod +x test_hello.sh CMD sh test_hello.sh </code></pre> "
  },
  {
    "Id": "41181159",
    "PostTypeId": "1",
    "CreationDate": "2016-12-16T09:31:39.537",
    "Score": "5",
    "ViewCount": "1740",
    "Body": "<p>I have got a set of spring boot apps that I would like to package as docker containers. I am using the following Dockerfile to create the container for one of the services:</p>  <pre><code>FROM java:8 VOLUME /tmp ADD myservice.jar app.jar RUN bash -c 'touch /app.jar' ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre>  <p>Inside, the services access some environment properties like for instance:</p>  <pre><code>@Value('${my.test.param:default}')  String testParam; . . . logger.info('param value is = '+testParam); </code></pre>  <p>Now, I would like to be able to override this setting via <code>docker run</code> command line like this</p>  <pre><code>docker run -p 8080:8080 -e my.test.param=changed mygroup/myservice:0.0.1  </code></pre>  <p>Unfortunately, this doesn't seem to work. I keep seeing the default value for the parameter <code>my.test.param</code>. I searched for ways to automatically add all <code>-e</code> parameters at the end of the <code>ENTRYPOINT</code> line, but didn't find any. Is there some general solution for this?</p> ",
    "OwnerUserId": "3375378",
    "LastActivityDate": "2016-12-16T09:31:39.537",
    "Title": "passing command line parameters to spring boot services inside docker container",
    "Tags": "<spring><docker><spring-boot>",
    "AnswerCount": "0",
    "CommentCount": "2",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": null
  }
]