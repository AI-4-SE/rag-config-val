[
  {
    "Id": "43235946",
    "PostTypeId": "1",
    "CreationDate": "2017-04-05T15:47:57.290",
    "Score": "9",
    "ViewCount": "15951",
    "Body": "<p>Spring Boot doesn't read application properties when running in Docker container.</p>  <p>My <strong>application.yml</strong></p>  <pre><code>server:   port: 8080   context-path: /mail custom:   greeting: Hello YML </code></pre>  <p><strong>Dockerfile</strong></p>  <pre><code>FROM java:8-jre VOLUME /tmp COPY ./mail.jar /app/mail.jar RUN sh -c 'touch /app/mail.jar' ENV JAVA_OPTS='' ENTRYPOINT [ 'sh', '-c', 'java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app/mail.jar' ] EXPOSE 8080 </code></pre>  <p>And a simple <strong>ApplicationController</strong></p>  <pre><code>@RestController public class ApplicationController {    private final Environment environment;    @Autowired   public ApplicationController(Environment environment) {     this.environment = environment;   }    @RequestMapping(path = '/')   public Hello hello() {     final Hello hello = new Hello();     hello.setGreeting(environment.getProperty('custom.greeting'));     return hello;   } } </code></pre>  <p>I'm using IntelliJ Docker plugin that automatically map ports 8080(docker):18080(host) and makes app available on <strong>http://localhost:18080</strong></p>  <p><strong>Docker</strong></p>  <ol> <li>server.context-path property isn't applied. App still available with <strong>/</strong> and not with <strong>/mail/</strong></li> <li>custom.greeting property not reads from properties file and controller returns <strong>{'greeting':null}</strong> instead <strong>{'greeting':'Hello YML'}</strong></li> </ol>  <p><strong>Without Docker</strong></p>  <ol start='3'> <li><p>context-path applied properly</p></li> <li><p>custom.greeting property returns by controller properly</p></li> </ol> ",
    "OwnerUserId": "4611579",
    "LastActivityDate": "2020-11-23T14:05:37.003",
    "Title": "Spring Boot can't read application.properties in Docker",
    "Tags": "<spring><docker><intellij-idea><spring-boot><dockerfile>",
    "AnswerCount": "3",
    "CommentCount": "8",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "43313424",
    "PostTypeId": "1",
    "CreationDate": "2017-04-10T00:36:45.593",
    "Score": "9",
    "ViewCount": "1747",
    "Body": "<p>So we have Java microservices written with Spring-Boot, using Consul for service discovery and config management and running in Docker containers.  All of it is working, but when a container dies or a service restarts the old service-id never goes away in Consul and the service forever after shows as 'Failing' in the Consul UI, even though the new container has registered and shows all Green.</p>  <p>We are not using heartbeat - but I cannot find much documentation on what the difference between heartbeat and healthcheck are for Consul.</p>  <p>Here's my bootstrp.yml</p>  <pre><code>spring:   application:     name: my-service   cloud:     config:       enabled: false     consul:       host: ${discovery.host:localhost}       port: ${discovery.port:8500}       config:         watch:           wait-time: 30           delay: 10000          profile-separator: '-'         format: FILES       discovery:         prefer-ip-address: true         instanceId: ${spring.application.name}:${spring.application.instance_id:${random.value}} </code></pre>  <p>There are other settings to enable heartbeat, but the docs say something about this putting more stress on the Consul cluster.</p>  <p>Has anyone managed to get Consul and Spring Boot/Docker services to actually de-register automatically?  It actually doesn't cause any real problems, but it makes the Consul UI pretty useless to actually monitor for up/down services.</p> ",
    "OwnerUserId": "68612",
    "LastEditorUserId": "68612",
    "LastEditDate": "2017-04-18T23:44:33.180",
    "LastActivityDate": "2017-04-27T13:51:33.883",
    "Title": "Consul and Spring Boot services in Docker - not deregistering",
    "Tags": "<java><docker><spring-boot><microservices><consul>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "44738469",
    "PostTypeId": "1",
    "CreationDate": "2017-06-24T16:20:56.010",
    "Score": "9",
    "ViewCount": "7110",
    "Body": "<p>I have a spring cloud config server and packaged it as a docker image then I have spring cloud eureka server which is also packaged as docker image.</p>  <p>When I run the two using docker compose I get the following error.</p>  <p><code>discovery-service_1  | 2017-06-24 15:36:12.059  INFO 5 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Fetching config from server at: http://config-service:9001 discovery-service_1  | 2017-06-24 15:36:12.997  WARN 5 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Could not locate PropertySource: I/O error on GET request for 'http://config-service:9001/cls-discovery-service/default': Connection refused (Connection refused); nested exception is java.net.ConnectException: Connection refused (Connection refused) </code></p>  <blockquote>   <p>Although the config service is up and running successfully, discover service still does not find it for some reason.</p> </blockquote>  <p><strong>Docker compose file being used here is this</strong>  <code> version: '2' services:         config-service:                 image: cloudsea/cls-config-service                 ports:                 - 9001:9001                 expose:                 - '9001'         discovery-service:                 image: cloudsea/cls-discovery-service                 depends_on:                 - config-service                 environment:                         CLOUD_SEA_CONFIG_SERVER_URI: http://config-service:9001                         EUREKA_DEFAULT_ZONE_URL: http://discovery-service:8761/eureka/                 ports:                 - 8761:8761                 links:                 - config-service:config-service </code></p>  <p>Below is the <strong>bootstrap.properties</strong> for DISCOVERY SERVICE</p>  <p><code>spring.cloud.config.uri = ${CLOUD_SEA_CONFIG_SERVER_URI:http://localhost:9001} spring.application.name = ${SPRING_APPLICATION_NAME:cls-discovery-service} </code></p>  <p>Below is the <strong>cls-discovery-service.properties</strong> for DISCOVERY SERVICE located in github.</p>  <p><code>server.port=${SERVER_PORT:8761} eureka.client.registerWithEureka: false eureka.client.fetchRegistry: false eureka.client.serviceUrl.defaultZone: ${EUREKA_DEFAULT_ZONE_URL:http://localhost:8761/eureka/} eureka.server.eviction-interval-timer-in-ms: 1000 </code></p>  <p>I am assuming something is wrong with my docker-compose.yml but I am not sure.</p>  <p>Any help will I am stick in this for hours ... heading close to days :(</p> ",
    "OwnerUserId": "3058432",
    "LastActivityDate": "2018-02-06T23:23:47.990",
    "Title": "Spring Cloud Config Server not working with Docker compose",
    "Tags": "<spring-boot><docker-compose><spring-cloud><spring-cloud-netflix><spring-cloud-config>",
    "AnswerCount": "3",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "44738469",
    "PostTypeId": "1",
    "CreationDate": "2017-06-24T16:20:56.010",
    "Score": "9",
    "ViewCount": "7110",
    "Body": "<p>I have a spring cloud config server and packaged it as a docker image then I have spring cloud eureka server which is also packaged as docker image.</p>  <p>When I run the two using docker compose I get the following error.</p>  <p><code>discovery-service_1  | 2017-06-24 15:36:12.059  INFO 5 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Fetching config from server at: http://config-service:9001 discovery-service_1  | 2017-06-24 15:36:12.997  WARN 5 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Could not locate PropertySource: I/O error on GET request for 'http://config-service:9001/cls-discovery-service/default': Connection refused (Connection refused); nested exception is java.net.ConnectException: Connection refused (Connection refused) </code></p>  <blockquote>   <p>Although the config service is up and running successfully, discover service still does not find it for some reason.</p> </blockquote>  <p><strong>Docker compose file being used here is this</strong>  <code> version: '2' services:         config-service:                 image: cloudsea/cls-config-service                 ports:                 - 9001:9001                 expose:                 - '9001'         discovery-service:                 image: cloudsea/cls-discovery-service                 depends_on:                 - config-service                 environment:                         CLOUD_SEA_CONFIG_SERVER_URI: http://config-service:9001                         EUREKA_DEFAULT_ZONE_URL: http://discovery-service:8761/eureka/                 ports:                 - 8761:8761                 links:                 - config-service:config-service </code></p>  <p>Below is the <strong>bootstrap.properties</strong> for DISCOVERY SERVICE</p>  <p><code>spring.cloud.config.uri = ${CLOUD_SEA_CONFIG_SERVER_URI:http://localhost:9001} spring.application.name = ${SPRING_APPLICATION_NAME:cls-discovery-service} </code></p>  <p>Below is the <strong>cls-discovery-service.properties</strong> for DISCOVERY SERVICE located in github.</p>  <p><code>server.port=${SERVER_PORT:8761} eureka.client.registerWithEureka: false eureka.client.fetchRegistry: false eureka.client.serviceUrl.defaultZone: ${EUREKA_DEFAULT_ZONE_URL:http://localhost:8761/eureka/} eureka.server.eviction-interval-timer-in-ms: 1000 </code></p>  <p>I am assuming something is wrong with my docker-compose.yml but I am not sure.</p>  <p>Any help will I am stick in this for hours ... heading close to days :(</p> ",
    "OwnerUserId": "3058432",
    "LastActivityDate": "2018-02-06T23:23:47.990",
    "Title": "Spring Cloud Config Server not working with Docker compose",
    "Tags": "<spring-boot><docker-compose><spring-cloud><spring-cloud-netflix><spring-cloud-config>",
    "AnswerCount": "3",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "44738469",
    "PostTypeId": "1",
    "CreationDate": "2017-06-24T16:20:56.010",
    "Score": "9",
    "ViewCount": "7110",
    "Body": "<p>I have a spring cloud config server and packaged it as a docker image then I have spring cloud eureka server which is also packaged as docker image.</p>  <p>When I run the two using docker compose I get the following error.</p>  <p><code>discovery-service_1  | 2017-06-24 15:36:12.059  INFO 5 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Fetching config from server at: http://config-service:9001 discovery-service_1  | 2017-06-24 15:36:12.997  WARN 5 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Could not locate PropertySource: I/O error on GET request for 'http://config-service:9001/cls-discovery-service/default': Connection refused (Connection refused); nested exception is java.net.ConnectException: Connection refused (Connection refused) </code></p>  <blockquote>   <p>Although the config service is up and running successfully, discover service still does not find it for some reason.</p> </blockquote>  <p><strong>Docker compose file being used here is this</strong>  <code> version: '2' services:         config-service:                 image: cloudsea/cls-config-service                 ports:                 - 9001:9001                 expose:                 - '9001'         discovery-service:                 image: cloudsea/cls-discovery-service                 depends_on:                 - config-service                 environment:                         CLOUD_SEA_CONFIG_SERVER_URI: http://config-service:9001                         EUREKA_DEFAULT_ZONE_URL: http://discovery-service:8761/eureka/                 ports:                 - 8761:8761                 links:                 - config-service:config-service </code></p>  <p>Below is the <strong>bootstrap.properties</strong> for DISCOVERY SERVICE</p>  <p><code>spring.cloud.config.uri = ${CLOUD_SEA_CONFIG_SERVER_URI:http://localhost:9001} spring.application.name = ${SPRING_APPLICATION_NAME:cls-discovery-service} </code></p>  <p>Below is the <strong>cls-discovery-service.properties</strong> for DISCOVERY SERVICE located in github.</p>  <p><code>server.port=${SERVER_PORT:8761} eureka.client.registerWithEureka: false eureka.client.fetchRegistry: false eureka.client.serviceUrl.defaultZone: ${EUREKA_DEFAULT_ZONE_URL:http://localhost:8761/eureka/} eureka.server.eviction-interval-timer-in-ms: 1000 </code></p>  <p>I am assuming something is wrong with my docker-compose.yml but I am not sure.</p>  <p>Any help will I am stick in this for hours ... heading close to days :(</p> ",
    "OwnerUserId": "3058432",
    "LastActivityDate": "2018-02-06T23:23:47.990",
    "Title": "Spring Cloud Config Server not working with Docker compose",
    "Tags": "<spring-boot><docker-compose><spring-cloud><spring-cloud-netflix><spring-cloud-config>",
    "AnswerCount": "3",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "51768216",
    "PostTypeId": "1",
    "AcceptedAnswerId": "51769581",
    "CreationDate": "2018-08-09T13:22:18.877",
    "Score": "9",
    "ViewCount": "19101",
    "Body": "<p>I have created some services in spring boot, I have 11 fat jars and I deploy them in docker containers, my doubt was that every jar was consuming between 1 and 1.5 GB of RAM without any use, I check the RAM by running:</p>  <pre><code>docker stats containername </code></pre>  <p>At first I thought that it was the java container and I tried to change to one that uses alpine but nothing changed, so I think the only problem is my jar. Is there a way to change the RAM that the jar is using? Or this behavior is normal because every jar has an embedded tomcat? Or maybe is better to put some jars together and deploy them as war and use only one tomcat for a group of 'jars'? Can someone share his/her experience?,</p>  <p>Thanks in advance.</p> ",
    "OwnerUserId": "5121282",
    "LastEditorUserId": "2115836",
    "LastEditDate": "2019-03-15T09:54:47.457",
    "LastActivityDate": "2019-03-15T09:54:47.457",
    "Title": "Spring boot is consuming too much RAM",
    "Tags": "<docker><spring-boot>",
    "AnswerCount": "3",
    "CommentCount": "5",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "54773058",
    "PostTypeId": "1",
    "CreationDate": "2019-02-19T18:48:48.617",
    "Score": "9",
    "ViewCount": "9227",
    "Body": "<p>I have a Docker image for a spring boot 2 app, in the image I use spring.config.additional-location to pass a some properties stored in a file on the container itself.</p>  <p>Now I want to use this container in another as a layer in another container or use it in a docker-compose file and I may need to override the spring.config.additional-location.</p>  <p>I tried to override it in an ENV variable: <code>SPRING_CONFIG_ADDITIONAL-LOCATION</code> with no success.</p>  <p>What is the proper way to achieve this.</p> ",
    "OwnerUserId": "986437",
    "LastActivityDate": "2019-03-01T19:57:17.787",
    "Title": "spring.config.additional-location as environmental variable",
    "Tags": "<java><spring><spring-boot><docker>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "58853372",
    "PostTypeId": "1",
    "AcceptedAnswerId": "58853599",
    "CreationDate": "2019-11-14T09:27:45.480",
    "Score": "9",
    "ViewCount": "9609",
    "Body": "<pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ARG JAR_FILE COPY ${JAR_FILE} app.jar ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre>  <p>The above <code>Dockerfile</code> sample is from the official <a href='https://spring.io/guides/gs/spring-boot-docker/' rel='noreferrer'>Spring Boot guide</a> for docker. I would like to know what the security property is used for since I don't usually set that up when running the app on my local development environment but it seems to come up on various containerization guides. Cheers!</p> ",
    "OwnerUserId": "2480182",
    "LastActivityDate": "2020-05-09T21:46:06.053",
    "Title": "What exactly does '-Djava.security.egd=file:/dev/./urandom' do when containerizing a Spring Boot application",
    "Tags": "<spring><spring-boot><docker><spring-security><dockerfile>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "70085543",
    "PostTypeId": "1",
    "AcceptedAnswerId": "70094866",
    "CreationDate": "2021-11-23T17:48:13.257",
    "Score": "9",
    "ViewCount": "11644",
    "Body": "<p>I'm using testcontainer version <code>1.15.2</code>. Tests are run in intellij on windows 10. I have a wiremock container. By default it listens on the port <code>8080</code>. I would like to map this port to let's say <code>8081</code>. So I do:</p> <pre><code>public WiremockContainer() {     super(&quot;wiremock/wiremock:2.9.0-alpine&quot;);      self()             .waitingFor(Wait.forLogMessage(&quot;.*port:\\\\s*8080.*&quot;, 1)                     .withStartupTimeout(Duration.ofSeconds(25L)))             .withCreateContainerCmdModifier(cmd -&gt; cmd.getHostConfig()                     .withPortBindings(new PortBinding(Ports.Binding.bindPort(8081), new ExposedPort(8080)))             )             .withNetworkAliases(&quot;wiremock&quot;)             .withExposedPorts(8081); } </code></pre> <p>When the container is created it listens on the random port, not the <code>8081</code>[1]. What am I doing wrong ? What should I do to make the container listen on <code>8081</code> instead of the random port ?</p> <p>[1]</p> <ol> <li>I have another container that tries to connect on <code>http://wiremock:8081</code> and keep getting <code>Connection refused</code></li> <li>When I add: <code>.waitingFor((...)forPort(8081)(...)));</code> timeout occurs.</li> </ol> ",
    "OwnerUserId": "2010564",
    "LastEditorUserId": "2010564",
    "LastEditDate": "2021-11-24T12:03:11.203",
    "LastActivityDate": "2023-11-20T09:23:29.550",
    "Title": "Testcontainer cannot configure port binding",
    "Tags": "<java><spring-boot><testcontainers><docker-java><testcontainers-junit5>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "72263445",
    "PostTypeId": "1",
    "CreationDate": "2022-05-16T17:42:50.990",
    "Score": "9",
    "ViewCount": "31669",
    "Body": "<p>I am using a containerized Spring boot application in Kubernetes. But the application automatically exits and restarts with exit code 143 and error message &quot;Error&quot;.</p> <p>I am not sure how to identify the reason for this error.</p> <p>My first idea was that Kubernetes stopped the container due to too high resource usage, as described <a href='https://komodor.com/learn/exit-codes-in-containers-and-kubernetes-the-complete-guide/' rel='noreferrer'>here</a>, but I can't see the corresponding kubelet logs.</p> <p>Is there any way to identify the cause/origin of the <code>SIGTERM</code>? Maybe from spring-boot itself, or from the JVM?</p> ",
    "OwnerUserId": "12344281",
    "LastActivityDate": "2024-02-08T16:00:19.620",
    "Title": "Kubernetes Pod terminates with Exit Code 143",
    "Tags": "<spring-boot><docker><kubernetes><jvm><exit-code>",
    "AnswerCount": "4",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "37057772",
    "PostTypeId": "1",
    "AcceptedAnswerId": "37058838",
    "CreationDate": "2016-05-05T18:31:19.767",
    "Score": "8",
    "ViewCount": "27008",
    "Body": "<p>In my project, web app is developed using Spring boot with default tomcat server. I am using NGINX as load-balancer and have configured my spring-boot-web-app in NGINX configuration as follows:</p>  <pre><code>location /spring-boot-web-app {      proxy_pass http://spring-boot-web-app/ }  http {     upstream /spring-boot-web-app {         server &lt;IP_of_spring_boot_app&gt;:&lt;Port_of_spring_boot_app&gt;     } } </code></pre>  <p>Now lets say NGINX IP and port as <strong>nginx_ip</strong> and <strong>nginx_port</strong> respectively. Also working URL for my web app as: <strong><a href='http://web_app_ip:web_app_port/rest/echo/hi' rel='noreferrer'>http://web_app_ip:web_app_port/rest/echo/hi</a></strong></p>  <p>The above URL works fine. But when i try to hit same URI via NGINX it throws 404. URL used via NGINX as:  <a href='http://nginx_ip:nginx_port/spring-boot-web-app/rest/echo/hi' rel='noreferrer'>http://nginx_ip:nginx_port/spring-boot-web-app/rest/echo/hi</a></p>  <p>Is there something i am missing?</p> ",
    "OwnerUserId": "4318036",
    "LastEditorUserId": "1986826",
    "LastEditDate": "2016-05-05T20:35:50.650",
    "LastActivityDate": "2017-01-04T13:10:28.913",
    "Title": "Spring Boot and Nginx integration",
    "Tags": "<nginx><docker><spring-boot><reverse-proxy><proxypass>",
    "AnswerCount": "1",
    "CommentCount": "8",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "39217402",
    "PostTypeId": "1",
    "CreationDate": "2016-08-30T01:12:30.090",
    "Score": "8",
    "ViewCount": "26857",
    "Body": "<p>I am novice to Spring Boot Microservices and Docker.</p> <p>The dockerfile in microservice project:</p> <p><a href='https://i.stack.imgur.com/3TYtK.png' rel='noreferrer'><img src='https://i.stack.imgur.com/3TYtK.png' alt='dockerfile' /></a></p> <p>docker build:</p> <p><a href='https://i.stack.imgur.com/iB8fT.png' rel='noreferrer'><img src='https://i.stack.imgur.com/iB8fT.png' alt='docker build' /></a></p> <p>docker images:</p> <p><a href='https://i.stack.imgur.com/ZZ427.png' rel='noreferrer'><img src='https://i.stack.imgur.com/ZZ427.png' alt='docker images' /></a></p> <p>when running the image, there is an error: Unable to access jarfile register_server.jar</p> <p><a href='https://i.stack.imgur.com/hF9eX.png' rel='noreferrer'><img src='https://i.stack.imgur.com/hF9eX.png' alt='error' /></a></p> <p>Cheers, Sean</p> ",
    "OwnerUserId": "1766812",
    "LastEditorUserId": "-1",
    "LastEditDate": "2020-06-20T09:12:55.060",
    "LastActivityDate": "2019-01-17T18:10:23.123",
    "Title": "Unable to access jarfile when running Docker image",
    "Tags": "<spring><docker><spring-boot>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "39894788",
    "PostTypeId": "1",
    "CreationDate": "2016-10-06T11:28:17.053",
    "Score": "8",
    "ViewCount": "5657",
    "Body": "<p>I'm Facing a FileNotFoundException while loading a JSON file which is in class path of Java jar using docker containers, it is a Spring-Boot application. This JSON file is available in resource folder . I'm Able to see the JSON file in docker under ./target/classes/ path.</p>  <pre><code>Resource resource = resourceLoader.getResource('classpath:folderNm/file.json'); HashMap&lt;String, String&gt; headerMapping = (HashMap&lt;String, String&gt;) parser.parse(new FileReader(resource.getFile().getAbsolutePath())); </code></pre>  <p>But I get this exception:</p>  <pre><code>java.io.FileNotFoundException: class path resource [folderNm/file.json] cannot be resolved to absolute file path because it does not reside in the file system: jar:file:/app.jar!/folderNm/file.json </code></pre>  <p>I tried</p>  <p>-> <code>resource.getFile().getPath();</code> -> <code>resource.getFile().getCanonicalPath();</code> -> '<code>./target/classes/folderName/fileName</code>' (hardcoded FilePath location) -> '<code>/app.jar!/folderNm/file.json</code>' (hardcoded FilePath location)</p>  <pre><code>InputStream inputStream = getClass().getResourceAsStream('xyz.json'); BufferedReader br = new BufferedReader(new InputStreamReader(inputStream, 'UTF-8'));             StringBuilder responseStrBuilder = new StringBuilder();             String inputStr;             while ((inputStr = br.readLine()) != null)                 responseStrBuilder.append(inputStr); </code></pre>  <p>none of the way above are running. Kindly Suggest a way to resolve this issue.</p> ",
    "OwnerUserId": "2324149",
    "LastEditorUserId": "57135",
    "LastEditDate": "2018-02-28T17:12:57.647",
    "LastActivityDate": "2018-02-28T17:12:57.647",
    "Title": "Facing FileNotFoundException while accessing JSON File in classpath using java in docker containers(SprintBootApplication)",
    "Tags": "<java><json><linux><docker><spring-boot>",
    "AnswerCount": "2",
    "CommentCount": "5",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "44125915",
    "PostTypeId": "1",
    "CreationDate": "2017-05-23T04:38:27.997",
    "Score": "8",
    "ViewCount": "16961",
    "Body": "<p>I have a spring boot application that connects to a mongo db and deployed the app with docker.  I am using this docker-compose.yml file, which works fine:</p>  <pre><code>version: '2' services:   db:       container_name: app-db       image: mongo       volumes:         - /data/db:/data/db       ports:         - 27017:27017   web:     container_name: spring-app     image: spring-app     depends_on:       - db     environment:       SPRING_DATA_MONGODB_URI: mongodb://db:27017/appDB       SPRING_DATA_MONGODB_HOST: db     ports:       - 8080:8080 </code></pre>  <p>Currently, the app is using the application.properties file embedded in the spring app docker image (spring-app).  How do I externalize / pass-in the application.properties file using docker-compose?</p>  <p>Thank you for your help</p> ",
    "OwnerUserId": "107216",
    "LastActivityDate": "2020-07-16T23:38:45.787",
    "Title": "docker-compose - externalize spring application.properties",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "44125915",
    "PostTypeId": "1",
    "CreationDate": "2017-05-23T04:38:27.997",
    "Score": "8",
    "ViewCount": "16961",
    "Body": "<p>I have a spring boot application that connects to a mongo db and deployed the app with docker.  I am using this docker-compose.yml file, which works fine:</p>  <pre><code>version: '2' services:   db:       container_name: app-db       image: mongo       volumes:         - /data/db:/data/db       ports:         - 27017:27017   web:     container_name: spring-app     image: spring-app     depends_on:       - db     environment:       SPRING_DATA_MONGODB_URI: mongodb://db:27017/appDB       SPRING_DATA_MONGODB_HOST: db     ports:       - 8080:8080 </code></pre>  <p>Currently, the app is using the application.properties file embedded in the spring app docker image (spring-app).  How do I externalize / pass-in the application.properties file using docker-compose?</p>  <p>Thank you for your help</p> ",
    "OwnerUserId": "107216",
    "LastActivityDate": "2020-07-16T23:38:45.787",
    "Title": "docker-compose - externalize spring application.properties",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "44125915",
    "PostTypeId": "1",
    "CreationDate": "2017-05-23T04:38:27.997",
    "Score": "8",
    "ViewCount": "16961",
    "Body": "<p>I have a spring boot application that connects to a mongo db and deployed the app with docker.  I am using this docker-compose.yml file, which works fine:</p>  <pre><code>version: '2' services:   db:       container_name: app-db       image: mongo       volumes:         - /data/db:/data/db       ports:         - 27017:27017   web:     container_name: spring-app     image: spring-app     depends_on:       - db     environment:       SPRING_DATA_MONGODB_URI: mongodb://db:27017/appDB       SPRING_DATA_MONGODB_HOST: db     ports:       - 8080:8080 </code></pre>  <p>Currently, the app is using the application.properties file embedded in the spring app docker image (spring-app).  How do I externalize / pass-in the application.properties file using docker-compose?</p>  <p>Thank you for your help</p> ",
    "OwnerUserId": "107216",
    "LastActivityDate": "2020-07-16T23:38:45.787",
    "Title": "docker-compose - externalize spring application.properties",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "44157039",
    "PostTypeId": "1",
    "CreationDate": "2017-05-24T11:26:58.923",
    "Score": "8",
    "ViewCount": "3335",
    "Body": "<p>I want to configure my spring interceptor in such a way that with every request it should get called.</p>  <ul> <li>I am using interceptor in API-GATEWAY <strong>(Spring-Boot)</strong></li> <li>From API-GATEWAY I am calling other microservices.</li> <li>The call's to other microservices from API-GATEWAY is working fine.</li> <li>Other Services which I am calling are Node.js Service, on the other hand, my API-Gateway is in spring boot.</li> <li>All the services (Node.js + Spring-Boot) are running on <strong>Docker Container</strong>.</li> </ul>  <p>I am facing an issue in Interceptor. I want to configure it in such a way that with every request it should be called the <code>preHandle()</code> and perform the operations that I have written in it.</p>  <p>I have notice one issue that I want to mention here.</p>  <p><strong>If the services which I am calling is stopped (Not Running), Interceptor is working properly and giving me a response like somename-service not found. If the same services are running at this time Interceptor is not executed.</strong></p>  <p>Here is my code snippet </p>  <pre><code>@EnableEurekaClient @SpringBootApplication @EnableZuulProxy @Configuration public class Application extends WebMvcConfigurerAdapter {      public static void main(String[] args) {         SpringApplication.run(Application.class, args);     }      @Autowired     private TokenValidateInterceptor tokenValidateInterceptor;      @Override     public void addInterceptors(InterceptorRegistry registry) {          registry.addInterceptor(tokenValidateInterceptor).addPathPatterns('/**');       } </code></pre>  <p>Interceptor </p>  <pre><code>@Component public class TokenValidateInterceptor extends HandlerInterceptorAdapter {       @Override     public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {         LOG.info('#### Starting TokenValidateInterceptor.preHandle ####');          String apiKey = null;         try {             apiKey = request.getHeader('apikey');              LOG.info('The request come with apikey ======' + apiKey);              LOG.info('Actual apikey ======' + azureApikey);   } </code></pre> ",
    "OwnerUserId": "7789526",
    "LastEditorUserId": "7789526",
    "LastEditDate": "2017-05-25T13:38:26.887",
    "LastActivityDate": "2020-08-10T12:15:30.360",
    "Title": "How to configure spring interceptor to get called with every request",
    "Tags": "<java><node.js><docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "44157039",
    "PostTypeId": "1",
    "CreationDate": "2017-05-24T11:26:58.923",
    "Score": "8",
    "ViewCount": "3335",
    "Body": "<p>I want to configure my spring interceptor in such a way that with every request it should get called.</p>  <ul> <li>I am using interceptor in API-GATEWAY <strong>(Spring-Boot)</strong></li> <li>From API-GATEWAY I am calling other microservices.</li> <li>The call's to other microservices from API-GATEWAY is working fine.</li> <li>Other Services which I am calling are Node.js Service, on the other hand, my API-Gateway is in spring boot.</li> <li>All the services (Node.js + Spring-Boot) are running on <strong>Docker Container</strong>.</li> </ul>  <p>I am facing an issue in Interceptor. I want to configure it in such a way that with every request it should be called the <code>preHandle()</code> and perform the operations that I have written in it.</p>  <p>I have notice one issue that I want to mention here.</p>  <p><strong>If the services which I am calling is stopped (Not Running), Interceptor is working properly and giving me a response like somename-service not found. If the same services are running at this time Interceptor is not executed.</strong></p>  <p>Here is my code snippet </p>  <pre><code>@EnableEurekaClient @SpringBootApplication @EnableZuulProxy @Configuration public class Application extends WebMvcConfigurerAdapter {      public static void main(String[] args) {         SpringApplication.run(Application.class, args);     }      @Autowired     private TokenValidateInterceptor tokenValidateInterceptor;      @Override     public void addInterceptors(InterceptorRegistry registry) {          registry.addInterceptor(tokenValidateInterceptor).addPathPatterns('/**');       } </code></pre>  <p>Interceptor </p>  <pre><code>@Component public class TokenValidateInterceptor extends HandlerInterceptorAdapter {       @Override     public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {         LOG.info('#### Starting TokenValidateInterceptor.preHandle ####');          String apiKey = null;         try {             apiKey = request.getHeader('apikey');              LOG.info('The request come with apikey ======' + apiKey);              LOG.info('Actual apikey ======' + azureApikey);   } </code></pre> ",
    "OwnerUserId": "7789526",
    "LastEditorUserId": "7789526",
    "LastEditDate": "2017-05-25T13:38:26.887",
    "LastActivityDate": "2020-08-10T12:15:30.360",
    "Title": "How to configure spring interceptor to get called with every request",
    "Tags": "<java><node.js><docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "44157039",
    "PostTypeId": "1",
    "CreationDate": "2017-05-24T11:26:58.923",
    "Score": "8",
    "ViewCount": "3335",
    "Body": "<p>I want to configure my spring interceptor in such a way that with every request it should get called.</p>  <ul> <li>I am using interceptor in API-GATEWAY <strong>(Spring-Boot)</strong></li> <li>From API-GATEWAY I am calling other microservices.</li> <li>The call's to other microservices from API-GATEWAY is working fine.</li> <li>Other Services which I am calling are Node.js Service, on the other hand, my API-Gateway is in spring boot.</li> <li>All the services (Node.js + Spring-Boot) are running on <strong>Docker Container</strong>.</li> </ul>  <p>I am facing an issue in Interceptor. I want to configure it in such a way that with every request it should be called the <code>preHandle()</code> and perform the operations that I have written in it.</p>  <p>I have notice one issue that I want to mention here.</p>  <p><strong>If the services which I am calling is stopped (Not Running), Interceptor is working properly and giving me a response like somename-service not found. If the same services are running at this time Interceptor is not executed.</strong></p>  <p>Here is my code snippet </p>  <pre><code>@EnableEurekaClient @SpringBootApplication @EnableZuulProxy @Configuration public class Application extends WebMvcConfigurerAdapter {      public static void main(String[] args) {         SpringApplication.run(Application.class, args);     }      @Autowired     private TokenValidateInterceptor tokenValidateInterceptor;      @Override     public void addInterceptors(InterceptorRegistry registry) {          registry.addInterceptor(tokenValidateInterceptor).addPathPatterns('/**');       } </code></pre>  <p>Interceptor </p>  <pre><code>@Component public class TokenValidateInterceptor extends HandlerInterceptorAdapter {       @Override     public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {         LOG.info('#### Starting TokenValidateInterceptor.preHandle ####');          String apiKey = null;         try {             apiKey = request.getHeader('apikey');              LOG.info('The request come with apikey ======' + apiKey);              LOG.info('Actual apikey ======' + azureApikey);   } </code></pre> ",
    "OwnerUserId": "7789526",
    "LastEditorUserId": "7789526",
    "LastEditDate": "2017-05-25T13:38:26.887",
    "LastActivityDate": "2020-08-10T12:15:30.360",
    "Title": "How to configure spring interceptor to get called with every request",
    "Tags": "<java><node.js><docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "44689202",
    "PostTypeId": "1",
    "AcceptedAnswerId": "45233417",
    "CreationDate": "2017-06-22T02:34:26.467",
    "Score": "8",
    "ViewCount": "9364",
    "Body": "<p>I have several microservices running in Docker Data Center. I have the same Eureka configuration across the services/applications. But some of the applications are registering with their <code>eth0</code> IP address instead of the container ID. </p>  <p>I have tried setting the <code>preferIpAddress</code> as <code>false</code> but it is not enforcing all the time.</p>  <p>There is no pattern. The same service which registers with container ID during the previous deployment gets registered with IP the other time. I want my services to register always with its container id. Is there a way to enforce it or am I missing something?</p>  <p>Note: I have also cleared all the old docker images from the registry, deployment nodes and tried from the scratch as well.</p>  <p>Eureka Server Config:</p>  <pre><code>eureka:   instance:     hostname: discovery   client:     registerWithEureka: false     fetchRegistry: false     serviceUrl:       defaultZone: http://${eureka.instance.hostname}:8761/eureka/ </code></pre>  <p>Microservices client config (It is same across all the microservices)</p>  <pre><code>eureka:   client:     healthcheck:       enabled: true     serviceUrl:       defaultZone: http://discovery:8761/eureka/   instance:     preferIpAddress: false     metadataMap:       instanceId: ${vcap.application.instance_id:${spring.application.name}:${spring.application.instance_id:${random.value}}} </code></pre>  <p>Eureka Dashboard Snapshot: <a href='https://i.stack.imgur.com/wlBLF.png' rel='nofollow noreferrer'><img src='https://i.stack.imgur.com/wlBLF.png' alt='enter image description here'></a></p> ",
    "OwnerUserId": "2498986",
    "LastEditorUserId": "1033581",
    "LastEditDate": "2018-11-02T10:54:58.280",
    "LastActivityDate": "2021-11-29T01:07:05.323",
    "Title": "Springboot client unable register with Eureka using Docker container id",
    "Tags": "<docker><spring-boot><spring-cloud><netflix-eureka>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "47266795",
    "PostTypeId": "1",
    "AcceptedAnswerId": "50781480",
    "CreationDate": "2017-11-13T14:34:43.837",
    "Score": "8",
    "ViewCount": "8110",
    "Body": "<p>I took this example <a href='https://github.com/paulc4/microservices-demo' rel='noreferrer'>https://github.com/paulc4/microservices-demo</a> and I created 3 docker images from it, with the following Dockerfiles:</p>  <p>springdocker-registration:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ADD target/microservice-demo-1.1.0.RELEASE.jar app.jar EXPOSE 1111 ENTRYPOINT exec java -jar /app.jar registration </code></pre>  <p>springdocker-accounts:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ADD target/microservice-demo-1.1.0.RELEASE.jar app.jar EXPOSE 2222 ENTRYPOINT exec java -jar /app.jar accounts </code></pre>  <p>springdocker-web:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ADD target/microservice-demo-1.1.0.RELEASE.jar app.jar EXPOSE 3333 ENTRYPOINT exec java -jar /app.jar web </code></pre>  <p>If I run the three images separately everything works ok, the <code>web</code> and <code>accounts</code> services register to the <code>registration</code> service (which is an implementation of the eureka registry) and I can use my application. However when using <code>docker-compose</code> with the following <code>docker-compose.yml</code> file</p>  <pre><code>version: '3.4' services:  registration:   image: springdocker-registration   ports:    - '1111:1111'   accounts:   image: springdocker-accounts   ports:    - '2222:2222'   links:    - registration   depends_on:    - registration   web:   image: springdocker-web   ports:    - '3333:3333'   depends_on:    - registration    - accounts   links:    - registration </code></pre>  <p>the services <code>web</code> and <code>accounts</code> are not able to register to the <code>registration</code> service. Here are the configuration files for the applications:</p>  <p>registration-server.yml:</p>  <pre><code>eureka:   instance:     hostname: localhost   client:       registerWithEureka: false     fetchRegistry: false     serviceUrl:      defaultZone: http://localhost:1111/eureka/  server:   port: 1111     spring:   thymeleaf:     enabled: false  </code></pre>  <p>accounts-server.yml:</p>  <pre><code>spring:   application:      name: accounts-service     freemarker:     enabled: false              thymeleaf:     cache: false                 prefix: classpath:/accounts-server/templates/      error:   path: /error  server:   port: 2222     eureka:   client:     serviceUrl:       defaultZone: http://localhost:1111/eureka   instance:     leaseRenewalIntervalInSeconds: 5        preferIpAddress: true </code></pre>  <p>web-server.yml</p>  <pre><code>spring:   application:     name: web-service    freemarker:     enabled: false        thymeleaf:     cache: false            prefix: classpath:/web-server/templates/     error:   path: /error  eureka:   client:     serviceUrl:       defaultZone: http://localhost:1111/eureka   instance:     leaseRenewalIntervalInSeconds: 5      preferIpAddress: true  server:   port: 3333   </code></pre>  <p>I can post the full console log of <code>docker-compose up</code> but I think this is the interesting point:</p>  <pre><code>1: ERROR RedirectingEurekaHttpClient - Request execution error com.sun.jersey.api.client.ClientHandlerException: java.net.ConnectException: Connection refused (Connection refused)  1: ERROR DiscoveryClient - DiscoveryClient_WEB-SERVICE/e3b5e6b3396c:web-service:3333 - was unable to refresh its cache! status = Cannot execute request on any known server com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server </code></pre> ",
    "OwnerUserId": "1534252",
    "LastEditorUserId": "1534252",
    "LastEditDate": "2017-11-14T08:36:09.360",
    "LastActivityDate": "2020-05-02T19:12:28.273",
    "Title": "Applications not registering to eureka when using docker-compose",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "47266795",
    "PostTypeId": "1",
    "AcceptedAnswerId": "50781480",
    "CreationDate": "2017-11-13T14:34:43.837",
    "Score": "8",
    "ViewCount": "8110",
    "Body": "<p>I took this example <a href='https://github.com/paulc4/microservices-demo' rel='noreferrer'>https://github.com/paulc4/microservices-demo</a> and I created 3 docker images from it, with the following Dockerfiles:</p>  <p>springdocker-registration:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ADD target/microservice-demo-1.1.0.RELEASE.jar app.jar EXPOSE 1111 ENTRYPOINT exec java -jar /app.jar registration </code></pre>  <p>springdocker-accounts:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ADD target/microservice-demo-1.1.0.RELEASE.jar app.jar EXPOSE 2222 ENTRYPOINT exec java -jar /app.jar accounts </code></pre>  <p>springdocker-web:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ADD target/microservice-demo-1.1.0.RELEASE.jar app.jar EXPOSE 3333 ENTRYPOINT exec java -jar /app.jar web </code></pre>  <p>If I run the three images separately everything works ok, the <code>web</code> and <code>accounts</code> services register to the <code>registration</code> service (which is an implementation of the eureka registry) and I can use my application. However when using <code>docker-compose</code> with the following <code>docker-compose.yml</code> file</p>  <pre><code>version: '3.4' services:  registration:   image: springdocker-registration   ports:    - '1111:1111'   accounts:   image: springdocker-accounts   ports:    - '2222:2222'   links:    - registration   depends_on:    - registration   web:   image: springdocker-web   ports:    - '3333:3333'   depends_on:    - registration    - accounts   links:    - registration </code></pre>  <p>the services <code>web</code> and <code>accounts</code> are not able to register to the <code>registration</code> service. Here are the configuration files for the applications:</p>  <p>registration-server.yml:</p>  <pre><code>eureka:   instance:     hostname: localhost   client:       registerWithEureka: false     fetchRegistry: false     serviceUrl:      defaultZone: http://localhost:1111/eureka/  server:   port: 1111     spring:   thymeleaf:     enabled: false  </code></pre>  <p>accounts-server.yml:</p>  <pre><code>spring:   application:      name: accounts-service     freemarker:     enabled: false              thymeleaf:     cache: false                 prefix: classpath:/accounts-server/templates/      error:   path: /error  server:   port: 2222     eureka:   client:     serviceUrl:       defaultZone: http://localhost:1111/eureka   instance:     leaseRenewalIntervalInSeconds: 5        preferIpAddress: true </code></pre>  <p>web-server.yml</p>  <pre><code>spring:   application:     name: web-service    freemarker:     enabled: false        thymeleaf:     cache: false            prefix: classpath:/web-server/templates/     error:   path: /error  eureka:   client:     serviceUrl:       defaultZone: http://localhost:1111/eureka   instance:     leaseRenewalIntervalInSeconds: 5      preferIpAddress: true  server:   port: 3333   </code></pre>  <p>I can post the full console log of <code>docker-compose up</code> but I think this is the interesting point:</p>  <pre><code>1: ERROR RedirectingEurekaHttpClient - Request execution error com.sun.jersey.api.client.ClientHandlerException: java.net.ConnectException: Connection refused (Connection refused)  1: ERROR DiscoveryClient - DiscoveryClient_WEB-SERVICE/e3b5e6b3396c:web-service:3333 - was unable to refresh its cache! status = Cannot execute request on any known server com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server </code></pre> ",
    "OwnerUserId": "1534252",
    "LastEditorUserId": "1534252",
    "LastEditDate": "2017-11-14T08:36:09.360",
    "LastActivityDate": "2020-05-02T19:12:28.273",
    "Title": "Applications not registering to eureka when using docker-compose",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "47266795",
    "PostTypeId": "1",
    "AcceptedAnswerId": "50781480",
    "CreationDate": "2017-11-13T14:34:43.837",
    "Score": "8",
    "ViewCount": "8110",
    "Body": "<p>I took this example <a href='https://github.com/paulc4/microservices-demo' rel='noreferrer'>https://github.com/paulc4/microservices-demo</a> and I created 3 docker images from it, with the following Dockerfiles:</p>  <p>springdocker-registration:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ADD target/microservice-demo-1.1.0.RELEASE.jar app.jar EXPOSE 1111 ENTRYPOINT exec java -jar /app.jar registration </code></pre>  <p>springdocker-accounts:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ADD target/microservice-demo-1.1.0.RELEASE.jar app.jar EXPOSE 2222 ENTRYPOINT exec java -jar /app.jar accounts </code></pre>  <p>springdocker-web:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ADD target/microservice-demo-1.1.0.RELEASE.jar app.jar EXPOSE 3333 ENTRYPOINT exec java -jar /app.jar web </code></pre>  <p>If I run the three images separately everything works ok, the <code>web</code> and <code>accounts</code> services register to the <code>registration</code> service (which is an implementation of the eureka registry) and I can use my application. However when using <code>docker-compose</code> with the following <code>docker-compose.yml</code> file</p>  <pre><code>version: '3.4' services:  registration:   image: springdocker-registration   ports:    - '1111:1111'   accounts:   image: springdocker-accounts   ports:    - '2222:2222'   links:    - registration   depends_on:    - registration   web:   image: springdocker-web   ports:    - '3333:3333'   depends_on:    - registration    - accounts   links:    - registration </code></pre>  <p>the services <code>web</code> and <code>accounts</code> are not able to register to the <code>registration</code> service. Here are the configuration files for the applications:</p>  <p>registration-server.yml:</p>  <pre><code>eureka:   instance:     hostname: localhost   client:       registerWithEureka: false     fetchRegistry: false     serviceUrl:      defaultZone: http://localhost:1111/eureka/  server:   port: 1111     spring:   thymeleaf:     enabled: false  </code></pre>  <p>accounts-server.yml:</p>  <pre><code>spring:   application:      name: accounts-service     freemarker:     enabled: false              thymeleaf:     cache: false                 prefix: classpath:/accounts-server/templates/      error:   path: /error  server:   port: 2222     eureka:   client:     serviceUrl:       defaultZone: http://localhost:1111/eureka   instance:     leaseRenewalIntervalInSeconds: 5        preferIpAddress: true </code></pre>  <p>web-server.yml</p>  <pre><code>spring:   application:     name: web-service    freemarker:     enabled: false        thymeleaf:     cache: false            prefix: classpath:/web-server/templates/     error:   path: /error  eureka:   client:     serviceUrl:       defaultZone: http://localhost:1111/eureka   instance:     leaseRenewalIntervalInSeconds: 5      preferIpAddress: true  server:   port: 3333   </code></pre>  <p>I can post the full console log of <code>docker-compose up</code> but I think this is the interesting point:</p>  <pre><code>1: ERROR RedirectingEurekaHttpClient - Request execution error com.sun.jersey.api.client.ClientHandlerException: java.net.ConnectException: Connection refused (Connection refused)  1: ERROR DiscoveryClient - DiscoveryClient_WEB-SERVICE/e3b5e6b3396c:web-service:3333 - was unable to refresh its cache! status = Cannot execute request on any known server com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server </code></pre> ",
    "OwnerUserId": "1534252",
    "LastEditorUserId": "1534252",
    "LastEditDate": "2017-11-14T08:36:09.360",
    "LastActivityDate": "2020-05-02T19:12:28.273",
    "Title": "Applications not registering to eureka when using docker-compose",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "47321197",
    "PostTypeId": "1",
    "CreationDate": "2017-11-16T03:42:07.823",
    "Score": "8",
    "ViewCount": "6901",
    "Body": "<p>Deploy <code>Spring Cloud</code> project with <code>docker</code>, some code in the <code>pom.xml</code>:</p>  <pre><code>&lt;build&gt;         &lt;plugins&gt;             &lt;plugin&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;             &lt;/plugin&gt;             &lt;!-- tag::plugin[] --&gt;             &lt;plugin&gt;                 &lt;groupId&gt;com.spotify&lt;/groupId&gt;                 &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;                 &lt;version&gt;0.4.3&lt;/version&gt;                 &lt;configuration&gt;                     &lt;imageName&gt;${docker.image.prefix}/${project.artifactId}&lt;/imageName&gt;                     &lt;dockerDirectory&gt;${project.basedir}&lt;/dockerDirectory&gt;                     &lt;resources&gt;                         &lt;resource&gt;                             &lt;targetPath&gt;/&lt;/targetPath&gt;                             &lt;directory&gt;${project.build.directory}&lt;/directory&gt;                             &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;                         &lt;/resource&gt;                     &lt;/resources&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt;             &lt;!-- end::plugin[] --&gt;              &lt;plugin&gt;                 &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                 &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;                 &lt;configuration&gt;                     &lt;skipTests&gt;true&lt;/skipTests&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt;         &lt;/plugins&gt;     &lt;/build&gt; </code></pre>  <p>when i run the command: <code>mvn package docker:build</code>, it throws errors:</p>  <pre><code>[INFO] ------------------------------------------------------------------------ [ERROR] Failed to execute goal com.spotify:docker-maven-plugin:0.4.3:build (default) on project users-microservice: Exception caught: java.util.concurrent.ExecutionException: com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: org.apache.http.conn.HttpHostConnectException: Connect to localhost:2375 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused -&gt; [Help 1] [ERROR] [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch. [ERROR] Re-run Maven using the -X switch to enable full debug logging. [ERROR] [ERROR] For more information about the errors and possible solutions, please read the following articles: [ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException [ERROR] [ERROR] After correcting the problems, you can resume the build with the command </code></pre>  <p>why will it connect to localhost:2375? Any idea, i will appreciate!</p> ",
    "OwnerUserId": "5443977",
    "LastEditorUserId": "5443977",
    "LastEditDate": "2017-11-17T03:13:11.887",
    "LastActivityDate": "2017-11-25T09:33:56.050",
    "Title": "Failed to execute goal com.spotify:docker-maven-plugin:0.4.3:build Exception caught: HttpHostConnectException: Connect to localhost:2375",
    "Tags": "<docker><spring-boot><maven-3><spring-cloud>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "47321197",
    "PostTypeId": "1",
    "CreationDate": "2017-11-16T03:42:07.823",
    "Score": "8",
    "ViewCount": "6901",
    "Body": "<p>Deploy <code>Spring Cloud</code> project with <code>docker</code>, some code in the <code>pom.xml</code>:</p>  <pre><code>&lt;build&gt;         &lt;plugins&gt;             &lt;plugin&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;             &lt;/plugin&gt;             &lt;!-- tag::plugin[] --&gt;             &lt;plugin&gt;                 &lt;groupId&gt;com.spotify&lt;/groupId&gt;                 &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;                 &lt;version&gt;0.4.3&lt;/version&gt;                 &lt;configuration&gt;                     &lt;imageName&gt;${docker.image.prefix}/${project.artifactId}&lt;/imageName&gt;                     &lt;dockerDirectory&gt;${project.basedir}&lt;/dockerDirectory&gt;                     &lt;resources&gt;                         &lt;resource&gt;                             &lt;targetPath&gt;/&lt;/targetPath&gt;                             &lt;directory&gt;${project.build.directory}&lt;/directory&gt;                             &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;                         &lt;/resource&gt;                     &lt;/resources&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt;             &lt;!-- end::plugin[] --&gt;              &lt;plugin&gt;                 &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                 &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;                 &lt;configuration&gt;                     &lt;skipTests&gt;true&lt;/skipTests&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt;         &lt;/plugins&gt;     &lt;/build&gt; </code></pre>  <p>when i run the command: <code>mvn package docker:build</code>, it throws errors:</p>  <pre><code>[INFO] ------------------------------------------------------------------------ [ERROR] Failed to execute goal com.spotify:docker-maven-plugin:0.4.3:build (default) on project users-microservice: Exception caught: java.util.concurrent.ExecutionException: com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: org.apache.http.conn.HttpHostConnectException: Connect to localhost:2375 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused -&gt; [Help 1] [ERROR] [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch. [ERROR] Re-run Maven using the -X switch to enable full debug logging. [ERROR] [ERROR] For more information about the errors and possible solutions, please read the following articles: [ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException [ERROR] [ERROR] After correcting the problems, you can resume the build with the command </code></pre>  <p>why will it connect to localhost:2375? Any idea, i will appreciate!</p> ",
    "OwnerUserId": "5443977",
    "LastEditorUserId": "5443977",
    "LastEditDate": "2017-11-17T03:13:11.887",
    "LastActivityDate": "2017-11-25T09:33:56.050",
    "Title": "Failed to execute goal com.spotify:docker-maven-plugin:0.4.3:build Exception caught: HttpHostConnectException: Connect to localhost:2375",
    "Tags": "<docker><spring-boot><maven-3><spring-cloud>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "47321197",
    "PostTypeId": "1",
    "CreationDate": "2017-11-16T03:42:07.823",
    "Score": "8",
    "ViewCount": "6901",
    "Body": "<p>Deploy <code>Spring Cloud</code> project with <code>docker</code>, some code in the <code>pom.xml</code>:</p>  <pre><code>&lt;build&gt;         &lt;plugins&gt;             &lt;plugin&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;             &lt;/plugin&gt;             &lt;!-- tag::plugin[] --&gt;             &lt;plugin&gt;                 &lt;groupId&gt;com.spotify&lt;/groupId&gt;                 &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;                 &lt;version&gt;0.4.3&lt;/version&gt;                 &lt;configuration&gt;                     &lt;imageName&gt;${docker.image.prefix}/${project.artifactId}&lt;/imageName&gt;                     &lt;dockerDirectory&gt;${project.basedir}&lt;/dockerDirectory&gt;                     &lt;resources&gt;                         &lt;resource&gt;                             &lt;targetPath&gt;/&lt;/targetPath&gt;                             &lt;directory&gt;${project.build.directory}&lt;/directory&gt;                             &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;                         &lt;/resource&gt;                     &lt;/resources&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt;             &lt;!-- end::plugin[] --&gt;              &lt;plugin&gt;                 &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                 &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;                 &lt;configuration&gt;                     &lt;skipTests&gt;true&lt;/skipTests&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt;         &lt;/plugins&gt;     &lt;/build&gt; </code></pre>  <p>when i run the command: <code>mvn package docker:build</code>, it throws errors:</p>  <pre><code>[INFO] ------------------------------------------------------------------------ [ERROR] Failed to execute goal com.spotify:docker-maven-plugin:0.4.3:build (default) on project users-microservice: Exception caught: java.util.concurrent.ExecutionException: com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: org.apache.http.conn.HttpHostConnectException: Connect to localhost:2375 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused -&gt; [Help 1] [ERROR] [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch. [ERROR] Re-run Maven using the -X switch to enable full debug logging. [ERROR] [ERROR] For more information about the errors and possible solutions, please read the following articles: [ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException [ERROR] [ERROR] After correcting the problems, you can resume the build with the command </code></pre>  <p>why will it connect to localhost:2375? Any idea, i will appreciate!</p> ",
    "OwnerUserId": "5443977",
    "LastEditorUserId": "5443977",
    "LastEditDate": "2017-11-17T03:13:11.887",
    "LastActivityDate": "2017-11-25T09:33:56.050",
    "Title": "Failed to execute goal com.spotify:docker-maven-plugin:0.4.3:build Exception caught: HttpHostConnectException: Connect to localhost:2375",
    "Tags": "<docker><spring-boot><maven-3><spring-cloud>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "48359972",
    "PostTypeId": "1",
    "AcceptedAnswerId": "48360582",
    "CreationDate": "2018-01-20T19:01:14.387",
    "Score": "8",
    "ViewCount": "14597",
    "Body": "<p>I am attempting to build a 'service' consisting of a Spring Boot application and PostgreSQL database. I have been able to access the database (running in a container) from the Spring Boot app while the Spring Boot application was running on my local machine. Now, when I attempt to move the Spring Boot application to a container, I am received the following error:</p>  <pre><code>inventory_1  | 2018-01-20 18:43:06.108 ERROR 1 --- [nio-8080-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.transaction.CannotCreateTransactionException: Could not open JPA EntityManager for transaction; nested exception is org.hibernate.exception.JDBCConnectionException: Unable to acquire JDBC Connection] with root cause inventory_1  | inventory_1  | java.net.ConnectException: Connection refused (Connection refused) </code></pre>  <p>However, I am able to connect to DB from my local machine: <code>psql -h localhost -p 5000 -U kelly_psql -d leisurely_diversion</code></p>  <p>My application.properties file:</p>  <pre><code>spring.jpa.hibernate.ddl-auto=none spring.jpa.show-sql=false spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect spring.datasource.url=jdbc:postgresql://localhost:5432/leisurely_diversion spring.datasource.username=kelly_psql spring.datasource.password=pass spring.datasource.driver-class-name=org.postgresql.Driver </code></pre>  <p>My docker-compose file:</p>  <pre><code>    # Use postgres/example user/password credentials version: '3.2'  services:   db:     image: postgres     ports:       - 5000:5432     environment:       POSTGRES_PASSWORD: example     volumes:       - type: volume         source: psql_data         target: /var/lib/postgresql/data     networks:        - app     restart: always   inventory:     image: kellymarchewa/inventory_api     depends_on:         - db     ports:       - 8080:8080     networks:       - app     restart: always volumes:   psql_data: networks:    app: </code></pre>  <p>My Dockerfile (from the <a href='https://spring.io/guides/gs/spring-boot-docker/' rel='noreferrer'>Spring website</a>)</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ARG JAR_FILE ADD ${JAR_FILE} app.jar ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre>  <p>I suspect the issue lies in a misunderstanding (on my part) of Docker or containers, but I am not sure. Any advice would be appreciated.</p> ",
    "OwnerUserId": "4783710",
    "LastEditorUserId": "2597143",
    "LastEditDate": "2018-01-21T15:35:31.800",
    "LastActivityDate": "2020-09-16T11:15:30.143",
    "Title": "Spring Boot, PostgreSQL, and Docker - Connection Refused whil Running in Container",
    "Tags": "<spring><postgresql><docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "48359972",
    "PostTypeId": "1",
    "AcceptedAnswerId": "48360582",
    "CreationDate": "2018-01-20T19:01:14.387",
    "Score": "8",
    "ViewCount": "14597",
    "Body": "<p>I am attempting to build a 'service' consisting of a Spring Boot application and PostgreSQL database. I have been able to access the database (running in a container) from the Spring Boot app while the Spring Boot application was running on my local machine. Now, when I attempt to move the Spring Boot application to a container, I am received the following error:</p>  <pre><code>inventory_1  | 2018-01-20 18:43:06.108 ERROR 1 --- [nio-8080-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.transaction.CannotCreateTransactionException: Could not open JPA EntityManager for transaction; nested exception is org.hibernate.exception.JDBCConnectionException: Unable to acquire JDBC Connection] with root cause inventory_1  | inventory_1  | java.net.ConnectException: Connection refused (Connection refused) </code></pre>  <p>However, I am able to connect to DB from my local machine: <code>psql -h localhost -p 5000 -U kelly_psql -d leisurely_diversion</code></p>  <p>My application.properties file:</p>  <pre><code>spring.jpa.hibernate.ddl-auto=none spring.jpa.show-sql=false spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect spring.datasource.url=jdbc:postgresql://localhost:5432/leisurely_diversion spring.datasource.username=kelly_psql spring.datasource.password=pass spring.datasource.driver-class-name=org.postgresql.Driver </code></pre>  <p>My docker-compose file:</p>  <pre><code>    # Use postgres/example user/password credentials version: '3.2'  services:   db:     image: postgres     ports:       - 5000:5432     environment:       POSTGRES_PASSWORD: example     volumes:       - type: volume         source: psql_data         target: /var/lib/postgresql/data     networks:        - app     restart: always   inventory:     image: kellymarchewa/inventory_api     depends_on:         - db     ports:       - 8080:8080     networks:       - app     restart: always volumes:   psql_data: networks:    app: </code></pre>  <p>My Dockerfile (from the <a href='https://spring.io/guides/gs/spring-boot-docker/' rel='noreferrer'>Spring website</a>)</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ARG JAR_FILE ADD ${JAR_FILE} app.jar ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre>  <p>I suspect the issue lies in a misunderstanding (on my part) of Docker or containers, but I am not sure. Any advice would be appreciated.</p> ",
    "OwnerUserId": "4783710",
    "LastEditorUserId": "2597143",
    "LastEditDate": "2018-01-21T15:35:31.800",
    "LastActivityDate": "2020-09-16T11:15:30.143",
    "Title": "Spring Boot, PostgreSQL, and Docker - Connection Refused whil Running in Container",
    "Tags": "<spring><postgresql><docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "48359972",
    "PostTypeId": "1",
    "AcceptedAnswerId": "48360582",
    "CreationDate": "2018-01-20T19:01:14.387",
    "Score": "8",
    "ViewCount": "14597",
    "Body": "<p>I am attempting to build a 'service' consisting of a Spring Boot application and PostgreSQL database. I have been able to access the database (running in a container) from the Spring Boot app while the Spring Boot application was running on my local machine. Now, when I attempt to move the Spring Boot application to a container, I am received the following error:</p>  <pre><code>inventory_1  | 2018-01-20 18:43:06.108 ERROR 1 --- [nio-8080-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.transaction.CannotCreateTransactionException: Could not open JPA EntityManager for transaction; nested exception is org.hibernate.exception.JDBCConnectionException: Unable to acquire JDBC Connection] with root cause inventory_1  | inventory_1  | java.net.ConnectException: Connection refused (Connection refused) </code></pre>  <p>However, I am able to connect to DB from my local machine: <code>psql -h localhost -p 5000 -U kelly_psql -d leisurely_diversion</code></p>  <p>My application.properties file:</p>  <pre><code>spring.jpa.hibernate.ddl-auto=none spring.jpa.show-sql=false spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect spring.datasource.url=jdbc:postgresql://localhost:5432/leisurely_diversion spring.datasource.username=kelly_psql spring.datasource.password=pass spring.datasource.driver-class-name=org.postgresql.Driver </code></pre>  <p>My docker-compose file:</p>  <pre><code>    # Use postgres/example user/password credentials version: '3.2'  services:   db:     image: postgres     ports:       - 5000:5432     environment:       POSTGRES_PASSWORD: example     volumes:       - type: volume         source: psql_data         target: /var/lib/postgresql/data     networks:        - app     restart: always   inventory:     image: kellymarchewa/inventory_api     depends_on:         - db     ports:       - 8080:8080     networks:       - app     restart: always volumes:   psql_data: networks:    app: </code></pre>  <p>My Dockerfile (from the <a href='https://spring.io/guides/gs/spring-boot-docker/' rel='noreferrer'>Spring website</a>)</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ARG JAR_FILE ADD ${JAR_FILE} app.jar ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre>  <p>I suspect the issue lies in a misunderstanding (on my part) of Docker or containers, but I am not sure. Any advice would be appreciated.</p> ",
    "OwnerUserId": "4783710",
    "LastEditorUserId": "2597143",
    "LastEditDate": "2018-01-21T15:35:31.800",
    "LastActivityDate": "2020-09-16T11:15:30.143",
    "Title": "Spring Boot, PostgreSQL, and Docker - Connection Refused whil Running in Container",
    "Tags": "<spring><postgresql><docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "49941955",
    "PostTypeId": "1",
    "AcceptedAnswerId": "51043076",
    "CreationDate": "2018-04-20T12:44:51.257",
    "Score": "8",
    "ViewCount": "11090",
    "Body": "<p>If I try to build a Docker container with a Spring Boot application under Windows 10, I get the following error:</p>  <pre><code>&gt; Task :docker FAILED COPY failed: stat /var/lib/docker/tmp/docker-builder711841135/myproject.jar: no such file or directory </code></pre>  <p>I'm using Docker Community Edition in version 18.03.0-ce-win59 (16762) and Gradle 4.7 with Java 8.</p>  <p><strong>build.gradle</strong> (shortened):</p>  <pre><code>plugins {     id 'java'     id 'org.springframework.boot' version '2.0.1.RELEASE'     id 'com.palantir.docker' version '0.19.2' }  version = '2.0.0' sourceCompatibility = 1.8 group = 'com.example'  repositories {     mavenCentral() }  bootJar {     archiveName 'myproject.jar' }  dependencies {     ... }  docker {     dependsOn(build)     name '${project.group}/${jar.baseName}'     files bootJar } </code></pre>  <p><strong>Dockerfile</strong> (sibling of build.gradle in the top-level project directory):</p>  <pre><code>FROM openjdk:8-jre COPY build/libs/myproject.jar myproject.jar  ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/myproject.jar'] </code></pre>  <p>If I build the Docker container with Docker only (without Gradle) it works.</p>  <p>How can I let Gradle (or Docker?) find the file myproject.jar?</p> ",
    "OwnerUserId": "238134",
    "LastEditorUserId": "238134",
    "LastEditDate": "2018-04-20T14:07:26.917",
    "LastActivityDate": "2021-06-23T03:48:16.967",
    "Title": ".jar file not found when building a Docker container with Palantir Gradle plug-in",
    "Tags": "<java><docker><spring-boot><gradle>",
    "AnswerCount": "5",
    "CommentCount": "8",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "50216280",
    "PostTypeId": "1",
    "AcceptedAnswerId": "50222583",
    "CreationDate": "2018-05-07T14:09:25.160",
    "Score": "8",
    "ViewCount": "62148",
    "Body": "<p>The docker container is not able to access the jar file, that is being accessed over the mount point <code>/my/project/dir</code>. I am certain it is not a permission issue, because I changed the access rights locally, so it should be able to read/write/execute it.</p>  <p>This is the <code>Dockerfile</code>:</p>  <pre><code>FROM tomcat:9-jre8 RUN apt-get update &amp;&amp; apt-get install librrds-perl rrdtool -y VOLUME ['/data/rrdtool', '/my/project/dir'] ENTRYPOINT [ 'java','-jar','/my/project/dir/build/libs/spring-project-0.1.0.jar' ] </code></pre>  <p>And this is the <code>docker-compose.yml</code> file:</p>  <pre><code>version: '2' services:  db:    container_name: db1    image: mysql:8    restart: always    environment:      MYSQL_ROOT_PASSWORD: password123      MYSQL_USER: user123      MYSQL_PASSWORD: pasw      MYSQL_DATABASE: mydb    expose:      - '3307'  db2:    container_name: db2    image: mysql:8    restart: always    environment:      MYSQL_ROOT_PASSWORD: password123      MYSQL_USER: user123      MYSQL_PASSWORD: pasw      MYSQL_DATABASE: mydb2    expose:      - '3308'  spring:    container_name: spring-boot-project    build:       context: ./      dockerfile: Dockerfile    links:      - db:db1      - db2:db2    depends_on:      - db      - db2    expose:      - '8081'    ports:      - '8081:8081'    restart: always </code></pre>  <p>This is the output from <code>docker-compose logs spring</code>:</p>  <pre><code>Error: Unable to access jarfile /my/project/dir/build/libs/spring-project-0.1.0.jar </code></pre> ",
    "OwnerUserId": "5703530",
    "LastEditorUserId": "5703530",
    "LastEditDate": "2018-05-07T18:25:15.080",
    "LastActivityDate": "2022-09-12T12:19:49.007",
    "Title": "Docker unable to access jar file",
    "Tags": "<java><docker><spring-boot><jar><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "4",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "50216280",
    "PostTypeId": "1",
    "AcceptedAnswerId": "50222583",
    "CreationDate": "2018-05-07T14:09:25.160",
    "Score": "8",
    "ViewCount": "62148",
    "Body": "<p>The docker container is not able to access the jar file, that is being accessed over the mount point <code>/my/project/dir</code>. I am certain it is not a permission issue, because I changed the access rights locally, so it should be able to read/write/execute it.</p>  <p>This is the <code>Dockerfile</code>:</p>  <pre><code>FROM tomcat:9-jre8 RUN apt-get update &amp;&amp; apt-get install librrds-perl rrdtool -y VOLUME ['/data/rrdtool', '/my/project/dir'] ENTRYPOINT [ 'java','-jar','/my/project/dir/build/libs/spring-project-0.1.0.jar' ] </code></pre>  <p>And this is the <code>docker-compose.yml</code> file:</p>  <pre><code>version: '2' services:  db:    container_name: db1    image: mysql:8    restart: always    environment:      MYSQL_ROOT_PASSWORD: password123      MYSQL_USER: user123      MYSQL_PASSWORD: pasw      MYSQL_DATABASE: mydb    expose:      - '3307'  db2:    container_name: db2    image: mysql:8    restart: always    environment:      MYSQL_ROOT_PASSWORD: password123      MYSQL_USER: user123      MYSQL_PASSWORD: pasw      MYSQL_DATABASE: mydb2    expose:      - '3308'  spring:    container_name: spring-boot-project    build:       context: ./      dockerfile: Dockerfile    links:      - db:db1      - db2:db2    depends_on:      - db      - db2    expose:      - '8081'    ports:      - '8081:8081'    restart: always </code></pre>  <p>This is the output from <code>docker-compose logs spring</code>:</p>  <pre><code>Error: Unable to access jarfile /my/project/dir/build/libs/spring-project-0.1.0.jar </code></pre> ",
    "OwnerUserId": "5703530",
    "LastEditorUserId": "5703530",
    "LastEditDate": "2018-05-07T18:25:15.080",
    "LastActivityDate": "2022-09-12T12:19:49.007",
    "Title": "Docker unable to access jar file",
    "Tags": "<java><docker><spring-boot><jar><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "4",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "50216280",
    "PostTypeId": "1",
    "AcceptedAnswerId": "50222583",
    "CreationDate": "2018-05-07T14:09:25.160",
    "Score": "8",
    "ViewCount": "62148",
    "Body": "<p>The docker container is not able to access the jar file, that is being accessed over the mount point <code>/my/project/dir</code>. I am certain it is not a permission issue, because I changed the access rights locally, so it should be able to read/write/execute it.</p>  <p>This is the <code>Dockerfile</code>:</p>  <pre><code>FROM tomcat:9-jre8 RUN apt-get update &amp;&amp; apt-get install librrds-perl rrdtool -y VOLUME ['/data/rrdtool', '/my/project/dir'] ENTRYPOINT [ 'java','-jar','/my/project/dir/build/libs/spring-project-0.1.0.jar' ] </code></pre>  <p>And this is the <code>docker-compose.yml</code> file:</p>  <pre><code>version: '2' services:  db:    container_name: db1    image: mysql:8    restart: always    environment:      MYSQL_ROOT_PASSWORD: password123      MYSQL_USER: user123      MYSQL_PASSWORD: pasw      MYSQL_DATABASE: mydb    expose:      - '3307'  db2:    container_name: db2    image: mysql:8    restart: always    environment:      MYSQL_ROOT_PASSWORD: password123      MYSQL_USER: user123      MYSQL_PASSWORD: pasw      MYSQL_DATABASE: mydb2    expose:      - '3308'  spring:    container_name: spring-boot-project    build:       context: ./      dockerfile: Dockerfile    links:      - db:db1      - db2:db2    depends_on:      - db      - db2    expose:      - '8081'    ports:      - '8081:8081'    restart: always </code></pre>  <p>This is the output from <code>docker-compose logs spring</code>:</p>  <pre><code>Error: Unable to access jarfile /my/project/dir/build/libs/spring-project-0.1.0.jar </code></pre> ",
    "OwnerUserId": "5703530",
    "LastEditorUserId": "5703530",
    "LastEditDate": "2018-05-07T18:25:15.080",
    "LastActivityDate": "2022-09-12T12:19:49.007",
    "Title": "Docker unable to access jar file",
    "Tags": "<java><docker><spring-boot><jar><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "4",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "52933220",
    "PostTypeId": "1",
    "AcceptedAnswerId": "52934014",
    "CreationDate": "2018-10-22T15:49:48.663",
    "Score": "8",
    "ViewCount": "18844",
    "Body": "<p>We working in small team of 4 people. We using docker to deploy our services. One of the services is a java Spring Boot project which is deployed after building docker image with maven. To make docker image of Spring Boot service we use <code>mvn clean package dockerfile:build</code>.</p>  <p>The fun part is that my colleagues have no problem building docker image of Spring Boot service. And I get maven error message:</p>  <pre><code>[ERROR] Failed to execute goal com.spotify:dockerfile-maven-plugin:1.3.6:build (default-cli) on project 'foo': Could not build image: com.spotify.docker.client.shaded.com.fasterxml.jackson.databind.JsonMappingException: Can not construct instance of com.spotify.docker.client.messages.RegistryAuth: no String-argument constructor/factory method to deserialize from String value ('osxkeychain') </code></pre>  <p>I tried to remove all maven repositories from <code>.m2/repository</code>, restart docker, and remove all images.</p>  <p>Later I tried to run <code>mvn clean package dockerfile:build</code> in to two separate commands:</p>  <ul> <li><code>mvn package</code>, then</li> <li><code>mvn docker:build</code></li> </ul>  <p><code>mvn package</code> passed, and <code>mvn docker:build</code> failed with the same error as shown above.</p>  <p>Maven version <code>3.5.4</code>, Docker version <code>18.06.1-ce, build e68fc7a</code>, OS: macOS mojave</p>  <p>I even tried to restart my PC hoping that it will fix it...</p>  <p>Edited: Here is the maven pom plugin <code>dockerfile-maven-plugin</code></p>  <pre><code>... &lt;plugin&gt;     &lt;groupId&gt;com.spotify&lt;/groupId&gt;     &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;     &lt;version&gt;1.3.6&lt;/version&gt;     &lt;configuration&gt;         &lt;repository&gt;${project.artifactId}&lt;/repository&gt;     &lt;/configuration&gt; &lt;/plugin&gt; ... </code></pre>  <p>Edit 2:</p>  <p>Full error message:</p>  <pre><code>[ERROR] Failed to execute goal com.spotify:dockerfile-maven-plugin:1.3.6:build (default) on project spring-boot-service: Could not build image: com.spotify.docker.client.shaded.com.fasterxml.jackson.databind.JsonMappingException: Can not construct instance of com.spotify.docker.client.messages.RegistryAuth: no String-argument constructor/factory method to deserialize from String value ('swarm') [ERROR]  at [Source: N/A; line: -1, column: -1] (through reference chain: java.util.LinkedHashMap['stackOrchestrator']) [ERROR] -&gt; [Help 1] [ERROR]  [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch. [ERROR] Re-run Maven using the -X switch to enable full debug logging. [ERROR]  [ERROR] For more information about the errors and possible solutions, please read the following articles: [ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException </code></pre>  <p>Edit 3:</p>  <p>docker-compose.yml</p>  <pre><code>wrapper:   image: spring-boot-service:latest ports:   - '8080:8080' expose:   - '8080' links:   - db   - another-service </code></pre>  <p>Solved:</p>  <p>In my case it was wrong version of <code>dockerfile-maven-plugin</code>. I used <code>1.3.6</code>, and <code>1.4.7</code> fixed the problem. </p>  <p>Thanks to <a href='https://stackoverflow.com/users/3301492/boris'>Boris</a>!</p>  <p>Update: One more thing!</p>  <p>Make sure when <code>mvn</code> finish build naming is correct, for example:</p>  <pre><code>[INFO] Successfully built **spring-boot-service:0.0.1-SNAPSHOT** </code></pre>  <p>And <code>docker-compose.yml</code> should look like this:</p>  <pre><code>... wrapper:   image: **spring-boot-service:0.0.1-SNAPSHOT** ... </code></pre> ",
    "OwnerUserId": "5834613",
    "LastEditorUserId": "5834613",
    "LastEditDate": "2018-10-22T17:35:29.400",
    "LastActivityDate": "2022-08-11T11:28:21.330",
    "Title": "Failed to execute goal com.spotify:dockerfile-maven-plugin:1.3.6:build on project 'foo': Could not build image:",
    "Tags": "<java><maven><docker><spring-boot>",
    "AnswerCount": "2",
    "CommentCount": "4",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "52933220",
    "PostTypeId": "1",
    "AcceptedAnswerId": "52934014",
    "CreationDate": "2018-10-22T15:49:48.663",
    "Score": "8",
    "ViewCount": "18844",
    "Body": "<p>We working in small team of 4 people. We using docker to deploy our services. One of the services is a java Spring Boot project which is deployed after building docker image with maven. To make docker image of Spring Boot service we use <code>mvn clean package dockerfile:build</code>.</p>  <p>The fun part is that my colleagues have no problem building docker image of Spring Boot service. And I get maven error message:</p>  <pre><code>[ERROR] Failed to execute goal com.spotify:dockerfile-maven-plugin:1.3.6:build (default-cli) on project 'foo': Could not build image: com.spotify.docker.client.shaded.com.fasterxml.jackson.databind.JsonMappingException: Can not construct instance of com.spotify.docker.client.messages.RegistryAuth: no String-argument constructor/factory method to deserialize from String value ('osxkeychain') </code></pre>  <p>I tried to remove all maven repositories from <code>.m2/repository</code>, restart docker, and remove all images.</p>  <p>Later I tried to run <code>mvn clean package dockerfile:build</code> in to two separate commands:</p>  <ul> <li><code>mvn package</code>, then</li> <li><code>mvn docker:build</code></li> </ul>  <p><code>mvn package</code> passed, and <code>mvn docker:build</code> failed with the same error as shown above.</p>  <p>Maven version <code>3.5.4</code>, Docker version <code>18.06.1-ce, build e68fc7a</code>, OS: macOS mojave</p>  <p>I even tried to restart my PC hoping that it will fix it...</p>  <p>Edited: Here is the maven pom plugin <code>dockerfile-maven-plugin</code></p>  <pre><code>... &lt;plugin&gt;     &lt;groupId&gt;com.spotify&lt;/groupId&gt;     &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;     &lt;version&gt;1.3.6&lt;/version&gt;     &lt;configuration&gt;         &lt;repository&gt;${project.artifactId}&lt;/repository&gt;     &lt;/configuration&gt; &lt;/plugin&gt; ... </code></pre>  <p>Edit 2:</p>  <p>Full error message:</p>  <pre><code>[ERROR] Failed to execute goal com.spotify:dockerfile-maven-plugin:1.3.6:build (default) on project spring-boot-service: Could not build image: com.spotify.docker.client.shaded.com.fasterxml.jackson.databind.JsonMappingException: Can not construct instance of com.spotify.docker.client.messages.RegistryAuth: no String-argument constructor/factory method to deserialize from String value ('swarm') [ERROR]  at [Source: N/A; line: -1, column: -1] (through reference chain: java.util.LinkedHashMap['stackOrchestrator']) [ERROR] -&gt; [Help 1] [ERROR]  [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch. [ERROR] Re-run Maven using the -X switch to enable full debug logging. [ERROR]  [ERROR] For more information about the errors and possible solutions, please read the following articles: [ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException </code></pre>  <p>Edit 3:</p>  <p>docker-compose.yml</p>  <pre><code>wrapper:   image: spring-boot-service:latest ports:   - '8080:8080' expose:   - '8080' links:   - db   - another-service </code></pre>  <p>Solved:</p>  <p>In my case it was wrong version of <code>dockerfile-maven-plugin</code>. I used <code>1.3.6</code>, and <code>1.4.7</code> fixed the problem. </p>  <p>Thanks to <a href='https://stackoverflow.com/users/3301492/boris'>Boris</a>!</p>  <p>Update: One more thing!</p>  <p>Make sure when <code>mvn</code> finish build naming is correct, for example:</p>  <pre><code>[INFO] Successfully built **spring-boot-service:0.0.1-SNAPSHOT** </code></pre>  <p>And <code>docker-compose.yml</code> should look like this:</p>  <pre><code>... wrapper:   image: **spring-boot-service:0.0.1-SNAPSHOT** ... </code></pre> ",
    "OwnerUserId": "5834613",
    "LastEditorUserId": "5834613",
    "LastEditDate": "2018-10-22T17:35:29.400",
    "LastActivityDate": "2022-08-11T11:28:21.330",
    "Title": "Failed to execute goal com.spotify:dockerfile-maven-plugin:1.3.6:build on project 'foo': Could not build image:",
    "Tags": "<java><maven><docker><spring-boot>",
    "AnswerCount": "2",
    "CommentCount": "4",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "52933220",
    "PostTypeId": "1",
    "AcceptedAnswerId": "52934014",
    "CreationDate": "2018-10-22T15:49:48.663",
    "Score": "8",
    "ViewCount": "18844",
    "Body": "<p>We working in small team of 4 people. We using docker to deploy our services. One of the services is a java Spring Boot project which is deployed after building docker image with maven. To make docker image of Spring Boot service we use <code>mvn clean package dockerfile:build</code>.</p>  <p>The fun part is that my colleagues have no problem building docker image of Spring Boot service. And I get maven error message:</p>  <pre><code>[ERROR] Failed to execute goal com.spotify:dockerfile-maven-plugin:1.3.6:build (default-cli) on project 'foo': Could not build image: com.spotify.docker.client.shaded.com.fasterxml.jackson.databind.JsonMappingException: Can not construct instance of com.spotify.docker.client.messages.RegistryAuth: no String-argument constructor/factory method to deserialize from String value ('osxkeychain') </code></pre>  <p>I tried to remove all maven repositories from <code>.m2/repository</code>, restart docker, and remove all images.</p>  <p>Later I tried to run <code>mvn clean package dockerfile:build</code> in to two separate commands:</p>  <ul> <li><code>mvn package</code>, then</li> <li><code>mvn docker:build</code></li> </ul>  <p><code>mvn package</code> passed, and <code>mvn docker:build</code> failed with the same error as shown above.</p>  <p>Maven version <code>3.5.4</code>, Docker version <code>18.06.1-ce, build e68fc7a</code>, OS: macOS mojave</p>  <p>I even tried to restart my PC hoping that it will fix it...</p>  <p>Edited: Here is the maven pom plugin <code>dockerfile-maven-plugin</code></p>  <pre><code>... &lt;plugin&gt;     &lt;groupId&gt;com.spotify&lt;/groupId&gt;     &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;     &lt;version&gt;1.3.6&lt;/version&gt;     &lt;configuration&gt;         &lt;repository&gt;${project.artifactId}&lt;/repository&gt;     &lt;/configuration&gt; &lt;/plugin&gt; ... </code></pre>  <p>Edit 2:</p>  <p>Full error message:</p>  <pre><code>[ERROR] Failed to execute goal com.spotify:dockerfile-maven-plugin:1.3.6:build (default) on project spring-boot-service: Could not build image: com.spotify.docker.client.shaded.com.fasterxml.jackson.databind.JsonMappingException: Can not construct instance of com.spotify.docker.client.messages.RegistryAuth: no String-argument constructor/factory method to deserialize from String value ('swarm') [ERROR]  at [Source: N/A; line: -1, column: -1] (through reference chain: java.util.LinkedHashMap['stackOrchestrator']) [ERROR] -&gt; [Help 1] [ERROR]  [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch. [ERROR] Re-run Maven using the -X switch to enable full debug logging. [ERROR]  [ERROR] For more information about the errors and possible solutions, please read the following articles: [ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException </code></pre>  <p>Edit 3:</p>  <p>docker-compose.yml</p>  <pre><code>wrapper:   image: spring-boot-service:latest ports:   - '8080:8080' expose:   - '8080' links:   - db   - another-service </code></pre>  <p>Solved:</p>  <p>In my case it was wrong version of <code>dockerfile-maven-plugin</code>. I used <code>1.3.6</code>, and <code>1.4.7</code> fixed the problem. </p>  <p>Thanks to <a href='https://stackoverflow.com/users/3301492/boris'>Boris</a>!</p>  <p>Update: One more thing!</p>  <p>Make sure when <code>mvn</code> finish build naming is correct, for example:</p>  <pre><code>[INFO] Successfully built **spring-boot-service:0.0.1-SNAPSHOT** </code></pre>  <p>And <code>docker-compose.yml</code> should look like this:</p>  <pre><code>... wrapper:   image: **spring-boot-service:0.0.1-SNAPSHOT** ... </code></pre> ",
    "OwnerUserId": "5834613",
    "LastEditorUserId": "5834613",
    "LastEditDate": "2018-10-22T17:35:29.400",
    "LastActivityDate": "2022-08-11T11:28:21.330",
    "Title": "Failed to execute goal com.spotify:dockerfile-maven-plugin:1.3.6:build on project 'foo': Could not build image:",
    "Tags": "<java><maven><docker><spring-boot>",
    "AnswerCount": "2",
    "CommentCount": "4",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "53407287",
    "PostTypeId": "1",
    "CreationDate": "2018-11-21T07:39:54.870",
    "Score": "8",
    "ViewCount": "18758",
    "Body": "<p>I have a spring boot project which I'd like to containerize using docker. I have a couple of spring boot applications which connect to same MySql server.</p>  <p>My spring applications requires the database to be completely setup (i.e. all the tables to be created and some data to be inserted in some of the tables) in order to start.</p>  <p>I am using <strong>Docker</strong> version <strong>18.09.0</strong> and <strong>docker-compose</strong> version <strong>1.23.1</strong> and ubuntu <strong>16.04</strong> LTS</p>  <hr>  <p>I have two files <strong><code>create.sql</code></strong> and <strong><code>insert.sql</code></strong>, which I use to initialise the database to be used by the application.</p>  <p>I create the images using the command <strong><code>docker-compose.yml</code></strong> and it runs successfully and creates the images.</p>  <p>I have the following questions.</p>  <ol> <li><p>I assume when using docker-compose, a container starts as soon as all its dependent containers have started. Is there a way to wait for the mysql server to be up and ready to accept connections, before my API container gets started?</p></li> <li><p>If I chose to create containers separately for the applications and mysql, and not use docker-compose, how do I make sure that my applications connect to the mysql container?</p></li> <li><p>Is there any other tool which might help me achieve this?</p></li> </ol>  <p><strong>Note:</strong> I have tried to use <strong><code>docker inspect &lt;container_id&gt;</code></strong> to find the the IpAddress for the mysql container and use it to connect, but it doesn't work as well.</p>  <hr>  <p>The following are the files I am using to create images.</p>  <p><strong><code>docker-compose.yml</code></strong> file.</p>  <pre><code>version: '3'  services:   demo-mysql:     image: demo-mysql     build: ./demo-mysql     volumes:       - /mnt/data/mysql-data:/var/lib/mysql     ports:       - 3306:3306     environment:       - MYSQL_ROOT_PASSWORD=root       - MYSQL_DATABASE=demo       - MYSQL_PASSWORD=root    demo-api:     image: demo-api-1.0     build: ./api     depends_on:       - demo-mysql     ports:       - 8080:8080     environment:       - DATABASE_HOST=demo-mysql       - DATABASE_USER=root       - DATABASE_PASSWORD=root       - DATABASE_NAME=demo       - DATABASE_PORT=3306    demo1-app:     image: demo1-app-1.0     build: ./demo1     depends_on:       - demo-mysql     ports:       - 8090:8090     environment:       - DATABASE_HOST=demo-mysql       - DATABASE_USER=root       - DATABASE_PASSWORD=root       - DATABASE_NAME=demo       - DATABASE_PORT=3306 </code></pre>  <p>The following is the <strong><code>Dockerfile</code></strong> for the spring boot project</p>  <pre><code>FROM java:8  VOLUME /tmp  ARG DATA_PATH=/src/main/resources ARG APP_PORT=8080  EXPOSE ${APP_PORT}  ADD /build/libs/demo-api.jar demo-api.jar  ENTRYPOINT ['java','-jar','demo-api.jar'] </code></pre>  <p>The following is the <strong><code>Dockerfile</code></strong> I used to create my mysql image</p>  <pre><code>FROM mysql:5.7  ENV MYSQL_DATABASE=demo \\     MYSQL_USER=root \\     MYSQL_ROOT_PASSWORD=root  ADD ./1.0/create.sql /docker-entrypoint-initdb.d ADD ./1.0/insert.sql /docker-entrypoint-initdb.d  EXPOSE 3306 </code></pre> ",
    "OwnerUserId": "5788945",
    "LastActivityDate": "2023-10-15T19:43:52.260",
    "Title": "Docker compose wait for database service initialisation",
    "Tags": "<mysql><spring-boot><docker><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "53407287",
    "PostTypeId": "1",
    "CreationDate": "2018-11-21T07:39:54.870",
    "Score": "8",
    "ViewCount": "18758",
    "Body": "<p>I have a spring boot project which I'd like to containerize using docker. I have a couple of spring boot applications which connect to same MySql server.</p>  <p>My spring applications requires the database to be completely setup (i.e. all the tables to be created and some data to be inserted in some of the tables) in order to start.</p>  <p>I am using <strong>Docker</strong> version <strong>18.09.0</strong> and <strong>docker-compose</strong> version <strong>1.23.1</strong> and ubuntu <strong>16.04</strong> LTS</p>  <hr>  <p>I have two files <strong><code>create.sql</code></strong> and <strong><code>insert.sql</code></strong>, which I use to initialise the database to be used by the application.</p>  <p>I create the images using the command <strong><code>docker-compose.yml</code></strong> and it runs successfully and creates the images.</p>  <p>I have the following questions.</p>  <ol> <li><p>I assume when using docker-compose, a container starts as soon as all its dependent containers have started. Is there a way to wait for the mysql server to be up and ready to accept connections, before my API container gets started?</p></li> <li><p>If I chose to create containers separately for the applications and mysql, and not use docker-compose, how do I make sure that my applications connect to the mysql container?</p></li> <li><p>Is there any other tool which might help me achieve this?</p></li> </ol>  <p><strong>Note:</strong> I have tried to use <strong><code>docker inspect &lt;container_id&gt;</code></strong> to find the the IpAddress for the mysql container and use it to connect, but it doesn't work as well.</p>  <hr>  <p>The following are the files I am using to create images.</p>  <p><strong><code>docker-compose.yml</code></strong> file.</p>  <pre><code>version: '3'  services:   demo-mysql:     image: demo-mysql     build: ./demo-mysql     volumes:       - /mnt/data/mysql-data:/var/lib/mysql     ports:       - 3306:3306     environment:       - MYSQL_ROOT_PASSWORD=root       - MYSQL_DATABASE=demo       - MYSQL_PASSWORD=root    demo-api:     image: demo-api-1.0     build: ./api     depends_on:       - demo-mysql     ports:       - 8080:8080     environment:       - DATABASE_HOST=demo-mysql       - DATABASE_USER=root       - DATABASE_PASSWORD=root       - DATABASE_NAME=demo       - DATABASE_PORT=3306    demo1-app:     image: demo1-app-1.0     build: ./demo1     depends_on:       - demo-mysql     ports:       - 8090:8090     environment:       - DATABASE_HOST=demo-mysql       - DATABASE_USER=root       - DATABASE_PASSWORD=root       - DATABASE_NAME=demo       - DATABASE_PORT=3306 </code></pre>  <p>The following is the <strong><code>Dockerfile</code></strong> for the spring boot project</p>  <pre><code>FROM java:8  VOLUME /tmp  ARG DATA_PATH=/src/main/resources ARG APP_PORT=8080  EXPOSE ${APP_PORT}  ADD /build/libs/demo-api.jar demo-api.jar  ENTRYPOINT ['java','-jar','demo-api.jar'] </code></pre>  <p>The following is the <strong><code>Dockerfile</code></strong> I used to create my mysql image</p>  <pre><code>FROM mysql:5.7  ENV MYSQL_DATABASE=demo \\     MYSQL_USER=root \\     MYSQL_ROOT_PASSWORD=root  ADD ./1.0/create.sql /docker-entrypoint-initdb.d ADD ./1.0/insert.sql /docker-entrypoint-initdb.d  EXPOSE 3306 </code></pre> ",
    "OwnerUserId": "5788945",
    "LastActivityDate": "2023-10-15T19:43:52.260",
    "Title": "Docker compose wait for database service initialisation",
    "Tags": "<mysql><spring-boot><docker><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "53407287",
    "PostTypeId": "1",
    "CreationDate": "2018-11-21T07:39:54.870",
    "Score": "8",
    "ViewCount": "18758",
    "Body": "<p>I have a spring boot project which I'd like to containerize using docker. I have a couple of spring boot applications which connect to same MySql server.</p>  <p>My spring applications requires the database to be completely setup (i.e. all the tables to be created and some data to be inserted in some of the tables) in order to start.</p>  <p>I am using <strong>Docker</strong> version <strong>18.09.0</strong> and <strong>docker-compose</strong> version <strong>1.23.1</strong> and ubuntu <strong>16.04</strong> LTS</p>  <hr>  <p>I have two files <strong><code>create.sql</code></strong> and <strong><code>insert.sql</code></strong>, which I use to initialise the database to be used by the application.</p>  <p>I create the images using the command <strong><code>docker-compose.yml</code></strong> and it runs successfully and creates the images.</p>  <p>I have the following questions.</p>  <ol> <li><p>I assume when using docker-compose, a container starts as soon as all its dependent containers have started. Is there a way to wait for the mysql server to be up and ready to accept connections, before my API container gets started?</p></li> <li><p>If I chose to create containers separately for the applications and mysql, and not use docker-compose, how do I make sure that my applications connect to the mysql container?</p></li> <li><p>Is there any other tool which might help me achieve this?</p></li> </ol>  <p><strong>Note:</strong> I have tried to use <strong><code>docker inspect &lt;container_id&gt;</code></strong> to find the the IpAddress for the mysql container and use it to connect, but it doesn't work as well.</p>  <hr>  <p>The following are the files I am using to create images.</p>  <p><strong><code>docker-compose.yml</code></strong> file.</p>  <pre><code>version: '3'  services:   demo-mysql:     image: demo-mysql     build: ./demo-mysql     volumes:       - /mnt/data/mysql-data:/var/lib/mysql     ports:       - 3306:3306     environment:       - MYSQL_ROOT_PASSWORD=root       - MYSQL_DATABASE=demo       - MYSQL_PASSWORD=root    demo-api:     image: demo-api-1.0     build: ./api     depends_on:       - demo-mysql     ports:       - 8080:8080     environment:       - DATABASE_HOST=demo-mysql       - DATABASE_USER=root       - DATABASE_PASSWORD=root       - DATABASE_NAME=demo       - DATABASE_PORT=3306    demo1-app:     image: demo1-app-1.0     build: ./demo1     depends_on:       - demo-mysql     ports:       - 8090:8090     environment:       - DATABASE_HOST=demo-mysql       - DATABASE_USER=root       - DATABASE_PASSWORD=root       - DATABASE_NAME=demo       - DATABASE_PORT=3306 </code></pre>  <p>The following is the <strong><code>Dockerfile</code></strong> for the spring boot project</p>  <pre><code>FROM java:8  VOLUME /tmp  ARG DATA_PATH=/src/main/resources ARG APP_PORT=8080  EXPOSE ${APP_PORT}  ADD /build/libs/demo-api.jar demo-api.jar  ENTRYPOINT ['java','-jar','demo-api.jar'] </code></pre>  <p>The following is the <strong><code>Dockerfile</code></strong> I used to create my mysql image</p>  <pre><code>FROM mysql:5.7  ENV MYSQL_DATABASE=demo \\     MYSQL_USER=root \\     MYSQL_ROOT_PASSWORD=root  ADD ./1.0/create.sql /docker-entrypoint-initdb.d ADD ./1.0/insert.sql /docker-entrypoint-initdb.d  EXPOSE 3306 </code></pre> ",
    "OwnerUserId": "5788945",
    "LastActivityDate": "2023-10-15T19:43:52.260",
    "Title": "Docker compose wait for database service initialisation",
    "Tags": "<mysql><spring-boot><docker><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "54616163",
    "PostTypeId": "1",
    "CreationDate": "2019-02-10T12:03:09.857",
    "Score": "8",
    "ViewCount": "31366",
    "Body": "<p>I wanted to build my springboot project. Then I want to dockerize my code. But when I built, I got error. I think this occured caused by postgresql setting. But I could not find reason. </p>  <p>Could you please help me?</p>  <pre><code>docker-compose.yml file;  version: '2' services:   web:     build: .     ports:       - 8080:8080   db:     container_name: productdb     image: postgres:9.5     volumes:     - sample_db:/var/lib/postgresql/data     environment:     - POSTGRES_PASSWORD=bright     - POSTGRES_USER=postgres     - POSTGRES_DB=productdb     - PGDATA=/var/lib/postgresql/data/pgdata     ports:     - '5432:5432'  volumes:   productdb: {} </code></pre>  <p>application.yml file;</p>  <pre><code>server:   port: 8761 eureka:   client:   registerWithEureka: false   fetchRegistry: false   server:   enableSelfPreservation: false   waitTimeInMsWhenSyncEmpty: 0  spring:   application:     name: product-service   datasource:     url: jdbc:postgresql://db:5432/productdb     username: postgres     password: xxxx     initialization-mode: always   jpa:     show-sql: true     hibernate:       ddl-auto:     properties:       hibernate:         temp:           use_jdbc_metadata_defaults: false </code></pre>  <p>Error looks like;</p>  <p>org.postgresql.util.PSQLException: The connection attempt failed.</p>  <p>Thank you</p> ",
    "OwnerUserId": "2152509",
    "LastEditorUserId": "2152509",
    "LastEditDate": "2019-02-11T10:31:53.677",
    "LastActivityDate": "2022-12-14T03:34:06.037",
    "Title": "How do I solve postgresql error 'connection attempt failed'?",
    "Tags": "<postgresql><spring-boot><docker>",
    "AnswerCount": "3",
    "CommentCount": "4",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "54928051",
    "PostTypeId": "1",
    "AcceptedAnswerId": "54929485",
    "CreationDate": "2019-02-28T14:34:45.250",
    "Score": "8",
    "ViewCount": "6630",
    "Body": "<p>i have technical problem trying solving when deploying my app spring boot app with docker container.</p>  <blockquote>   <p>org.apache.kafka.common.KafkaException: org.apache.kafka.common.KafkaException: Failed to load SSL keystore /tmp/tomcat-docbase.4737956707529585395.8080/deployments/app/certs/kafka.truststore.jks</p> </blockquote>  <p>/deployments is my workdir configure in dockerfile</p>  <p>i find it strange that it picking on tmp/tomcat docbase because when configuring for other truststore it getting in the correct place. Here what inside my application.yaml</p>  <pre><code>spring:    kafka:      bootstrap-servers:localhost:9092      ssl:        truststore-location: /deployments/app/certs/kafka-truststore.jks        truststore-password: test      consumer:       group-id: consumerid server:    ssl:     enabled: false     key-store: /deployments/app/certs/dp--dev.jks     key-store-password: changeit     trust-store: /deployments/app/certs/ol-truststore-dev.jks     trust-store-password: test </code></pre>  <p>it something that i am missing or it relate to kafka springframework lib that i am using ?</p> ",
    "OwnerUserId": "2142023",
    "LastEditorUserId": "1240763",
    "LastEditDate": "2020-09-01T19:33:45.390",
    "LastActivityDate": "2020-09-01T19:33:45.390",
    "Title": "problem path for truststore inside docker with spring boot and kafka",
    "Tags": "<spring-boot><docker><apache-kafka><spring-kafka>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "55562381",
    "PostTypeId": "1",
    "AcceptedAnswerId": "55635671",
    "CreationDate": "2019-04-07T18:34:58.743",
    "Score": "8",
    "ViewCount": "11712",
    "Body": "<p>Dockerfile</p>  <pre><code>FROM openjdk:8  ADD target/docker-spring-boot.jar docker-spring-boot.jar EXPOSE 8085 ENTRYPOINT ['java','-jar','docker-spring-boot.jar'] </code></pre>  <p>command to build docker</p>  <pre><code>docker build -f Dockerfile -t docker-spring-boot . </code></pre>  <p>spring boot jar location below .</p>  <pre><code>target/docker-spring-boot.jar </code></pre>  <p>command to run docker</p>  <pre><code>docker run -p 8085:8085 docker-spring-boot </code></pre>  <p>The application works normally without a docker. Not able to run the application on docker.</p>  <p>Error:</p>  <pre><code>This site can\u2019t be reached </code></pre>  <p>docker run logs</p>  <pre><code> E:\\micorservices_samples\\docker-spring-boot\\docker-springbootdocker run -p 8085 :8085 docker-spring-boot     .   ____          _            __ _ _  /\\\\ / ___'_ __ _ _(_)_ __  __  _ \\ \\ \\ \\ ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\  \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )   '  |____| .__|_| |_|_| |_\\__, | / / / /   =========|_|==============|___/=/_/_/_/  :: Spring Boot ::        (v2.1.4.RELEASE)   2019-04-07 18:29:47.944  INFO 1 --- [           main]  c.r.d.DockerSpringbootAppl ication        : Starting  DockerSpringbootApplication v0.0.1-SNAPSHOT on 352ac4d 12009 with PID  1 (/docker-spring-boot.jar started by root in /) 2019-04-07  18:29:47.970  INFO 1 --- [main] c.r.d.DockerSpringbootAppl  ication        : No active profile set, falling back to default  profiles: defaul t 2019-04-07 18:29:54.302  INFO 1 --- [            main] o.s.b.w.embedded.tomcat.To mcatWebServer  : Tomcat initialized  with port(s): 8085 (http) 2019-04-07 18:29:54.463  INFO 1 --- [         main] o.apache.catalina.core.Sta ndardService   : Starting service  [Tomcat] 2019-04-07 18:29:54.464  INFO 1 --- [           main]  org.apache.catalina.core.S tandardEngine  : Starting Servlet engine:  [Apache Tomcat/9.0.17] 2019-04-07 18:29:54.854  INFO 1 --- [            main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring  embedded WebApplicationContext 2019-04-07 18:29:54.855  INFO 1 --- [    main] o.s.web.context.ContextLoa der            : Root  WebApplicationContext: initialization completed in 6539 ms 2019-04-07  18:29:55.859  INFO 1 --- [main] o.s.s.concurrent.ThreadPoo  lTaskExecutor  : Initializing ExecutorService  'applicationTaskExecutor' 2019-04-07 18:29:56.691  INFO 1 --- [         main] o.s.b.w.embedded.tomcat.To mcatWebServer  : Tomcat started on  port(s): 8085 (http) with context path '' 2019-04-07 18:29:56.705   INFO 1 --- [main] c.r.d.DockerSpringbootAppl ication         : Started DockerSpringbootApplication in 10.902 seconds (JVM runn ing  for 12.566)     C:\\Users\\Mabeldocker logs -f 20026c6c7602     .   ____          _            __ _ _  /\\\\ / ___'_ __ _ _(_)_ __  __  _ \\ \\ \\ \\ ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\  \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )   '  |____| .__|_| |_|_| |_\\__, | / / / /   =========|_|==============|___/=/_/_/_/  :: Spring Boot ::        (v2.1.4.RELEASE)   2019-04-07 18:51:23.381  INFO 1 --- [           main]  c.r.d.DockerSpringbootAppl ication        : Starting  DockerSpringbootApplication v0.0.1-SNAPSHOT on 20026c6 c7602 with PID  1 (/dsb.jar started by root in /) 2019-04-07 18:51:23.403  INFO 1 ---  [           main] c.r.d.DockerSpringbootAppl ication        : No  active profile set, falling back to default profiles: defaul t  2019-04-07 18:51:29.434  INFO 1 --- [main]  o.s.b.w.embedded.tomcat.To mcatWebServer  : Tomcat initialized with  port(s): 8085 (http) 2019-04-07 18:51:29.608  INFO 1 --- [            main] o.apache.catalina.core.Sta ndardService   : Starting service  [Tomcat] 2019-04-07 18:51:29.613  INFO 1 --- [           main]  org.apache.catalina.core.S tandardEngine  : Starting Servlet engine:  [Apache Tomcat/9.0.17] 2019-04-07 18:51:30.012  INFO 1 --- [            main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring  embedded WebApplicationContext 2019-04-07 18:51:30.014  INFO 1 --- [    main] o.s.web.context.ContextLoa der            : Root  WebApplicationContext: initialization completed in 6275 ms 2019-04-07  18:51:31.038  INFO 1 --- [           main] o.s.s.concurrent.ThreadPoo  lTaskExecutor  : Initializing ExecutorService  'applicationTaskExecutor' 2019-04-07 18:51:31.879  INFO 1 --- [         main] o.s.b.w.embedded.tomcat.To mcatWebServer  : Tomcat started on  port(s): 8085 (http) with context path '' 2019-04-07 18:51:31.895   INFO 1 --- [           main] c.r.d.DockerSpringbootAppl ication         : Started DockerSpringbootApplication in 10.631 seconds (JVM runn ing  for 12.241) </code></pre>  <p>Github link <a href='https://github.com/robert07ravikumar/spring-boot-docker' rel='noreferrer'>https://github.com/robert07ravikumar/spring-boot-docker</a></p>  <p><a href='https://i.stack.imgur.com/AHQ2Q.png' rel='noreferrer'><img src='https://i.stack.imgur.com/AHQ2Q.png' alt='enter image description here'></a></p> ",
    "OwnerUserId": "4844908",
    "LastEditorUserId": "3968921",
    "LastEditDate": "2019-04-11T08:05:30.060",
    "LastActivityDate": "2021-09-09T23:29:17.500",
    "Title": "Not able to connect to docker image with a spring boot application",
    "Tags": "<java><spring><spring-boot><docker><containers>",
    "AnswerCount": "6",
    "CommentCount": "5",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "56441497",
    "PostTypeId": "1",
    "AcceptedAnswerId": "56441664",
    "CreationDate": "2019-06-04T09:52:04.153",
    "Score": "8",
    "ViewCount": "19487",
    "Body": "<p>What I'm trying to do is, connect from my spring-boot app to mysql database in Docker. Each in their own container.</p>  <p>But I must be having something wrong because I can't do it.</p>  <p><strong>To keep it simple :</strong></p>  <p>application-properties :</p>  <pre><code># URL for the mysql db spring.datasource.url=jdbc:mysql://workaround-mysql:3308/workaround?serverTimezone=UTC&amp;max_allowed_packet=15728640 # User name in mysql spring.datasource.username=springuser # Password for mysql spring.datasource.password=admin #Port at which application runs server.port=8080 </code></pre>  <p>docker-compose for MySQL:</p>  <pre><code>version: '3' services:   workaround-mysql:     container_name: workaround-mysql     image: mysql     environment:       MYSQL_DATABASE: workaround       MYSQL_USER: springuser       MYSQL_PASSWORD: admin       MYSQL_ROOT_PASSWORD: admin       MYSQL_ROOT_HOST: '%'     ports:       - '3308:3306'     restart: always </code></pre>  <p>So pretty simple right ? Database I start with <code>docker-compose up</code>:</p>  <p><a href='https://i.stack.imgur.com/NKfvA.png' rel='noreferrer'><img src='https://i.stack.imgur.com/NKfvA.png' alt='enter image description here'></a></p>  <p>All seems to be working fine so far.</p>  <p>Now that I have db started, to the application, this is its <code>docker-compose.yml</code>:</p>  <pre><code>version: '3' services:    workaround:     restart: always     # will build ./docker/workaround/Dockerfile     build: ./docker/workaround     working_dir: /workaround     volumes:       - ./:/workaround       - ~/.m2:/root/.m2     expose:       - '8080'     command: 'mvn clean spring-boot:run' </code></pre>  <p>For its <code>Dockerfile</code> I use Linux Alpine and Java.</p>  <pre><code>FROM alpine:3.9 ....add java... RUN apk update RUN apk add dos2unix --update-cache --repository http://dl-3.alpinelinux.org/alpine/edge/community/ --allow-untrusted RUN apk add bash RUN apk add maven </code></pre>  <p>Super simple. Now let's start the application :</p>  <p><a href='https://i.stack.imgur.com/VFGe0.png' rel='noreferrer'><img src='https://i.stack.imgur.com/VFGe0.png' alt='enter image description here'></a></p>  <p><a href='https://i.stack.imgur.com/WEpR6.png' rel='noreferrer'><img src='https://i.stack.imgur.com/WEpR6.png' alt='enter image description here'></a></p>  <p><a href='https://i.stack.imgur.com/w6o93.png' rel='noreferrer'><img src='https://i.stack.imgur.com/w6o93.png' alt='enter image description here'></a></p>  <p>Unknown host, so let's try the IP then :</p>  <pre><code>    docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' workaround-mysql  # URL for the mysql db spring.datasource.url=jdbc:mysql://172.20.0.2:3308/workaround?serverTimezone=UTC&amp;max_allowed_packet=15728640 </code></pre>  <p>Now I get timeout:</p>  <p><a href='https://i.stack.imgur.com/AOtVs.png' rel='noreferrer'><img src='https://i.stack.imgur.com/AOtVs.png' alt='enter image description here'></a></p>  <p>As you can see I get error. What is wrong with my setup and how to fix this? Either I have unknown host exception or Refused to connect or connection timeout.</p>  <p>I have tried:</p>  <ul> <li>Using ip of a container in my application.properties, didn't work</li> <li>Different ports for MySQL and application </li> <li>Different images and versions of MySQL </li> <li>Having everything in one docker compose with wait</li> <li>timer for database.</li> <li>Minimal setup with <a href='https://github.com/hellokoding/hellokoding-courses/tree/master/docker-examples/dockercompose-springboot-mysql-nginx' rel='noreferrer'>https://github.com/hellokoding/hellokoding-courses/tree/master/docker-examples/dockercompose-springboot-mysql-nginx</a> Also resulted in communication link failure, Site was accessible but I doubt that db was connected properly.</li> </ul>  <p><strong>Notes</strong>: </p>  <ul> <li><p>I run this all on one computer I use port 3308 because I have local MySQL db at 3306.</p></li> <li><p>Here is <code>docker ps -a</code></p></li> </ul>  <p><a href='https://i.stack.imgur.com/z7YJK.png' rel='noreferrer'><img src='https://i.stack.imgur.com/z7YJK.png' alt='enter image description here'></a></p>  <p>@Vusal ANSWER output :</p>  <p><a href='https://i.stack.imgur.com/EIUFN.png' rel='noreferrer'><img src='https://i.stack.imgur.com/EIUFN.png' alt='enter image description here'></a></p>  <p>Only thing different from code in answer I did wait for database to be ready 30 seconds</p>  <pre><code>command: /bin/bash -c 'sleep 30;mvn clean spring-boot:run;' </code></pre> ",
    "OwnerUserId": "2733333",
    "LastEditorUserId": "472495",
    "LastEditDate": "2019-06-04T21:39:08.083",
    "LastActivityDate": "2020-07-19T06:01:40.877",
    "Title": "Docker MySQL - can't connect from Spring Boot app to MySQL database",
    "Tags": "<mysql><spring><spring-boot><docker><docker-compose>",
    "AnswerCount": "4",
    "CommentCount": "7",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "56441497",
    "PostTypeId": "1",
    "AcceptedAnswerId": "56441664",
    "CreationDate": "2019-06-04T09:52:04.153",
    "Score": "8",
    "ViewCount": "19487",
    "Body": "<p>What I'm trying to do is, connect from my spring-boot app to mysql database in Docker. Each in their own container.</p>  <p>But I must be having something wrong because I can't do it.</p>  <p><strong>To keep it simple :</strong></p>  <p>application-properties :</p>  <pre><code># URL for the mysql db spring.datasource.url=jdbc:mysql://workaround-mysql:3308/workaround?serverTimezone=UTC&amp;max_allowed_packet=15728640 # User name in mysql spring.datasource.username=springuser # Password for mysql spring.datasource.password=admin #Port at which application runs server.port=8080 </code></pre>  <p>docker-compose for MySQL:</p>  <pre><code>version: '3' services:   workaround-mysql:     container_name: workaround-mysql     image: mysql     environment:       MYSQL_DATABASE: workaround       MYSQL_USER: springuser       MYSQL_PASSWORD: admin       MYSQL_ROOT_PASSWORD: admin       MYSQL_ROOT_HOST: '%'     ports:       - '3308:3306'     restart: always </code></pre>  <p>So pretty simple right ? Database I start with <code>docker-compose up</code>:</p>  <p><a href='https://i.stack.imgur.com/NKfvA.png' rel='noreferrer'><img src='https://i.stack.imgur.com/NKfvA.png' alt='enter image description here'></a></p>  <p>All seems to be working fine so far.</p>  <p>Now that I have db started, to the application, this is its <code>docker-compose.yml</code>:</p>  <pre><code>version: '3' services:    workaround:     restart: always     # will build ./docker/workaround/Dockerfile     build: ./docker/workaround     working_dir: /workaround     volumes:       - ./:/workaround       - ~/.m2:/root/.m2     expose:       - '8080'     command: 'mvn clean spring-boot:run' </code></pre>  <p>For its <code>Dockerfile</code> I use Linux Alpine and Java.</p>  <pre><code>FROM alpine:3.9 ....add java... RUN apk update RUN apk add dos2unix --update-cache --repository http://dl-3.alpinelinux.org/alpine/edge/community/ --allow-untrusted RUN apk add bash RUN apk add maven </code></pre>  <p>Super simple. Now let's start the application :</p>  <p><a href='https://i.stack.imgur.com/VFGe0.png' rel='noreferrer'><img src='https://i.stack.imgur.com/VFGe0.png' alt='enter image description here'></a></p>  <p><a href='https://i.stack.imgur.com/WEpR6.png' rel='noreferrer'><img src='https://i.stack.imgur.com/WEpR6.png' alt='enter image description here'></a></p>  <p><a href='https://i.stack.imgur.com/w6o93.png' rel='noreferrer'><img src='https://i.stack.imgur.com/w6o93.png' alt='enter image description here'></a></p>  <p>Unknown host, so let's try the IP then :</p>  <pre><code>    docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' workaround-mysql  # URL for the mysql db spring.datasource.url=jdbc:mysql://172.20.0.2:3308/workaround?serverTimezone=UTC&amp;max_allowed_packet=15728640 </code></pre>  <p>Now I get timeout:</p>  <p><a href='https://i.stack.imgur.com/AOtVs.png' rel='noreferrer'><img src='https://i.stack.imgur.com/AOtVs.png' alt='enter image description here'></a></p>  <p>As you can see I get error. What is wrong with my setup and how to fix this? Either I have unknown host exception or Refused to connect or connection timeout.</p>  <p>I have tried:</p>  <ul> <li>Using ip of a container in my application.properties, didn't work</li> <li>Different ports for MySQL and application </li> <li>Different images and versions of MySQL </li> <li>Having everything in one docker compose with wait</li> <li>timer for database.</li> <li>Minimal setup with <a href='https://github.com/hellokoding/hellokoding-courses/tree/master/docker-examples/dockercompose-springboot-mysql-nginx' rel='noreferrer'>https://github.com/hellokoding/hellokoding-courses/tree/master/docker-examples/dockercompose-springboot-mysql-nginx</a> Also resulted in communication link failure, Site was accessible but I doubt that db was connected properly.</li> </ul>  <p><strong>Notes</strong>: </p>  <ul> <li><p>I run this all on one computer I use port 3308 because I have local MySQL db at 3306.</p></li> <li><p>Here is <code>docker ps -a</code></p></li> </ul>  <p><a href='https://i.stack.imgur.com/z7YJK.png' rel='noreferrer'><img src='https://i.stack.imgur.com/z7YJK.png' alt='enter image description here'></a></p>  <p>@Vusal ANSWER output :</p>  <p><a href='https://i.stack.imgur.com/EIUFN.png' rel='noreferrer'><img src='https://i.stack.imgur.com/EIUFN.png' alt='enter image description here'></a></p>  <p>Only thing different from code in answer I did wait for database to be ready 30 seconds</p>  <pre><code>command: /bin/bash -c 'sleep 30;mvn clean spring-boot:run;' </code></pre> ",
    "OwnerUserId": "2733333",
    "LastEditorUserId": "472495",
    "LastEditDate": "2019-06-04T21:39:08.083",
    "LastActivityDate": "2020-07-19T06:01:40.877",
    "Title": "Docker MySQL - can't connect from Spring Boot app to MySQL database",
    "Tags": "<mysql><spring><spring-boot><docker><docker-compose>",
    "AnswerCount": "4",
    "CommentCount": "7",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "56441497",
    "PostTypeId": "1",
    "AcceptedAnswerId": "56441664",
    "CreationDate": "2019-06-04T09:52:04.153",
    "Score": "8",
    "ViewCount": "19487",
    "Body": "<p>What I'm trying to do is, connect from my spring-boot app to mysql database in Docker. Each in their own container.</p>  <p>But I must be having something wrong because I can't do it.</p>  <p><strong>To keep it simple :</strong></p>  <p>application-properties :</p>  <pre><code># URL for the mysql db spring.datasource.url=jdbc:mysql://workaround-mysql:3308/workaround?serverTimezone=UTC&amp;max_allowed_packet=15728640 # User name in mysql spring.datasource.username=springuser # Password for mysql spring.datasource.password=admin #Port at which application runs server.port=8080 </code></pre>  <p>docker-compose for MySQL:</p>  <pre><code>version: '3' services:   workaround-mysql:     container_name: workaround-mysql     image: mysql     environment:       MYSQL_DATABASE: workaround       MYSQL_USER: springuser       MYSQL_PASSWORD: admin       MYSQL_ROOT_PASSWORD: admin       MYSQL_ROOT_HOST: '%'     ports:       - '3308:3306'     restart: always </code></pre>  <p>So pretty simple right ? Database I start with <code>docker-compose up</code>:</p>  <p><a href='https://i.stack.imgur.com/NKfvA.png' rel='noreferrer'><img src='https://i.stack.imgur.com/NKfvA.png' alt='enter image description here'></a></p>  <p>All seems to be working fine so far.</p>  <p>Now that I have db started, to the application, this is its <code>docker-compose.yml</code>:</p>  <pre><code>version: '3' services:    workaround:     restart: always     # will build ./docker/workaround/Dockerfile     build: ./docker/workaround     working_dir: /workaround     volumes:       - ./:/workaround       - ~/.m2:/root/.m2     expose:       - '8080'     command: 'mvn clean spring-boot:run' </code></pre>  <p>For its <code>Dockerfile</code> I use Linux Alpine and Java.</p>  <pre><code>FROM alpine:3.9 ....add java... RUN apk update RUN apk add dos2unix --update-cache --repository http://dl-3.alpinelinux.org/alpine/edge/community/ --allow-untrusted RUN apk add bash RUN apk add maven </code></pre>  <p>Super simple. Now let's start the application :</p>  <p><a href='https://i.stack.imgur.com/VFGe0.png' rel='noreferrer'><img src='https://i.stack.imgur.com/VFGe0.png' alt='enter image description here'></a></p>  <p><a href='https://i.stack.imgur.com/WEpR6.png' rel='noreferrer'><img src='https://i.stack.imgur.com/WEpR6.png' alt='enter image description here'></a></p>  <p><a href='https://i.stack.imgur.com/w6o93.png' rel='noreferrer'><img src='https://i.stack.imgur.com/w6o93.png' alt='enter image description here'></a></p>  <p>Unknown host, so let's try the IP then :</p>  <pre><code>    docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' workaround-mysql  # URL for the mysql db spring.datasource.url=jdbc:mysql://172.20.0.2:3308/workaround?serverTimezone=UTC&amp;max_allowed_packet=15728640 </code></pre>  <p>Now I get timeout:</p>  <p><a href='https://i.stack.imgur.com/AOtVs.png' rel='noreferrer'><img src='https://i.stack.imgur.com/AOtVs.png' alt='enter image description here'></a></p>  <p>As you can see I get error. What is wrong with my setup and how to fix this? Either I have unknown host exception or Refused to connect or connection timeout.</p>  <p>I have tried:</p>  <ul> <li>Using ip of a container in my application.properties, didn't work</li> <li>Different ports for MySQL and application </li> <li>Different images and versions of MySQL </li> <li>Having everything in one docker compose with wait</li> <li>timer for database.</li> <li>Minimal setup with <a href='https://github.com/hellokoding/hellokoding-courses/tree/master/docker-examples/dockercompose-springboot-mysql-nginx' rel='noreferrer'>https://github.com/hellokoding/hellokoding-courses/tree/master/docker-examples/dockercompose-springboot-mysql-nginx</a> Also resulted in communication link failure, Site was accessible but I doubt that db was connected properly.</li> </ul>  <p><strong>Notes</strong>: </p>  <ul> <li><p>I run this all on one computer I use port 3308 because I have local MySQL db at 3306.</p></li> <li><p>Here is <code>docker ps -a</code></p></li> </ul>  <p><a href='https://i.stack.imgur.com/z7YJK.png' rel='noreferrer'><img src='https://i.stack.imgur.com/z7YJK.png' alt='enter image description here'></a></p>  <p>@Vusal ANSWER output :</p>  <p><a href='https://i.stack.imgur.com/EIUFN.png' rel='noreferrer'><img src='https://i.stack.imgur.com/EIUFN.png' alt='enter image description here'></a></p>  <p>Only thing different from code in answer I did wait for database to be ready 30 seconds</p>  <pre><code>command: /bin/bash -c 'sleep 30;mvn clean spring-boot:run;' </code></pre> ",
    "OwnerUserId": "2733333",
    "LastEditorUserId": "472495",
    "LastEditDate": "2019-06-04T21:39:08.083",
    "LastActivityDate": "2020-07-19T06:01:40.877",
    "Title": "Docker MySQL - can't connect from Spring Boot app to MySQL database",
    "Tags": "<mysql><spring><spring-boot><docker><docker-compose>",
    "AnswerCount": "4",
    "CommentCount": "7",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "56938511",
    "PostTypeId": "1",
    "CreationDate": "2019-07-08T15:50:21.217",
    "Score": "8",
    "ViewCount": "7029",
    "Body": "<p>I have a Spring Boot Application and developed it with a mongo db which was running in brew services. </p>  <p>To get a connection to the db I just had to put the following into application.properties in Spring Boot </p>  <pre><code>spring.data.mongodb.uri=mongodb://localhost:27017/db </code></pre>  <p>changing the application properties to </p>  <pre><code>spring.data.mongodb.uri=mongodb://mongo:27017/db </code></pre>  <p>didtn't change anything, same Error as before.</p>  <p>Now I'm trying to put the SpringBoot Application and the MongoDB into Docker-Containers, but cant get any connection working.</p>  <p>So this is my Dockerfile in the SpringBoot Application:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp EXPOSE 8080 ADD /build/libs/dg-0.0.1-SNAPSHOT.jar dg-0.0.1-SNAPSHOT.jar ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/dg-0.0.1-SNAPSHOT.jar'] </code></pre>  <p>This is my Docker-Compose.yml file:</p>  <pre><code>version: '3'  services:  mongo:  container_name: docker-mongo  image: mongo:latest  ports:    - '27017:27017'  volumes:   - ./data/db:/data/db  spring:  depends_on:    - mongo  image:    docker-spring-http-alpine  ports:    - '8080:8080'  links:    - mongo </code></pre>  <p>After executing Docker-Compose with </p>  <pre><code>docker-compose up </code></pre>  <p>I get the following error: (this is the actual error message )</p>  <pre><code>2019-07-08 23:10:19.990  INFO 1 --- [localhost:27017] org.mongodb.driver.cluster: Exception in monitor thread while connecting to server localhost:27017       com.mongodb.MongoSocketOpenException: Exception opening socket at com.mongodb.internal.connection.SocketStream.open(SocketStream.java:67) ~[mongodb-driver-core-3.8.2.jar!/:na] at com.mongodb.internal.connection.InternalStreamConnection.open(InternalStreamConnection.java:126) ~[mongodb-driver-core-3.8.2.jar!/:na] at com.mongodb.internal.connection.DefaultServerMonitor$ServerMonitorRunnable.run(DefaultServerMonitor.java:117) ~[mongodb-driver-core-3.8.2.jar!/:na] at java.lang.Thread.run(Thread.java:748) [na:1.8.0_212] Caused by: java.net.ConnectException: Connection refused (Connection refused) at java.net.PlainSocketImpl.socketConnect(Native Method) ~[na:1.8.0_212] at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350) ~[na:1.8.0_212] at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206) ~[na:1.8.0_212] at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188) ~[na:1.8.0_212] at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392) ~[na:1.8.0_212] at java.net.Socket.connect(Socket.java:589) ~[na:1.8.0_212] at com.mongodb.internal.connection.SocketStreamHelper.initialize(SocketStreamHelper.java:64) ~[mongodb-driver-core-3.8.2.jar!/:na] at com.mongodb.internal.connection.SocketStream.open(SocketStream.java:62) ~[mongodb-driver-core-3.8.2.jar!/:na] ... 3 common frames omitted </code></pre>  <p>Does someone know whats the problem here? In development environment it works like a charm.</p>  <p>Thanks in advance</p>  <p>Adding the following line to the Dockerfile </p>  <pre><code>'-Dspring.data.mongodb.uri=mongodb://mongo:27017/dg' </code></pre>  <p>into Entrypoint like this solved the connection issue</p>  <pre><code>ENTRYPOINT ['java', '-Dspring.data.mongodb.uri=mongodb://mongo:27017/dg','-Djava.security.egd=file:/dev/./urandom','-jar','/dg-0.0.1-SNAPSHOT.jar'] </code></pre>  <p>I was able to get connection to the db without the mentioned line above in the Entrypoint in the Dockerfile. I guess this is if you like to connect your db over 'links'</p>  <p>But now I was able to connect over Network, this is my code:</p>  <pre><code>version: '3.6'  services:   mongo:  container_name: docker_mongo  networks:    - gateway  ports:    - '27017:27017'  hostname: mongo  image: mongo:latest  volumes:    - ./data/db:/data/db   spring:  container_name: docker-spring  networks:    - gateway  ports:    - '8080:8080'  hostname: spring  depends_on:    - mongo  image: dg-docker-spring-http-alpine-j  networks: gateway: driver: 'bridge' </code></pre>  <p>and the following in application properties</p>  <pre><code>spring.data.mongodb.host=docker_mongo spring.data.mongodb.port=27017 spring.data.mongodb.database=db </code></pre>  <p>So it looks like the connection is working over Network now. The same code did not work with Version 3.0</p>  <p>To prevent SpringBoot to connect automatically to mongo over localhost it's also necessary to exclude MongoAutoConfiguration!</p>  <pre><code>@SpringBootApplication(exclude={MongoAutoConfiguration.class}) </code></pre>  <p>Thank you all for your help</p> ",
    "OwnerUserId": "4461271",
    "LastEditorUserId": "4461271",
    "LastEditDate": "2019-07-12T13:51:34.053",
    "LastActivityDate": "2019-07-12T13:51:34.053",
    "Title": "SpringBoot in Docker not connecting to Mongo in Docker",
    "Tags": "<mongodb><spring-boot><docker><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "56938511",
    "PostTypeId": "1",
    "CreationDate": "2019-07-08T15:50:21.217",
    "Score": "8",
    "ViewCount": "7029",
    "Body": "<p>I have a Spring Boot Application and developed it with a mongo db which was running in brew services. </p>  <p>To get a connection to the db I just had to put the following into application.properties in Spring Boot </p>  <pre><code>spring.data.mongodb.uri=mongodb://localhost:27017/db </code></pre>  <p>changing the application properties to </p>  <pre><code>spring.data.mongodb.uri=mongodb://mongo:27017/db </code></pre>  <p>didtn't change anything, same Error as before.</p>  <p>Now I'm trying to put the SpringBoot Application and the MongoDB into Docker-Containers, but cant get any connection working.</p>  <p>So this is my Dockerfile in the SpringBoot Application:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp EXPOSE 8080 ADD /build/libs/dg-0.0.1-SNAPSHOT.jar dg-0.0.1-SNAPSHOT.jar ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/dg-0.0.1-SNAPSHOT.jar'] </code></pre>  <p>This is my Docker-Compose.yml file:</p>  <pre><code>version: '3'  services:  mongo:  container_name: docker-mongo  image: mongo:latest  ports:    - '27017:27017'  volumes:   - ./data/db:/data/db  spring:  depends_on:    - mongo  image:    docker-spring-http-alpine  ports:    - '8080:8080'  links:    - mongo </code></pre>  <p>After executing Docker-Compose with </p>  <pre><code>docker-compose up </code></pre>  <p>I get the following error: (this is the actual error message )</p>  <pre><code>2019-07-08 23:10:19.990  INFO 1 --- [localhost:27017] org.mongodb.driver.cluster: Exception in monitor thread while connecting to server localhost:27017       com.mongodb.MongoSocketOpenException: Exception opening socket at com.mongodb.internal.connection.SocketStream.open(SocketStream.java:67) ~[mongodb-driver-core-3.8.2.jar!/:na] at com.mongodb.internal.connection.InternalStreamConnection.open(InternalStreamConnection.java:126) ~[mongodb-driver-core-3.8.2.jar!/:na] at com.mongodb.internal.connection.DefaultServerMonitor$ServerMonitorRunnable.run(DefaultServerMonitor.java:117) ~[mongodb-driver-core-3.8.2.jar!/:na] at java.lang.Thread.run(Thread.java:748) [na:1.8.0_212] Caused by: java.net.ConnectException: Connection refused (Connection refused) at java.net.PlainSocketImpl.socketConnect(Native Method) ~[na:1.8.0_212] at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350) ~[na:1.8.0_212] at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206) ~[na:1.8.0_212] at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188) ~[na:1.8.0_212] at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392) ~[na:1.8.0_212] at java.net.Socket.connect(Socket.java:589) ~[na:1.8.0_212] at com.mongodb.internal.connection.SocketStreamHelper.initialize(SocketStreamHelper.java:64) ~[mongodb-driver-core-3.8.2.jar!/:na] at com.mongodb.internal.connection.SocketStream.open(SocketStream.java:62) ~[mongodb-driver-core-3.8.2.jar!/:na] ... 3 common frames omitted </code></pre>  <p>Does someone know whats the problem here? In development environment it works like a charm.</p>  <p>Thanks in advance</p>  <p>Adding the following line to the Dockerfile </p>  <pre><code>'-Dspring.data.mongodb.uri=mongodb://mongo:27017/dg' </code></pre>  <p>into Entrypoint like this solved the connection issue</p>  <pre><code>ENTRYPOINT ['java', '-Dspring.data.mongodb.uri=mongodb://mongo:27017/dg','-Djava.security.egd=file:/dev/./urandom','-jar','/dg-0.0.1-SNAPSHOT.jar'] </code></pre>  <p>I was able to get connection to the db without the mentioned line above in the Entrypoint in the Dockerfile. I guess this is if you like to connect your db over 'links'</p>  <p>But now I was able to connect over Network, this is my code:</p>  <pre><code>version: '3.6'  services:   mongo:  container_name: docker_mongo  networks:    - gateway  ports:    - '27017:27017'  hostname: mongo  image: mongo:latest  volumes:    - ./data/db:/data/db   spring:  container_name: docker-spring  networks:    - gateway  ports:    - '8080:8080'  hostname: spring  depends_on:    - mongo  image: dg-docker-spring-http-alpine-j  networks: gateway: driver: 'bridge' </code></pre>  <p>and the following in application properties</p>  <pre><code>spring.data.mongodb.host=docker_mongo spring.data.mongodb.port=27017 spring.data.mongodb.database=db </code></pre>  <p>So it looks like the connection is working over Network now. The same code did not work with Version 3.0</p>  <p>To prevent SpringBoot to connect automatically to mongo over localhost it's also necessary to exclude MongoAutoConfiguration!</p>  <pre><code>@SpringBootApplication(exclude={MongoAutoConfiguration.class}) </code></pre>  <p>Thank you all for your help</p> ",
    "OwnerUserId": "4461271",
    "LastEditorUserId": "4461271",
    "LastEditDate": "2019-07-12T13:51:34.053",
    "LastActivityDate": "2019-07-12T13:51:34.053",
    "Title": "SpringBoot in Docker not connecting to Mongo in Docker",
    "Tags": "<mongodb><spring-boot><docker><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "56938511",
    "PostTypeId": "1",
    "CreationDate": "2019-07-08T15:50:21.217",
    "Score": "8",
    "ViewCount": "7029",
    "Body": "<p>I have a Spring Boot Application and developed it with a mongo db which was running in brew services. </p>  <p>To get a connection to the db I just had to put the following into application.properties in Spring Boot </p>  <pre><code>spring.data.mongodb.uri=mongodb://localhost:27017/db </code></pre>  <p>changing the application properties to </p>  <pre><code>spring.data.mongodb.uri=mongodb://mongo:27017/db </code></pre>  <p>didtn't change anything, same Error as before.</p>  <p>Now I'm trying to put the SpringBoot Application and the MongoDB into Docker-Containers, but cant get any connection working.</p>  <p>So this is my Dockerfile in the SpringBoot Application:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp EXPOSE 8080 ADD /build/libs/dg-0.0.1-SNAPSHOT.jar dg-0.0.1-SNAPSHOT.jar ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/dg-0.0.1-SNAPSHOT.jar'] </code></pre>  <p>This is my Docker-Compose.yml file:</p>  <pre><code>version: '3'  services:  mongo:  container_name: docker-mongo  image: mongo:latest  ports:    - '27017:27017'  volumes:   - ./data/db:/data/db  spring:  depends_on:    - mongo  image:    docker-spring-http-alpine  ports:    - '8080:8080'  links:    - mongo </code></pre>  <p>After executing Docker-Compose with </p>  <pre><code>docker-compose up </code></pre>  <p>I get the following error: (this is the actual error message )</p>  <pre><code>2019-07-08 23:10:19.990  INFO 1 --- [localhost:27017] org.mongodb.driver.cluster: Exception in monitor thread while connecting to server localhost:27017       com.mongodb.MongoSocketOpenException: Exception opening socket at com.mongodb.internal.connection.SocketStream.open(SocketStream.java:67) ~[mongodb-driver-core-3.8.2.jar!/:na] at com.mongodb.internal.connection.InternalStreamConnection.open(InternalStreamConnection.java:126) ~[mongodb-driver-core-3.8.2.jar!/:na] at com.mongodb.internal.connection.DefaultServerMonitor$ServerMonitorRunnable.run(DefaultServerMonitor.java:117) ~[mongodb-driver-core-3.8.2.jar!/:na] at java.lang.Thread.run(Thread.java:748) [na:1.8.0_212] Caused by: java.net.ConnectException: Connection refused (Connection refused) at java.net.PlainSocketImpl.socketConnect(Native Method) ~[na:1.8.0_212] at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350) ~[na:1.8.0_212] at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206) ~[na:1.8.0_212] at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188) ~[na:1.8.0_212] at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392) ~[na:1.8.0_212] at java.net.Socket.connect(Socket.java:589) ~[na:1.8.0_212] at com.mongodb.internal.connection.SocketStreamHelper.initialize(SocketStreamHelper.java:64) ~[mongodb-driver-core-3.8.2.jar!/:na] at com.mongodb.internal.connection.SocketStream.open(SocketStream.java:62) ~[mongodb-driver-core-3.8.2.jar!/:na] ... 3 common frames omitted </code></pre>  <p>Does someone know whats the problem here? In development environment it works like a charm.</p>  <p>Thanks in advance</p>  <p>Adding the following line to the Dockerfile </p>  <pre><code>'-Dspring.data.mongodb.uri=mongodb://mongo:27017/dg' </code></pre>  <p>into Entrypoint like this solved the connection issue</p>  <pre><code>ENTRYPOINT ['java', '-Dspring.data.mongodb.uri=mongodb://mongo:27017/dg','-Djava.security.egd=file:/dev/./urandom','-jar','/dg-0.0.1-SNAPSHOT.jar'] </code></pre>  <p>I was able to get connection to the db without the mentioned line above in the Entrypoint in the Dockerfile. I guess this is if you like to connect your db over 'links'</p>  <p>But now I was able to connect over Network, this is my code:</p>  <pre><code>version: '3.6'  services:   mongo:  container_name: docker_mongo  networks:    - gateway  ports:    - '27017:27017'  hostname: mongo  image: mongo:latest  volumes:    - ./data/db:/data/db   spring:  container_name: docker-spring  networks:    - gateway  ports:    - '8080:8080'  hostname: spring  depends_on:    - mongo  image: dg-docker-spring-http-alpine-j  networks: gateway: driver: 'bridge' </code></pre>  <p>and the following in application properties</p>  <pre><code>spring.data.mongodb.host=docker_mongo spring.data.mongodb.port=27017 spring.data.mongodb.database=db </code></pre>  <p>So it looks like the connection is working over Network now. The same code did not work with Version 3.0</p>  <p>To prevent SpringBoot to connect automatically to mongo over localhost it's also necessary to exclude MongoAutoConfiguration!</p>  <pre><code>@SpringBootApplication(exclude={MongoAutoConfiguration.class}) </code></pre>  <p>Thank you all for your help</p> ",
    "OwnerUserId": "4461271",
    "LastEditorUserId": "4461271",
    "LastEditDate": "2019-07-12T13:51:34.053",
    "LastActivityDate": "2019-07-12T13:51:34.053",
    "Title": "SpringBoot in Docker not connecting to Mongo in Docker",
    "Tags": "<mongodb><spring-boot><docker><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "58098979",
    "PostTypeId": "1",
    "AcceptedAnswerId": "58101472",
    "CreationDate": "2019-09-25T12:57:32.777",
    "Score": "8",
    "ViewCount": "16699",
    "Body": "<h1>Env</h1>  <p>Spring Boot 2.1.2. </p>  <p>2 environments: <code>local</code>(postgres 11) and <code>qa</code> (docker swarm with postgres 10 and application)</p>  <h1>Problem</h1>  <p>After <code>maxLifetime</code> passes, hikari recreates connections(closes old ones and creating new ones), but on <code>qa</code> environment connections are not getting closed: checking with <code>select * from pg_stat_activity wheredataname=...</code> and in logs we have:</p>  <pre><code>2019-09-25 12:00:20.694 DEBUG 6 --- [nnection closer] c.z.h.p.PoolBase                         : HikariPool-1 - Closing connection org.postgresql.jdbc.PgConnection@54d41592: (connection has passed maxLifetime) 2019-09-25 12:00:20.699 DEBUG 6 --- [onnection adder] c.z.h.p.HikariPool                       : HikariPool-1 - Added connection org.postgresql.jdbc.PgConnection@29e14ddb 2019-09-25 12:00:26.372 DEBUG 6 --- [nnection closer] c.z.h.p.PoolBase                         : HikariPool-1 - Closing connection org.postgresql.jdbc.PgConnection@11684c62: (connection has passed maxLifetime) 2019-09-25 12:00:26.376 DEBUG 6 --- [onnection adder] c.z.h.p.HikariPool                       : HikariPool-1 - Added connection org.postgresql.jdbc.PgConnection@453f8d6c 2019-09-25 12:00:28.130 DEBUG 6 --- [nnection closer] c.z.h.p.PoolBase                         : HikariPool-1 - Closing connection org.postgresql.jdbc.PgConnection@1b2ef2bc: (connection has passed maxLifetime) 2019-09-25 12:00:28.135 DEBUG 6 --- [onnection adder] c.z.h.p.HikariPool                       : HikariPool-1 - Added connection org.postgresql.jdbc.PgConnection@4bf86bbb 2019-09-25 12:00:28.459 DEBUG 6 --- [nnection closer] c.z.h.p.PoolBase                         : HikariPool-1 - Closing connection org.postgresql.jdbc.PgConnection@34fbeadd: (connection has passed maxLifetime) 2019-09-25 12:00:28.464 DEBUG 6 --- [onnection adder] c.z.h.p.HikariPool                       : HikariPool-1 - Added connection org.postgresql.jdbc.PgConnection@4fc7e61c 2019-09-25 12:00:31.962 DEBUG 6 --- [nnection closer] c.z.h.p.PoolBase                         : HikariPool-1 - Closing connection org.postgresql.jdbc.PgConnection@40771fc4: (connection has passed maxLifetime) 2019-09-25 12:00:31.966 DEBUG 6 --- [onnection adder] c.z.h.p.HikariPool                       : HikariPool-1 - Added connection org.postgresql.jdbc.PgConnection@ac56180 2019-09-25 12:00:35.600 DEBUG 6 --- [nnection closer] c.z.h.p.PoolBase                         : HikariPool-1 - Closing connection org.postgresql.jdbc.PgConnection@65cae248: (connection has passed maxLifetime) 2019-09-25 12:00:35.607 DEBUG 6 --- [onnection adder] c.z.h.p.HikariPool                       : HikariPool-1 - Added connection org.postgresql.jdbc.PgConnection@33a8d959 2019-09-25 12:00:35.649  WARN 6 --- [   scheduling-1] c.z.h.p.PoolBase                         : HikariPool-1 - Failed to validate connection org.postgresql.jdbc.PgConnection@15e91fa9 (This connection has been closed.). Possibly consider using a shorter maxLifetime value. 2019-09-25 12:00:35.650  WARN 6 --- [   scheduling-1] c.z.h.p.PoolBase                         : HikariPool-1 - Failed to validate connection org.postgresql.jdbc.PgConnection@11d699cc (This connection has been closed.). Possibly consider using a shorter maxLifetime value. 2019-09-25 12:00:35.651  WARN 6 --- [   scheduling-1] c.z.h.p.PoolBase                         : HikariPool-1 - Failed to validate connection org.postgresql.jdbc.PgConnection@3883b6a6 (This connection has been closed.). Possibly consider using a shorter maxLifetime value. 2019-09-25 12:00:35.652  WARN 6 --- [   scheduling-1] c.z.h.p.PoolBase                         : HikariPool-1 - Failed to validate connection org.postgresql.jdbc.PgConnection@230234a5 (This connection has been closed.). Possibly consider using a shorter maxLifetime value. 2019-09-25 12:00:35.657 DEBUG 6 --- [nnection closer] c.z.h.p.PoolBase                         : HikariPool-1 - Closing connection org.postgresql.jdbc.PgConnection@15e91fa9: (connection is dead) 2019-09-25 12:00:35.657 DEBUG 6 --- [nnection closer] c.z.h.p.PoolBase                         : HikariPool-1 - Closing connection org.postgresql.jdbc.PgConnection@11d699cc: (connection is dead) 2019-09-25 12:00:35.657 DEBUG 6 --- [nnection closer] c.z.h.p.PoolBase                         : HikariPool-1 - Closing connection org.postgresql.jdbc.PgConnection@3883b6a6: (connection is dead) 2019-09-25 12:00:35.658 DEBUG 6 --- [nnection closer] c.z.h.p.PoolBase                         : HikariPool-1 - Closing connection org.postgresql.jdbc.PgConnection@230234a5: (connection is dead) 2019-09-25 12:00:35.674 DEBUG 6 --- [onnection adder] c.z.h.p.HikariPool                       : HikariPool-1 - Added connection org.postgresql.jdbc.PgConnection@3b85c924 2019-09-25 12:00:35.678 DEBUG 6 --- [onnection adder] c.z.h.p.HikariPool                       : HikariPool-1 - Added connection org.postgresql.jdbc.PgConnection@4b022f4e 2019-09-25 12:00:35.686 DEBUG 6 --- [onnection adder] c.z.h.p.HikariPool                       : HikariPool-1 - Added connection org.postgresql.jdbc.PgConnection@6aea9ecf 2019-09-25 12:00:35.691 DEBUG 6 --- [onnection adder] c.z.h.p.HikariPool                       : HikariPool-1 - Added connection org.postgresql.jdbc.PgConnection@1ffdf0da </code></pre>  <h1>Question:</h1>  <p>Why connections are not getting closed?</p>  <p><strong>Edit:</strong> Hikari config:</p>  <pre><code> c.z.h.HikariConfig  : HikariPool-1 - configuration:  c.z.h.HikariConfig  : allowPoolSuspension.............false  c.z.h.HikariConfig  : autoCommit......................true  c.z.h.HikariConfig  : catalog.........................none  c.z.h.HikariConfig  : connectionInitSql...............none  c.z.h.HikariConfig  : connectionTestQuery.............none  c.z.h.HikariConfig  : connectionTimeout...............30000  c.z.h.HikariConfig  : dataSource......................none  c.z.h.HikariConfig  : dataSourceClassName.............none  c.z.h.HikariConfig  : dataSourceJNDI..................none  c.z.h.HikariConfig  : dataSourceProperties............{password=&lt;masked&gt;}  c.z.h.HikariConfig  : driverClassName.................'org.postgresql.Driver'  c.z.h.HikariConfig  : healthCheckProperties...........{}  c.z.h.HikariConfig  : healthCheckRegistry.............none  c.z.h.HikariConfig  : idleTimeout.....................600000  c.z.h.HikariConfig  : initializationFailTimeout.......1  c.z.h.HikariConfig  : isolateInternalQueries..........false  c.z.h.HikariConfig  : jdbcUrl.........................jdbc:postgresql://postgres/db  c.z.h.HikariConfig  : leakDetectionThreshold..........0  c.z.h.HikariConfig  : maxLifetime.....................1800000  c.z.h.HikariConfig  : maximumPoolSize.................10  c.z.h.HikariConfig  : metricRegistry..................none  c.z.h.HikariConfig  : metricsTrackerFactory...........none  c.z.h.HikariConfig  : minimumIdle.....................10  c.z.h.HikariConfig  : password........................&lt;masked&gt;  c.z.h.HikariConfig  : poolName........................'HikariPool-1'  c.z.h.HikariConfig  : readOnly........................false  c.z.h.HikariConfig  : registerMbeans..................false  c.z.h.HikariConfig  : scheduledExecutor...............none  c.z.h.HikariConfig  : schema..........................none  c.z.h.HikariConfig  : threadFactory...................internal  c.z.h.HikariConfig  : transactionIsolation............default  c.z.h.HikariConfig  : username........................'username'  c.z.h.HikariConfig  : validationTimeout...............5000  c.z.h.HikariDataSource  : HikariPool-1 - Starting...  c.z.h.p.HikariPool  : HikariPool-1 - Added connection org.postgresql.jdbc.PgConnection@53fd0d10  c.z.h.HikariDataSource  : HikariPool-1 - Start completed.  o.f.c.i.d.DatabaseFactory : Database: jdbc:postgresql://postgres/db (PostgreSQL 10.10) </code></pre> ",
    "OwnerUserId": "3575763",
    "LastEditorUserId": "3575763",
    "LastEditDate": "2019-09-25T13:52:04.660",
    "LastActivityDate": "2019-09-25T15:05:33.293",
    "Title": "Connections not being closed(HikariCP, Postgres)",
    "Tags": "<postgresql><spring-boot><docker-swarm><hikaricp>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "60551591",
    "PostTypeId": "1",
    "AcceptedAnswerId": "60551704",
    "CreationDate": "2020-03-05T18:07:43.347",
    "Score": "8",
    "ViewCount": "23166",
    "Body": "<p>Before onboarding to the enterprise k8s / AWS EKS, I am using <code>docker-desktop</code> for local k8s testing on Mac with the following Dockerfile:</p> <pre><code>FROM openjdk:11-jre-slim ARG JAR_FILE=target/*.jar COPY ${JAR_FILE} app.jar ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] </code></pre> <p>with the following deployment steps to <code>docker-desktop</code>:</p> <pre><code>docker build . -t cpchung/rema  kubectl create deployment rema --image=cpchung/rema --dry-run -o=yaml &gt; deployment.yaml echo --- &gt;&gt; deployment.yaml kubectl create service clusterip rema --tcp=8080:8080 --dry-run -o=yaml &gt;&gt; deployment.yaml kubectl apply -f deployment.yaml </code></pre> <p>This generates the deployment.yaml:</p> <pre><code>apiVersion: apps/v1 kind: Deployment metadata:   creationTimestamp: null   labels:     app: rema   name: rema spec:   replicas: 1   selector:     matchLabels:       app: rema   strategy: {}   template:     metadata:       creationTimestamp: null       labels:         app: rema     spec:       containers:       - image: cpchung/rema         name: rema         resources: {} status: {} --- apiVersion: v1 kind: Service metadata:   creationTimestamp: null   labels:     app: rema   name: rema spec:   ports:   - name: 8080-8080     port: 8080     protocol: TCP     targetPort: 8080   selector:     app: rema   type: ClusterIP status:   loadBalancer: {} </code></pre> <p>and test the deployment with the following health check:</p> <pre><code>kubectl port-forward svc/rema 8080:8080 </code></pre> <pre><code>curl localhost:8080/actuator/health </code></pre> <p>But I am getting this error:</p> <pre><code>robinhood $ kubectl get all NAME                        READY   STATUS             RESTARTS   AGE pod/rema-57df6cf5fc-px8pc   0/1     ImagePullBackOff   0          4m29s  NAME                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE service/kubernetes   ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP    18h service/rema         ClusterIP   10.100.78.60   &lt;none&gt;        8080/TCP   152m  NAME                   READY   UP-TO-DATE   AVAILABLE   AGE deployment.apps/rema   0/1     1            0           4m29s  NAME                              DESIRED   CURRENT   READY   AGE replicaset.apps/rema-57df6cf5fc   1         1         0       4m29s   robinhood $ kubectl logs rema-57df6cf5fc-px8pc Error from server (BadRequest): container &quot;rema&quot; in pod &quot;rema-57df6cf5fc-px8pc&quot; is waiting to start: image can't be pulled </code></pre> <p>But I really have the image from dockers:</p> <pre><code>robinhood $ docker images REPOSITORY                                      TAG                 IMAGE ID            CREATED             SIZE cpchung/rema                                    latest              14a4957873cd        2 hours ago         224MB  </code></pre> <p>What could be wrong here?  I am using mac with docker-desktop.</p> ",
    "OwnerUserId": "1611102",
    "LastEditorUserId": "1611102",
    "LastEditDate": "2021-04-29T02:29:19.050",
    "LastActivityDate": "2021-04-29T02:29:19.050",
    "Title": "kubernetes: image can't be pulled",
    "Tags": "<java><spring-boot><docker><kubernetes>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "61019493",
    "PostTypeId": "1",
    "AcceptedAnswerId": "61153001",
    "CreationDate": "2020-04-03T19:55:56.580",
    "Score": "8",
    "ViewCount": "1703",
    "Body": "<p>In a Spring Boot 1.5.9 application I want to access static resources through HTTP using Google Chrome.</p>  <p>In Docker I have <strong><code>404</code> error</strong>, it worked fine in embedded tomcat.</p>  <h2>Configuration</h2>  <p>This is the <code>Dockerfile</code>:</p>  <pre><code>FROM openjdk:8-jre-alpine VOLUME /tmp  RUN addgroup -S spring --gid 13371 &amp;&amp; adduser -S spring -G spring --uid 13371 RUN mkdir -p /srv/upload RUN chown -R spring:spring /srv/upload  ADD *.jar app.jar RUN sh -c 'touch /app.jar'  USER spring:spring  ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-Duser.timezone=UTC','-jar','/app.jar'] </code></pre>  <p>This is how I configure the static resources:</p>  <pre class='lang-java prettyprint-override'><code>public class MyWebMvcConfigurerAdapter extends WebMvcConfigurerAdapter {      @Override     public void addResourceHandlers(ResourceHandlerRegistry registry) {         registry.addResourceHandler('/resources/**')                 .addResourceLocations('file:upload/images/')                 .setCachePeriod(0);     } } </code></pre>  <h2>Result</h2>  <p>This is the result log when I access the URL from chrome <strong>in docker</strong> <code>http://localhost:8080/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png</code></p>  <pre class='lang-sh prettyprint-override'><code>Counting up[http-nio-8080-Acceptor-0] latch=1 Socket: [org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper@45deea1:org.apache.tomcat.util.net.NioChannel@68f517c7:java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:47510]], Read from buffer: [0] Received [GET /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png HTTP/1.1 Host: localhost:8080 Connection: keep-alive Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36 Sec-Fetch-Dest: document Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Sec-Fetch-Site: none Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Accept-Encoding: gzip, deflate, br Accept-Language: en-US,en;q=0.9,fr-FR;q=0.8,fr;q=0.7,ru-RU;q=0.6,ru;q=0.5,vi-VN;q=0.4,vi;q=0.3  ] Security checking request GET /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png   No applicable constraints defined  Not subject to any constraint Bound request context to thread: org.springframework.session.web.http.SessionRepositoryFilter$SessionRepositoryRequestWrapper@1f960fc1 Trying to match using Ant [pattern='/oauth/token'] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/oauth/token' Trying to match using Ant [pattern='/oauth/token_key'] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/oauth/token_key' Trying to match using Ant [pattern='/oauth/check_token'] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/oauth/check_token' No matches found Trying to match using Ant [pattern='/favicon.ico'] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/favicon.ico' Trying to match using Ant [pattern='/favicon.png'] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/favicon.png' Trying to match using Ant [pattern='/login'] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/login' Trying to match using Ant [pattern='/logout'] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/logout' Trying to match using Ant [pattern='/ping'] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/ping' Trying to match using Ant [pattern='/oauth/authorize'] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/oauth/authorize' Trying to match using Ant [pattern='/cb/**'] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/cb/**' Trying to match using Ant [pattern='/'] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/' Trying to match using Ant [pattern='/public/**'] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/public/**' Trying to match using Ant [pattern='/resources/**'] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/resources/**' matched /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png at position 1 of 11 in additional filter chain; firing Filter: 'WebAsyncManagerIntegrationFilter' /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png at position 2 of 11 in additional filter chain; firing Filter: 'SecurityContextPersistenceFilter' Set encoding to ISO-8859-1 No HttpSession currently exists No SecurityContext was available from the HttpSession: null. A new one will be created. /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png at position 3 of 11 in additional filter chain; firing Filter: 'HeaderWriterFilter' Not injecting HSTS header since it did not match the requestMatcher org.springframework.security.web.header.writers.HstsHeaderWriter$SecureRequestMatcher@1877aac3 /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png at position 4 of 11 in additional filter chain; firing Filter: 'LogoutFilter' Trying to match using Ant [pattern='/logout', GET] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/logout' Trying to match using Ant [pattern='/logout', POST] Request 'GET /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png' doesn't match 'POST /logout Trying to match using Ant [pattern='/logout', PUT] Request 'GET /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png' doesn't match 'PUT /logout Trying to match using Ant [pattern='/logout', DELETE] Request 'GET /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png' doesn't match 'DELETE /logout No matches found /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png at position 5 of 11 in additional filter chain; firing Filter: 'UsernamePasswordAuthenticationFilter' Request 'GET /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png' doesn't match 'POST /login /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png at position 6 of 11 in additional filter chain; firing Filter: 'RequestCacheAwareFilter' /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png at position 7 of 11 in additional filter chain; firing Filter: 'SecurityContextHolderAwareRequestFilter' /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png at position 8 of 11 in additional filter chain; firing Filter: 'AnonymousAuthenticationFilter' Populated SecurityContextHolder with anonymous token: 'org.springframework.security.authentication.AnonymousAuthenticationToken@9055e4a6: Principal: anonymousUser; Credentials: [PROTECTED]; Authenticated: true; Details: org.springframework.security.web.authentication.WebAuthenticationDetails@957e: RemoteIpAddress: 127.0.0.1; SessionId: null; Granted Authorities: ROLE_ANONYMOUS' /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png at position 9 of 11 in additional filter chain; firing Filter: 'SessionManagementFilter' /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png at position 10 of 11 in additional filter chain; firing Filter: 'ExceptionTranslationFilter' /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png at position 11 of 11 in additional filter chain; firing Filter: 'FilterSecurityInterceptor' Trying to match using Ant [pattern='/logout', GET] Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/logout' Trying to match using Ant [pattern='/logout', POST] Request 'GET /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png' doesn't match 'POST /logout Trying to match using Ant [pattern='/logout', PUT] Request 'GET /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png' doesn't match 'PUT /logout Trying to match using Ant [pattern='/logout', DELETE] Request 'GET /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png' doesn't match 'DELETE /logout No matches found Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/favicon.ico' Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/favicon.png' Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/ping' Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/public/**' Checking match of request : '/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png'; against '/resources/**' Secure object: FilterInvocation: URL: /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png; Attributes: [permitAll] Previously Authenticated: org.springframework.security.authentication.AnonymousAuthenticationToken@9055e4a6: Principal: anonymousUser; Credentials: [PROTECTED]; Authenticated: true; Details: org.springframework.security.web.authentication.WebAuthenticationDetails@957e: RemoteIpAddress: 127.0.0.1; SessionId: null; Granted Authorities: ROLE_ANONYMOUS Voter: org.springframework.security.web.access.expression.WebExpressionVoter@6f01175d, returned: 1 Authorization successful RunAsManager did not change Authentication object /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png reached end of additional filter chain; proceeding with original chain DispatcherServlet with name 'dispatcherServlet' processing GET request for [/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png] Looking up handler method for path /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png looking up handler for path: /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png Did not find handler method for [/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png] Looking up handler method for path /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png Did not find handler method for [/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png] Looking up handler method for path /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png Did not find handler method for [/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png] Looking up handler method for path /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png Did not find handler method for [/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png] Looking up handler method for path /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png Did not find handler method for [/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png] Looking up handler method for path /resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png Did not find handler method for [/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png] Matching patterns for request [/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png] are [/resources/**, /**] URI Template variables for request [/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png] are {} Mapping [/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png] to HandlerExecutionChain with handler [ResourceHttpRequestHandler [locations=[URL [file:upload/images/], class path resource [META-INF/resources/], class path resource [resources/], class path resource [static/], class path resource [public/]], resolvers=[org.springframework.web.servlet.resource.PathResourceResolver@6f49d153]]] and 1 interceptor Last-Modified value for [/resources/promotions/37/lg/31723d95-eec3-4ff9-aa42-e3477559e9df.png] is: -1 SecurityContext is empty or contents are anonymous - context will not be stored in HttpSession. Null ModelAndView returned to DispatcherServlet with name 'dispatcherServlet': assuming HandlerAdapter completed request handling Successfully completed request Chain processed normally SecurityContextHolder now cleared, as request processing completed Cleared thread-bound request context: org.springframework.session.web.http.SessionRepositoryFilter$SessionRepositoryRequestWrapper@1f960fc1 Processing ErrorPage[errorCode=0, location=/error] DispatcherServlet with name 'dispatcherServlet' processing GET request for [/error] Looking up handler method for path /error looking up handler for path: /error Did not find handler method for [/error] Looking up handler method for path /error Did not find handler method for [/error] Looking up handler method for path /error Returning handler method [public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)] Returning cached instance of singleton bean 'basicErrorController' Last-Modified value for [/error] is: -1 Requested media types are [text/html, text/html;q=0.8] based on Accept header types and producible media types [text/html]) Returning cached instance of singleton bean 'error' Returning [org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration$SpelView@351e414e] based on requested media type 'text/html' Rendering view [org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration$SpelView@351e414e] in DispatcherServlet with name 'dispatcherServlet' Successfully completed request  Disabling the response for further output Socket: [org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper@45deea1:org.apache.tomcat.util.net.NioChannel@68f517c7:java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:47510]], Read from buffer: [0] Socket: [org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper@45deea1:org.apache.tomcat.util.net.NioChannel@68f517c7:java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:47510]], Status in: [OPEN_READ], State out: [OPEN]  </code></pre>  <h2>Expected</h2>  <p>This is what I expect (in the development environment) while accessing <code>http://localhost:8080/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg</code></p>  <pre class='lang-sh prettyprint-override'><code>Counting up[http-nio-8080-Acceptor-0] latch=1 Socket: [org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper@4d64a855:org.apache.tomcat.util.net.NioChannel@3eaf8ba0:java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:59330]], Read from buffer: [0] Received [GET /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg HTTP/1.1 Host: localhost:8080 Connection: keep-alive Pragma: no-cache Cache-Control: no-cache Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36 Sec-Fetch-Dest: document Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Sec-Fetch-Site: none Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Accept-Encoding: gzip, deflate, br Accept-Language: en-US,en;q=0.9,fr-FR;q=0.8,fr;q=0.7,ru-RU;q=0.6,ru;q=0.5,vi-VN;q=0.4,vi;q=0.3  ] Security checking request GET /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg   No applicable constraints defined  Not subject to any constraint Bound request context to thread: org.springframework.session.web.http.SessionRepositoryFilter$SessionRepositoryRequestWrapper@29e45b2 Trying to match using Ant [pattern='/'] Checking match of request : '/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg'; against '/' Trying to match using Ant [pattern='/public/**'] Checking match of request : '/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg'; against '/public/**' Trying to match using Ant [pattern='/resources/**'] Checking match of request : '/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg'; against '/resources/**' matched /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg at position 1 of 11 in additional filter chain; firing Filter: 'WebAsyncManagerIntegrationFilter' /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg at position 2 of 11 in additional filter chain; firing Filter: 'SecurityContextPersistenceFilter' Set encoding to ISO-8859-1 No HttpSession currently exists No SecurityContext was available from the HttpSession: null. A new one will be created. /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg at position 3 of 11 in additional filter chain; firing Filter: 'HeaderWriterFilter' Not injecting HSTS header since it did not match the requestMatcher org.springframework.security.web.header.writers.HstsHeaderWriter$SecureRequestMatcher@204c4db /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg at position 4 of 11 in additional filter chain; firing Filter: 'LogoutFilter' Trying to match using Ant [pattern='/logout', GET] Checking match of request : '/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg'; against '/logout' Trying to match using Ant [pattern='/logout', POST] Request 'GET /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg' doesn't match 'POST /logout Trying to match using Ant [pattern='/logout', PUT] Request 'GET /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg' doesn't match 'PUT /logout Trying to match using Ant [pattern='/logout', DELETE] Request 'GET /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg' doesn't match 'DELETE /logout No matches found /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg at position 5 of 11 in additional filter chain; firing Filter: 'UsernamePasswordAuthenticationFilter' Request 'GET /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg' doesn't match 'POST /login /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg at position 6 of 11 in additional filter chain; firing Filter: 'RequestCacheAwareFilter' /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg at position 7 of 11 in additional filter chain; firing Filter: 'SecurityContextHolderAwareRequestFilter' /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg at position 8 of 11 in additional filter chain; firing Filter: 'AnonymousAuthenticationFilter' Populated SecurityContextHolder with anonymous token: 'org.springframework.security.authentication.AnonymousAuthenticationToken@9055e4a6: Principal: anonymousUser; Credentials: [PROTECTED]; Authenticated: true; Details: org.springframework.security.web.authentication.WebAuthenticationDetails@957e: RemoteIpAddress: 127.0.0.1; SessionId: null; Granted Authorities: ROLE_ANONYMOUS' /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg at position 9 of 11 in additional filter chain; firing Filter: 'SessionManagementFilter' /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg at position 10 of 11 in additional filter chain; firing Filter: 'ExceptionTranslationFilter' /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg at position 11 of 11 in additional filter chain; firing Filter: 'FilterSecurityInterceptor' No matches found g/843291ef-2309-4809-9f37-38257e087a97.jpeg'; against '/public/**' Checking match of request : '/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg'; against '/resources/**' Secure object: FilterInvocation: URL: /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg; Attributes: [permitAll] Previously Authenticated: org.springframework.security.authentication.AnonymousAuthenticationToken@9055e4a6: Principal: anonymousUser; Credentials: [PROTECTED]; Authenticated: true; Details: org.springframework.security.web.authentication.WebAuthenticationDetails@957e: RemoteIpAddress: 127.0.0.1; SessionId: null; Granted Authorities: ROLE_ANONYMOUS Voter: org.springframework.security.web.access.expression.WebExpressionVoter@199cd81c, returned: 1 Authorization successful RunAsManager did not change Authentication object /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg reached end of additional filter chain; proceeding with original chain DispatcherServlet with name 'dispatcherServlet' processing GET request for [/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg] Looking up handler method for path /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg looking up handler for path: /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg Did not find handler method for [/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg] Looking up handler method for path /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg Did not find handler method for [/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg] Looking up handler method for path /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg Did not find handler method for [/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg] Looking up handler method for path /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg Did not find handler method for [/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg] Looking up handler method for path /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg Did not find handler method for [/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg] Looking up handler method for path /resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg Did not find handler method for [/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg] Matching patterns for request [/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg] are [/resources/**, /**] URI Template variables for request [/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg] are {} Mapping [/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg] to HandlerExecutionChain with handler [ResourceHttpRequestHandler [locations=[URL [file:upload/images/], class path resource [META-INF/resources/], class path resource [resources/], class path resource [static/], class path resource [public/]], resolvers=[org.springframework.web.servlet.resource.PathResourceResolver@49a0fe14]]] and 1 interceptor Last-Modified value for [/resources/promotions/39/lg/843291ef-2309-4809-9f37-38257e087a97.jpeg] is: -1 SecurityContext is empty or contents are anonymous - context will not be stored in HttpSession. Null ModelAndView returned to DispatcherServlet with name 'dispatcherServlet': assuming HandlerAdapter completed request handling Successfully completed request </code></pre>  <h2>Investigation</h2>  <p>I have replicated the production environment locally and I used the same absolute path <code>file:/srv/upload/images</code> in development, I can confirm that status code are different within docker and without it:</p>  <ul> <li>In embedded tomcat: 200</li> <li>In docker: 404 </li> </ul>  <p>The problem is not related to the path being different but only because of docker.</p>  <h2>Question</h2>  <ul> <li>Is there a step I have forgotten?</li> </ul>  <p>Any hint would be much appreciated.</p> ",
    "OwnerUserId": "2127277",
    "LastEditorUserId": "2127277",
    "LastEditDate": "2020-04-06T19:23:26.033",
    "LastActivityDate": "2022-09-15T11:10:39.537",
    "Title": "Spring boot 1.5.9, 404 error while accessing resources images within Docker container",
    "Tags": "<spring><spring-boot><docker><spring-mvc><spring-security>",
    "AnswerCount": "1",
    "CommentCount": "10",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "62655110",
    "PostTypeId": "1",
    "AcceptedAnswerId": "62659993",
    "CreationDate": "2020-06-30T10:12:22.127",
    "Score": "8",
    "ViewCount": "7732",
    "Body": "<p>I'm trying to run spring-boot-admin on ECS Fargate - and after a few minutes the server dies and the logs are filled with 'too many open files in system' errors.</p> <p>I'm using spring-boot 2.3.1, and have tried 2.2.3 and the 2.3.0-SNAPSHOT of spring-boot-admin.  The jar is running on an ubuntu 20.04 base image with openjdk-11-jdk-headless installed.  The ECS service has 2gb RAM available, and I've increased Ulimits on nofile and nproc (100000)</p> <pre><code>      Ulimits:         - Name: nofile           HardLimit: 1000000           SoftLimit: 1000000         - Name: nproc           HardLimit: 1000000           SoftLimit: 1000000 </code></pre> <p>Stacktrace:</p> <p><code>2020-06-29 22:03:35.691 ERROR 6 --- [io-8080-exec-24] o.a.c.c.C.[.[.[/].[dispatcherServlet] : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is io.netty.channel.ChannelException: io.netty.channel.unix.Errors$NativeIoException: newSocketStream(..) failed: Too many open files in system] with root cause io.netty.channel.unix.Errors$NativeIoException: newSocketStream(..) failed: Too many open files in system 2020-06-29 22:03:36.345 ERROR 6 --- [io-8080-exec-14] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is io.netty.channel.ChannelException: io.netty.channel.unix.Errors$NativeIoException: newSocketStream(..) failed: Too many open files in system] with root cause io.netty.channel.unix.Errors$NativeIoException: newSocketStream(..) failed: Too many open files in system 2020-06-29 22:03:36.350 ERROR 6 --- [o-8080-Acceptor] org.apache.tomcat.util.net.Acceptor : Socket accept failed java.io.IOException: Too many open files in system at java.base/sun.nio.ch.ServerSocketChannelImpl.accept0(Native Method) ~[na:na] at java.base/sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:533) ~[na:na] at java.base/sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:285) ~[na:na] at org.apache.tomcat.util.net.NioEndpoint.serverSocketAccept(NioEndpoint.java:469) ~[tomcat-embed-core-9.0.36.jar!/:9.0.36] at org.apache.tomcat.util.net.NioEndpoint.serverSocketAccept(NioEndpoint.java:71) ~[tomcat-embed-core-9.0.36.jar!/:9.0.36] at org.apache.tomcat.util.net.Acceptor.run(Acceptor.java:95) ~[tomcat-embed-core-9.0.36.jar!/:9.0.36] at java.base/java.lang.Thread.run(Thread.java:834) ~[na:na]</code></p> <p>I've got a set of 8 microservices connected with the sba-client (no security at the moment) for 3 environments (24 instances in total).  Only settings in the client are:</p> <pre><code>spring.boot.admin.client.instance.prefer-ip=true spring.boot.admin.client.url=https://xxxxx.com spring.boot.admin.client.instance.name= spring.boot.admin.client.instance.metadata.tags.environment=${spring.profiles.active} </code></pre> <p>I've enabled prefer IP as the majority of these instances arent behind Eureka or a load balancer, and just process data off queues.</p> <p>The server only has <code>spring.boot.admin.ui.public-url</code> set.</p> <p>For the first few minutes everything works fine - but then these errors start occuring and everything falls over.  Cloudwatch metrics say the cpu shoot to 100%, then target-group healthchecks on sba fail and ECS restarts the task.  This currently takes about 30 minutes.</p> <p>Raising the ulimits from defaults has increased the time before the app falls over, but it still falls over eventually - as if its leaking sockets / connections.</p> <p>I've not had any experience running webflux / netty apps - is there something I'm missing?  Do I need to set a higher ulimit?</p> ",
    "OwnerUserId": "329028",
    "LastActivityDate": "2020-07-13T14:04:55.430",
    "Title": "Spring Boot Admin - Too Many open Files In System Error",
    "Tags": "<spring-boot><docker><amazon-ecs><spring-boot-admin>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "66138983",
    "PostTypeId": "1",
    "CreationDate": "2021-02-10T14:37:28.777",
    "Score": "8",
    "ViewCount": "9335",
    "Body": "<p>I am new to docker and try to run a mysql image using below command on a windows server.</p> <pre><code>docker run  -e MYSQL_ROOT_PASSWORD=sEe@21 -e MYSQL_DATABASE=emp_db -p 3306:3306 --name mysql_emp mysql </code></pre> <p>It successfully downloaded and configured. I am getting a log in the CMD which says</p> <pre><code>root@localhost is created with an empty password ! Please consider switching off the --initialize-insecure option. </code></pre> <p>I have already given the root password which I set to use by the application and hence I get an error saying that cannot connect to DB from the spring boot service. MySQL full log is as follows</p> <pre><code>2021-02-10 14:25:43+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.23-1debian10 started. 2021-02-10 14:25:43+00:00 [Note] [Entrypoint]: Switching to dedicated user 'mysql' 2021-02-10 14:25:43+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.23-1debian10 started. 2021-02-10 14:25:43+00:00 [Note] [Entrypoint]: Initializing database files 2021-02-10T14:25:43.801929Z 0 [System] [MY-013169] [Server] /usr/sbin/mysqld (mysqld 8.0.23) initializing of server in progress as process 43 2021-02-10T14:25:43.808218Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started. 2021-02-10T14:25:44.547274Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended. 2021-02-10T14:25:46.632843Z 6 [Warning] [MY-010453] [Server] root@localhost is created with an empty password ! Please consider switching off the --initialize-insecure option. 2021-02-10 14:25:51+00:00 [Note] [Entrypoint]: Database files initialized 2021-02-10 14:25:51+00:00 [Note] [Entrypoint]: Starting temporary server 2021-02-10T14:25:51.770335Z 0 [System] [MY-010116] [Server] /usr/sbin/mysqld (mysqld 8.0.23) starting as process 88 2021-02-10T14:25:51.804446Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started. 2021-02-10T14:25:52.039318Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended. 2021-02-10T14:25:52.169969Z 0 [System] [MY-011323] [Server] X Plugin ready for connections. Socket: /var/run/mysqld/mysqlx.sock 2021-02-10T14:25:52.299951Z 0 [Warning] [MY-010068] [Server] CA certificate ca.pem is self signed. 2021-02-10T14:25:52.300259Z 0 [System] [MY-013602] [Server] Channel mysql_main configured to support TLS. Encrypted connections are now supported for this channel. 2021-02-10T14:25:52.304466Z 0 [Warning] [MY-011810] [Server] Insecure configuration for --pid-file: Location '/var/run/mysqld' in the path is accessible to all OS users. Consider choosing a different directory. 2021-02-10T14:25:52.327240Z 0 [System] [MY-010931] [Server] /usr/sbin/mysqld: ready for connections. Version: '8.0.23'  socket: '/var/run/mysqld/mysqld.sock'  port: 0  MySQL Community Server - GPL. 2021-02-10 14:25:52+00:00 [Note] [Entrypoint]: Temporary server started. Warning: Unable to load '/usr/share/zoneinfo/iso3166.tab' as time zone. Skipping it. Warning: Unable to load '/usr/share/zoneinfo/leap-seconds.list' as time zone. Skipping it. Warning: Unable to load '/usr/share/zoneinfo/zone.tab' as time zone. Skipping it. Warning: Unable to load '/usr/share/zoneinfo/zone1970.tab' as time zone. Skipping it. 2021-02-10 14:25:58+00:00 [Note] [Entrypoint]: Creating database emp_db  2021-02-10 14:25:58+00:00 [Note] [Entrypoint]: Stopping temporary server 2021-02-10T14:25:58.448858Z 11 [System] [MY-013172] [Server] Received SHUTDOWN from user root. Shutting down mysqld (Version: 8.0.23). 2021-02-10T14:26:00.212816Z 0 [System] [MY-010910] [Server] /usr/sbin/mysqld: Shutdown complete (mysqld 8.0.23)  MySQL Community Server - GPL. 2021-02-10 14:26:00+00:00 [Note] [Entrypoint]: Temporary server stopped  2021-02-10 14:26:00+00:00 [Note] [Entrypoint]: MySQL init process done. Ready for start up.  2021-02-10T14:26:00.738118Z 0 [System] [MY-010116] [Server] /usr/sbin/mysqld (mysqld 8.0.23) starting as process 1 2021-02-10T14:26:00.763121Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started. 2021-02-10T14:26:00.999006Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended. 2021-02-10T14:26:01.135971Z 0 [System] [MY-011323] [Server] X Plugin ready for connections. Bind-address: '::' port: 33060, socket: /var/run/mysqld/mysqlx.sock 2021-02-10T14:26:01.269210Z 0 [Warning] [MY-010068] [Server] CA certificate ca.pem is self signed. 2021-02-10T14:26:01.269444Z 0 [System] [MY-013602] [Server] Channel mysql_main configured to support TLS. Encrypted connections are now supported for this channel. 2021-02-10T14:26:01.275037Z 0 [Warning] [MY-011810] [Server] Insecure configuration for --pid-file: Location '/var/run/mysqld' in the path is accessible to all OS users. Consider choosing a different directory. 2021-02-10T14:26:01.297388Z 0 [System] [MY-010931] [Server] /usr/sbin/mysqld: ready for connections. Version: '8.0.23'  socket: '/var/run/mysqld/mysqld.sock'  port: 3306  MySQL Community Server - GPL. </code></pre> <p>Would like to understand what is wrong I am doing ? any parameter is missing in the docker run command ?</p> ",
    "OwnerUserId": "5178586",
    "LastActivityDate": "2021-09-18T12:11:58.223",
    "Title": "Docker - mysql configured with empty password for the root user",
    "Tags": "<spring-boot><docker><mysql-8.0>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "67194033",
    "PostTypeId": "1",
    "CreationDate": "2021-04-21T10:29:53.577",
    "Score": "8",
    "ViewCount": "9415",
    "Body": "<p>I have a working Spring Boot 2.25 application built with mvn. As per <a href='https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/html/using-boot-devtools.html' rel='nofollow noreferrer'>this documentation</a> I add</p> <pre><code>&lt;dependencies&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;         &lt;optional&gt;true&lt;/optional&gt;     &lt;/dependency&gt; &lt;/dependencies&gt; </code></pre> <p>From the documentation:</p> <blockquote> <p>As DevTools monitors classpath resources, the only way to trigger a restart is to update the classpath. The way in which you cause the classpath to be updated depends on the IDE that you are using. In Eclipse, saving a modified file causes the classpath to be updated and triggers a restart. In IntelliJ IDEA, building the project (Build -&gt; Build Project) has the same effect.</p> </blockquote> <p>With the application running I tried a simple</p> <pre><code>touch /path/to/app.jar </code></pre> <p>expecting the application to restart but nothing happened.</p> <p>Okay, so maybe it's doing something smarter. I modified some source .java, recompiled the .jar, and <code>cp</code>'d it to replace the running .jar file and... nothing happened.</p> <p>Also from the documentation</p> <blockquote> <p>DevTools relies on the application context\u2019s shutdown hook to close it during a restart. It does not work correctly if you have disabled the shutdown hook (SpringApplication.setRegisterShutdownHook(false)).</p> </blockquote> <p>I am not doing this.</p> <blockquote> <p>DevTools needs to customize the ResourceLoader used by the ApplicationContext. If your application provides one already, it is going to be wrapped. Direct override of the getResource method on the ApplicationContext is not supported.</p> </blockquote> <p>I am not doing this.</p> <p>I am running this in a Docker container, if that matters. From the documentation:</p> <blockquote> <p>Developer tools are automatically disabled when running a fully packaged application. If your application is launched from java -jar or if it is started from a special classloader, then it is considered a \u201cproduction application\u201d. If that does not apply to you (i.e. if you run your application from a container), consider excluding devtools or set the -Dspring.devtools.restart.enabled=false system property.</p> </blockquote> <p>I don't understand what this means or if it is relevant.</p> <p>I want to recompile a .jar and replace it in the running docker container and trigger and application restart without restarting the container. How can I do this?</p> <p>EDIT: I am using <code>mvn</code> to rebuild the jar, then <code>docker cp</code> to replace it in the running container. (IntelliJ IDEA claims to rebuild the project, but the jar files are actually <em>not</em> touched, but that's another story.) I am looking for a non-IDE-specific solution.</p> ",
    "OwnerUserId": "458742",
    "LastEditorUserId": "13942448",
    "LastEditDate": "2021-07-17T13:35:04.823",
    "LastActivityDate": "2023-07-10T11:32:46.553",
    "Title": "spring-boot-devtools Automatic Restart not working",
    "Tags": "<java><spring-boot><docker><spring-boot-devtools>",
    "AnswerCount": "6",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "70007676",
    "PostTypeId": "1",
    "AcceptedAnswerId": "70008049",
    "CreationDate": "2021-11-17T15:58:06.787",
    "Score": "8",
    "ViewCount": "5179",
    "Body": "<p>How do you inject Docker secrets (files/data from /run/secrets) into the application.properties files? Is it safe to use environment variables?</p> ",
    "OwnerUserId": "17439965",
    "LastEditorUserId": "466862",
    "LastEditDate": "2021-11-17T17:23:25.187",
    "LastActivityDate": "2022-12-13T20:55:44.510",
    "Title": "How to handle Docker-Secrets in application.properties files",
    "Tags": "<java><spring><spring-boot><docker><docker-secrets>",
    "AnswerCount": "4",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "33660966",
    "PostTypeId": "1",
    "CreationDate": "2015-11-11T22:22:02.403",
    "Score": "7",
    "ViewCount": "1925",
    "Body": "<p>We've three Spring Boot applications:</p>  <ul> <li>Eureka Service</li> <li>Config Server</li> <li>Simple Web Service making use of Eureka and Config Server</li> </ul>  <p>I've set up the services so that we use a Eureka First Discovery, i.e. the simple web application finds out about the config server from the eureka service. </p>  <p>When started separately (either locally or by starting them as individual docker images) everything is ok, i.e. start config server after discovery service is running, and the Simple web service is started once the config server is running.</p>  <p>When docker-compose is used to start the services, they obviously start at the same time and essentially race to get up and running. This isn't an issue as we've added failFast: true and retry values to the simple web service and also have the docker container restarting so that the simple web service will eventually restart at a time when the discovery service and config server are both running but this doesn't feel optimal. </p>  <p>The unexpected behaviour we noticed was the following:</p>  <ul> <li>The simple web service reattempts a number of times to connect to the discovery service. This is sensible and expected</li> <li>At the same time the simple web service attempts to contact the config server. Because it cannot contact the discovery service, it retries to connect to a config server on localhost, e.g. logs show retries going to <a href='http://localhost:8888' rel='noreferrer'>http://localhost:8888</a>. This wasn't expected.</li> <li>The simple web service will eventually successfully connect to the discovery service but the logs show it stills tries to establish communication to the config server by going to <a href='http://localhost:8888' rel='noreferrer'>http://localhost:8888</a>. Again, this wasn't ideal.</li> </ul>  <p>Three questions/observations:</p>  <ul> <li>Is it a sensible strategy for the config client to fall back to trying localhost:8888 when it has been configured to use discovery to find the config server?</li> <li>When the eureka connections is established, should the retry mechanism not now switch to trying the config server endpoint as indicated by Eureka? Essentially putting in higher/longer retry intervals and periods for the config server connection is pointless in this case as it's never going to connect to it if it's looking at localhost so we're better just failing fast.</li> <li>Are there any properties that can override this behaviour?</li> </ul>  <p>I've created a sample github repo that demonstrates this behaviour:</p>  <p><a href='https://github.com/KramKroc/eurekafirstdiscovery/' rel='noreferrer'>https://github.com/KramKroc/eurekafirstdiscovery/tree/master</a></p> ",
    "OwnerUserId": "530846",
    "LastEditorUserId": "530846",
    "LastEditDate": "2015-11-12T15:51:39.393",
    "LastActivityDate": "2015-11-12T15:51:39.393",
    "Title": "Eureka First Discovery & Config Client Retry with Docker Compose",
    "Tags": "<spring-boot><spring-cloud><docker-compose><netflix-eureka>",
    "AnswerCount": "0",
    "CommentCount": "5",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "33660966",
    "PostTypeId": "1",
    "CreationDate": "2015-11-11T22:22:02.403",
    "Score": "7",
    "ViewCount": "1925",
    "Body": "<p>We've three Spring Boot applications:</p>  <ul> <li>Eureka Service</li> <li>Config Server</li> <li>Simple Web Service making use of Eureka and Config Server</li> </ul>  <p>I've set up the services so that we use a Eureka First Discovery, i.e. the simple web application finds out about the config server from the eureka service. </p>  <p>When started separately (either locally or by starting them as individual docker images) everything is ok, i.e. start config server after discovery service is running, and the Simple web service is started once the config server is running.</p>  <p>When docker-compose is used to start the services, they obviously start at the same time and essentially race to get up and running. This isn't an issue as we've added failFast: true and retry values to the simple web service and also have the docker container restarting so that the simple web service will eventually restart at a time when the discovery service and config server are both running but this doesn't feel optimal. </p>  <p>The unexpected behaviour we noticed was the following:</p>  <ul> <li>The simple web service reattempts a number of times to connect to the discovery service. This is sensible and expected</li> <li>At the same time the simple web service attempts to contact the config server. Because it cannot contact the discovery service, it retries to connect to a config server on localhost, e.g. logs show retries going to <a href='http://localhost:8888' rel='noreferrer'>http://localhost:8888</a>. This wasn't expected.</li> <li>The simple web service will eventually successfully connect to the discovery service but the logs show it stills tries to establish communication to the config server by going to <a href='http://localhost:8888' rel='noreferrer'>http://localhost:8888</a>. Again, this wasn't ideal.</li> </ul>  <p>Three questions/observations:</p>  <ul> <li>Is it a sensible strategy for the config client to fall back to trying localhost:8888 when it has been configured to use discovery to find the config server?</li> <li>When the eureka connections is established, should the retry mechanism not now switch to trying the config server endpoint as indicated by Eureka? Essentially putting in higher/longer retry intervals and periods for the config server connection is pointless in this case as it's never going to connect to it if it's looking at localhost so we're better just failing fast.</li> <li>Are there any properties that can override this behaviour?</li> </ul>  <p>I've created a sample github repo that demonstrates this behaviour:</p>  <p><a href='https://github.com/KramKroc/eurekafirstdiscovery/' rel='noreferrer'>https://github.com/KramKroc/eurekafirstdiscovery/tree/master</a></p> ",
    "OwnerUserId": "530846",
    "LastEditorUserId": "530846",
    "LastEditDate": "2015-11-12T15:51:39.393",
    "LastActivityDate": "2015-11-12T15:51:39.393",
    "Title": "Eureka First Discovery & Config Client Retry with Docker Compose",
    "Tags": "<spring-boot><spring-cloud><docker-compose><netflix-eureka>",
    "AnswerCount": "0",
    "CommentCount": "5",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "33660966",
    "PostTypeId": "1",
    "CreationDate": "2015-11-11T22:22:02.403",
    "Score": "7",
    "ViewCount": "1925",
    "Body": "<p>We've three Spring Boot applications:</p>  <ul> <li>Eureka Service</li> <li>Config Server</li> <li>Simple Web Service making use of Eureka and Config Server</li> </ul>  <p>I've set up the services so that we use a Eureka First Discovery, i.e. the simple web application finds out about the config server from the eureka service. </p>  <p>When started separately (either locally or by starting them as individual docker images) everything is ok, i.e. start config server after discovery service is running, and the Simple web service is started once the config server is running.</p>  <p>When docker-compose is used to start the services, they obviously start at the same time and essentially race to get up and running. This isn't an issue as we've added failFast: true and retry values to the simple web service and also have the docker container restarting so that the simple web service will eventually restart at a time when the discovery service and config server are both running but this doesn't feel optimal. </p>  <p>The unexpected behaviour we noticed was the following:</p>  <ul> <li>The simple web service reattempts a number of times to connect to the discovery service. This is sensible and expected</li> <li>At the same time the simple web service attempts to contact the config server. Because it cannot contact the discovery service, it retries to connect to a config server on localhost, e.g. logs show retries going to <a href='http://localhost:8888' rel='noreferrer'>http://localhost:8888</a>. This wasn't expected.</li> <li>The simple web service will eventually successfully connect to the discovery service but the logs show it stills tries to establish communication to the config server by going to <a href='http://localhost:8888' rel='noreferrer'>http://localhost:8888</a>. Again, this wasn't ideal.</li> </ul>  <p>Three questions/observations:</p>  <ul> <li>Is it a sensible strategy for the config client to fall back to trying localhost:8888 when it has been configured to use discovery to find the config server?</li> <li>When the eureka connections is established, should the retry mechanism not now switch to trying the config server endpoint as indicated by Eureka? Essentially putting in higher/longer retry intervals and periods for the config server connection is pointless in this case as it's never going to connect to it if it's looking at localhost so we're better just failing fast.</li> <li>Are there any properties that can override this behaviour?</li> </ul>  <p>I've created a sample github repo that demonstrates this behaviour:</p>  <p><a href='https://github.com/KramKroc/eurekafirstdiscovery/' rel='noreferrer'>https://github.com/KramKroc/eurekafirstdiscovery/tree/master</a></p> ",
    "OwnerUserId": "530846",
    "LastEditorUserId": "530846",
    "LastEditDate": "2015-11-12T15:51:39.393",
    "LastActivityDate": "2015-11-12T15:51:39.393",
    "Title": "Eureka First Discovery & Config Client Retry with Docker Compose",
    "Tags": "<spring-boot><spring-cloud><docker-compose><netflix-eureka>",
    "AnswerCount": "0",
    "CommentCount": "5",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "34449995",
    "PostTypeId": "1",
    "CreationDate": "2015-12-24T08:59:54.050",
    "Score": "7",
    "ViewCount": "2659",
    "Body": "<p>I am using spring boot to develop an app and I am using mysql as database.I have the below configuration in application.properties.</p>  <pre><code>server.port=8090 spring.datasource.url=jdbc:mysql://mysql:3306/sampleDB spring.datasource.username=root spring.datasource.password= spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.jpa.hibernate.dialect=org.hibernate.dialect.MySQLDialect spring.hibernate.dialect=org.hibernate.dialect.MySQLDialect spring.jpa.hibernate.show_sql=true spring.jpa.hibernate.ddl-auto=update spring.jpa.temp.use_jdbc_metadata_defaults=false logging.file=employee.log spring.datasource.testOnBorrow=true spring.datasource.validationQuery=SELECT 1 </code></pre>  <p>I have the respective DB in my local and it is working in my local. But as soon as I create a docker image and link to my mysql docker container it is throwing the below exception. </p>  <pre><code>org.hibernate.HibernateException: Access to DialectResolutionInfo cannot be null when 'hibernate.dialect' not set </code></pre>  <p>The container is not even building even for me to look into it.</p>  <pre><code>sudo docker run --name bootApp -d  --link mysql:mysql  springio/employeesecurity </code></pre>  <p>where <strong>springio/employeesecurity</strong> is my springBoot docker name and <strong>mysql</strong> is my msql container.</p> ",
    "OwnerUserId": "3828260",
    "LastActivityDate": "2022-04-15T05:43:11.233",
    "Title": "Spring Boot in Docker throwing an exception 'hibernate.dialect' not set",
    "Tags": "<hibernate><docker><spring-boot>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "37490324",
    "PostTypeId": "1",
    "AcceptedAnswerId": "37490325",
    "CreationDate": "2016-05-27T18:40:07.273",
    "Score": "7",
    "ViewCount": "8961",
    "Body": "<p>I've got a Spring Boot application implementing a service which I want to run in a Docker container. I've followed the guideline of the official <a href='https://spring.io/guides/gs/spring-boot-docker/' rel='nofollow noreferrer'>Spring docs</a> which suggest to create a DockerFile similar to this:</p>  <pre><code>FROM frolvlad/alpine-oraclejdk8:slim VOLUME /tmp ADD gs-spring-boot-docker-0.1.0.jar app.jar RUN sh -c 'touch /app.jar' ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre>  <p>Then once the image is pushed to Docker I use <a href='https://docs.docker.com/compose/' rel='nofollow noreferrer'>Docker Compose</a> to launch it this way:</p>  <pre><code>  spring-boot-docker:     ports:     - '80:80'     expose:     - '80'     image: my-repo/spring-boot-docker:0.1.0-SNAPSHOT     container_name: spring-boot-docker     environment:       JAVA_OPTS: '-Xmx64m' </code></pre>  <p>Here I've got the <code>JAVA_OPTS</code> variable which limits the memory allocation, however, when I execute <code>docker stats spring-boot-docker</code>, the memory taken by the container is excessive (I understand the total memory taken by the JVM might be much more than 64M, but in this case is totally boundless).</p>  <p>I've also tried with the <a href='https://stackoverflow.com/questions/28837544/can-i-use-mem-limit-in-docker-compose-and-how'><code>mem_limit</code> param</a>, but this slows down the application noticeably.</p> ",
    "OwnerUserId": "1199132",
    "LastEditorUserId": "-1",
    "LastEditDate": "2017-05-23T12:02:31.193",
    "LastActivityDate": "2016-05-29T07:48:44.820",
    "Title": "Limit JVM memory consumption in a Docker container",
    "Tags": "<java><docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "37490324",
    "PostTypeId": "1",
    "AcceptedAnswerId": "37490325",
    "CreationDate": "2016-05-27T18:40:07.273",
    "Score": "7",
    "ViewCount": "8961",
    "Body": "<p>I've got a Spring Boot application implementing a service which I want to run in a Docker container. I've followed the guideline of the official <a href='https://spring.io/guides/gs/spring-boot-docker/' rel='nofollow noreferrer'>Spring docs</a> which suggest to create a DockerFile similar to this:</p>  <pre><code>FROM frolvlad/alpine-oraclejdk8:slim VOLUME /tmp ADD gs-spring-boot-docker-0.1.0.jar app.jar RUN sh -c 'touch /app.jar' ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre>  <p>Then once the image is pushed to Docker I use <a href='https://docs.docker.com/compose/' rel='nofollow noreferrer'>Docker Compose</a> to launch it this way:</p>  <pre><code>  spring-boot-docker:     ports:     - '80:80'     expose:     - '80'     image: my-repo/spring-boot-docker:0.1.0-SNAPSHOT     container_name: spring-boot-docker     environment:       JAVA_OPTS: '-Xmx64m' </code></pre>  <p>Here I've got the <code>JAVA_OPTS</code> variable which limits the memory allocation, however, when I execute <code>docker stats spring-boot-docker</code>, the memory taken by the container is excessive (I understand the total memory taken by the JVM might be much more than 64M, but in this case is totally boundless).</p>  <p>I've also tried with the <a href='https://stackoverflow.com/questions/28837544/can-i-use-mem-limit-in-docker-compose-and-how'><code>mem_limit</code> param</a>, but this slows down the application noticeably.</p> ",
    "OwnerUserId": "1199132",
    "LastEditorUserId": "-1",
    "LastEditDate": "2017-05-23T12:02:31.193",
    "LastActivityDate": "2016-05-29T07:48:44.820",
    "Title": "Limit JVM memory consumption in a Docker container",
    "Tags": "<java><docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "37490324",
    "PostTypeId": "1",
    "AcceptedAnswerId": "37490325",
    "CreationDate": "2016-05-27T18:40:07.273",
    "Score": "7",
    "ViewCount": "8961",
    "Body": "<p>I've got a Spring Boot application implementing a service which I want to run in a Docker container. I've followed the guideline of the official <a href='https://spring.io/guides/gs/spring-boot-docker/' rel='nofollow noreferrer'>Spring docs</a> which suggest to create a DockerFile similar to this:</p>  <pre><code>FROM frolvlad/alpine-oraclejdk8:slim VOLUME /tmp ADD gs-spring-boot-docker-0.1.0.jar app.jar RUN sh -c 'touch /app.jar' ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre>  <p>Then once the image is pushed to Docker I use <a href='https://docs.docker.com/compose/' rel='nofollow noreferrer'>Docker Compose</a> to launch it this way:</p>  <pre><code>  spring-boot-docker:     ports:     - '80:80'     expose:     - '80'     image: my-repo/spring-boot-docker:0.1.0-SNAPSHOT     container_name: spring-boot-docker     environment:       JAVA_OPTS: '-Xmx64m' </code></pre>  <p>Here I've got the <code>JAVA_OPTS</code> variable which limits the memory allocation, however, when I execute <code>docker stats spring-boot-docker</code>, the memory taken by the container is excessive (I understand the total memory taken by the JVM might be much more than 64M, but in this case is totally boundless).</p>  <p>I've also tried with the <a href='https://stackoverflow.com/questions/28837544/can-i-use-mem-limit-in-docker-compose-and-how'><code>mem_limit</code> param</a>, but this slows down the application noticeably.</p> ",
    "OwnerUserId": "1199132",
    "LastEditorUserId": "-1",
    "LastEditDate": "2017-05-23T12:02:31.193",
    "LastActivityDate": "2016-05-29T07:48:44.820",
    "Title": "Limit JVM memory consumption in a Docker container",
    "Tags": "<java><docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "42175951",
    "PostTypeId": "1",
    "AcceptedAnswerId": "42175990",
    "CreationDate": "2017-02-11T12:38:20.267",
    "Score": "7",
    "ViewCount": "16754",
    "Body": "<p>I am setting up a Spring application to run using compose. The application needs to establish a connection to ActiveMQ either running locally for developers or to existing instances for staging/production.</p>  <p>I setup the following which is working great for local dev:</p>  <pre><code>amq:     image: rmohr/activemq:latest     ports:       - '61616:61616'       - '8161:8161' legacy-bridge:     image:  myco/myservice     links:       - amq </code></pre>  <p>and in the application configuration I am declaring the AMQ connection as </p>  <pre><code>broker-url=tcp://amq:61616 </code></pre>  <p>Running docker-compose up is working great, activeMQ is fired up locally and my application constiner starts and connects to it.</p>  <p>Now I need to set this up for staging/production where the ActiveMQ instances are running on existing hardware within the infrastructure. My thoughts are to either use spring profiles to handle a different configurations in which case the application configuration entry for 'broker-url=tcp://amq:61616' would become something like <code>broker-url=tcp://some.host.here:61616</code> or find some way to create a dns entry within my production docker-compose.yml which will point an <code>amq</code> dns entry to the associated staging or production queues.</p>  <p>What is the best approach here and if it is DNS, how to I set that up in compose?</p>  <p>Thanks!</p> ",
    "OwnerUserId": "1232376",
    "LastActivityDate": "2023-06-25T00:49:27.493",
    "Title": "How to configure dns entries for Docker Compose",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "42175951",
    "PostTypeId": "1",
    "AcceptedAnswerId": "42175990",
    "CreationDate": "2017-02-11T12:38:20.267",
    "Score": "7",
    "ViewCount": "16754",
    "Body": "<p>I am setting up a Spring application to run using compose. The application needs to establish a connection to ActiveMQ either running locally for developers or to existing instances for staging/production.</p>  <p>I setup the following which is working great for local dev:</p>  <pre><code>amq:     image: rmohr/activemq:latest     ports:       - '61616:61616'       - '8161:8161' legacy-bridge:     image:  myco/myservice     links:       - amq </code></pre>  <p>and in the application configuration I am declaring the AMQ connection as </p>  <pre><code>broker-url=tcp://amq:61616 </code></pre>  <p>Running docker-compose up is working great, activeMQ is fired up locally and my application constiner starts and connects to it.</p>  <p>Now I need to set this up for staging/production where the ActiveMQ instances are running on existing hardware within the infrastructure. My thoughts are to either use spring profiles to handle a different configurations in which case the application configuration entry for 'broker-url=tcp://amq:61616' would become something like <code>broker-url=tcp://some.host.here:61616</code> or find some way to create a dns entry within my production docker-compose.yml which will point an <code>amq</code> dns entry to the associated staging or production queues.</p>  <p>What is the best approach here and if it is DNS, how to I set that up in compose?</p>  <p>Thanks!</p> ",
    "OwnerUserId": "1232376",
    "LastActivityDate": "2023-06-25T00:49:27.493",
    "Title": "How to configure dns entries for Docker Compose",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "42175951",
    "PostTypeId": "1",
    "AcceptedAnswerId": "42175990",
    "CreationDate": "2017-02-11T12:38:20.267",
    "Score": "7",
    "ViewCount": "16754",
    "Body": "<p>I am setting up a Spring application to run using compose. The application needs to establish a connection to ActiveMQ either running locally for developers or to existing instances for staging/production.</p>  <p>I setup the following which is working great for local dev:</p>  <pre><code>amq:     image: rmohr/activemq:latest     ports:       - '61616:61616'       - '8161:8161' legacy-bridge:     image:  myco/myservice     links:       - amq </code></pre>  <p>and in the application configuration I am declaring the AMQ connection as </p>  <pre><code>broker-url=tcp://amq:61616 </code></pre>  <p>Running docker-compose up is working great, activeMQ is fired up locally and my application constiner starts and connects to it.</p>  <p>Now I need to set this up for staging/production where the ActiveMQ instances are running on existing hardware within the infrastructure. My thoughts are to either use spring profiles to handle a different configurations in which case the application configuration entry for 'broker-url=tcp://amq:61616' would become something like <code>broker-url=tcp://some.host.here:61616</code> or find some way to create a dns entry within my production docker-compose.yml which will point an <code>amq</code> dns entry to the associated staging or production queues.</p>  <p>What is the best approach here and if it is DNS, how to I set that up in compose?</p>  <p>Thanks!</p> ",
    "OwnerUserId": "1232376",
    "LastActivityDate": "2023-06-25T00:49:27.493",
    "Title": "How to configure dns entries for Docker Compose",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "45996171",
    "PostTypeId": "1",
    "AcceptedAnswerId": "46000034",
    "CreationDate": "2017-09-01T08:32:44.300",
    "Score": "7",
    "ViewCount": "4794",
    "Body": "<p>I'm running Elasticsearch instance from Docker. The image is from jHipster docker hub repo: <a href='https://hub.docker.com/r/jhipster/jhipster-elasticsearch/' rel='noreferrer'>jhipster/jhipster-elasticsearch/</a> - I'm using image v1.3.2 because I need Elasticsearch 2.4.0 (to be in line with Spring Boot version of the project).</p>  <p>I'm starting ES container along with Logstash and Kibana images, with <code>docker-compose</code>. This are the settings for starting ES container:</p>  <pre><code>jhipster-elasticsearch:     image: jhipster/jhipster-elasticsearch:v1.3.2     ports:         - 9400:9200         - 9500:9300     volumes:        - ./log-es-config/elasticsearch_custom.yml:/usr/share/elasticsearch/config/elasticsearch.yml </code></pre>  <p>So I'm using 9400 for REST and 9500 for transport communication.</p>  <p>This is configuration inside <code>elasticsearch_custom.yml</code> that is mounted to ES config:</p>  <pre><code>cluster.name: 'log-cluster' node.name: 'log-node' http.host: 0.0.0.0 transport.host: 127.0.0.1 transport.tcp.port: 9500 transport.publish_port: 9500 </code></pre>  <p>When I start container, this is what I get from <code>http://localhost:9400/_nodes</code>:</p>  <pre><code>'cluster_name': 'log-cluster',   'nodes': {     'xLsGj2DyTdCF89I7sAToVw': {       'name': 'log-node',       'transport_address': '127.0.0.1:9500',       'host': '127.0.0.1',       'ip': '127.0.0.1',       'version': '2.4.0',       'build': 'ce9f0c7',       'http_address': '172.18.0.5:9200',       'settings': {         'cluster': {           'name': 'log-cluster'         },         ... (I can put all response if needed) </code></pre>  <p><strong>JAVA API:</strong></p>  <p>Now I'm trying to connect to this ES node like this:</p>  <pre><code>    @Bean     public ElasticsearchOperations logsElasticsearchOperations() throws UnknownHostException {         Settings settings = Settings.settingsBuilder()             .put('cluster.name', 'log-cluster')             .put('node.name', 'log-node')             .build();          Client client = TransportClient.builder()             .settings(settings)             .build()             .addTransportAddress(new InetSocketTransportAddress(new InetSocketAddress('127.0.0.1', 9500)));           ElasticsearchTemplate template = new ElasticsearchTemplate(client);         template.createIndex(ProcessLog.class);         log.debug('Elasticsearch for logs configured.');         return template;     } </code></pre>  <p>The error I'm getting is the most famous one:</p>  <p><strong><code>Caused by: org.elasticsearch.client.transport.NoNodeAvailableException: None of the configured nodes are available: [{#transport#-1}{127.0.0.1}{127.0.0.1:9500}]</code></strong></p>  <p>I googled and tried different config approaches, also with <code>client.transport.sniff</code> set to <code>false</code>, but non of those worked. Now I spent lots of time trying to configure this one and I'm still missing something.</p>  <p>Thanks in advance for help. </p>  <p><strong>UPDATE:</strong></p>  <p>There is also embedded ES instance running when I start the app. So host ports config is like this:</p>  <ul> <li>Embedded ES: 9200 (http), 9300 (tcp)</li> <li>Docker's ES: 9400 (http), 9500 (tcp)</li> </ul>  <p>Here is full <code>docker-compose.yml</code>:</p>  <pre><code>    version: '2'     services:     jhipster-elasticsearch:         # elasticsearch 2.4.0 - to be in line with spring boot version         image: jhipster/jhipster-elasticsearch:v1.3.2         ports:             - 9400:9200             - 9500:9300         volumes:            - ./log-es-config/elasticsearch_custom.yml:/usr/share/elasticsearch/config/elasticsearch.yml     jhipster-logstash:         image: jhipster/jhipster-logstash:v2.2.1         command: logstash -f /conf/logstash_custom.conf         ports:             - 5000:5000/udp             - 6000:6000/tcp         volumes:             - ./logstash-log-es-conf/:/conf     jhipster-console:         image: jhipster/jhipster-console:v2.0.1         ports:             - 5601:5601     jhipster-zipkin:         image: jhipster/jhipster-zipkin:v2.0.1         ports:             - 9411:9411         environment:             - ES_HOSTS=http://jhipster-elasticsearch:9400             - ZIPKIN_UI_LOGS_URL=http://localhost:5601/app/kibana#/dashboard/logs-dashboard?_g=(refreshInterval:(display:Off,pause:!f,value:0),time:(from:now-1h,mode:quick,to:now))&amp;_a=(filters:!(),options:(darkTheme:!f),panels:!((col:1,id:logs-levels,panelIndex:2,row:1,size_x:6,size_y:3,type:visualization),(col:7,columns:!(stack_trace),id:Stacktraces,panelIndex:7,row:1,size_x:4,size_y:3,sort:!('@timestamp',desc),type:search),(col:11,id:Log-forwarding-instructions,panelIndex:8,row:1,size_x:2,size_y:3,type:visualization),(col:1,columns:!(app_name,level,message),id:All-logs,panelIndex:9,row:4,size_x:12,size_y:7,sort:!('@timestamp',asc),type:search)),query:(query_string:(analyze_wildcard:!t,query:'{traceId}')),title:logs-dashboard,uiState:()) </code></pre> ",
    "OwnerUserId": "5250885",
    "LastEditorUserId": "5250885",
    "LastEditDate": "2017-09-01T09:04:49.137",
    "LastActivityDate": "2017-09-01T13:59:55.687",
    "Title": "Connecting to Docker Elasticsearch instance through Java/Spring Boot",
    "Tags": "<java><elasticsearch><docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "45996171",
    "PostTypeId": "1",
    "AcceptedAnswerId": "46000034",
    "CreationDate": "2017-09-01T08:32:44.300",
    "Score": "7",
    "ViewCount": "4794",
    "Body": "<p>I'm running Elasticsearch instance from Docker. The image is from jHipster docker hub repo: <a href='https://hub.docker.com/r/jhipster/jhipster-elasticsearch/' rel='noreferrer'>jhipster/jhipster-elasticsearch/</a> - I'm using image v1.3.2 because I need Elasticsearch 2.4.0 (to be in line with Spring Boot version of the project).</p>  <p>I'm starting ES container along with Logstash and Kibana images, with <code>docker-compose</code>. This are the settings for starting ES container:</p>  <pre><code>jhipster-elasticsearch:     image: jhipster/jhipster-elasticsearch:v1.3.2     ports:         - 9400:9200         - 9500:9300     volumes:        - ./log-es-config/elasticsearch_custom.yml:/usr/share/elasticsearch/config/elasticsearch.yml </code></pre>  <p>So I'm using 9400 for REST and 9500 for transport communication.</p>  <p>This is configuration inside <code>elasticsearch_custom.yml</code> that is mounted to ES config:</p>  <pre><code>cluster.name: 'log-cluster' node.name: 'log-node' http.host: 0.0.0.0 transport.host: 127.0.0.1 transport.tcp.port: 9500 transport.publish_port: 9500 </code></pre>  <p>When I start container, this is what I get from <code>http://localhost:9400/_nodes</code>:</p>  <pre><code>'cluster_name': 'log-cluster',   'nodes': {     'xLsGj2DyTdCF89I7sAToVw': {       'name': 'log-node',       'transport_address': '127.0.0.1:9500',       'host': '127.0.0.1',       'ip': '127.0.0.1',       'version': '2.4.0',       'build': 'ce9f0c7',       'http_address': '172.18.0.5:9200',       'settings': {         'cluster': {           'name': 'log-cluster'         },         ... (I can put all response if needed) </code></pre>  <p><strong>JAVA API:</strong></p>  <p>Now I'm trying to connect to this ES node like this:</p>  <pre><code>    @Bean     public ElasticsearchOperations logsElasticsearchOperations() throws UnknownHostException {         Settings settings = Settings.settingsBuilder()             .put('cluster.name', 'log-cluster')             .put('node.name', 'log-node')             .build();          Client client = TransportClient.builder()             .settings(settings)             .build()             .addTransportAddress(new InetSocketTransportAddress(new InetSocketAddress('127.0.0.1', 9500)));           ElasticsearchTemplate template = new ElasticsearchTemplate(client);         template.createIndex(ProcessLog.class);         log.debug('Elasticsearch for logs configured.');         return template;     } </code></pre>  <p>The error I'm getting is the most famous one:</p>  <p><strong><code>Caused by: org.elasticsearch.client.transport.NoNodeAvailableException: None of the configured nodes are available: [{#transport#-1}{127.0.0.1}{127.0.0.1:9500}]</code></strong></p>  <p>I googled and tried different config approaches, also with <code>client.transport.sniff</code> set to <code>false</code>, but non of those worked. Now I spent lots of time trying to configure this one and I'm still missing something.</p>  <p>Thanks in advance for help. </p>  <p><strong>UPDATE:</strong></p>  <p>There is also embedded ES instance running when I start the app. So host ports config is like this:</p>  <ul> <li>Embedded ES: 9200 (http), 9300 (tcp)</li> <li>Docker's ES: 9400 (http), 9500 (tcp)</li> </ul>  <p>Here is full <code>docker-compose.yml</code>:</p>  <pre><code>    version: '2'     services:     jhipster-elasticsearch:         # elasticsearch 2.4.0 - to be in line with spring boot version         image: jhipster/jhipster-elasticsearch:v1.3.2         ports:             - 9400:9200             - 9500:9300         volumes:            - ./log-es-config/elasticsearch_custom.yml:/usr/share/elasticsearch/config/elasticsearch.yml     jhipster-logstash:         image: jhipster/jhipster-logstash:v2.2.1         command: logstash -f /conf/logstash_custom.conf         ports:             - 5000:5000/udp             - 6000:6000/tcp         volumes:             - ./logstash-log-es-conf/:/conf     jhipster-console:         image: jhipster/jhipster-console:v2.0.1         ports:             - 5601:5601     jhipster-zipkin:         image: jhipster/jhipster-zipkin:v2.0.1         ports:             - 9411:9411         environment:             - ES_HOSTS=http://jhipster-elasticsearch:9400             - ZIPKIN_UI_LOGS_URL=http://localhost:5601/app/kibana#/dashboard/logs-dashboard?_g=(refreshInterval:(display:Off,pause:!f,value:0),time:(from:now-1h,mode:quick,to:now))&amp;_a=(filters:!(),options:(darkTheme:!f),panels:!((col:1,id:logs-levels,panelIndex:2,row:1,size_x:6,size_y:3,type:visualization),(col:7,columns:!(stack_trace),id:Stacktraces,panelIndex:7,row:1,size_x:4,size_y:3,sort:!('@timestamp',desc),type:search),(col:11,id:Log-forwarding-instructions,panelIndex:8,row:1,size_x:2,size_y:3,type:visualization),(col:1,columns:!(app_name,level,message),id:All-logs,panelIndex:9,row:4,size_x:12,size_y:7,sort:!('@timestamp',asc),type:search)),query:(query_string:(analyze_wildcard:!t,query:'{traceId}')),title:logs-dashboard,uiState:()) </code></pre> ",
    "OwnerUserId": "5250885",
    "LastEditorUserId": "5250885",
    "LastEditDate": "2017-09-01T09:04:49.137",
    "LastActivityDate": "2017-09-01T13:59:55.687",
    "Title": "Connecting to Docker Elasticsearch instance through Java/Spring Boot",
    "Tags": "<java><elasticsearch><docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "45996171",
    "PostTypeId": "1",
    "AcceptedAnswerId": "46000034",
    "CreationDate": "2017-09-01T08:32:44.300",
    "Score": "7",
    "ViewCount": "4794",
    "Body": "<p>I'm running Elasticsearch instance from Docker. The image is from jHipster docker hub repo: <a href='https://hub.docker.com/r/jhipster/jhipster-elasticsearch/' rel='noreferrer'>jhipster/jhipster-elasticsearch/</a> - I'm using image v1.3.2 because I need Elasticsearch 2.4.0 (to be in line with Spring Boot version of the project).</p>  <p>I'm starting ES container along with Logstash and Kibana images, with <code>docker-compose</code>. This are the settings for starting ES container:</p>  <pre><code>jhipster-elasticsearch:     image: jhipster/jhipster-elasticsearch:v1.3.2     ports:         - 9400:9200         - 9500:9300     volumes:        - ./log-es-config/elasticsearch_custom.yml:/usr/share/elasticsearch/config/elasticsearch.yml </code></pre>  <p>So I'm using 9400 for REST and 9500 for transport communication.</p>  <p>This is configuration inside <code>elasticsearch_custom.yml</code> that is mounted to ES config:</p>  <pre><code>cluster.name: 'log-cluster' node.name: 'log-node' http.host: 0.0.0.0 transport.host: 127.0.0.1 transport.tcp.port: 9500 transport.publish_port: 9500 </code></pre>  <p>When I start container, this is what I get from <code>http://localhost:9400/_nodes</code>:</p>  <pre><code>'cluster_name': 'log-cluster',   'nodes': {     'xLsGj2DyTdCF89I7sAToVw': {       'name': 'log-node',       'transport_address': '127.0.0.1:9500',       'host': '127.0.0.1',       'ip': '127.0.0.1',       'version': '2.4.0',       'build': 'ce9f0c7',       'http_address': '172.18.0.5:9200',       'settings': {         'cluster': {           'name': 'log-cluster'         },         ... (I can put all response if needed) </code></pre>  <p><strong>JAVA API:</strong></p>  <p>Now I'm trying to connect to this ES node like this:</p>  <pre><code>    @Bean     public ElasticsearchOperations logsElasticsearchOperations() throws UnknownHostException {         Settings settings = Settings.settingsBuilder()             .put('cluster.name', 'log-cluster')             .put('node.name', 'log-node')             .build();          Client client = TransportClient.builder()             .settings(settings)             .build()             .addTransportAddress(new InetSocketTransportAddress(new InetSocketAddress('127.0.0.1', 9500)));           ElasticsearchTemplate template = new ElasticsearchTemplate(client);         template.createIndex(ProcessLog.class);         log.debug('Elasticsearch for logs configured.');         return template;     } </code></pre>  <p>The error I'm getting is the most famous one:</p>  <p><strong><code>Caused by: org.elasticsearch.client.transport.NoNodeAvailableException: None of the configured nodes are available: [{#transport#-1}{127.0.0.1}{127.0.0.1:9500}]</code></strong></p>  <p>I googled and tried different config approaches, also with <code>client.transport.sniff</code> set to <code>false</code>, but non of those worked. Now I spent lots of time trying to configure this one and I'm still missing something.</p>  <p>Thanks in advance for help. </p>  <p><strong>UPDATE:</strong></p>  <p>There is also embedded ES instance running when I start the app. So host ports config is like this:</p>  <ul> <li>Embedded ES: 9200 (http), 9300 (tcp)</li> <li>Docker's ES: 9400 (http), 9500 (tcp)</li> </ul>  <p>Here is full <code>docker-compose.yml</code>:</p>  <pre><code>    version: '2'     services:     jhipster-elasticsearch:         # elasticsearch 2.4.0 - to be in line with spring boot version         image: jhipster/jhipster-elasticsearch:v1.3.2         ports:             - 9400:9200             - 9500:9300         volumes:            - ./log-es-config/elasticsearch_custom.yml:/usr/share/elasticsearch/config/elasticsearch.yml     jhipster-logstash:         image: jhipster/jhipster-logstash:v2.2.1         command: logstash -f /conf/logstash_custom.conf         ports:             - 5000:5000/udp             - 6000:6000/tcp         volumes:             - ./logstash-log-es-conf/:/conf     jhipster-console:         image: jhipster/jhipster-console:v2.0.1         ports:             - 5601:5601     jhipster-zipkin:         image: jhipster/jhipster-zipkin:v2.0.1         ports:             - 9411:9411         environment:             - ES_HOSTS=http://jhipster-elasticsearch:9400             - ZIPKIN_UI_LOGS_URL=http://localhost:5601/app/kibana#/dashboard/logs-dashboard?_g=(refreshInterval:(display:Off,pause:!f,value:0),time:(from:now-1h,mode:quick,to:now))&amp;_a=(filters:!(),options:(darkTheme:!f),panels:!((col:1,id:logs-levels,panelIndex:2,row:1,size_x:6,size_y:3,type:visualization),(col:7,columns:!(stack_trace),id:Stacktraces,panelIndex:7,row:1,size_x:4,size_y:3,sort:!('@timestamp',desc),type:search),(col:11,id:Log-forwarding-instructions,panelIndex:8,row:1,size_x:2,size_y:3,type:visualization),(col:1,columns:!(app_name,level,message),id:All-logs,panelIndex:9,row:4,size_x:12,size_y:7,sort:!('@timestamp',asc),type:search)),query:(query_string:(analyze_wildcard:!t,query:'{traceId}')),title:logs-dashboard,uiState:()) </code></pre> ",
    "OwnerUserId": "5250885",
    "LastEditorUserId": "5250885",
    "LastEditDate": "2017-09-01T09:04:49.137",
    "LastActivityDate": "2017-09-01T13:59:55.687",
    "Title": "Connecting to Docker Elasticsearch instance through Java/Spring Boot",
    "Tags": "<java><elasticsearch><docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "47091229",
    "PostTypeId": "1",
    "CreationDate": "2017-11-03T08:19:32.310",
    "Score": "7",
    "ViewCount": "8474",
    "Body": "<p>I have a Spring-Boot Application with REST API (Maven build and MongoDB Database). I will also make a UI with Angular 2 on top of that (npm build). </p>  <p>What i would like to do is, to host this site, with its backend &amp; database on a server. Can i do that on my Synology NAS (DS216j)? Or should i better buy a small computer like Raspberry Pi 3?</p>  <p>I have heard somewhere that we can deploy our apps in Docker, and Synology has a docker app or sth? Will this help me reaching my goal? I would like to have a step by step guide from your similar setups. </p> ",
    "OwnerUserId": "2224454",
    "LastEditorUserId": "2224454",
    "LastEditDate": "2017-11-03T21:29:24.240",
    "LastActivityDate": "2017-11-03T21:29:24.240",
    "Title": "Can i deploy my Java Spring-Boot Application in my Synology NAS?",
    "Tags": "<java><docker><spring-boot><deployment><synology>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "48227857",
    "PostTypeId": "1",
    "AcceptedAnswerId": "48231206",
    "CreationDate": "2018-01-12T14:04:01.130",
    "Score": "7",
    "ViewCount": "27483",
    "Body": "<p>I'm trying to use <code>Spring Boot</code> with <code>Kafka</code> and <code>ZooKeeper</code> with <code>Docker</code> :</p>  <p><code>docker-compose.yml:</code></p>  <pre><code>version: '2'  services:  zookeeper:  image: wurstmeister/zookeeper  restart: always  ports:    - '2181:2181'  kafka:  image: wurstmeister/kafka  restart: always  ports:    - '9092:9092'  environment:    KAFKA_ADVERTISED_HOST_NAME: localhost    KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181 </code></pre>  <p><code>docker ps</code> output:</p>  <pre><code>CONTAINER ID        IMAGE                    COMMAND                            CREATED             STATUS              PORTS                                                        NAMES 980e6b09f4e3        wurstmeister/kafka       'start-kafka.sh'         29 minutes ago      Up 29 minutes       0.0.0.0:9092-&gt;9092/tcp                               samplespringkafkaproducerconsumermaster_kafka_1 64519d4808aa        wurstmeister/zookeeper   '/bin/sh -c '/usr/sb\u2026'   2 hours ago         Up 29 minutes       22/tcp, 2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp   samplespringkafkaproducerconsumermaster_zookeeper_1 </code></pre>  <p><code>docker-compose up</code> output log:</p>  <pre><code>kafka_1      | [2018-01-12 13:14:49,545] INFO Client environment:java.library.path=/usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib (org.apache.zookeeper.ZooKeeper) kafka_1      | [2018-01-12 13:14:49,546] INFO Client environment:java.io.tmpdir=/tmp (org.apache.zookeeper.ZooKeeper) kafka_1      | [2018-01-12 13:14:49,546] INFO Client environment:java.compiler=&lt;NA&gt; (org.apache.zookeeper.ZooKeeper) kafka_1      | [2018-01-12 13:14:49,547] INFO Client environment:os.name=Linux (org.apache.zookeeper.ZooKeeper) kafka_1      | [2018-01-12 13:14:49,547] INFO Client environment:os.arch=amd64 (org.apache.zookeeper.ZooKeeper) kafka_1      | [2018-01-12 13:14:49,548] INFO Client environment:os.version=4.9.60-linuxkit-aufs (org.apache.zookeeper.ZooKeeper) kafka_1      | [2018-01-12 13:14:49,548] INFO Client environment:user.name=root (org.apache.zookeeper.ZooKeeper) kafka_1      | [2018-01-12 13:14:49,549] INFO Client environment:user.home=/root (org.apache.zookeeper.ZooKeeper) kafka_1      | [2018-01-12 13:14:49,549] INFO Client environment:user.dir=/ (org.apache.zookeeper.ZooKeeper) kafka_1      | [2018-01-12 13:14:49,552] INFO Initiating client connection, connectString=zookeeper:2181 sessionTimeout=6000 watcher=org.I0Itec.zkclient.ZkClient@1534f01b (org.apache.zookeeper.ZooKeeper) kafka_1      | [2018-01-12 13:14:49,574] INFO Waiting for keeper state SyncConnected (org.I0Itec.zkclient.ZkClient) kafka_1      | [2018-01-12 13:14:49,578] INFO Opening socket connection to server samplespringkafkaproducerconsumermaster_zookeeper_1.samplespringkafkaproducerconsumermaster_default/192.168.32.2:2181. Will not attempt to authenticate using SASL (unknown error) (org.apache.zookeeper.ClientCnxn) zookeeper_1  | 2018-01-12 13:14:49,591 [myid:] - INFO  [NIOServerCxn.Factory:0.0.0.0/0.0.0.0:2181:NIOServerCnxnFactory@192] - Accepted socket connection from /192.168.32.3:51466 kafka_1      | [2018-01-12 13:14:49,593] INFO Socket connection established to samplespringkafkaproducerconsumermaster_zookeeper_1.samplespringkafkaproducerconsumermaster_default/192.168.32.2:2181, initiating session (org.apache.zookeeper.ClientCnxn) zookeeper_1  | 2018-01-12 13:14:49,600 [myid:] - INFO  [NIOServerCxn.Factory:0.0.0.0/0.0.0.0:2181:ZooKeeperServer@928] - Client attempting to establish new session at /192.168.32.3:51466 zookeeper_1  | 2018-01-12 13:14:49,603 [myid:] - INFO  [SyncThread:0:FileTxnLog@203] - Creating new log file: log.fd zookeeper_1  | 2018-01-12 13:14:49,613 [myid:] - INFO  [SyncThread:0:ZooKeeperServer@673] - Established session 0x160ea8232b00000 with negotiated timeout 6000 for client /192.168.32.3:51466 kafka_1      | [2018-01-12 13:14:49,616] INFO Session establishment complete on server samplespringkafkaproducerconsumermaster_zookeeper_1.samplespringkafkaproducerconsumermaster_default/192.168.32.2:2181, sessionid = 0x160ea8232b00000, negotiated timeout = 6000 (org.apache.zookeeper.ClientCnxn) kafka_1      | [2018-01-12 13:14:49,619] INFO zookeeper state changed (SyncConnected) (org.I0Itec.zkclient.ZkClient) kafka_1      | [2018-01-12 13:14:49,992] INFO Cluster ID = Fgy9ybPPQQ-QdLINzHpmVA (kafka.server.KafkaServer) kafka_1      | [2018-01-12 13:14:50,003] WARN No meta.properties file under dir /kafka/kafka-logs-980e6b09f4e3/meta.properties (kafka.server.BrokerMetadataCheckpoint) kafka_1      | [2018-01-12 13:14:50,065] INFO [ThrottledRequestReaper-Fetch]: Starting (kafka.server.ClientQuotaManager$ThrottledRequestReaper) kafka_1      | [2018-01-12 13:14:50,065] INFO [ThrottledRequestReaper-Produce]: Starting (kafka.server.ClientQuotaManager$ThrottledRequestReaper) kafka_1      | [2018-01-12 13:14:50,067] INFO [ThrottledRequestReaper-Request]: Starting (kafka.server.ClientQuotaManager$ThrottledRequestReaper) kafka_1      | [2018-01-12 13:14:50,167] INFO Log directory '/kafka/kafka-logs-980e6b09f4e3' not found, creating it. (kafka.log.LogManager) kafka_1      | [2018-01-12 13:14:50,183] INFO Loading logs. (kafka.log.LogManager) kafka_1      | [2018-01-12 13:14:50,199] INFO Logs loading complete in 15 ms. (kafka.log.LogManager) kafka_1      | [2018-01-12 13:14:50,283] INFO Starting log cleanup with a period of 300000 ms. (kafka.log.LogManager) kafka_1      | [2018-01-12 13:14:50,291] INFO Starting log flusher with a default period of 9223372036854775807 ms. (kafka.log.LogManager) kafka_1      | [2018-01-12 13:14:50,633] INFO Awaiting socket connections on 0.0.0.0:9092. (kafka.network.Acceptor) kafka_1      | [2018-01-12 13:14:50,639] INFO [SocketServer brokerId=1005] Started 1 acceptor threads (kafka.network.SocketServer) kafka_1      | [2018-01-12 13:14:50,673] INFO [ExpirationReaper-1005-Produce]: Starting (kafka.server.DelayedOperationPurgatory$ExpiredOperationReaper) kafka_1      | [2018-01-12 13:14:50,674] INFO [ExpirationReaper-1005-Fetch]: Starting (kafka.server.DelayedOperationPurgatory$ExpiredOperationReaper) kafka_1      | [2018-01-12 13:14:50,675] INFO [ExpirationReaper-1005-DeleteRecords]: Starting (kafka.server.DelayedOperationPurgatory$ExpiredOperationReaper) kafka_1      | [2018-01-12 13:14:50,691] INFO [LogDirFailureHandler]: Starting (kafka.server.ReplicaManager$LogDirFailureHandler) kafka_1      | [2018-01-12 13:14:50,753] INFO [ExpirationReaper-1005-topic]: Starting (kafka.server.DelayedOperationPurgatory$ExpiredOperationReaper) kafka_1      | [2018-01-12 13:14:50,757] INFO [ExpirationReaper-1005-Heartbeat]: Starting (kafka.server.DelayedOperationPurgatory$ExpiredOperationReaper) kafka_1      | [2018-01-12 13:14:50,762] INFO [ExpirationReaper-1005-Rebalance]: Starting (kafka.server.DelayedOperationPurgatory$ExpiredOperationReaper) kafka_1      | [2018-01-12 13:14:50,777] INFO Creating /controller (is it secure? false) (kafka.utils.ZKCheckedEphemeral) kafka_1      | [2018-01-12 13:14:50,791] INFO [GroupCoordinator 1005]: Starting up. (kafka.coordinator.group.GroupCoordinator) kafka_1      | [2018-01-12 13:14:50,791] INFO Result of znode creation is: OK (kafka.utils.ZKCheckedEphemeral) kafka_1      | [2018-01-12 13:14:50,793] INFO [GroupCoordinator 1005]: Startup complete. (kafka.coordinator.group.GroupCoordinator) kafka_1      | [2018-01-12 13:14:50,798] INFO [GroupMetadataManager brokerId=1005] Removed 0 expired offsets in 5 milliseconds. (kafka.coordinator.group.GroupMetadataManager) kafka_1      | [2018-01-12 13:14:50,811] INFO [ProducerId Manager 1005]: Acquired new producerId block (brokerId:1005,blockStartProducerId:5000,blockEndProducerId:5999) by writing to Zk with path version 6 (kafka.coordinator.transaction.ProducerIdManager) kafka_1      | [2018-01-12 13:14:50,848] INFO [TransactionCoordinator id=1005] Starting up. (kafka.coordinator.transaction.TransactionCoordinator) kafka_1      | [2018-01-12 13:14:50,850] INFO [Transaction Marker Channel Manager 1005]: Starting (kafka.coordinator.transaction.TransactionMarkerChannelManager) kafka_1      | [2018-01-12 13:14:50,850] INFO [TransactionCoordinator id=1005] Startup complete. (kafka.coordinator.transaction.TransactionCoordinator) kafka_1      | [2018-01-12 13:14:50,949] INFO Creating /brokers/ids/1005 (is it secure? false) (kafka.utils.ZKCheckedEphemeral) zookeeper_1  | 2018-01-12 13:14:50,952 [myid:] - INFO  [ProcessThread(sid:0 cport:2181)::PrepRequestProcessor@649] - Got user-level KeeperException when processing sessionid:0x160ea8232b00000 type:create cxid:0x70 zxid:0x102 txntype:-1 reqpath:n/a Error Path:/brokers Error:KeeperErrorCode = NodeExists for /brokers zookeeper_1  | 2018-01-12 13:14:50,952 [myid:] - INFO  [ProcessThread(sid:0 cport:2181)::PrepRequestProcessor@649] - Got user-level KeeperException when processing sessionid:0x160ea8232b00000 type:create cxid:0x71 zxid:0x103 txntype:-1 reqpath:n/a Error Path:/brokers/ids Error:KeeperErrorCode = NodeExists for /brokers/ids kafka_1      | [2018-01-12 13:14:50,957] INFO Result of znode creation is: OK (kafka.utils.ZKCheckedEphemeral) kafka_1      | [2018-01-12 13:14:50,959] INFO Registered broker 1005 at path /brokers/ids/1005 with addresses: EndPoint(localhost,9092,ListenerName(PLAINTEXT),PLAINTEXT) (kafka.utils.ZkUtils) kafka_1      | [2018-01-12 13:14:50,961] WARN No meta.properties file under dir /kafka/kafka-logs-980e6b09f4e3/meta.properties (kafka.server.BrokerMetadataCheckpoint) kafka_1      | [2018-01-12 13:14:50,992] INFO Kafka version : 1.0.0 (org.apache.kafka.common.utils.AppInfoParser) kafka_1      | [2018-01-12 13:14:50,993] INFO Kafka commitId : aaa7af6d4a11b29d (org.apache.kafka.common.utils.AppInfoParser) kafka_1      | [2018-01-12 13:14:51,004] INFO [KafkaServer id=1005] started (kafka.server.KafkaServer) zookeeper_1  | 2018-01-12 13:14:51,263 [myid:] - INFO  [ProcessThread(sid:0 cport:2181)::PrepRequestProcessor@649] - Got user-level KeeperException when processing sessionid:0x160ea8232b00000 type:delete cxid:0xe3 zxid:0x105 txntype:-1 reqpath:n/a Error Path:/admin/preferred_replica_election Error:KeeperErrorCode = NoNode for /admin/preferred_replica_election kafka_1      | [2018-01-12 13:24:50,793] INFO [GroupMetadataManager brokerId=1005] Removed 0 expired offsets in 0 milliseconds. (kafka.coordinator.group.GroupMetadataManager) kafka_1      | [2018-01-12 13:34:50,795] INFO [GroupMetadataManager brokerId=1005] Removed 0 expired offsets in 0 milliseconds. (kafka.coordinator.group.GroupMetadataManager) </code></pre>  <p><code>Kafka</code> maven dependency in <code>Producer</code> and <code>Consumer</code>:</p>  <pre><code> &lt;parent&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;      &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;      &lt;relativePath/&gt;  &lt;/parent&gt;   &lt;dependency&gt;      &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;      &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;  &lt;/dependency&gt; </code></pre>  <p><code>application.properties</code> in <code>Producer</code>:</p>  <pre><code> spring.kafka.producer.bootstrap-servers=0.0.0.0:9092   spring.kafka.consumer.topic=kafka_topic  server.port=8080 </code></pre>  <p><code>application.properties</code> in <code>Consumer</code>:</p>  <pre><code> spring.kafka.consumer.bootstrap-servers=0.0.0.0:9092  spring.kafka.consumer.group-id=WorkUnitApp   spring.kafka.consumer.topic=kafka_topic  server.port=8081 </code></pre>  <p><code>Consumer</code>:</p>  <pre><code>@Component  public class Consumer {  private static final Logger LOGGER = LoggerFactory.getLogger(Consumer.class);  @KafkaListener(topics = '${spring.kafka.consumer.topic}')  public void receive(ConsumerRecord&lt;?, ?&gt; consumerRecord) {  LOGGER.info('received payload='{}'', consumerRecord.toString());  } } </code></pre>  <p><code>Producer</code>:</p>  <pre><code>@Component public class Producer {  private static final Logger LOGGER = LoggerFactory.getLogger(Producer.class);  @Autowired private KafkaTemplate&lt;String, String&gt; kafkaTemplate;  public void send(String topic, String payload) {  LOGGER.info('sending payload='{}' to topic='{}'', payload, topic);  kafkaTemplate.send(topic, payload);  } } </code></pre>  <p><code>ConsumerConfig</code> log:</p>  <pre><code>2018-01-12 15:25:48.220  INFO 20919 --- [           main] o.a.k.clients.consumer.ConsumerConfig    : ConsumerConfig values:  auto.commit.interval.ms = 5000 auto.offset.reset = latest bootstrap.servers = [0.0.0.0:9092] check.crcs = true client.id = consumer-1 connections.max.idle.ms = 540000 enable.auto.commit = true exclude.internal.topics = true fetch.max.bytes = 52428800 fetch.max.wait.ms = 500 fetch.min.bytes = 1 group.id = WorkUnitApp heartbeat.interval.ms = 3000 interceptor.classes = null key.deserializer = class org.apache.kafka.common.serialization.StringDeserializer max.partition.fetch.bytes = 1048576 max.poll.interval.ms = 300000 max.poll.records = 500 metadata.max.age.ms = 300000 metric.reporters = [] metrics.num.samples = 2 metrics.sample.window.ms = 30000 partition.assignment.strategy = [class org.apache.kafka.clients.consumer.RangeAssignor] receive.buffer.bytes = 65536 reconnect.backoff.ms = 50 request.timeout.ms = 305000 retry.backoff.ms = 100 sasl.kerberos.kinit.cmd = /usr/bin/kinit sasl.kerberos.min.time.before.relogin = 60000 sasl.kerberos.service.name = null sasl.kerberos.ticket.renew.jitter = 0.05 sasl.kerberos.ticket.renew.window.factor = 0.8 sasl.mechanism = GSSAPI security.protocol = PLAINTEXT send.buffer.bytes = 131072 session.timeout.ms = 10000 ssl.cipher.suites = null ssl.enabled.protocols = [TLSv1.2, TLSv1.1, TLSv1] ssl.endpoint.identification.algorithm = null ssl.key.password = null ssl.keymanager.algorithm = SunX509 ssl.keystore.location = null ssl.keystore.password = null ssl.keystore.type = JKS ssl.protocol = TLS ssl.provider = null ssl.secure.random.implementation = null ssl.trustmanager.algorithm = PKIX ssl.truststore.location = null ssl.truststore.password = null ssl.truststore.type = JKS value.deserializer = class org.apache.kafka.common.serialization.StringDeserializer </code></pre>  <p><code>ProducerConfig</code> log:</p>  <pre><code>2018-01-12 15:26:27.956  INFO 20924 --- [nio-8080-exec-1] o.a.k.clients.producer.ProducerConfig    : ProducerConfig values:  acks = 1 batch.size = 16384 block.on.buffer.full = false bootstrap.servers = [0.0.0.0:9092] buffer.memory = 33554432 client.id = producer-1 compression.type = none connections.max.idle.ms = 540000 interceptor.classes = null key.serializer = class org.apache.kafka.common.serialization.StringSerializer linger.ms = 0 max.block.ms = 60000 max.in.flight.requests.per.connection = 5 max.request.size = 1048576 metadata.fetch.timeout.ms = 60000 metadata.max.age.ms = 300000 metric.reporters = [] metrics.num.samples = 2 metrics.sample.window.ms = 30000 partitioner.class = class org.apache.kafka.clients.producer.internals.DefaultPartitioner receive.buffer.bytes = 32768 reconnect.backoff.ms = 50 request.timeout.ms = 30000 retries = 0 retry.backoff.ms = 100 sasl.kerberos.kinit.cmd = /usr/bin/kinit sasl.kerberos.min.time.before.relogin = 60000 sasl.kerberos.service.name = null sasl.kerberos.ticket.renew.jitter = 0.05 sasl.kerberos.ticket.renew.window.factor = 0.8 sasl.mechanism = GSSAPI security.protocol = PLAINTEXT send.buffer.bytes = 131072 ssl.cipher.suites = null ssl.enabled.protocols = [TLSv1.2, TLSv1.1, TLSv1] ssl.endpoint.identification.algorithm = null ssl.key.password = null ssl.keymanager.algorithm = SunX509 ssl.keystore.location = null ssl.keystore.password = null ssl.keystore.type = JKS ssl.protocol = TLS ssl.provider = null ssl.secure.random.implementation = null ssl.trustmanager.algorithm = PKIX ssl.truststore.location = null ssl.truststore.password = null ssl.truststore.type = JKS timeout.ms = 30000 value.serializer = class org.apache.kafka.common.serialization.StringSerializer </code></pre>  <p>When i try to send a message I get an exception:</p>  <p><code>producer.send('kafka_topic', 'test')</code> </p>  <p>exception log:</p>  <pre><code>2018-01-12 15:26:27.975  INFO 20924 --- [nio-8080-exec-1]    o.a.kafka.common.utils.AppInfoParser     : Kafka version : 0.10.1.1 2018-01-12 15:26:27.975  INFO 20924 --- [nio-8080-exec-1] o.a.kafka.common.utils.AppInfoParser     : Kafka commitId : f10ef2720b03b247 2018-01-12 15:26:58.152 ERROR 20924 --- [ad | producer-1] o.s.k.support.LoggingProducerListener    : Exception thrown when sending a message with key='null' and payload='test' to topic kafka_topic:  org.apache.kafka.common.errors.TimeoutException: Expiring 1 record(s) for kafka_topic-0 due to 30033 ms has passed since batch creation plus linger time </code></pre>  <p>How to fix it ?</p> ",
    "OwnerUserId": "8112217",
    "LastActivityDate": "2021-09-13T15:03:17.070",
    "Title": "Spring Boot & Kafka, Producer thrown exception with key='null'",
    "Tags": "<docker><spring-boot><apache-kafka>",
    "AnswerCount": "4",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "50035024",
    "PostTypeId": "1",
    "AcceptedAnswerId": "50035102",
    "CreationDate": "2018-04-26T04:48:51.413",
    "Score": "7",
    "ViewCount": "4801",
    "Body": "<p>I'm trying to pass environment variables to a Spring Boot application but it doesn't seem to be working.</p>  <p>Docker run command:</p>  <pre><code>docker run my-image -e TEST_VAR='testing' </code></pre>  <p>Spring Boot main():</p>  <pre><code>@SpringBootApplication public class MyApplication {      public static void main(String[] args) {         ApplicationContext ctx = SpringApplication.run(MyApplication.class, args);          //Read environmental variables:         Map&lt;String, String&gt; env = System.getenv();         System.out.println('TEST_VAR: '+env.get('TEST_VAR'));       } } </code></pre>  <p>Output:</p>  <pre><code>TEST_VAR: null </code></pre>  <p>How can I successfully pass environmental variables with Docker? </p> ",
    "OwnerUserId": "3564870",
    "LastActivityDate": "2018-04-26T11:30:35.793",
    "Title": "Passing Environment Variables With Docker to Spring Boot Application Not Working",
    "Tags": "<docker><spring-boot>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "51710753",
    "PostTypeId": "1",
    "AcceptedAnswerId": "51724659",
    "CreationDate": "2018-08-06T15:11:59.427",
    "Score": "7",
    "ViewCount": "13215",
    "Body": "<p>Good day collegues. I developed an application based on sparkLauncher that run an executable jar where are 5 operations. Each operation depending on the specific variable. I have a main hadoop cluster spark2.3.0-hadoop2.6.5. It works good on it. Part of my working code:</p>  <pre><code> private void runSparkJob(String pathToJar, final LocalDate startDate, final LocalDate endDate) {         if (executionInProgress.get()) {             LOGGER.warn('Execution already in progress');             return;         }         Process sparkProcess = null;         try {             LOGGER.info('Create SparkLauncher. SparkHome: [{}]. JarPath: [{}].', sparkHome, vmJarPath);             executionInProgress.set(true);             sparkProcess = new SparkLauncher()                     .setAppName(activeOperationProfile)                     .setSparkHome(sparkHome) //sparkHome folder on main cluster                     .setAppResource(pathToJar) // jar with 5 operation                     .setConf(SparkLauncher.DRIVER_EXTRA_JAVA_OPTIONS,                             String.format('-Drunner.operation-profile=%1$s -Doperation.startDate=%2$s -Doperation.endDate=%3$s', activeOperationProfile, startDate,endDate))                     .setConf(SparkLauncher.DRIVER_MEMORY, '12G')                     .redirectToLog(LOGGER.getName())                     .setMaster('yarn')                     .launch();              sparkProcess.waitFor();             int exitCode = sparkProcess.exitValue();             if (exitCode != 0) {                 throw new RuntimeException('Illegal exit code. Expected: [0]. Actual: [' + exitCode + ']');             }          } catch (IOException | InterruptedException e) {             LOGGER.error('Error occurred while running SparkApplication.', e);             throw new RuntimeException(e);         } finally {             if (sparkProcess != null &amp;&amp; sparkProcess.isAlive()) {                 LOGGER.warn('Process still alive. Try to kill');                 sparkProcess.destroy();             }             executionInProgress.set(false);         }     } </code></pre>  <p>I have started a docker container, where is a downloaded spark 2.3.0-hadoop6. This container needed for testers. <strong>I changed master to .setMaster('local'), put new profile with paths to sparkHome, jarsWithOpertations</strong> and packaged jar without shade(tried with shade and it doesn't work for me). When i tried to run my sparkLaunch app i have an exception now:</p>  <blockquote>   <p>2018-08-06 14:47:53,150 INFO    [n.m.m.b.r.SparkBaseOperationsRunner.runSparkJob] 105 : Create   SparkLauncher. SparkHome:   [/opt/bigtv/spark/spark-2.3.0-bin-hadoop2.6]. JarPath:   [/opt/bigtv/bin/multirating-bigdata-operations-MASTER-SNAPSHOT.jar].   2018-08-06 14:47:54,905 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 : 2018-08-06   14:47:54 WARN  NativeCodeLoader:62 - Unable to load native-hadoop   library for your platform... using builtin-java classes where   applicable 2018-08-06 14:47:57,042 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 : 2018-08-06   14:47:57 ERROR SpringApplication:842 - Application run failed   2018-08-06 14:47:57,043 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :   <strong>java.lang.NoSuchMethodError:   org.yaml.snakeyaml.Yaml.(Lorg/yaml/snakeyaml/constructor/BaseConstructor;Lorg/yaml/snakeyaml/representer/Representer;Lorg/yaml/snakeyaml/DumperOptions;Lorg/yaml/snakeyaml/LoaderOptions;Lorg/yaml/snakeyaml/resolver/Resolver;)V</strong>   2018-08-06 14:47:57,043 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.env.OriginTrackedYamlLoader.createYaml(OriginTrackedYamlLoader.java:70)   2018-08-06 14:47:57,043 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.beans.factory.config.YamlProcessor.process(YamlProcessor.java:139)   2018-08-06 14:47:57,044 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.env.OriginTrackedYamlLoader.load(OriginTrackedYamlLoader.java:75)   2018-08-06 14:47:57,044 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.env.YamlPropertySourceLoader.load(YamlPropertySourceLoader.java:50)   2018-08-06 14:47:57,044 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.context.config.ConfigFileApplicationListener$Loader.loadDocuments(ConfigFileApplicationListener.java:547)   2018-08-06 14:47:57,044 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.context.config.ConfigFileApplicationListener$Loader.load(ConfigFileApplicationListener.java:517)   2018-08-06 14:47:57,045 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.context.config.ConfigFileApplicationListener$Loader.loadForFileExtension(ConfigFileApplicationListener.java:496)   2018-08-06 14:47:57,045 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.context.config.ConfigFileApplicationListener$Loader.load(ConfigFileApplicationListener.java:464)   2018-08-06 14:47:57,045 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.context.config.ConfigFileApplicationListener$Loader.lambda$null$6(ConfigFileApplicationListener.java:446)   2018-08-06 14:47:57,046 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   java.lang.Iterable.forEach(Iterable.java:75) 2018-08-06 14:47:57,046   INFO  [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.context.config.ConfigFileApplicationListener$Loader.lambda$load$7(ConfigFileApplicationListener.java:445)   2018-08-06 14:47:57,046 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   java.lang.Iterable.forEach(Iterable.java:75) 2018-08-06 14:47:57,046   INFO  [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.context.config.ConfigFileApplicationListener$Loader.load(ConfigFileApplicationListener.java:442)   2018-08-06 14:47:57,046 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.context.config.ConfigFileApplicationListener$Loader.load(ConfigFileApplicationListener.java:330)   2018-08-06 14:47:57,047 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.context.config.ConfigFileApplicationListener.addPropertySources(ConfigFileApplicationListener.java:212)   2018-08-06 14:47:57,047 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.context.config.ConfigFileApplicationListener.postProcessEnvironment(ConfigFileApplicationListener.java:195)   2018-08-06 14:47:57,047 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.context.config.ConfigFileApplicationListener.onApplicationEnvironmentPreparedEvent(ConfigFileApplicationListener.java:182)   2018-08-06 14:47:57,047 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.context.config.ConfigFileApplicationListener.onApplicationEvent(ConfigFileApplicationListener.java:168)   2018-08-06 14:47:57,048 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172)   2018-08-06 14:47:57,048 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165)   2018-08-06 14:47:57,048 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139)   2018-08-06 14:47:57,048 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:127)   2018-08-06 14:47:57,049 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.context.event.EventPublishingRunListener.environmentPrepared(EventPublishingRunListener.java:74)   2018-08-06 14:47:57,049 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.SpringApplicationRunListeners.environmentPrepared(SpringApplicationRunListeners.java:54)   2018-08-06 14:47:57,049 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.SpringApplication.prepareEnvironment(SpringApplication.java:358)   2018-08-06 14:47:57,049 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.SpringApplication.run(SpringApplication.java:317)   2018-08-06 14:47:57,050 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.SpringApplication.run(SpringApplication.java:1255)   2018-08-06 14:47:57,050 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.SpringApplication.run(SpringApplication.java:1243)   2018-08-06 14:47:57,050 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   net.mediascope.multirating.bigdata.operations.OperationRunner.main(OperationRunner.java:21)   2018-08-06 14:47:57,050 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 2018-08-06   14:47:57,050 INFO  [o.a.spark.launcher.OutputRedirector.redirect] 63 :   at   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   2018-08-06 14:47:57,051 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   2018-08-06 14:47:57,051 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   java.lang.reflect.Method.invoke(Method.java:498) 2018-08-06   14:47:57,051 INFO  [o.a.spark.launcher.OutputRedirector.redirect] 63 :   at   org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:48)   2018-08-06 14:47:57,051 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.loader.Launcher.launch(Launcher.java:87)   2018-08-06 14:47:57,052 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.loader.Launcher.launch(Launcher.java:50)   2018-08-06 14:47:57,052 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:51)   2018-08-06 14:47:57,052 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 2018-08-06   14:47:57,052 INFO  [o.a.spark.launcher.OutputRedirector.redirect] 63 :   at   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   2018-08-06 14:47:57,053 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   2018-08-06 14:47:57,053 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   java.lang.reflect.Method.invoke(Method.java:498) 2018-08-06   14:47:57,053 INFO  [o.a.spark.launcher.OutputRedirector.redirect] 63 :   at   org.apache.spark.deploy.JavaMainApplication.start(SparkApplication.scala:52)   2018-08-06 14:47:57,053 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.apache.spark.deploy.SparkSubmit$.org$apache$spark$deploy$SparkSubmit$$runMain(SparkSubmit.scala:879)   2018-08-06 14:47:57,054 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.apache.spark.deploy.SparkSubmit$.doRunMain$1(SparkSubmit.scala:197)   2018-08-06 14:47:57,054 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.apache.spark.deploy.SparkSubmit$.submit(SparkSubmit.scala:227)   2018-08-06 14:47:57,054 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.apache.spark.deploy.SparkSubmit$.main(SparkSubmit.scala:136)   2018-08-06 14:47:57,054 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 :       at   org.apache.spark.deploy.SparkSubmit.main(SparkSubmit.scala) 2018-08-06   14:47:57,058 INFO  [o.a.spark.launcher.OutputRedirector.redirect] 63 :   2018-08-06 14:47:57 INFO  ShutdownHookManager:54 - Shutdown hook   called 2018-08-06 14:47:57,060 INFO    [o.a.spark.launcher.OutputRedirector.redirect] 63 : 2018-08-06   14:47:57 INFO  ShutdownHookManager:54 - Deleting directory   /tmp/spark-55b54924-e628-43fe-9e43-ed34d7f35a8b 2018-08-06   14:47:57,151 INFO    [o.s.b.a.l.ConditionEvaluationReportLoggingListener.logAutoConfigurationReport]   101 :</p>      <p>Error starting ApplicationContext. To display the conditions report   re-run your application with 'debug' enabled.</p> </blockquote>  <p>In my project i have snake yaml 1.19 from spring 5.0 and no others dependicies. I can not understand what the problem is, perhaps when I put it into docker container manual it was necessary to install something else besides the spark. </p>  <p>Pom from module with operations:</p>  <pre><code>&lt;dependencies&gt;         &lt;dependency&gt;             &lt;groupId&gt;net.mediascope&lt;/groupId&gt;             &lt;artifactId&gt;multirating-bigdata-core&lt;/artifactId&gt;             &lt;version&gt;${project.version}&lt;/version&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;!-- Data Base --&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.jdbi&lt;/groupId&gt;             &lt;artifactId&gt;jdbi&lt;/artifactId&gt;             &lt;version&gt;2.71&lt;/version&gt;         &lt;/dependency&gt;          &lt;dependency&gt;             &lt;groupId&gt;com.microsoft.sqlserver&lt;/groupId&gt;             &lt;artifactId&gt;sqljdbc42&lt;/artifactId&gt;             &lt;version&gt;4.2&lt;/version&gt;         &lt;/dependency&gt;          &lt;dependency&gt;             &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;             &lt;artifactId&gt;spark-core_2.11&lt;/artifactId&gt;             &lt;exclusions&gt;                 &lt;exclusion&gt;                     &lt;groupId&gt;org.slf4j&lt;/groupId&gt;                     &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;                 &lt;/exclusion&gt;                 &lt;exclusion&gt;                     &lt;groupId&gt;org.codehaus.janino&lt;/groupId&gt;                     &lt;artifactId&gt;commons-compiler&lt;/artifactId&gt;                 &lt;/exclusion&gt;             &lt;/exclusions&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;             &lt;artifactId&gt;spark-sql_2.11&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;net.sourceforge.jtds&lt;/groupId&gt;             &lt;artifactId&gt;jtds&lt;/artifactId&gt;             &lt;version&gt;1.3.1&lt;/version&gt;         &lt;/dependency&gt;     &lt;/dependencies&gt;      &lt;profiles&gt;         &lt;profile&gt;             &lt;id&gt;local&lt;/id&gt;             &lt;build&gt;                 &lt;plugins&gt;                     &lt;plugin&gt;                         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                         &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                         &lt;configuration&gt;                             &lt;profiles&gt;                                 &lt;profile&gt;${profile.active}&lt;/profile&gt;                             &lt;/profiles&gt;                             &lt;executable&gt;true&lt;/executable&gt;                         &lt;/configuration&gt;                     &lt;/plugin&gt;                 &lt;/plugins&gt;             &lt;/build&gt;         &lt;/profile&gt;         &lt;profile&gt;             &lt;id&gt;hadoop&lt;/id&gt;             &lt;build&gt;                 &lt;!--\u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0434\u043b\u044f \u0430\u0434\u0430\u043f\u0442\u0430\u0446\u0438\u0438 Spring-Boot \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u043f\u043e\u0434 \u0437\u0430\u043f\u0443\u0441\u043a \u0447\u0435\u0440\u0435\u0437 Spark--&gt;                 &lt;plugins&gt;                     &lt;plugin&gt;                         &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                         &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;                         &lt;version&gt;2.3&lt;/version&gt;                         &lt;executions&gt;                             &lt;execution&gt;                                 &lt;phase&gt;package&lt;/phase&gt;                                 &lt;goals&gt;                                     &lt;goal&gt;shade&lt;/goal&gt;                                 &lt;/goals&gt;                                 &lt;configuration&gt;                                     &lt;transformers&gt;                                         &lt;transformer                                                 implementation='org.apache.maven.plugins.shade.resource.AppendingTransformer'&gt;                                             &lt;resource&gt;META-INF/spring.handlers&lt;/resource&gt;                                         &lt;/transformer&gt;                                         &lt;transformer                                                 implementation='org.apache.maven.plugins.shade.resource.AppendingTransformer'&gt;                                             &lt;resource&gt;META-INF/spring.schemas&lt;/resource&gt;                                         &lt;/transformer&gt;                                         &lt;transformer                                                 implementation='org.apache.maven.plugins.shade.resource.AppendingTransformer'&gt;                                             &lt;resource&gt;META-INF/spring.provides&lt;/resource&gt;                                         &lt;/transformer&gt;                                         &lt;transformer                                                 implementation='org.springframework.boot.maven.PropertiesMergingResourceTransformer'&gt;                                             &lt;resource&gt;META-INF/spring.factories&lt;/resource&gt;                                         &lt;/transformer&gt;                                         &lt;transformer                                                 implementation='org.apache.maven.plugins.shade.resource.ManifestResourceTransformer'&gt;                                             &lt;mainClass&gt;${start-class}&lt;/mainClass&gt;                                         &lt;/transformer&gt;                                     &lt;/transformers&gt;                                 &lt;/configuration&gt;                             &lt;/execution&gt;                         &lt;/executions&gt;                     &lt;/plugin&gt;                 &lt;/plugins&gt;             &lt;/build&gt;         &lt;/profile&gt;     &lt;/profiles&gt;I </code></pre> ",
    "OwnerUserId": "7576157",
    "LastActivityDate": "2023-04-20T04:19:52.560",
    "Title": "SparkLauncher. java.lang.NoSuchMethodError: org.yaml.snakeyaml.Yaml.<init>",
    "Tags": "<java><docker><apache-spark><spring-boot><yaml>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "52069406",
    "PostTypeId": "1",
    "CreationDate": "2018-08-29T04:17:55.510",
    "Score": "7",
    "ViewCount": "2219",
    "Body": "<p>I created spring boot project, it works well if I run locally. However, when I dockerize this app and run it inside Docker container. The problems occurs with <code>Error creating bean with name 'org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration'</code></p>  <p>application.properties</p>  <pre><code>spring.datasource.jdbc-url=xxx spring.datasource.username=xxx spring.datasource.password=xxx spring.datasource.driver-class-name=org.postgresql.Driver spring.datasource.maximum-pool-size=100 spring.datasource.testWhileIdle=true spring.datasource.validationQuery=SELECT 1 spring.jpa.hibernate.naming.implicit-strategy=org.hibernate.boot.model.naming.ImplicitNamingStrategyLegacyHbmImpl spring.jpa.hibernate.naming.physical-strategy=org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy spring.jpa.hibernate.ddl-auto=update spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect spring.jpa.generate-ddl=true spring.jpa.show-sql=true spring.jpa.properties.hibernate.default_schema=public spring.jpa.properties.hibernate.temp.use_jdbc_metadata_defaults=false </code></pre>  <p>Dockerfile</p>  <pre><code>FROM openjdk:8-jdk COPY target/app-*.jar /app.jar EXPOSE 8080/tcp ENTRYPOINT ['java', '-jar', '/app.jar'] </code></pre>  <p>Errors:</p>  <pre><code>2018-08-29 03:56:06.093  WARN 1 --- [           main] ConfigServletWebServerApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaConfiguration': Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'authorizationServerConfiguration': Unsatisfied dependency expressed through field 'authenticationManager'; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'webSecurityConfiguration': Unsatisfied dependency expressed through field 'partyPlusUserDetailsService'; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'partyPlusUserDetailsService' defined in URL [jar:file:/app.jar!/BOOT-INF/classes!/com/datnt/pplus/service/user/PartyPlusUserDetailsService.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'userRepository': Cannot create inner bean '(inner bean)#71238fc2' of type [org.springframework.orm.jpa.SharedEntityManagerCreator] while setting bean property 'entityManager'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name '(inner bean)#71238fc2': Cannot resolve reference to bean 'entityManagerFactory' while setting constructor argument; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'entityManagerFactory': Requested bean is currently in creation: Is there an unresolvable circular reference? 2018-08-29 03:56:06.099  INFO 1 --- [           main] o.apache.catalina.core.StandardService   : Stopping service [Tomcat] 2018-08-29 03:56:06.140  INFO 1 --- [           main] ConditionEvaluationReportLoggingListener :  </code></pre>  <p>Could anyone help me to solve this issues?</p> ",
    "OwnerUserId": "3007695",
    "LastEditorUserId": "3007695",
    "LastEditDate": "2019-01-17T07:51:38.570",
    "LastActivityDate": "2019-01-31T09:12:12.040",
    "Title": "Error creating bean with name 'org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration' when run on Docker container",
    "Tags": "<java><spring><docker><spring-boot>",
    "AnswerCount": "1",
    "CommentCount": "10",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "53093020",
    "PostTypeId": "1",
    "AcceptedAnswerId": "53227196",
    "CreationDate": "2018-10-31T22:52:44.750",
    "Score": "7",
    "ViewCount": "5006",
    "Body": "<p>We have around of 10 different applications that are Spring Boot projects with Groovy.</p>  <p>All of our projects build correctly in all developer work stations and they were running correctly until yesterday, however suddenly all of them stopped working today only in our GitLab CI pipelines with below error:</p>  <pre><code>[INFO] Tests run: 0, Failures: 0, Errors: 0, Skipped: 0 [INFO]  [INFO] ------------------------------------------------------------------------ [INFO] BUILD FAILURE [INFO] ------------------------------------------------------------------------ [INFO] Total time: 01:37 min [INFO] Finished at: 2018-10-31T17:49:11Z [INFO] ------------------------------------------------------------------------ [ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.21.0:test (default-test) on project ctg-oms-component: There are test failures. [ERROR]  [ERROR] Please refer to /builds/ctg-integrations/ctg-oms-component/target/surefire-reports for the individual test results. [ERROR] Please refer to dump files (if any exist) [date]-jvmRun[N].dump, [date].dumpstream and [date]-jvmRun[N].dumpstream. [ERROR] ExecutionException The forked VM terminated without properly saying goodbye. VM crash or System.exit called? </code></pre>  <p>I've pulled the same docker image that is using our GitLab CI pipeline, tested building the project and everything works correctly. However, the error occurs only in GitLab CI.</p>  <p>After an investigation looks like surefire is creating a fork that makes GitLab CI docker crash. In order to fix this, I've added below explicit configuration to avoid forked VM and this got rid of above error.</p>  <pre><code>&lt;!-- Needed only for GitLab CI --&gt; &lt;plugin&gt;     &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;     &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;     &lt;configuration&gt;         &lt;forkCount&gt;0&lt;/forkCount&gt;     &lt;/configuration&gt; &lt;/plugin&gt; </code></pre>  <p>Do you know why this is occurring? Is there another way to fix GitLab CI to avoid this issue? I don't really like this workaround, since it is just a way to avoid GitLab CI to explode but don't know how Docker is handled behind the scenes in Gitlab.</p> ",
    "OwnerUserId": "710099",
    "LastActivityDate": "2019-12-05T08:17:01.517",
    "Title": "GitLab CI is failing due to maven-surefire-plugin with VM crash",
    "Tags": "<docker><spring-boot><gitlab><gitlab-ci><maven-surefire-plugin>",
    "AnswerCount": "5",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "53093020",
    "PostTypeId": "1",
    "AcceptedAnswerId": "53227196",
    "CreationDate": "2018-10-31T22:52:44.750",
    "Score": "7",
    "ViewCount": "5006",
    "Body": "<p>We have around of 10 different applications that are Spring Boot projects with Groovy.</p>  <p>All of our projects build correctly in all developer work stations and they were running correctly until yesterday, however suddenly all of them stopped working today only in our GitLab CI pipelines with below error:</p>  <pre><code>[INFO] Tests run: 0, Failures: 0, Errors: 0, Skipped: 0 [INFO]  [INFO] ------------------------------------------------------------------------ [INFO] BUILD FAILURE [INFO] ------------------------------------------------------------------------ [INFO] Total time: 01:37 min [INFO] Finished at: 2018-10-31T17:49:11Z [INFO] ------------------------------------------------------------------------ [ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.21.0:test (default-test) on project ctg-oms-component: There are test failures. [ERROR]  [ERROR] Please refer to /builds/ctg-integrations/ctg-oms-component/target/surefire-reports for the individual test results. [ERROR] Please refer to dump files (if any exist) [date]-jvmRun[N].dump, [date].dumpstream and [date]-jvmRun[N].dumpstream. [ERROR] ExecutionException The forked VM terminated without properly saying goodbye. VM crash or System.exit called? </code></pre>  <p>I've pulled the same docker image that is using our GitLab CI pipeline, tested building the project and everything works correctly. However, the error occurs only in GitLab CI.</p>  <p>After an investigation looks like surefire is creating a fork that makes GitLab CI docker crash. In order to fix this, I've added below explicit configuration to avoid forked VM and this got rid of above error.</p>  <pre><code>&lt;!-- Needed only for GitLab CI --&gt; &lt;plugin&gt;     &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;     &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;     &lt;configuration&gt;         &lt;forkCount&gt;0&lt;/forkCount&gt;     &lt;/configuration&gt; &lt;/plugin&gt; </code></pre>  <p>Do you know why this is occurring? Is there another way to fix GitLab CI to avoid this issue? I don't really like this workaround, since it is just a way to avoid GitLab CI to explode but don't know how Docker is handled behind the scenes in Gitlab.</p> ",
    "OwnerUserId": "710099",
    "LastActivityDate": "2019-12-05T08:17:01.517",
    "Title": "GitLab CI is failing due to maven-surefire-plugin with VM crash",
    "Tags": "<docker><spring-boot><gitlab><gitlab-ci><maven-surefire-plugin>",
    "AnswerCount": "5",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "53093020",
    "PostTypeId": "1",
    "AcceptedAnswerId": "53227196",
    "CreationDate": "2018-10-31T22:52:44.750",
    "Score": "7",
    "ViewCount": "5006",
    "Body": "<p>We have around of 10 different applications that are Spring Boot projects with Groovy.</p>  <p>All of our projects build correctly in all developer work stations and they were running correctly until yesterday, however suddenly all of them stopped working today only in our GitLab CI pipelines with below error:</p>  <pre><code>[INFO] Tests run: 0, Failures: 0, Errors: 0, Skipped: 0 [INFO]  [INFO] ------------------------------------------------------------------------ [INFO] BUILD FAILURE [INFO] ------------------------------------------------------------------------ [INFO] Total time: 01:37 min [INFO] Finished at: 2018-10-31T17:49:11Z [INFO] ------------------------------------------------------------------------ [ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.21.0:test (default-test) on project ctg-oms-component: There are test failures. [ERROR]  [ERROR] Please refer to /builds/ctg-integrations/ctg-oms-component/target/surefire-reports for the individual test results. [ERROR] Please refer to dump files (if any exist) [date]-jvmRun[N].dump, [date].dumpstream and [date]-jvmRun[N].dumpstream. [ERROR] ExecutionException The forked VM terminated without properly saying goodbye. VM crash or System.exit called? </code></pre>  <p>I've pulled the same docker image that is using our GitLab CI pipeline, tested building the project and everything works correctly. However, the error occurs only in GitLab CI.</p>  <p>After an investigation looks like surefire is creating a fork that makes GitLab CI docker crash. In order to fix this, I've added below explicit configuration to avoid forked VM and this got rid of above error.</p>  <pre><code>&lt;!-- Needed only for GitLab CI --&gt; &lt;plugin&gt;     &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;     &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;     &lt;configuration&gt;         &lt;forkCount&gt;0&lt;/forkCount&gt;     &lt;/configuration&gt; &lt;/plugin&gt; </code></pre>  <p>Do you know why this is occurring? Is there another way to fix GitLab CI to avoid this issue? I don't really like this workaround, since it is just a way to avoid GitLab CI to explode but don't know how Docker is handled behind the scenes in Gitlab.</p> ",
    "OwnerUserId": "710099",
    "LastActivityDate": "2019-12-05T08:17:01.517",
    "Title": "GitLab CI is failing due to maven-surefire-plugin with VM crash",
    "Tags": "<docker><spring-boot><gitlab><gitlab-ci><maven-surefire-plugin>",
    "AnswerCount": "5",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "53152471",
    "PostTypeId": "1",
    "CreationDate": "2018-11-05T10:25:04.230",
    "Score": "7",
    "ViewCount": "7176",
    "Body": "<p>is there a way to choose if I want to have a logback appender or not, via environment variable?<br> <br> I have a dockerized spring boot Microservice and added now the ELK stack.<br> That works fine so far.<br> But now if I want to start my service without ELK stack, the application throws an error, that it doesn't know the host of Logstash:</p>  <pre><code>app | 10:09:23,537 |-ERROR in ch.qos.logback.classic.net.SyslogAppender[SYSLOG] - Could not create SyslogWriter java.net.UnknownHostException: logstash: Name or service not known app |   at java.net.UnknownHostException: logstash: Name or service not known </code></pre>  <p>Here is my logback.xml file:</p>  <pre><code>&lt;?xml version='1.0' encoding='UTF-8'?&gt; &lt;configuration&gt;      &lt;appender name='SYSLOG' class='ch.qos.logback.classic.net.SyslogAppender'&gt;         &lt;syslogHost&gt;logstash&lt;/syslogHost&gt;         &lt;port&gt;5000&lt;/port&gt;         &lt;facility&gt;LOCAL1&lt;/facility&gt;         &lt;suffixPattern&gt;[%thread] %logger %msg&lt;/suffixPattern&gt;     &lt;/appender&gt;      &lt;root level='INFO'&gt;         &lt;appender-ref ref='SYSLOG'/&gt;     &lt;/root&gt;  &lt;/configuration&gt; </code></pre>  <p>I know this is a very simple version, but I am new in logging with logback/ELK stack.<br> <br> So is there a way to inject something with an environment variable like in yaml files e.g. <code>active=${LOGBACK_ACTIVE:false}</code> like I can do it with my prometheus metrics?</p> ",
    "OwnerUserId": "8344100",
    "LastEditorUserId": "8344100",
    "LastEditDate": "2018-11-05T10:27:43.633",
    "LastActivityDate": "2020-05-25T18:10:37.513",
    "Title": "How can I dynamically (by env variable) activate/deactivate logback or logback appender?",
    "Tags": "<spring-boot><logging><docker-compose><logback><elastic-stack>",
    "AnswerCount": "2",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "53152471",
    "PostTypeId": "1",
    "CreationDate": "2018-11-05T10:25:04.230",
    "Score": "7",
    "ViewCount": "7176",
    "Body": "<p>is there a way to choose if I want to have a logback appender or not, via environment variable?<br> <br> I have a dockerized spring boot Microservice and added now the ELK stack.<br> That works fine so far.<br> But now if I want to start my service without ELK stack, the application throws an error, that it doesn't know the host of Logstash:</p>  <pre><code>app | 10:09:23,537 |-ERROR in ch.qos.logback.classic.net.SyslogAppender[SYSLOG] - Could not create SyslogWriter java.net.UnknownHostException: logstash: Name or service not known app |   at java.net.UnknownHostException: logstash: Name or service not known </code></pre>  <p>Here is my logback.xml file:</p>  <pre><code>&lt;?xml version='1.0' encoding='UTF-8'?&gt; &lt;configuration&gt;      &lt;appender name='SYSLOG' class='ch.qos.logback.classic.net.SyslogAppender'&gt;         &lt;syslogHost&gt;logstash&lt;/syslogHost&gt;         &lt;port&gt;5000&lt;/port&gt;         &lt;facility&gt;LOCAL1&lt;/facility&gt;         &lt;suffixPattern&gt;[%thread] %logger %msg&lt;/suffixPattern&gt;     &lt;/appender&gt;      &lt;root level='INFO'&gt;         &lt;appender-ref ref='SYSLOG'/&gt;     &lt;/root&gt;  &lt;/configuration&gt; </code></pre>  <p>I know this is a very simple version, but I am new in logging with logback/ELK stack.<br> <br> So is there a way to inject something with an environment variable like in yaml files e.g. <code>active=${LOGBACK_ACTIVE:false}</code> like I can do it with my prometheus metrics?</p> ",
    "OwnerUserId": "8344100",
    "LastEditorUserId": "8344100",
    "LastEditDate": "2018-11-05T10:27:43.633",
    "LastActivityDate": "2020-05-25T18:10:37.513",
    "Title": "How can I dynamically (by env variable) activate/deactivate logback or logback appender?",
    "Tags": "<spring-boot><logging><docker-compose><logback><elastic-stack>",
    "AnswerCount": "2",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "53152471",
    "PostTypeId": "1",
    "CreationDate": "2018-11-05T10:25:04.230",
    "Score": "7",
    "ViewCount": "7176",
    "Body": "<p>is there a way to choose if I want to have a logback appender or not, via environment variable?<br> <br> I have a dockerized spring boot Microservice and added now the ELK stack.<br> That works fine so far.<br> But now if I want to start my service without ELK stack, the application throws an error, that it doesn't know the host of Logstash:</p>  <pre><code>app | 10:09:23,537 |-ERROR in ch.qos.logback.classic.net.SyslogAppender[SYSLOG] - Could not create SyslogWriter java.net.UnknownHostException: logstash: Name or service not known app |   at java.net.UnknownHostException: logstash: Name or service not known </code></pre>  <p>Here is my logback.xml file:</p>  <pre><code>&lt;?xml version='1.0' encoding='UTF-8'?&gt; &lt;configuration&gt;      &lt;appender name='SYSLOG' class='ch.qos.logback.classic.net.SyslogAppender'&gt;         &lt;syslogHost&gt;logstash&lt;/syslogHost&gt;         &lt;port&gt;5000&lt;/port&gt;         &lt;facility&gt;LOCAL1&lt;/facility&gt;         &lt;suffixPattern&gt;[%thread] %logger %msg&lt;/suffixPattern&gt;     &lt;/appender&gt;      &lt;root level='INFO'&gt;         &lt;appender-ref ref='SYSLOG'/&gt;     &lt;/root&gt;  &lt;/configuration&gt; </code></pre>  <p>I know this is a very simple version, but I am new in logging with logback/ELK stack.<br> <br> So is there a way to inject something with an environment variable like in yaml files e.g. <code>active=${LOGBACK_ACTIVE:false}</code> like I can do it with my prometheus metrics?</p> ",
    "OwnerUserId": "8344100",
    "LastEditorUserId": "8344100",
    "LastEditDate": "2018-11-05T10:27:43.633",
    "LastActivityDate": "2020-05-25T18:10:37.513",
    "Title": "How can I dynamically (by env variable) activate/deactivate logback or logback appender?",
    "Tags": "<spring-boot><logging><docker-compose><logback><elastic-stack>",
    "AnswerCount": "2",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "53227826",
    "PostTypeId": "1",
    "AcceptedAnswerId": "57970111",
    "CreationDate": "2018-11-09T14:39:07.137",
    "Score": "7",
    "ViewCount": "22750",
    "Body": "<p>I have a spring boot java application running inside a docker container. I configured logback in the application. Where i can access the generated logs? The configured path is:</p>  <pre><code>&lt;property name='LOG_PATH' value='logs'/&gt; </code></pre>  <p>I am currently checking logs using: docker logs containerName --follow  But this command return the current logs from the last time the application was started. How can i check the rolling logs or archived ones.</p>  <p>Is there a way to create a volume for logback logs?</p> ",
    "OwnerUserId": "8294118",
    "LastActivityDate": "2019-09-17T08:17:59.290",
    "Title": "Spring boot - Docker logs",
    "Tags": "<java><linux><spring-boot><docker>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "53429062",
    "PostTypeId": "1",
    "CreationDate": "2018-11-22T10:38:36.987",
    "Score": "7",
    "ViewCount": "14310",
    "Body": "<p>I am building my first Springboot 2.0 application. I am trying to put my Springboot application into one docker container and my PostgresDB into another container.  </p>  <p><strong>My Dockerfile</strong></p>  <pre><code>    FROM frolvlad/alpine-oraclejdk8:slim     VOLUME /tmp     ADD springboot-api-demo-0.1*.jar app.jar     RUN sh -c 'touch /app.jar'     EXPOSE 9443     ENTRYPOINT [ 'sh', '-c', 'java $JAVA_OPTS -Djava.security.egd=file:/dev/urandom -jar /app.jar' ] </code></pre>  <p><strong>My docker-compose.yml file</strong></p>  <pre><code>version: '2.1'  services:   springboot-api-demo:     image: 'fw/springboot-api-demo'     mem_limit: 1024m     ports:       - '8080:8080'     environment:       - SPRING_PROFILES_ACTIVE=local       - AWS_REGION=local       - ENVIRONMENT=local       - AUTH_ENABLED=false   postgres:     container_name: pgdb     image: postgres:9.6-alpine     environment:     - 'POSTGRES_ROOT_PASSWORD=postgres'     - 'POSTGRES_USER=postgres'     - 'POSTGRES_PASSWORD=postgres'     ports:     - '54321:5432' </code></pre>  <p>I am using Springboot JPA Data 2.0 with below config data in my <strong>application.properties</strong></p>  <pre><code>spring.datasource.url= jdbc:postgresql://localhost:54321/java_learning spring.datasource.username=postgres spring.datasource.password=postgres </code></pre>  <p>I can test that Both of the Images are up. Also from docker log and docker events, I see that postgres  Container is running fine, even I can access it and also created a DB too. But springboot container started but i died because it could not connect to postgress and throwing error below. </p>  <blockquote>   <p>Unable to obtain connection from database: The connection attempt   failed</p> </blockquote>  <p>Note that my host machine already has Postgres on port 5432 thats why I did a port mapping ofr 54321:5432 on my postgres container. Here is Proof :) -</p>  <pre><code>\u279c  springboot-api-demo git:(master) \u2717 lsof -i:54321               COMMAND     PID             USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME com.docke 44345 shailendra.singh   18u  IPv4 0xf62897fbdd69e31d      0t0  TCP *:54321 (LISTEN) com.docke 44345 shailendra.singh   21u  IPv6 0xf62897fbdd119975      0t0  TCP localhost:54321 (LISTEN)  \u279c  springboot-api-demo git:(master) \u2717 lsof -i:5432  COMMAND  PID             USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME postgres 715 shailendra.singh    5u  IPv6 0xf62897fbb43e03b5      0t0  TCP localhost:postgresql (LISTEN) postgres 715 shailendra.singh    6u  IPv4 0xf62897fbbaeea9bd      0t0  TCP localhost:postgresql (LISTEN) </code></pre>  <p>I am not sure what is the problem. But my Springboot application is not able to connect my postgres container which is running fine with proper creadentials. </p> ",
    "OwnerUserId": "3511619",
    "LastEditorUserId": "2275818",
    "LastEditDate": "2018-11-22T10:52:45.053",
    "LastActivityDate": "2022-06-09T04:12:13.973",
    "Title": "Docker: Springboot container can not connect to PostgreSql Container Connection error",
    "Tags": "<postgresql><spring-boot><docker><docker-compose>",
    "AnswerCount": "4",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "53429062",
    "PostTypeId": "1",
    "CreationDate": "2018-11-22T10:38:36.987",
    "Score": "7",
    "ViewCount": "14310",
    "Body": "<p>I am building my first Springboot 2.0 application. I am trying to put my Springboot application into one docker container and my PostgresDB into another container.  </p>  <p><strong>My Dockerfile</strong></p>  <pre><code>    FROM frolvlad/alpine-oraclejdk8:slim     VOLUME /tmp     ADD springboot-api-demo-0.1*.jar app.jar     RUN sh -c 'touch /app.jar'     EXPOSE 9443     ENTRYPOINT [ 'sh', '-c', 'java $JAVA_OPTS -Djava.security.egd=file:/dev/urandom -jar /app.jar' ] </code></pre>  <p><strong>My docker-compose.yml file</strong></p>  <pre><code>version: '2.1'  services:   springboot-api-demo:     image: 'fw/springboot-api-demo'     mem_limit: 1024m     ports:       - '8080:8080'     environment:       - SPRING_PROFILES_ACTIVE=local       - AWS_REGION=local       - ENVIRONMENT=local       - AUTH_ENABLED=false   postgres:     container_name: pgdb     image: postgres:9.6-alpine     environment:     - 'POSTGRES_ROOT_PASSWORD=postgres'     - 'POSTGRES_USER=postgres'     - 'POSTGRES_PASSWORD=postgres'     ports:     - '54321:5432' </code></pre>  <p>I am using Springboot JPA Data 2.0 with below config data in my <strong>application.properties</strong></p>  <pre><code>spring.datasource.url= jdbc:postgresql://localhost:54321/java_learning spring.datasource.username=postgres spring.datasource.password=postgres </code></pre>  <p>I can test that Both of the Images are up. Also from docker log and docker events, I see that postgres  Container is running fine, even I can access it and also created a DB too. But springboot container started but i died because it could not connect to postgress and throwing error below. </p>  <blockquote>   <p>Unable to obtain connection from database: The connection attempt   failed</p> </blockquote>  <p>Note that my host machine already has Postgres on port 5432 thats why I did a port mapping ofr 54321:5432 on my postgres container. Here is Proof :) -</p>  <pre><code>\u279c  springboot-api-demo git:(master) \u2717 lsof -i:54321               COMMAND     PID             USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME com.docke 44345 shailendra.singh   18u  IPv4 0xf62897fbdd69e31d      0t0  TCP *:54321 (LISTEN) com.docke 44345 shailendra.singh   21u  IPv6 0xf62897fbdd119975      0t0  TCP localhost:54321 (LISTEN)  \u279c  springboot-api-demo git:(master) \u2717 lsof -i:5432  COMMAND  PID             USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME postgres 715 shailendra.singh    5u  IPv6 0xf62897fbb43e03b5      0t0  TCP localhost:postgresql (LISTEN) postgres 715 shailendra.singh    6u  IPv4 0xf62897fbbaeea9bd      0t0  TCP localhost:postgresql (LISTEN) </code></pre>  <p>I am not sure what is the problem. But my Springboot application is not able to connect my postgres container which is running fine with proper creadentials. </p> ",
    "OwnerUserId": "3511619",
    "LastEditorUserId": "2275818",
    "LastEditDate": "2018-11-22T10:52:45.053",
    "LastActivityDate": "2022-06-09T04:12:13.973",
    "Title": "Docker: Springboot container can not connect to PostgreSql Container Connection error",
    "Tags": "<postgresql><spring-boot><docker><docker-compose>",
    "AnswerCount": "4",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "53429062",
    "PostTypeId": "1",
    "CreationDate": "2018-11-22T10:38:36.987",
    "Score": "7",
    "ViewCount": "14310",
    "Body": "<p>I am building my first Springboot 2.0 application. I am trying to put my Springboot application into one docker container and my PostgresDB into another container.  </p>  <p><strong>My Dockerfile</strong></p>  <pre><code>    FROM frolvlad/alpine-oraclejdk8:slim     VOLUME /tmp     ADD springboot-api-demo-0.1*.jar app.jar     RUN sh -c 'touch /app.jar'     EXPOSE 9443     ENTRYPOINT [ 'sh', '-c', 'java $JAVA_OPTS -Djava.security.egd=file:/dev/urandom -jar /app.jar' ] </code></pre>  <p><strong>My docker-compose.yml file</strong></p>  <pre><code>version: '2.1'  services:   springboot-api-demo:     image: 'fw/springboot-api-demo'     mem_limit: 1024m     ports:       - '8080:8080'     environment:       - SPRING_PROFILES_ACTIVE=local       - AWS_REGION=local       - ENVIRONMENT=local       - AUTH_ENABLED=false   postgres:     container_name: pgdb     image: postgres:9.6-alpine     environment:     - 'POSTGRES_ROOT_PASSWORD=postgres'     - 'POSTGRES_USER=postgres'     - 'POSTGRES_PASSWORD=postgres'     ports:     - '54321:5432' </code></pre>  <p>I am using Springboot JPA Data 2.0 with below config data in my <strong>application.properties</strong></p>  <pre><code>spring.datasource.url= jdbc:postgresql://localhost:54321/java_learning spring.datasource.username=postgres spring.datasource.password=postgres </code></pre>  <p>I can test that Both of the Images are up. Also from docker log and docker events, I see that postgres  Container is running fine, even I can access it and also created a DB too. But springboot container started but i died because it could not connect to postgress and throwing error below. </p>  <blockquote>   <p>Unable to obtain connection from database: The connection attempt   failed</p> </blockquote>  <p>Note that my host machine already has Postgres on port 5432 thats why I did a port mapping ofr 54321:5432 on my postgres container. Here is Proof :) -</p>  <pre><code>\u279c  springboot-api-demo git:(master) \u2717 lsof -i:54321               COMMAND     PID             USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME com.docke 44345 shailendra.singh   18u  IPv4 0xf62897fbdd69e31d      0t0  TCP *:54321 (LISTEN) com.docke 44345 shailendra.singh   21u  IPv6 0xf62897fbdd119975      0t0  TCP localhost:54321 (LISTEN)  \u279c  springboot-api-demo git:(master) \u2717 lsof -i:5432  COMMAND  PID             USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME postgres 715 shailendra.singh    5u  IPv6 0xf62897fbb43e03b5      0t0  TCP localhost:postgresql (LISTEN) postgres 715 shailendra.singh    6u  IPv4 0xf62897fbbaeea9bd      0t0  TCP localhost:postgresql (LISTEN) </code></pre>  <p>I am not sure what is the problem. But my Springboot application is not able to connect my postgres container which is running fine with proper creadentials. </p> ",
    "OwnerUserId": "3511619",
    "LastEditorUserId": "2275818",
    "LastEditDate": "2018-11-22T10:52:45.053",
    "LastActivityDate": "2022-06-09T04:12:13.973",
    "Title": "Docker: Springboot container can not connect to PostgreSql Container Connection error",
    "Tags": "<postgresql><spring-boot><docker><docker-compose>",
    "AnswerCount": "4",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "53959448",
    "PostTypeId": "1",
    "CreationDate": "2018-12-28T13:37:30.923",
    "Score": "7",
    "ViewCount": "22712",
    "Body": "<p>Request execution error. endpoint=DefaultEndpoint{ serviceUrl='<a href='http://localhost:8761/eureka/' rel='noreferrer'>http://localhost:8761/eureka/</a>} is giving when I am running in docker windows but It is registering with eureka server when I am running in spring boot app in STS.</p>  <p>for server i run in docker     docker run -p 8761:8080 serverimagename     for services I run in docker     docker run -p 8762:8080 servicesimagename     server app.properties</p>  <pre><code>DOCKER_HOST=tcp://127.0.0.1:2375 eureka.instance.hostname=localhost eureka.instance.secure-port-enabled= true #eureka.instance.statusPageUrl: https://${eureka.hostname}:${eureka.instance.secure-port} #eureka.instance.service-url.defaultZone: https://localhost:8761/eureka eureka.client.register-with-eureka=false eureka.client.fetch-registry=false and services app.properties spring.application.name=demo1 DOCKER_HOST=tcp://127.0.0.1:2375 eureka.client.register-with-eureka=true eureka.client.fetch-registry=true spring.thymeleaf.prefix=/WEB-INF/ spring.thymeleaf.suffix=.jsp     </code></pre>  <p>ERROR 1 --- [tbeatExecutor-0] c.n.d.s.t.d.RedirectingEurekaHttpClient  : Request execution error. endpoint=DefaultEndpoint{ serviceUrl='<a href='http://localhost:8761/eureka/' rel='noreferrer'>http://localhost:8761/eureka/</a>}</p>  <pre><code>com.sun.jersey.api.client.ClientHandlerException: java.net.ConnectException: Connection refused (Connection refused)         at com.sun.jersey.client.apache4.ApacheHttpClient4Handler.handle(ApacheHttpClient4Handler.java:187) ~[jersey-apache-client4-1.19.1.jar!/:1.19.1]         at com.sun.jersey.api.client.filter.GZIPContentEncodingFilter.handle(GZIPContentEncodingFilter.java:123) ~[jersey-client-1.19.1.jar!/:1.19.1]         at com.netflix.discovery.EurekaIdentityHeaderFilter.handle(EurekaIdentityHeaderFilter.java:27) ~[eureka-client-1.9.8.jar!/:1.9.8]         at com.sun.jersey.api.client.Client.handle(Client.java:652) ~[jersey-client-1.19.1.jar!/:1.19.1]         at com.sun.jersey.api.client.WebResource.handle(WebResource.java:682) ~[jersey-client-1.19.1.jar!/:1.19.1]         at com.sun.jersey.api.client.WebResource.access$200(WebResource.java:74) ~[jersey-client-1.19.1.jar!/:1.19.1]         at com.sun.jersey.api.client.WebResource$Builder.put(WebResource.java:529) ~[jersey-client-1.19.1.jar!/:1.19.1]         at com.netflix.discovery.shared.transport.jersey.AbstractJerseyEurekaHttpClient.sendHeartBeat(AbstractJerseyEurekaHttpClient.java:102) ~[eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92) [eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.shared.transport.decorator.MetricsCollectingEurekaHttpClient.execute(MetricsCollectingEurekaHttpClient.java:73) ~[eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89) [eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92) [eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:118) ~[eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:79) ~[eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89) [eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92) [eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120) [eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89) [eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92) [eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77) [eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89) [eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:846) [eureka-client-1.9.8.jar!/:1.9.8]         at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1405) [eureka-client-1.9.8.jar!/:1.9.8]         at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [na:1.8.0_111]         at java.util.concurrent.FutureTask.run(FutureTask.java:266) [na:1.8.0_111]         at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_111]         at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_111]         at java.lang.Thread.run(Thread.java:745) [na:1.8.0_111] Caused by: java.net.ConnectException: Connection refused (Connection refused)         at java.net.PlainSocketImpl.socketConnect(Native Method) ~[na:1.8.0_111]         at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350) ~[na:1.8.0_111]         at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206) ~[na:1.8.0_111]         at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188) ~[na:1.8.0_111]         at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392) ~[na:1.8.0_111]         at java.net.Socket.connect(Socket.java:589) ~[na:1.8.0_111]         at org.apache.http.conn.scheme.PlainSocketFactory.connectSocket(PlainSocketFactory.java:121) ~[httpclient-4.5.6.jar!/:4.5.6]         at org.apache.http.impl.conn.DefaultClientConnectionOperator.openConnection(DefaultClientConnectionOperator.java:180) ~[httpclient-4.5.6.jar!/:4.5.6]         at org.apache.http.impl.conn.AbstractPoolEntry.open(AbstractPoolEntry.java:144) ~[httpclient-4.5.6.jar!/:4.5.6]         at org.apache.http.impl.conn.AbstractPooledConnAdapter.open(AbstractPooledConnAdapter.java:134) ~[httpclient-4.5.6.jar!/:4.5.6]         at org.apache.http.impl.client.DefaultRequestDirector.tryConnect(DefaultRequestDirector.java:610) ~[httpclient-4.5.6.jar!/:4.5.6]         at org.apache.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:445) ~[httpclient-4.5.6.jar!/:4.5.6]         at org.apache.http.impl.client.AbstractHttpClient.doExecute(AbstractHttpClient.java:835) ~[httpclient-4.5.6.jar!/:4.5.6]         at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:118) ~[httpclient-4.5.6.jar!/:4.5.6]         at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56) ~[httpclient-4.5.6.jar!/:4.5.6]         at com.sun.jersey.client.apache4.ApacheHttpClient4Handler.handle(ApacheHttpClient4Handler.java:173) ~[jersey-apache-client4-1.19.1.jar!/:1.19.1]         ... 27 common frames omitted </code></pre> ",
    "OwnerUserId": "10389158",
    "LastEditorUserId": "4370109",
    "LastEditDate": "2019-03-08T22:22:53.207",
    "LastActivityDate": "2022-04-15T11:23:28.073",
    "Title": "Eureka services giving Request execution error?",
    "Tags": "<spring-boot><docker><netflix-eureka>",
    "AnswerCount": "4",
    "CommentCount": "8",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "54692666",
    "PostTypeId": "1",
    "AcceptedAnswerId": "54692798",
    "CreationDate": "2019-02-14T14:24:02.643",
    "Score": "7",
    "ViewCount": "14653",
    "Body": "<p>I have to consume an external rest API(using restTemplate.exchange) with Spring Boot. My rest API is running on port 8083 with URL <a href='http://localhost:8083/myrest' rel='noreferrer'>http://localhost:8083/myrest</a> (Docker command : <code>docker run -p 8083:8083 myrest-app</code>)</p>  <p>External API is available in form of public docker image and after running below command , I am able to pull and run it locally.</p>  <pre><code> docker pull dockerExternalId/external-rest-api docker     run -d -p 3000:3000 dockerExternalId/external-rest-api </code></pre>  <p>a) If I enter external rest API URL, for example <a href='http://localhost:3000/externalrestapi/testresource' rel='noreferrer'>http://localhost:3000/externalrestapi/testresource</a> directly in chrome, then I get valid JSON data.</p>  <p>b) If I invoke it with myrest application from eclipse(Spring Boot Application), still I am getting valid JSON Response. (I am using Windows Platform to test this)</p>  <p>c) But if I run it on Docker and execute myrest service (say <a href='http://localhost:8083/myrest' rel='noreferrer'>http://localhost:8083/myrest</a>), then i am facing <code>java.net.ConnectException: Connection refused</code> </p>  <p><strong>More details :</strong> </p>  <pre><code>org.springframework.web.client.ResourceAccessException: I/O error on GET request for 'http://localhost:3000/externalrestapi/testresource': Connection refused (Connection refused); nested exception is java.net.ConnectException: Connection refused (Connection refused) </code></pre>  <p><strong>P.S -  I am using Docker on Windows.</strong></p> ",
    "OwnerUserId": "1064076",
    "LastEditorUserId": "1064076",
    "LastEditDate": "2019-02-14T14:45:27.173",
    "LastActivityDate": "2019-02-15T07:57:50.560",
    "Title": "Docker : java.net.ConnectException: Connection refused - Application running at port 8083 is not able to access other application on port 3000",
    "Tags": "<rest><spring-boot><docker><dockerfile>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "54896064",
    "PostTypeId": "1",
    "AcceptedAnswerId": "54896158",
    "CreationDate": "2019-02-27T00:00:09.977",
    "Score": "7",
    "ViewCount": "4380",
    "Body": "<p>I'm trying to load a file in a spring boot application that is running inside a Docker container but I'm getting the following exception:</p>  <pre><code>java.nio.file.FileSystemNotFoundException   at com.sun.nio.zipfs.ZipFileSystemProvider.getFileSystem(ZipFileSystemProvider.java:171) ~[zipfs.jar:1.8.0_191]     at com.sun.nio.zipfs.ZipFileSystemProvider.getPath(ZipFileSystemProvider.java:157) ~[zipfs.jar:1.8.0_191]   at java.nio.file.Paths.get(Paths.java:143) ~[?:1.8.0_191]   at app.metrics.collector.util.FileUtils.getContentAsSingleLine(FileUtils.java:17) ~[classes!/:?]       at app.metrics.collector.jobs.DbQueryJob.generatePreparedStatement(DbQueryJob.java:54) ~[classes!/:?]  at app.metrics.collector.jobs.DbQueryJob.execute(DbQueryJob.java:36) ~[classes!/:?]    at org.quartz.core.JobRunShell.run(JobRunShell.java:202) [quartz-2.3.0.jar!/:?]  </code></pre>  <p>The error does not appears when I execute the jar outside the container.</p>  <p>Here is the Dockerfile:</p>  <pre><code>FROM openjdk:8-jdk-alpine ADD build/app.jar app.jar ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','app.jar'] </code></pre>  <p>And here is the method that loads the file:</p>  <pre><code>    public static String getContentAsSingleLine(String fileName) throws URISyntaxException, IOException {     String data;     Path path = Paths.get(FileUtils.class.getClassLoader().getResource(fileName).toURI());     Stream&lt;String&gt; lines = Files.lines(path);     data = lines.collect(Collectors.joining(StringUtils.SPACE));     lines.close();     return data; } </code></pre>  <p>The file is located in the resource folder: </p>  <pre><code>/src/main/resources/database/file.sql </code></pre>  <p>and the argument passed to the method is:</p>  <pre><code>'database/file.sql' </code></pre>  <ul> <li>Does anyone have an idea of the cause of the issue and its possible solution ?</li> </ul> ",
    "OwnerUserId": "3490266",
    "LastActivityDate": "2024-01-19T23:51:37.417",
    "Title": "FileSystemNotFoundException in a Dockerized Spring Boot Application",
    "Tags": "<java><spring-boot><docker>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "55322488",
    "PostTypeId": "1",
    "CreationDate": "2019-03-24T09:46:35.973",
    "Score": "7",
    "ViewCount": "6791",
    "Body": "<p>I developed a java program which is supposed to run in docker. However, I encountered a lot of pains when debugging my java program running in docker. </p>  <p>I searched on Internet, some tutorials proposed tools like spring-dev-tools (as my java program is a spring-boot-based program).</p>  <p><a href='https://www.youtube.com/watch?v=sz5Zv5QQ5ek' rel='noreferrer'>https://www.youtube.com/watch?v=sz5Zv5QQ5ek</a></p>  <p>Based on thoses tutorials, debugging is ok, such as setting breakpoint and variable watching, however, when I update my code (for instance, some classes), thoses changes cannot be reflected immediately in the program running in docker, the programm behaves as old code. </p>  <p>Can anybody give some hints ?</p> ",
    "OwnerUserId": "5663160",
    "LastEditorUserId": "3664714",
    "LastEditDate": "2019-06-07T13:55:59.170",
    "LastActivityDate": "2019-06-07T13:55:59.170",
    "Title": "hot reload java program running in docker",
    "Tags": "<java><spring-boot><docker>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "56284845",
    "PostTypeId": "1",
    "AcceptedAnswerId": "56285260",
    "CreationDate": "2019-05-24T01:42:29.300",
    "Score": "7",
    "ViewCount": "16500",
    "Body": "<p>I have a multi-module maven project. Parent pom looks like this:</p>  <pre><code>&lt;project&gt;     ...     &lt;packaging&gt;pom&lt;/packaging&gt;        &lt;modules&gt;         &lt;module&gt;common&lt;/module&gt;         &lt;module&gt;a&lt;/module&gt;         &lt;module&gt;b&lt;/module&gt;     &lt;/modules&gt; &lt;/project&gt; </code></pre>  <p><code>common</code> builds a jar, which is added as dependency in the other modules, like this:</p>  <pre><code>&lt;dependency&gt;     &lt;groupId&gt;my.project&lt;/groupId&gt;     &lt;artifactId&gt;common&lt;/artifactId&gt;     &lt;version&gt;${module.common.version}&lt;/version&gt; &lt;/dependency&gt; </code></pre>  <p>Modules <code>a</code> and <code>b</code> are Spring Boot projects having the <a href='https://github.com/spotify/dockerfile-maven' rel='noreferrer'>spotify docker plugin</a>.</p>  <p>I need to be able to run <code>mvn deploy</code> in order to get the spotify plugin push the docker image.</p>  <p><code>mvn install</code> works fine, which builds the docker images. But in order to push them, when I run <code>mvn deploy</code>, it throws error for the <code>common</code> module:</p>  <blockquote>   <p>[ERROR] Failed to execute goal   org.apache.maven.plugins:maven-deploy-plugin:2.7:deploy   (default-deploy) on project common: Deployment failed: repository   element was not specified in the POM inside distributionManagement   element or in -DaltDeploymentRepository=id::layout::url parameter</p> </blockquote>  <p>Searching for this error, <a href='https://stackoverflow.com/questions/27153024/repository-element-was-not-specified-in-the-pom-inside-distributionmanagement-el?rq=1'>this answer</a> suggests adding the repository url in the <code>distributionManagement</code> section. But I don't want to deploy <code>common</code>. I just want to build it, so it gets injected as dependency in the other modules and deploy those other modules. How can I do that?</p>  <p>I tried to deploy only <code>a</code> and <code>b</code> using this command, but it gives the same error for <code>common</code>:</p>  <pre><code>mvn clean \\    -DdockerRegistryHost=123.dkr.ecr.us-west-1.amazonaws.com/test1 \\    --projects a,b \\    --also-make \\    deploy </code></pre> ",
    "OwnerUserId": "1039555",
    "LastActivityDate": "2019-05-24T02:54:57.943",
    "Title": "Skip maven deploy for one module",
    "Tags": "<java><maven><spring-boot><docker><spotify-docker-client>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "56284845",
    "PostTypeId": "1",
    "AcceptedAnswerId": "56285260",
    "CreationDate": "2019-05-24T01:42:29.300",
    "Score": "7",
    "ViewCount": "16500",
    "Body": "<p>I have a multi-module maven project. Parent pom looks like this:</p>  <pre><code>&lt;project&gt;     ...     &lt;packaging&gt;pom&lt;/packaging&gt;        &lt;modules&gt;         &lt;module&gt;common&lt;/module&gt;         &lt;module&gt;a&lt;/module&gt;         &lt;module&gt;b&lt;/module&gt;     &lt;/modules&gt; &lt;/project&gt; </code></pre>  <p><code>common</code> builds a jar, which is added as dependency in the other modules, like this:</p>  <pre><code>&lt;dependency&gt;     &lt;groupId&gt;my.project&lt;/groupId&gt;     &lt;artifactId&gt;common&lt;/artifactId&gt;     &lt;version&gt;${module.common.version}&lt;/version&gt; &lt;/dependency&gt; </code></pre>  <p>Modules <code>a</code> and <code>b</code> are Spring Boot projects having the <a href='https://github.com/spotify/dockerfile-maven' rel='noreferrer'>spotify docker plugin</a>.</p>  <p>I need to be able to run <code>mvn deploy</code> in order to get the spotify plugin push the docker image.</p>  <p><code>mvn install</code> works fine, which builds the docker images. But in order to push them, when I run <code>mvn deploy</code>, it throws error for the <code>common</code> module:</p>  <blockquote>   <p>[ERROR] Failed to execute goal   org.apache.maven.plugins:maven-deploy-plugin:2.7:deploy   (default-deploy) on project common: Deployment failed: repository   element was not specified in the POM inside distributionManagement   element or in -DaltDeploymentRepository=id::layout::url parameter</p> </blockquote>  <p>Searching for this error, <a href='https://stackoverflow.com/questions/27153024/repository-element-was-not-specified-in-the-pom-inside-distributionmanagement-el?rq=1'>this answer</a> suggests adding the repository url in the <code>distributionManagement</code> section. But I don't want to deploy <code>common</code>. I just want to build it, so it gets injected as dependency in the other modules and deploy those other modules. How can I do that?</p>  <p>I tried to deploy only <code>a</code> and <code>b</code> using this command, but it gives the same error for <code>common</code>:</p>  <pre><code>mvn clean \\    -DdockerRegistryHost=123.dkr.ecr.us-west-1.amazonaws.com/test1 \\    --projects a,b \\    --also-make \\    deploy </code></pre> ",
    "OwnerUserId": "1039555",
    "LastActivityDate": "2019-05-24T02:54:57.943",
    "Title": "Skip maven deploy for one module",
    "Tags": "<java><maven><spring-boot><docker><spotify-docker-client>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "56284845",
    "PostTypeId": "1",
    "AcceptedAnswerId": "56285260",
    "CreationDate": "2019-05-24T01:42:29.300",
    "Score": "7",
    "ViewCount": "16500",
    "Body": "<p>I have a multi-module maven project. Parent pom looks like this:</p>  <pre><code>&lt;project&gt;     ...     &lt;packaging&gt;pom&lt;/packaging&gt;        &lt;modules&gt;         &lt;module&gt;common&lt;/module&gt;         &lt;module&gt;a&lt;/module&gt;         &lt;module&gt;b&lt;/module&gt;     &lt;/modules&gt; &lt;/project&gt; </code></pre>  <p><code>common</code> builds a jar, which is added as dependency in the other modules, like this:</p>  <pre><code>&lt;dependency&gt;     &lt;groupId&gt;my.project&lt;/groupId&gt;     &lt;artifactId&gt;common&lt;/artifactId&gt;     &lt;version&gt;${module.common.version}&lt;/version&gt; &lt;/dependency&gt; </code></pre>  <p>Modules <code>a</code> and <code>b</code> are Spring Boot projects having the <a href='https://github.com/spotify/dockerfile-maven' rel='noreferrer'>spotify docker plugin</a>.</p>  <p>I need to be able to run <code>mvn deploy</code> in order to get the spotify plugin push the docker image.</p>  <p><code>mvn install</code> works fine, which builds the docker images. But in order to push them, when I run <code>mvn deploy</code>, it throws error for the <code>common</code> module:</p>  <blockquote>   <p>[ERROR] Failed to execute goal   org.apache.maven.plugins:maven-deploy-plugin:2.7:deploy   (default-deploy) on project common: Deployment failed: repository   element was not specified in the POM inside distributionManagement   element or in -DaltDeploymentRepository=id::layout::url parameter</p> </blockquote>  <p>Searching for this error, <a href='https://stackoverflow.com/questions/27153024/repository-element-was-not-specified-in-the-pom-inside-distributionmanagement-el?rq=1'>this answer</a> suggests adding the repository url in the <code>distributionManagement</code> section. But I don't want to deploy <code>common</code>. I just want to build it, so it gets injected as dependency in the other modules and deploy those other modules. How can I do that?</p>  <p>I tried to deploy only <code>a</code> and <code>b</code> using this command, but it gives the same error for <code>common</code>:</p>  <pre><code>mvn clean \\    -DdockerRegistryHost=123.dkr.ecr.us-west-1.amazonaws.com/test1 \\    --projects a,b \\    --also-make \\    deploy </code></pre> ",
    "OwnerUserId": "1039555",
    "LastActivityDate": "2019-05-24T02:54:57.943",
    "Title": "Skip maven deploy for one module",
    "Tags": "<java><maven><spring-boot><docker><spotify-docker-client>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "58217665",
    "PostTypeId": "1",
    "CreationDate": "2019-10-03T10:55:54.487",
    "Score": "7",
    "ViewCount": "45680",
    "Body": "<p>I have my spring boot application running on Openshift as container built using docker Image. I have enabled the logging in my application and prints all the logs.  Now i want to examine the log files of the POD to check for any errors, since one my request is failing.  I do know about the command line option <code>oc logs -f &lt;podname&gt;</code> That just prints the log into cmd prompt, but i want whole log to be copied from server to local file. So that i can find some particular lines or errors. Is is possible?</p> ",
    "OwnerUserId": "3346416",
    "LastEditorUserId": "3346416",
    "LastEditDate": "2019-10-03T12:16:32.290",
    "LastActivityDate": "2023-07-04T06:15:33.230",
    "Title": "How to get the logs of a POD in openshift to local file",
    "Tags": "<java><spring-boot><docker><openshift>",
    "AnswerCount": "10",
    "CommentCount": "2",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "59299794",
    "PostTypeId": "1",
    "AcceptedAnswerId": "59327134",
    "CreationDate": "2019-12-12T07:40:51.737",
    "Score": "7",
    "ViewCount": "10125",
    "Body": "<p>I have a simple Gradle Spring Boot Java application, where I am trying to get some properties value from  &quot;application.properties&quot; and &quot;application-dev.properties&quot; using spring boot profiling. It is working fine and Spring Boot profile is loading when I try to run application on the local machine, but when when I try to run same application on the Docker, suddenly an error pops up which says that application is not able to find resources on the classpath.</p> <p>Below is the project structure:</p> <p><a href='https://i.stack.imgur.com/4bm3I.png' rel='nofollow noreferrer'><img src='https://i.stack.imgur.com/4bm3I.png' alt='Project structure of the application' /></a></p> <p>In the App.Config class I have the following code. As you can see I am trying to get property value from application.properties file.</p> <pre><code>@Component @PropertySource(&quot;classpath:application.properties&quot;) public class AppConfig {  @Value(&quot;${host}&quot;) private String host; @Value(&quot;${map}&quot;) private String map;  public String getHost() {     return host; }  public void setHost(String host) {     this.host = host; }  public String getMap() {     return map; }  public void setMap(String map) {     this.map = map; } } </code></pre> <p>application.properties contains following code:</p> <pre><code>map = Main-Map  spring.profiles.active=${profile} </code></pre> <p>application-dev.properties contains following code:</p> <pre><code>host = Development-host </code></pre> <p>As you can see I am setting profile value in application.properties from outside. That's what I am trying to inject through docker</p> <p>Dockerfile contain following code:</p> <pre><code>FROM java:8  VOLUME /tmp  ENV tom=dev  ADD build/libs/demo-0.0.1-SNAPSHOT.jar /app/app.jar  ADD build/resources/main/application.properties /app/application.properties  ADD build/resources/main/application-dev.properties /app/application-dev.properties  WORKDIR /app  ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-  Dprofile=${tom}&quot;,&quot;-jar&quot;,&quot;app.jar&quot;, &quot;-  -spring.config.location=/app/application.properties, /app/application-  dev.properties&quot;] </code></pre> <p>I build Docker image using following command:</p> <pre><code>docker build -t demo:latest . </code></pre> <p>I run Docker using following command:</p> <pre><code>docker run -p 8083:8080 demo:latest </code></pre> <p>When I run <code>docker run</code> command, so comes below exception:</p> <pre><code>2019-12-12 07:09:50.405  INFO 1 --- [           main] com.example.demo.DemoApplication         :  Starting DemoApplication on ed7cb11b8a34 with PID 1 (/app/app.jar started by root in /app) 2019-12-12 07:09:50.407  INFO 1 --- [           main] com.example.demo.DemoApplication         : The  following profiles are active: dev 2019-12-12 07:09:50.603  WARN 1 --- [           main] ConfigServletWebServerApplicationContext :  Exception encountered during context initialization - cancelling refresh attempt:  org.springframework.beans.factory.BeanDefinitionStoreException: Failed to parse configuration class  [com.example.demo.DemoApplication]; nested exception is java.io.FileNotFoundException: class path  resource [application.properties] cannot be opened because it does not exist 2019-12-12 07:09:50.712 ERROR 1 --- [           main] o.s.boot.SpringApplication               :  Application run failed  org.springframework.beans.factory.BeanDefinitionStoreException: Failed to parse configuration class [   com.example.demo.DemoApplication]; nested exception is java.io.FileNotFoundException: class path  resource [ application.properties] cannot be opened because it does not exist     at  </code></pre> <p>What can I try to resolve this?</p> ",
    "OwnerUserId": "3661407",
    "LastEditorUserId": "472495",
    "LastEditDate": "2023-02-08T19:03:06.900",
    "LastActivityDate": "2023-02-08T19:03:06.900",
    "Title": "Docker cannot find Resource on classpath",
    "Tags": "<java><spring><spring-boot><dockerfile>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "59564269",
    "PostTypeId": "1",
    "AcceptedAnswerId": "59566367",
    "CreationDate": "2020-01-02T13:34:50.143",
    "Score": "7",
    "ViewCount": "2410",
    "Body": "<p>I used to configure <code>-Djava.security.egd=file:/dev/./urandom</code> in my Dockerfile for Spring Boot applications.</p> <p>In <a href='https://spring.io/guides/gs/spring-boot-docker/' rel='nofollow noreferrer'>https://spring.io/guides/gs/spring-boot-docker/</a> (or GitHub <a href='https://github.com/dsyer/gs-spring-boot-docker' rel='nofollow noreferrer'>https://github.com/dsyer/gs-spring-boot-docker</a>) a comment was added that this is not required any more for newer versions:</p> <blockquote> <p>To reduce Tomcat startup time we added a system property pointing to &quot;/dev/urandom&quot; as a source of entropy. This is not necessary with more recent versions of Spring Boot, if you use the &quot;standard&quot; version of Tomcat (or any other web server).</p> </blockquote> <p>I am looking for any references for this change in Tomcat or Spring Boot repos, and which Spring Boot versions are affected.</p> ",
    "OwnerUserId": "5444798",
    "LastEditorUserId": "482717",
    "LastEditDate": "2023-07-24T18:25:55.070",
    "LastActivityDate": "2023-07-24T18:25:55.070",
    "Title": "Deprecated java.security.egd=file:/dev/./urandom for Spring Boot applications?",
    "Tags": "<spring-boot><docker><tomcat>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "63789255",
    "PostTypeId": "1",
    "CreationDate": "2020-09-08T07:40:03.367",
    "Score": "7",
    "ViewCount": "2997",
    "Body": "<p>My Spring Boot project contains the Spring Boot Maven Plugin which I use for building a Docker image by running <code>mvn spring-boot:build-image</code>.</p> <pre class='lang-xml prettyprint-override'><code>&lt;plugin&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;     &lt;executions&gt;         &lt;execution&gt;             &lt;phase&gt;package&lt;/phase&gt;             &lt;goals&gt;                 &lt;goal&gt;build-image&lt;/goal&gt;             &lt;/goals&gt;         &lt;/execution&gt;     &lt;/executions&gt; &lt;/plugin&gt; </code></pre> <p>When deploying this image to a Docker stack I need to run a healthcheck using the <code>curl</code> command but unfortunately <code>curl</code> is not installed by the default buildpack.</p> <p>Is it possible to further tweak the image building process so that <code>curl</code> gets installed into the iamge? I couldn't find the necessary information</p> ",
    "OwnerUserId": "478406",
    "LastEditorUserId": "478406",
    "LastEditDate": "2020-09-08T07:47:11.900",
    "LastActivityDate": "2023-02-25T12:59:25.103",
    "Title": "Install package in Docker image created by Spring Boot Maven plugin",
    "Tags": "<spring-boot><docker><spring-boot-maven-plugin>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "63789255",
    "PostTypeId": "1",
    "CreationDate": "2020-09-08T07:40:03.367",
    "Score": "7",
    "ViewCount": "2997",
    "Body": "<p>My Spring Boot project contains the Spring Boot Maven Plugin which I use for building a Docker image by running <code>mvn spring-boot:build-image</code>.</p> <pre class='lang-xml prettyprint-override'><code>&lt;plugin&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;     &lt;executions&gt;         &lt;execution&gt;             &lt;phase&gt;package&lt;/phase&gt;             &lt;goals&gt;                 &lt;goal&gt;build-image&lt;/goal&gt;             &lt;/goals&gt;         &lt;/execution&gt;     &lt;/executions&gt; &lt;/plugin&gt; </code></pre> <p>When deploying this image to a Docker stack I need to run a healthcheck using the <code>curl</code> command but unfortunately <code>curl</code> is not installed by the default buildpack.</p> <p>Is it possible to further tweak the image building process so that <code>curl</code> gets installed into the iamge? I couldn't find the necessary information</p> ",
    "OwnerUserId": "478406",
    "LastEditorUserId": "478406",
    "LastEditDate": "2020-09-08T07:47:11.900",
    "LastActivityDate": "2023-02-25T12:59:25.103",
    "Title": "Install package in Docker image created by Spring Boot Maven plugin",
    "Tags": "<spring-boot><docker><spring-boot-maven-plugin>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "63789255",
    "PostTypeId": "1",
    "CreationDate": "2020-09-08T07:40:03.367",
    "Score": "7",
    "ViewCount": "2997",
    "Body": "<p>My Spring Boot project contains the Spring Boot Maven Plugin which I use for building a Docker image by running <code>mvn spring-boot:build-image</code>.</p> <pre class='lang-xml prettyprint-override'><code>&lt;plugin&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;     &lt;executions&gt;         &lt;execution&gt;             &lt;phase&gt;package&lt;/phase&gt;             &lt;goals&gt;                 &lt;goal&gt;build-image&lt;/goal&gt;             &lt;/goals&gt;         &lt;/execution&gt;     &lt;/executions&gt; &lt;/plugin&gt; </code></pre> <p>When deploying this image to a Docker stack I need to run a healthcheck using the <code>curl</code> command but unfortunately <code>curl</code> is not installed by the default buildpack.</p> <p>Is it possible to further tweak the image building process so that <code>curl</code> gets installed into the iamge? I couldn't find the necessary information</p> ",
    "OwnerUserId": "478406",
    "LastEditorUserId": "478406",
    "LastEditDate": "2020-09-08T07:47:11.900",
    "LastActivityDate": "2023-02-25T12:59:25.103",
    "Title": "Install package in Docker image created by Spring Boot Maven plugin",
    "Tags": "<spring-boot><docker><spring-boot-maven-plugin>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "64591075",
    "PostTypeId": "1",
    "CreationDate": "2020-10-29T12:25:09.843",
    "Score": "7",
    "ViewCount": "3527",
    "Body": "<p>I run my docker-compose file mysql last version in windows. But i want to run mysql version5.7 and i am getting an error.</p> <blockquote> <p>InnoDB: Table flags are 0 in the data dictionary but the flags in file ./ibdata1 are 0x4000!</p> </blockquote> <p><strong>docker-compose.yaml</strong></p> <pre><code>version: '3' services:   mysql:     image: mysql:5.7     volumes:       - db_data:/var/lib/mysql     restart: always     environment:       MYSQL_ROOT_PASSWORD: password     ports:       - 3306:3306  volumes:   db_data: </code></pre> <p><strong>application.yaml</strong></p> <pre><code>spring:   datasource:     type: com.zaxxer.hikari.HikariDataSource     url: &amp;connectionUrl jdbc:mysql://${DB_CONNECTION_IP:localhost}:${DB_CONNECTION_PORT:3306}/masa?createDatabaseIfNotExist=true&amp;useSSL=false&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC&amp;zeroDateTimeBehavior=convertToNull&amp;useUnicode=true&amp;characterEncoding=UTF-8     username: &amp;username ${DB_CONNECTION_USERNAME:root}     password: &amp;password ${DB_CONNECTION_PASSWORD:root}   jpa:     show-sql: true </code></pre> <p>How can I solve this problem?</p> ",
    "OwnerUserId": "4204154",
    "LastActivityDate": "2020-10-29T12:25:09.843",
    "Title": "InnoDB: Table flags are 0 in the data dictionary but the flags in file ./ibdata1 are 0x4000",
    "Tags": "<mysql><windows><spring-boot><docker>",
    "AnswerCount": "0",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "64774067",
    "PostTypeId": "1",
    "AcceptedAnswerId": "64775095",
    "CreationDate": "2020-11-10T17:46:14.350",
    "Score": "7",
    "ViewCount": "9755",
    "Body": "<p>I'm building a java spring boot app docker container on Azure DevOps using the spring boot maven plugin. After that I want to push it to an azure container registry. But it fails with</p> <blockquote> <p>An image does not exist locally with the tag: ***/my/container</p> </blockquote> <p>Unfortunately the start of the container uri is masked with <code>***</code>. But as you can see in the output of <code>/usr/bin/docker images</code> below, the container is registered. I tried to follow this example: <a href='https://medium.com/@TimvanBaarsen/build-your-spring-boot-project-using-azure-pipelines-in-azure-devops-3305977991d' rel='noreferrer'>https://medium.com/@TimvanBaarsen/build-your-spring-boot-project-using-azure-pipelines-in-azure-devops-3305977991d</a></p> <p><strong>Pipeline steps</strong></p> <pre class='lang-yaml prettyprint-override'><code>steps: - task: Maven@3   displayName: &quot;Build Docker image&quot;   inputs:     mavenPomFile: 'pom.xml'     goals: 'spring-boot:build-image'     publishJUnitResults: false     jdkVersionOption: '1.11'     mavenOptions: '-Xmx3072m -Dspring-boot.build-image.imageName=acr-foobar.azurecr.io/my/container'  - task: Docker@2   displayName: Push Docker image   inputs:     containerRegistry: 'acr-foobar.azurecr.io'     repository: 'my/container'     command: 'push'     tags: 'latest' </code></pre> <p><strong>Output Maven Task</strong></p> <pre><code>[INFO] Successfully built image 'acr-***/my/container:latest' </code></pre> <p><strong>Output Docker Task</strong></p> <pre><code>Starting: Push Docker image ============================================================================== Task         : Docker Description  : Build or push Docker images, login or logout, start or stop containers, or run a Docker command Version      : 2.176.0 Author       : Microsoft Corporation Help         : https://aka.ms/azpipes-docker-tsg ============================================================================== /usr/bin/docker images /usr/bin/docker push ***/my/container:latest REPOSITORY                                             TAG                     IMAGE ID            CREATED             SIZE paketobuildpacks/run                                   base-cnb                523e5e0ad089        6 days ago          87.2MB node                                                   10                      2457d5f85d32        13 days ago         911MB node                                                   10-alpine               b328632eb00c        13 days ago         83.6MB node                                                   12                      1f560ce4ce7e        4 weeks ago         918MB buildpack-deps                                         stretch                 b39de549c36a        4 weeks ago         835MB buildpack-deps                                         buster                  f3f98451c17d        4 weeks ago         804MB debian                                                 9                       c4ccba324c9c        4 weeks ago         101MB debian                                                 8                       091099bf65ad        4 weeks ago         129MB node                                                   12-alpine               d8b74300d554        4 weeks ago         89.6MB ubuntu                                                 14.04                   df043b4f0cf1        7 weeks ago         197MB jekyll/builder                                         latest                  a8007cad4069        2 months ago        677MB alpine                                                 3.9                     78a2ce922f86        6 months ago        5.55MB alpine                                                 3.10                    be4e4bea2c2e        6 months ago        5.58MB alpine                                                 3.8                     c8bccc0af957        9 months ago        4.41MB alpine                                                 3.7                     6d1ef012b567        20 months ago       4.21MB mcr.microsoft.com/azure-pipelines/node8-typescript     latest                  9a948d360778        2 years ago         595MB gcr.io/paketo-buildpacks/builder                       base-platform-api-0.3   6248029341bb        40 years ago        568MB acr-***/my/container   latest                  61477479d5e0        40 years ago        283MB The push refers to repository [***/my/container] An image does not exist locally with the tag: ***/my/container ##[error]An image does not exist locally with the tag: ***/my/container ##[error]The process '/usr/bin/docker' failed with exit code 1 Finishing: Push Docker image </code></pre> <p>What's wrong here?</p> ",
    "OwnerUserId": "1489968",
    "LastActivityDate": "2021-09-25T10:21:39.750",
    "Title": "Azure Devops Docker Push: An image does not exist locally with the tag",
    "Tags": "<spring-boot><docker><azure-devops><azure-container-registry>",
    "AnswerCount": "2",
    "CommentCount": "2",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "64849028",
    "PostTypeId": "1",
    "AcceptedAnswerId": "64958942",
    "CreationDate": "2020-11-15T19:43:42.410",
    "Score": "7",
    "ViewCount": "4410",
    "Body": "<p>Using Spring Boot 2.4.0, I'm trying to configure the <code>spring-boot:build-image</code> task to push an image to my private GitHub container registry.</p> <p>I used <a href='https://docs.spring.io/spring-boot/docs/2.4.0/maven-plugin/reference/htmlsingle/#build-image-example-publish' rel='noreferrer'>these instructions</a> to configure my POM as follows:</p> <pre class='lang-xml prettyprint-override'><code>            &lt;plugin&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                 &lt;configuration&gt;                     &lt;image&gt;                         &lt;name&gt;ghcr.io/abc/${project.artifactId}:${project.version}&lt;/name&gt;                         &lt;publish&gt;true&lt;/publish&gt;                     &lt;/image&gt;                     &lt;docker&gt;                         &lt;publishRegistry&gt;                             &lt;username&gt;abc&lt;/username&gt;                             &lt;token&gt;mytoken&lt;/token&gt;                             &lt;url&gt;https://ghcr.io&lt;/url&gt;                         &lt;/publishRegistry&gt;                     &lt;/docker&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt; </code></pre> <p>When I execute the <code>spring-boot:build-image</code> task, it builds the image but I get the following error when it tries to push:</p> <pre><code>[INFO] Successfully built image 'ghcr.io/abc/def:1.5.0' [INFO] [INFO]  &gt; Pushing image 'ghcr.io/abc/def:1.5.0' 100% Execution default-cli of goal org.springframework.boot:spring-boot-maven-plugin:2.4.0:build-image failed: Error response received when pushing image: error parsing HTTP 405 response body: unexpected end of JSON input: &quot;&quot; -&gt; [Help 1] </code></pre> <p>I can manually push the image using <code>docker push</code>, and I have tried doing a <code>docker login</code> which doesn't help either. I am also not behind any firewall or proxy.</p> ",
    "OwnerUserId": "657224",
    "LastEditorUserId": "657224",
    "LastEditDate": "2020-11-16T00:50:21.490",
    "LastActivityDate": "2020-11-22T20:04:35.763",
    "Title": "Maven Spring Boot Cannot Push Docker Image",
    "Tags": "<spring-boot><docker><spring-boot-maven-plugin>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "64849028",
    "PostTypeId": "1",
    "AcceptedAnswerId": "64958942",
    "CreationDate": "2020-11-15T19:43:42.410",
    "Score": "7",
    "ViewCount": "4410",
    "Body": "<p>Using Spring Boot 2.4.0, I'm trying to configure the <code>spring-boot:build-image</code> task to push an image to my private GitHub container registry.</p> <p>I used <a href='https://docs.spring.io/spring-boot/docs/2.4.0/maven-plugin/reference/htmlsingle/#build-image-example-publish' rel='noreferrer'>these instructions</a> to configure my POM as follows:</p> <pre class='lang-xml prettyprint-override'><code>            &lt;plugin&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                 &lt;configuration&gt;                     &lt;image&gt;                         &lt;name&gt;ghcr.io/abc/${project.artifactId}:${project.version}&lt;/name&gt;                         &lt;publish&gt;true&lt;/publish&gt;                     &lt;/image&gt;                     &lt;docker&gt;                         &lt;publishRegistry&gt;                             &lt;username&gt;abc&lt;/username&gt;                             &lt;token&gt;mytoken&lt;/token&gt;                             &lt;url&gt;https://ghcr.io&lt;/url&gt;                         &lt;/publishRegistry&gt;                     &lt;/docker&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt; </code></pre> <p>When I execute the <code>spring-boot:build-image</code> task, it builds the image but I get the following error when it tries to push:</p> <pre><code>[INFO] Successfully built image 'ghcr.io/abc/def:1.5.0' [INFO] [INFO]  &gt; Pushing image 'ghcr.io/abc/def:1.5.0' 100% Execution default-cli of goal org.springframework.boot:spring-boot-maven-plugin:2.4.0:build-image failed: Error response received when pushing image: error parsing HTTP 405 response body: unexpected end of JSON input: &quot;&quot; -&gt; [Help 1] </code></pre> <p>I can manually push the image using <code>docker push</code>, and I have tried doing a <code>docker login</code> which doesn't help either. I am also not behind any firewall or proxy.</p> ",
    "OwnerUserId": "657224",
    "LastEditorUserId": "657224",
    "LastEditDate": "2020-11-16T00:50:21.490",
    "LastActivityDate": "2020-11-22T20:04:35.763",
    "Title": "Maven Spring Boot Cannot Push Docker Image",
    "Tags": "<spring-boot><docker><spring-boot-maven-plugin>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  }
]