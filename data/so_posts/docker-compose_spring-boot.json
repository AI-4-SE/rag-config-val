[
  {
    "Id": "44738469",
    "PostTypeId": "1",
    "CreationDate": "2017-06-24T16:20:56.010",
    "Score": "9",
    "ViewCount": "7110",
    "Body": "<p>I have a spring cloud config server and packaged it as a docker image then I have spring cloud eureka server which is also packaged as docker image.</p>  <p>When I run the two using docker compose I get the following error.</p>  <p><code>discovery-service_1  | 2017-06-24 15:36:12.059  INFO 5 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Fetching config from server at: http://config-service:9001 discovery-service_1  | 2017-06-24 15:36:12.997  WARN 5 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Could not locate PropertySource: I/O error on GET request for 'http://config-service:9001/cls-discovery-service/default': Connection refused (Connection refused); nested exception is java.net.ConnectException: Connection refused (Connection refused) </code></p>  <blockquote>   <p>Although the config service is up and running successfully, discover service still does not find it for some reason.</p> </blockquote>  <p><strong>Docker compose file being used here is this</strong>  <code> version: '2' services:         config-service:                 image: cloudsea/cls-config-service                 ports:                 - 9001:9001                 expose:                 - '9001'         discovery-service:                 image: cloudsea/cls-discovery-service                 depends_on:                 - config-service                 environment:                         CLOUD_SEA_CONFIG_SERVER_URI: http://config-service:9001                         EUREKA_DEFAULT_ZONE_URL: http://discovery-service:8761/eureka/                 ports:                 - 8761:8761                 links:                 - config-service:config-service </code></p>  <p>Below is the <strong>bootstrap.properties</strong> for DISCOVERY SERVICE</p>  <p><code>spring.cloud.config.uri = ${CLOUD_SEA_CONFIG_SERVER_URI:http://localhost:9001} spring.application.name = ${SPRING_APPLICATION_NAME:cls-discovery-service} </code></p>  <p>Below is the <strong>cls-discovery-service.properties</strong> for DISCOVERY SERVICE located in github.</p>  <p><code>server.port=${SERVER_PORT:8761} eureka.client.registerWithEureka: false eureka.client.fetchRegistry: false eureka.client.serviceUrl.defaultZone: ${EUREKA_DEFAULT_ZONE_URL:http://localhost:8761/eureka/} eureka.server.eviction-interval-timer-in-ms: 1000 </code></p>  <p>I am assuming something is wrong with my docker-compose.yml but I am not sure.</p>  <p>Any help will I am stick in this for hours ... heading close to days :(</p> ",
    "OwnerUserId": "3058432",
    "LastActivityDate": "2018-02-06T23:23:47.990",
    "Title": "Spring Cloud Config Server not working with Docker compose",
    "Tags": "<spring-boot><docker-compose><spring-cloud><spring-cloud-netflix><spring-cloud-config>",
    "AnswerCount": "3",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "44738469",
    "PostTypeId": "1",
    "CreationDate": "2017-06-24T16:20:56.010",
    "Score": "9",
    "ViewCount": "7110",
    "Body": "<p>I have a spring cloud config server and packaged it as a docker image then I have spring cloud eureka server which is also packaged as docker image.</p>  <p>When I run the two using docker compose I get the following error.</p>  <p><code>discovery-service_1  | 2017-06-24 15:36:12.059  INFO 5 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Fetching config from server at: http://config-service:9001 discovery-service_1  | 2017-06-24 15:36:12.997  WARN 5 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Could not locate PropertySource: I/O error on GET request for 'http://config-service:9001/cls-discovery-service/default': Connection refused (Connection refused); nested exception is java.net.ConnectException: Connection refused (Connection refused) </code></p>  <blockquote>   <p>Although the config service is up and running successfully, discover service still does not find it for some reason.</p> </blockquote>  <p><strong>Docker compose file being used here is this</strong>  <code> version: '2' services:         config-service:                 image: cloudsea/cls-config-service                 ports:                 - 9001:9001                 expose:                 - '9001'         discovery-service:                 image: cloudsea/cls-discovery-service                 depends_on:                 - config-service                 environment:                         CLOUD_SEA_CONFIG_SERVER_URI: http://config-service:9001                         EUREKA_DEFAULT_ZONE_URL: http://discovery-service:8761/eureka/                 ports:                 - 8761:8761                 links:                 - config-service:config-service </code></p>  <p>Below is the <strong>bootstrap.properties</strong> for DISCOVERY SERVICE</p>  <p><code>spring.cloud.config.uri = ${CLOUD_SEA_CONFIG_SERVER_URI:http://localhost:9001} spring.application.name = ${SPRING_APPLICATION_NAME:cls-discovery-service} </code></p>  <p>Below is the <strong>cls-discovery-service.properties</strong> for DISCOVERY SERVICE located in github.</p>  <p><code>server.port=${SERVER_PORT:8761} eureka.client.registerWithEureka: false eureka.client.fetchRegistry: false eureka.client.serviceUrl.defaultZone: ${EUREKA_DEFAULT_ZONE_URL:http://localhost:8761/eureka/} eureka.server.eviction-interval-timer-in-ms: 1000 </code></p>  <p>I am assuming something is wrong with my docker-compose.yml but I am not sure.</p>  <p>Any help will I am stick in this for hours ... heading close to days :(</p> ",
    "OwnerUserId": "3058432",
    "LastActivityDate": "2018-02-06T23:23:47.990",
    "Title": "Spring Cloud Config Server not working with Docker compose",
    "Tags": "<spring-boot><docker-compose><spring-cloud><spring-cloud-netflix><spring-cloud-config>",
    "AnswerCount": "3",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "44738469",
    "PostTypeId": "1",
    "CreationDate": "2017-06-24T16:20:56.010",
    "Score": "9",
    "ViewCount": "7110",
    "Body": "<p>I have a spring cloud config server and packaged it as a docker image then I have spring cloud eureka server which is also packaged as docker image.</p>  <p>When I run the two using docker compose I get the following error.</p>  <p><code>discovery-service_1  | 2017-06-24 15:36:12.059  INFO 5 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Fetching config from server at: http://config-service:9001 discovery-service_1  | 2017-06-24 15:36:12.997  WARN 5 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Could not locate PropertySource: I/O error on GET request for 'http://config-service:9001/cls-discovery-service/default': Connection refused (Connection refused); nested exception is java.net.ConnectException: Connection refused (Connection refused) </code></p>  <blockquote>   <p>Although the config service is up and running successfully, discover service still does not find it for some reason.</p> </blockquote>  <p><strong>Docker compose file being used here is this</strong>  <code> version: '2' services:         config-service:                 image: cloudsea/cls-config-service                 ports:                 - 9001:9001                 expose:                 - '9001'         discovery-service:                 image: cloudsea/cls-discovery-service                 depends_on:                 - config-service                 environment:                         CLOUD_SEA_CONFIG_SERVER_URI: http://config-service:9001                         EUREKA_DEFAULT_ZONE_URL: http://discovery-service:8761/eureka/                 ports:                 - 8761:8761                 links:                 - config-service:config-service </code></p>  <p>Below is the <strong>bootstrap.properties</strong> for DISCOVERY SERVICE</p>  <p><code>spring.cloud.config.uri = ${CLOUD_SEA_CONFIG_SERVER_URI:http://localhost:9001} spring.application.name = ${SPRING_APPLICATION_NAME:cls-discovery-service} </code></p>  <p>Below is the <strong>cls-discovery-service.properties</strong> for DISCOVERY SERVICE located in github.</p>  <p><code>server.port=${SERVER_PORT:8761} eureka.client.registerWithEureka: false eureka.client.fetchRegistry: false eureka.client.serviceUrl.defaultZone: ${EUREKA_DEFAULT_ZONE_URL:http://localhost:8761/eureka/} eureka.server.eviction-interval-timer-in-ms: 1000 </code></p>  <p>I am assuming something is wrong with my docker-compose.yml but I am not sure.</p>  <p>Any help will I am stick in this for hours ... heading close to days :(</p> ",
    "OwnerUserId": "3058432",
    "LastActivityDate": "2018-02-06T23:23:47.990",
    "Title": "Spring Cloud Config Server not working with Docker compose",
    "Tags": "<spring-boot><docker-compose><spring-cloud><spring-cloud-netflix><spring-cloud-config>",
    "AnswerCount": "3",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "44125915",
    "PostTypeId": "1",
    "CreationDate": "2017-05-23T04:38:27.997",
    "Score": "8",
    "ViewCount": "16961",
    "Body": "<p>I have a spring boot application that connects to a mongo db and deployed the app with docker.  I am using this docker-compose.yml file, which works fine:</p>  <pre><code>version: '2' services:   db:       container_name: app-db       image: mongo       volumes:         - /data/db:/data/db       ports:         - 27017:27017   web:     container_name: spring-app     image: spring-app     depends_on:       - db     environment:       SPRING_DATA_MONGODB_URI: mongodb://db:27017/appDB       SPRING_DATA_MONGODB_HOST: db     ports:       - 8080:8080 </code></pre>  <p>Currently, the app is using the application.properties file embedded in the spring app docker image (spring-app).  How do I externalize / pass-in the application.properties file using docker-compose?</p>  <p>Thank you for your help</p> ",
    "OwnerUserId": "107216",
    "LastActivityDate": "2020-07-16T23:38:45.787",
    "Title": "docker-compose - externalize spring application.properties",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "44125915",
    "PostTypeId": "1",
    "CreationDate": "2017-05-23T04:38:27.997",
    "Score": "8",
    "ViewCount": "16961",
    "Body": "<p>I have a spring boot application that connects to a mongo db and deployed the app with docker.  I am using this docker-compose.yml file, which works fine:</p>  <pre><code>version: '2' services:   db:       container_name: app-db       image: mongo       volumes:         - /data/db:/data/db       ports:         - 27017:27017   web:     container_name: spring-app     image: spring-app     depends_on:       - db     environment:       SPRING_DATA_MONGODB_URI: mongodb://db:27017/appDB       SPRING_DATA_MONGODB_HOST: db     ports:       - 8080:8080 </code></pre>  <p>Currently, the app is using the application.properties file embedded in the spring app docker image (spring-app).  How do I externalize / pass-in the application.properties file using docker-compose?</p>  <p>Thank you for your help</p> ",
    "OwnerUserId": "107216",
    "LastActivityDate": "2020-07-16T23:38:45.787",
    "Title": "docker-compose - externalize spring application.properties",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "44125915",
    "PostTypeId": "1",
    "CreationDate": "2017-05-23T04:38:27.997",
    "Score": "8",
    "ViewCount": "16961",
    "Body": "<p>I have a spring boot application that connects to a mongo db and deployed the app with docker.  I am using this docker-compose.yml file, which works fine:</p>  <pre><code>version: '2' services:   db:       container_name: app-db       image: mongo       volumes:         - /data/db:/data/db       ports:         - 27017:27017   web:     container_name: spring-app     image: spring-app     depends_on:       - db     environment:       SPRING_DATA_MONGODB_URI: mongodb://db:27017/appDB       SPRING_DATA_MONGODB_HOST: db     ports:       - 8080:8080 </code></pre>  <p>Currently, the app is using the application.properties file embedded in the spring app docker image (spring-app).  How do I externalize / pass-in the application.properties file using docker-compose?</p>  <p>Thank you for your help</p> ",
    "OwnerUserId": "107216",
    "LastActivityDate": "2020-07-16T23:38:45.787",
    "Title": "docker-compose - externalize spring application.properties",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "44157039",
    "PostTypeId": "1",
    "CreationDate": "2017-05-24T11:26:58.923",
    "Score": "8",
    "ViewCount": "3335",
    "Body": "<p>I want to configure my spring interceptor in such a way that with every request it should get called.</p>  <ul> <li>I am using interceptor in API-GATEWAY <strong>(Spring-Boot)</strong></li> <li>From API-GATEWAY I am calling other microservices.</li> <li>The call's to other microservices from API-GATEWAY is working fine.</li> <li>Other Services which I am calling are Node.js Service, on the other hand, my API-Gateway is in spring boot.</li> <li>All the services (Node.js + Spring-Boot) are running on <strong>Docker Container</strong>.</li> </ul>  <p>I am facing an issue in Interceptor. I want to configure it in such a way that with every request it should be called the <code>preHandle()</code> and perform the operations that I have written in it.</p>  <p>I have notice one issue that I want to mention here.</p>  <p><strong>If the services which I am calling is stopped (Not Running), Interceptor is working properly and giving me a response like somename-service not found. If the same services are running at this time Interceptor is not executed.</strong></p>  <p>Here is my code snippet </p>  <pre><code>@EnableEurekaClient @SpringBootApplication @EnableZuulProxy @Configuration public class Application extends WebMvcConfigurerAdapter {      public static void main(String[] args) {         SpringApplication.run(Application.class, args);     }      @Autowired     private TokenValidateInterceptor tokenValidateInterceptor;      @Override     public void addInterceptors(InterceptorRegistry registry) {          registry.addInterceptor(tokenValidateInterceptor).addPathPatterns('/**');       } </code></pre>  <p>Interceptor </p>  <pre><code>@Component public class TokenValidateInterceptor extends HandlerInterceptorAdapter {       @Override     public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {         LOG.info('#### Starting TokenValidateInterceptor.preHandle ####');          String apiKey = null;         try {             apiKey = request.getHeader('apikey');              LOG.info('The request come with apikey ======' + apiKey);              LOG.info('Actual apikey ======' + azureApikey);   } </code></pre> ",
    "OwnerUserId": "7789526",
    "LastEditorUserId": "7789526",
    "LastEditDate": "2017-05-25T13:38:26.887",
    "LastActivityDate": "2020-08-10T12:15:30.360",
    "Title": "How to configure spring interceptor to get called with every request",
    "Tags": "<java><node.js><docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "44157039",
    "PostTypeId": "1",
    "CreationDate": "2017-05-24T11:26:58.923",
    "Score": "8",
    "ViewCount": "3335",
    "Body": "<p>I want to configure my spring interceptor in such a way that with every request it should get called.</p>  <ul> <li>I am using interceptor in API-GATEWAY <strong>(Spring-Boot)</strong></li> <li>From API-GATEWAY I am calling other microservices.</li> <li>The call's to other microservices from API-GATEWAY is working fine.</li> <li>Other Services which I am calling are Node.js Service, on the other hand, my API-Gateway is in spring boot.</li> <li>All the services (Node.js + Spring-Boot) are running on <strong>Docker Container</strong>.</li> </ul>  <p>I am facing an issue in Interceptor. I want to configure it in such a way that with every request it should be called the <code>preHandle()</code> and perform the operations that I have written in it.</p>  <p>I have notice one issue that I want to mention here.</p>  <p><strong>If the services which I am calling is stopped (Not Running), Interceptor is working properly and giving me a response like somename-service not found. If the same services are running at this time Interceptor is not executed.</strong></p>  <p>Here is my code snippet </p>  <pre><code>@EnableEurekaClient @SpringBootApplication @EnableZuulProxy @Configuration public class Application extends WebMvcConfigurerAdapter {      public static void main(String[] args) {         SpringApplication.run(Application.class, args);     }      @Autowired     private TokenValidateInterceptor tokenValidateInterceptor;      @Override     public void addInterceptors(InterceptorRegistry registry) {          registry.addInterceptor(tokenValidateInterceptor).addPathPatterns('/**');       } </code></pre>  <p>Interceptor </p>  <pre><code>@Component public class TokenValidateInterceptor extends HandlerInterceptorAdapter {       @Override     public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {         LOG.info('#### Starting TokenValidateInterceptor.preHandle ####');          String apiKey = null;         try {             apiKey = request.getHeader('apikey');              LOG.info('The request come with apikey ======' + apiKey);              LOG.info('Actual apikey ======' + azureApikey);   } </code></pre> ",
    "OwnerUserId": "7789526",
    "LastEditorUserId": "7789526",
    "LastEditDate": "2017-05-25T13:38:26.887",
    "LastActivityDate": "2020-08-10T12:15:30.360",
    "Title": "How to configure spring interceptor to get called with every request",
    "Tags": "<java><node.js><docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "44157039",
    "PostTypeId": "1",
    "CreationDate": "2017-05-24T11:26:58.923",
    "Score": "8",
    "ViewCount": "3335",
    "Body": "<p>I want to configure my spring interceptor in such a way that with every request it should get called.</p>  <ul> <li>I am using interceptor in API-GATEWAY <strong>(Spring-Boot)</strong></li> <li>From API-GATEWAY I am calling other microservices.</li> <li>The call's to other microservices from API-GATEWAY is working fine.</li> <li>Other Services which I am calling are Node.js Service, on the other hand, my API-Gateway is in spring boot.</li> <li>All the services (Node.js + Spring-Boot) are running on <strong>Docker Container</strong>.</li> </ul>  <p>I am facing an issue in Interceptor. I want to configure it in such a way that with every request it should be called the <code>preHandle()</code> and perform the operations that I have written in it.</p>  <p>I have notice one issue that I want to mention here.</p>  <p><strong>If the services which I am calling is stopped (Not Running), Interceptor is working properly and giving me a response like somename-service not found. If the same services are running at this time Interceptor is not executed.</strong></p>  <p>Here is my code snippet </p>  <pre><code>@EnableEurekaClient @SpringBootApplication @EnableZuulProxy @Configuration public class Application extends WebMvcConfigurerAdapter {      public static void main(String[] args) {         SpringApplication.run(Application.class, args);     }      @Autowired     private TokenValidateInterceptor tokenValidateInterceptor;      @Override     public void addInterceptors(InterceptorRegistry registry) {          registry.addInterceptor(tokenValidateInterceptor).addPathPatterns('/**');       } </code></pre>  <p>Interceptor </p>  <pre><code>@Component public class TokenValidateInterceptor extends HandlerInterceptorAdapter {       @Override     public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {         LOG.info('#### Starting TokenValidateInterceptor.preHandle ####');          String apiKey = null;         try {             apiKey = request.getHeader('apikey');              LOG.info('The request come with apikey ======' + apiKey);              LOG.info('Actual apikey ======' + azureApikey);   } </code></pre> ",
    "OwnerUserId": "7789526",
    "LastEditorUserId": "7789526",
    "LastEditDate": "2017-05-25T13:38:26.887",
    "LastActivityDate": "2020-08-10T12:15:30.360",
    "Title": "How to configure spring interceptor to get called with every request",
    "Tags": "<java><node.js><docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "47266795",
    "PostTypeId": "1",
    "AcceptedAnswerId": "50781480",
    "CreationDate": "2017-11-13T14:34:43.837",
    "Score": "8",
    "ViewCount": "8110",
    "Body": "<p>I took this example <a href='https://github.com/paulc4/microservices-demo' rel='noreferrer'>https://github.com/paulc4/microservices-demo</a> and I created 3 docker images from it, with the following Dockerfiles:</p>  <p>springdocker-registration:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ADD target/microservice-demo-1.1.0.RELEASE.jar app.jar EXPOSE 1111 ENTRYPOINT exec java -jar /app.jar registration </code></pre>  <p>springdocker-accounts:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ADD target/microservice-demo-1.1.0.RELEASE.jar app.jar EXPOSE 2222 ENTRYPOINT exec java -jar /app.jar accounts </code></pre>  <p>springdocker-web:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ADD target/microservice-demo-1.1.0.RELEASE.jar app.jar EXPOSE 3333 ENTRYPOINT exec java -jar /app.jar web </code></pre>  <p>If I run the three images separately everything works ok, the <code>web</code> and <code>accounts</code> services register to the <code>registration</code> service (which is an implementation of the eureka registry) and I can use my application. However when using <code>docker-compose</code> with the following <code>docker-compose.yml</code> file</p>  <pre><code>version: '3.4' services:  registration:   image: springdocker-registration   ports:    - '1111:1111'   accounts:   image: springdocker-accounts   ports:    - '2222:2222'   links:    - registration   depends_on:    - registration   web:   image: springdocker-web   ports:    - '3333:3333'   depends_on:    - registration    - accounts   links:    - registration </code></pre>  <p>the services <code>web</code> and <code>accounts</code> are not able to register to the <code>registration</code> service. Here are the configuration files for the applications:</p>  <p>registration-server.yml:</p>  <pre><code>eureka:   instance:     hostname: localhost   client:       registerWithEureka: false     fetchRegistry: false     serviceUrl:      defaultZone: http://localhost:1111/eureka/  server:   port: 1111     spring:   thymeleaf:     enabled: false  </code></pre>  <p>accounts-server.yml:</p>  <pre><code>spring:   application:      name: accounts-service     freemarker:     enabled: false              thymeleaf:     cache: false                 prefix: classpath:/accounts-server/templates/      error:   path: /error  server:   port: 2222     eureka:   client:     serviceUrl:       defaultZone: http://localhost:1111/eureka   instance:     leaseRenewalIntervalInSeconds: 5        preferIpAddress: true </code></pre>  <p>web-server.yml</p>  <pre><code>spring:   application:     name: web-service    freemarker:     enabled: false        thymeleaf:     cache: false            prefix: classpath:/web-server/templates/     error:   path: /error  eureka:   client:     serviceUrl:       defaultZone: http://localhost:1111/eureka   instance:     leaseRenewalIntervalInSeconds: 5      preferIpAddress: true  server:   port: 3333   </code></pre>  <p>I can post the full console log of <code>docker-compose up</code> but I think this is the interesting point:</p>  <pre><code>1: ERROR RedirectingEurekaHttpClient - Request execution error com.sun.jersey.api.client.ClientHandlerException: java.net.ConnectException: Connection refused (Connection refused)  1: ERROR DiscoveryClient - DiscoveryClient_WEB-SERVICE/e3b5e6b3396c:web-service:3333 - was unable to refresh its cache! status = Cannot execute request on any known server com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server </code></pre> ",
    "OwnerUserId": "1534252",
    "LastEditorUserId": "1534252",
    "LastEditDate": "2017-11-14T08:36:09.360",
    "LastActivityDate": "2020-05-02T19:12:28.273",
    "Title": "Applications not registering to eureka when using docker-compose",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "47266795",
    "PostTypeId": "1",
    "AcceptedAnswerId": "50781480",
    "CreationDate": "2017-11-13T14:34:43.837",
    "Score": "8",
    "ViewCount": "8110",
    "Body": "<p>I took this example <a href='https://github.com/paulc4/microservices-demo' rel='noreferrer'>https://github.com/paulc4/microservices-demo</a> and I created 3 docker images from it, with the following Dockerfiles:</p>  <p>springdocker-registration:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ADD target/microservice-demo-1.1.0.RELEASE.jar app.jar EXPOSE 1111 ENTRYPOINT exec java -jar /app.jar registration </code></pre>  <p>springdocker-accounts:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ADD target/microservice-demo-1.1.0.RELEASE.jar app.jar EXPOSE 2222 ENTRYPOINT exec java -jar /app.jar accounts </code></pre>  <p>springdocker-web:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ADD target/microservice-demo-1.1.0.RELEASE.jar app.jar EXPOSE 3333 ENTRYPOINT exec java -jar /app.jar web </code></pre>  <p>If I run the three images separately everything works ok, the <code>web</code> and <code>accounts</code> services register to the <code>registration</code> service (which is an implementation of the eureka registry) and I can use my application. However when using <code>docker-compose</code> with the following <code>docker-compose.yml</code> file</p>  <pre><code>version: '3.4' services:  registration:   image: springdocker-registration   ports:    - '1111:1111'   accounts:   image: springdocker-accounts   ports:    - '2222:2222'   links:    - registration   depends_on:    - registration   web:   image: springdocker-web   ports:    - '3333:3333'   depends_on:    - registration    - accounts   links:    - registration </code></pre>  <p>the services <code>web</code> and <code>accounts</code> are not able to register to the <code>registration</code> service. Here are the configuration files for the applications:</p>  <p>registration-server.yml:</p>  <pre><code>eureka:   instance:     hostname: localhost   client:       registerWithEureka: false     fetchRegistry: false     serviceUrl:      defaultZone: http://localhost:1111/eureka/  server:   port: 1111     spring:   thymeleaf:     enabled: false  </code></pre>  <p>accounts-server.yml:</p>  <pre><code>spring:   application:      name: accounts-service     freemarker:     enabled: false              thymeleaf:     cache: false                 prefix: classpath:/accounts-server/templates/      error:   path: /error  server:   port: 2222     eureka:   client:     serviceUrl:       defaultZone: http://localhost:1111/eureka   instance:     leaseRenewalIntervalInSeconds: 5        preferIpAddress: true </code></pre>  <p>web-server.yml</p>  <pre><code>spring:   application:     name: web-service    freemarker:     enabled: false        thymeleaf:     cache: false            prefix: classpath:/web-server/templates/     error:   path: /error  eureka:   client:     serviceUrl:       defaultZone: http://localhost:1111/eureka   instance:     leaseRenewalIntervalInSeconds: 5      preferIpAddress: true  server:   port: 3333   </code></pre>  <p>I can post the full console log of <code>docker-compose up</code> but I think this is the interesting point:</p>  <pre><code>1: ERROR RedirectingEurekaHttpClient - Request execution error com.sun.jersey.api.client.ClientHandlerException: java.net.ConnectException: Connection refused (Connection refused)  1: ERROR DiscoveryClient - DiscoveryClient_WEB-SERVICE/e3b5e6b3396c:web-service:3333 - was unable to refresh its cache! status = Cannot execute request on any known server com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server </code></pre> ",
    "OwnerUserId": "1534252",
    "LastEditorUserId": "1534252",
    "LastEditDate": "2017-11-14T08:36:09.360",
    "LastActivityDate": "2020-05-02T19:12:28.273",
    "Title": "Applications not registering to eureka when using docker-compose",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "47266795",
    "PostTypeId": "1",
    "AcceptedAnswerId": "50781480",
    "CreationDate": "2017-11-13T14:34:43.837",
    "Score": "8",
    "ViewCount": "8110",
    "Body": "<p>I took this example <a href='https://github.com/paulc4/microservices-demo' rel='noreferrer'>https://github.com/paulc4/microservices-demo</a> and I created 3 docker images from it, with the following Dockerfiles:</p>  <p>springdocker-registration:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ADD target/microservice-demo-1.1.0.RELEASE.jar app.jar EXPOSE 1111 ENTRYPOINT exec java -jar /app.jar registration </code></pre>  <p>springdocker-accounts:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ADD target/microservice-demo-1.1.0.RELEASE.jar app.jar EXPOSE 2222 ENTRYPOINT exec java -jar /app.jar accounts </code></pre>  <p>springdocker-web:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ADD target/microservice-demo-1.1.0.RELEASE.jar app.jar EXPOSE 3333 ENTRYPOINT exec java -jar /app.jar web </code></pre>  <p>If I run the three images separately everything works ok, the <code>web</code> and <code>accounts</code> services register to the <code>registration</code> service (which is an implementation of the eureka registry) and I can use my application. However when using <code>docker-compose</code> with the following <code>docker-compose.yml</code> file</p>  <pre><code>version: '3.4' services:  registration:   image: springdocker-registration   ports:    - '1111:1111'   accounts:   image: springdocker-accounts   ports:    - '2222:2222'   links:    - registration   depends_on:    - registration   web:   image: springdocker-web   ports:    - '3333:3333'   depends_on:    - registration    - accounts   links:    - registration </code></pre>  <p>the services <code>web</code> and <code>accounts</code> are not able to register to the <code>registration</code> service. Here are the configuration files for the applications:</p>  <p>registration-server.yml:</p>  <pre><code>eureka:   instance:     hostname: localhost   client:       registerWithEureka: false     fetchRegistry: false     serviceUrl:      defaultZone: http://localhost:1111/eureka/  server:   port: 1111     spring:   thymeleaf:     enabled: false  </code></pre>  <p>accounts-server.yml:</p>  <pre><code>spring:   application:      name: accounts-service     freemarker:     enabled: false              thymeleaf:     cache: false                 prefix: classpath:/accounts-server/templates/      error:   path: /error  server:   port: 2222     eureka:   client:     serviceUrl:       defaultZone: http://localhost:1111/eureka   instance:     leaseRenewalIntervalInSeconds: 5        preferIpAddress: true </code></pre>  <p>web-server.yml</p>  <pre><code>spring:   application:     name: web-service    freemarker:     enabled: false        thymeleaf:     cache: false            prefix: classpath:/web-server/templates/     error:   path: /error  eureka:   client:     serviceUrl:       defaultZone: http://localhost:1111/eureka   instance:     leaseRenewalIntervalInSeconds: 5      preferIpAddress: true  server:   port: 3333   </code></pre>  <p>I can post the full console log of <code>docker-compose up</code> but I think this is the interesting point:</p>  <pre><code>1: ERROR RedirectingEurekaHttpClient - Request execution error com.sun.jersey.api.client.ClientHandlerException: java.net.ConnectException: Connection refused (Connection refused)  1: ERROR DiscoveryClient - DiscoveryClient_WEB-SERVICE/e3b5e6b3396c:web-service:3333 - was unable to refresh its cache! status = Cannot execute request on any known server com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server </code></pre> ",
    "OwnerUserId": "1534252",
    "LastEditorUserId": "1534252",
    "LastEditDate": "2017-11-14T08:36:09.360",
    "LastActivityDate": "2020-05-02T19:12:28.273",
    "Title": "Applications not registering to eureka when using docker-compose",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "48359972",
    "PostTypeId": "1",
    "AcceptedAnswerId": "48360582",
    "CreationDate": "2018-01-20T19:01:14.387",
    "Score": "8",
    "ViewCount": "14597",
    "Body": "<p>I am attempting to build a 'service' consisting of a Spring Boot application and PostgreSQL database. I have been able to access the database (running in a container) from the Spring Boot app while the Spring Boot application was running on my local machine. Now, when I attempt to move the Spring Boot application to a container, I am received the following error:</p>  <pre><code>inventory_1  | 2018-01-20 18:43:06.108 ERROR 1 --- [nio-8080-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.transaction.CannotCreateTransactionException: Could not open JPA EntityManager for transaction; nested exception is org.hibernate.exception.JDBCConnectionException: Unable to acquire JDBC Connection] with root cause inventory_1  | inventory_1  | java.net.ConnectException: Connection refused (Connection refused) </code></pre>  <p>However, I am able to connect to DB from my local machine: <code>psql -h localhost -p 5000 -U kelly_psql -d leisurely_diversion</code></p>  <p>My application.properties file:</p>  <pre><code>spring.jpa.hibernate.ddl-auto=none spring.jpa.show-sql=false spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect spring.datasource.url=jdbc:postgresql://localhost:5432/leisurely_diversion spring.datasource.username=kelly_psql spring.datasource.password=pass spring.datasource.driver-class-name=org.postgresql.Driver </code></pre>  <p>My docker-compose file:</p>  <pre><code>    # Use postgres/example user/password credentials version: '3.2'  services:   db:     image: postgres     ports:       - 5000:5432     environment:       POSTGRES_PASSWORD: example     volumes:       - type: volume         source: psql_data         target: /var/lib/postgresql/data     networks:        - app     restart: always   inventory:     image: kellymarchewa/inventory_api     depends_on:         - db     ports:       - 8080:8080     networks:       - app     restart: always volumes:   psql_data: networks:    app: </code></pre>  <p>My Dockerfile (from the <a href='https://spring.io/guides/gs/spring-boot-docker/' rel='noreferrer'>Spring website</a>)</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ARG JAR_FILE ADD ${JAR_FILE} app.jar ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre>  <p>I suspect the issue lies in a misunderstanding (on my part) of Docker or containers, but I am not sure. Any advice would be appreciated.</p> ",
    "OwnerUserId": "4783710",
    "LastEditorUserId": "2597143",
    "LastEditDate": "2018-01-21T15:35:31.800",
    "LastActivityDate": "2020-09-16T11:15:30.143",
    "Title": "Spring Boot, PostgreSQL, and Docker - Connection Refused whil Running in Container",
    "Tags": "<spring><postgresql><docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "48359972",
    "PostTypeId": "1",
    "AcceptedAnswerId": "48360582",
    "CreationDate": "2018-01-20T19:01:14.387",
    "Score": "8",
    "ViewCount": "14597",
    "Body": "<p>I am attempting to build a 'service' consisting of a Spring Boot application and PostgreSQL database. I have been able to access the database (running in a container) from the Spring Boot app while the Spring Boot application was running on my local machine. Now, when I attempt to move the Spring Boot application to a container, I am received the following error:</p>  <pre><code>inventory_1  | 2018-01-20 18:43:06.108 ERROR 1 --- [nio-8080-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.transaction.CannotCreateTransactionException: Could not open JPA EntityManager for transaction; nested exception is org.hibernate.exception.JDBCConnectionException: Unable to acquire JDBC Connection] with root cause inventory_1  | inventory_1  | java.net.ConnectException: Connection refused (Connection refused) </code></pre>  <p>However, I am able to connect to DB from my local machine: <code>psql -h localhost -p 5000 -U kelly_psql -d leisurely_diversion</code></p>  <p>My application.properties file:</p>  <pre><code>spring.jpa.hibernate.ddl-auto=none spring.jpa.show-sql=false spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect spring.datasource.url=jdbc:postgresql://localhost:5432/leisurely_diversion spring.datasource.username=kelly_psql spring.datasource.password=pass spring.datasource.driver-class-name=org.postgresql.Driver </code></pre>  <p>My docker-compose file:</p>  <pre><code>    # Use postgres/example user/password credentials version: '3.2'  services:   db:     image: postgres     ports:       - 5000:5432     environment:       POSTGRES_PASSWORD: example     volumes:       - type: volume         source: psql_data         target: /var/lib/postgresql/data     networks:        - app     restart: always   inventory:     image: kellymarchewa/inventory_api     depends_on:         - db     ports:       - 8080:8080     networks:       - app     restart: always volumes:   psql_data: networks:    app: </code></pre>  <p>My Dockerfile (from the <a href='https://spring.io/guides/gs/spring-boot-docker/' rel='noreferrer'>Spring website</a>)</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ARG JAR_FILE ADD ${JAR_FILE} app.jar ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre>  <p>I suspect the issue lies in a misunderstanding (on my part) of Docker or containers, but I am not sure. Any advice would be appreciated.</p> ",
    "OwnerUserId": "4783710",
    "LastEditorUserId": "2597143",
    "LastEditDate": "2018-01-21T15:35:31.800",
    "LastActivityDate": "2020-09-16T11:15:30.143",
    "Title": "Spring Boot, PostgreSQL, and Docker - Connection Refused whil Running in Container",
    "Tags": "<spring><postgresql><docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "48359972",
    "PostTypeId": "1",
    "AcceptedAnswerId": "48360582",
    "CreationDate": "2018-01-20T19:01:14.387",
    "Score": "8",
    "ViewCount": "14597",
    "Body": "<p>I am attempting to build a 'service' consisting of a Spring Boot application and PostgreSQL database. I have been able to access the database (running in a container) from the Spring Boot app while the Spring Boot application was running on my local machine. Now, when I attempt to move the Spring Boot application to a container, I am received the following error:</p>  <pre><code>inventory_1  | 2018-01-20 18:43:06.108 ERROR 1 --- [nio-8080-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.transaction.CannotCreateTransactionException: Could not open JPA EntityManager for transaction; nested exception is org.hibernate.exception.JDBCConnectionException: Unable to acquire JDBC Connection] with root cause inventory_1  | inventory_1  | java.net.ConnectException: Connection refused (Connection refused) </code></pre>  <p>However, I am able to connect to DB from my local machine: <code>psql -h localhost -p 5000 -U kelly_psql -d leisurely_diversion</code></p>  <p>My application.properties file:</p>  <pre><code>spring.jpa.hibernate.ddl-auto=none spring.jpa.show-sql=false spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect spring.datasource.url=jdbc:postgresql://localhost:5432/leisurely_diversion spring.datasource.username=kelly_psql spring.datasource.password=pass spring.datasource.driver-class-name=org.postgresql.Driver </code></pre>  <p>My docker-compose file:</p>  <pre><code>    # Use postgres/example user/password credentials version: '3.2'  services:   db:     image: postgres     ports:       - 5000:5432     environment:       POSTGRES_PASSWORD: example     volumes:       - type: volume         source: psql_data         target: /var/lib/postgresql/data     networks:        - app     restart: always   inventory:     image: kellymarchewa/inventory_api     depends_on:         - db     ports:       - 8080:8080     networks:       - app     restart: always volumes:   psql_data: networks:    app: </code></pre>  <p>My Dockerfile (from the <a href='https://spring.io/guides/gs/spring-boot-docker/' rel='noreferrer'>Spring website</a>)</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ARG JAR_FILE ADD ${JAR_FILE} app.jar ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre>  <p>I suspect the issue lies in a misunderstanding (on my part) of Docker or containers, but I am not sure. Any advice would be appreciated.</p> ",
    "OwnerUserId": "4783710",
    "LastEditorUserId": "2597143",
    "LastEditDate": "2018-01-21T15:35:31.800",
    "LastActivityDate": "2020-09-16T11:15:30.143",
    "Title": "Spring Boot, PostgreSQL, and Docker - Connection Refused whil Running in Container",
    "Tags": "<spring><postgresql><docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "50216280",
    "PostTypeId": "1",
    "AcceptedAnswerId": "50222583",
    "CreationDate": "2018-05-07T14:09:25.160",
    "Score": "8",
    "ViewCount": "62148",
    "Body": "<p>The docker container is not able to access the jar file, that is being accessed over the mount point <code>/my/project/dir</code>. I am certain it is not a permission issue, because I changed the access rights locally, so it should be able to read/write/execute it.</p>  <p>This is the <code>Dockerfile</code>:</p>  <pre><code>FROM tomcat:9-jre8 RUN apt-get update &amp;&amp; apt-get install librrds-perl rrdtool -y VOLUME ['/data/rrdtool', '/my/project/dir'] ENTRYPOINT [ 'java','-jar','/my/project/dir/build/libs/spring-project-0.1.0.jar' ] </code></pre>  <p>And this is the <code>docker-compose.yml</code> file:</p>  <pre><code>version: '2' services:  db:    container_name: db1    image: mysql:8    restart: always    environment:      MYSQL_ROOT_PASSWORD: password123      MYSQL_USER: user123      MYSQL_PASSWORD: pasw      MYSQL_DATABASE: mydb    expose:      - '3307'  db2:    container_name: db2    image: mysql:8    restart: always    environment:      MYSQL_ROOT_PASSWORD: password123      MYSQL_USER: user123      MYSQL_PASSWORD: pasw      MYSQL_DATABASE: mydb2    expose:      - '3308'  spring:    container_name: spring-boot-project    build:       context: ./      dockerfile: Dockerfile    links:      - db:db1      - db2:db2    depends_on:      - db      - db2    expose:      - '8081'    ports:      - '8081:8081'    restart: always </code></pre>  <p>This is the output from <code>docker-compose logs spring</code>:</p>  <pre><code>Error: Unable to access jarfile /my/project/dir/build/libs/spring-project-0.1.0.jar </code></pre> ",
    "OwnerUserId": "5703530",
    "LastEditorUserId": "5703530",
    "LastEditDate": "2018-05-07T18:25:15.080",
    "LastActivityDate": "2022-09-12T12:19:49.007",
    "Title": "Docker unable to access jar file",
    "Tags": "<java><docker><spring-boot><jar><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "4",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "50216280",
    "PostTypeId": "1",
    "AcceptedAnswerId": "50222583",
    "CreationDate": "2018-05-07T14:09:25.160",
    "Score": "8",
    "ViewCount": "62148",
    "Body": "<p>The docker container is not able to access the jar file, that is being accessed over the mount point <code>/my/project/dir</code>. I am certain it is not a permission issue, because I changed the access rights locally, so it should be able to read/write/execute it.</p>  <p>This is the <code>Dockerfile</code>:</p>  <pre><code>FROM tomcat:9-jre8 RUN apt-get update &amp;&amp; apt-get install librrds-perl rrdtool -y VOLUME ['/data/rrdtool', '/my/project/dir'] ENTRYPOINT [ 'java','-jar','/my/project/dir/build/libs/spring-project-0.1.0.jar' ] </code></pre>  <p>And this is the <code>docker-compose.yml</code> file:</p>  <pre><code>version: '2' services:  db:    container_name: db1    image: mysql:8    restart: always    environment:      MYSQL_ROOT_PASSWORD: password123      MYSQL_USER: user123      MYSQL_PASSWORD: pasw      MYSQL_DATABASE: mydb    expose:      - '3307'  db2:    container_name: db2    image: mysql:8    restart: always    environment:      MYSQL_ROOT_PASSWORD: password123      MYSQL_USER: user123      MYSQL_PASSWORD: pasw      MYSQL_DATABASE: mydb2    expose:      - '3308'  spring:    container_name: spring-boot-project    build:       context: ./      dockerfile: Dockerfile    links:      - db:db1      - db2:db2    depends_on:      - db      - db2    expose:      - '8081'    ports:      - '8081:8081'    restart: always </code></pre>  <p>This is the output from <code>docker-compose logs spring</code>:</p>  <pre><code>Error: Unable to access jarfile /my/project/dir/build/libs/spring-project-0.1.0.jar </code></pre> ",
    "OwnerUserId": "5703530",
    "LastEditorUserId": "5703530",
    "LastEditDate": "2018-05-07T18:25:15.080",
    "LastActivityDate": "2022-09-12T12:19:49.007",
    "Title": "Docker unable to access jar file",
    "Tags": "<java><docker><spring-boot><jar><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "4",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "50216280",
    "PostTypeId": "1",
    "AcceptedAnswerId": "50222583",
    "CreationDate": "2018-05-07T14:09:25.160",
    "Score": "8",
    "ViewCount": "62148",
    "Body": "<p>The docker container is not able to access the jar file, that is being accessed over the mount point <code>/my/project/dir</code>. I am certain it is not a permission issue, because I changed the access rights locally, so it should be able to read/write/execute it.</p>  <p>This is the <code>Dockerfile</code>:</p>  <pre><code>FROM tomcat:9-jre8 RUN apt-get update &amp;&amp; apt-get install librrds-perl rrdtool -y VOLUME ['/data/rrdtool', '/my/project/dir'] ENTRYPOINT [ 'java','-jar','/my/project/dir/build/libs/spring-project-0.1.0.jar' ] </code></pre>  <p>And this is the <code>docker-compose.yml</code> file:</p>  <pre><code>version: '2' services:  db:    container_name: db1    image: mysql:8    restart: always    environment:      MYSQL_ROOT_PASSWORD: password123      MYSQL_USER: user123      MYSQL_PASSWORD: pasw      MYSQL_DATABASE: mydb    expose:      - '3307'  db2:    container_name: db2    image: mysql:8    restart: always    environment:      MYSQL_ROOT_PASSWORD: password123      MYSQL_USER: user123      MYSQL_PASSWORD: pasw      MYSQL_DATABASE: mydb2    expose:      - '3308'  spring:    container_name: spring-boot-project    build:       context: ./      dockerfile: Dockerfile    links:      - db:db1      - db2:db2    depends_on:      - db      - db2    expose:      - '8081'    ports:      - '8081:8081'    restart: always </code></pre>  <p>This is the output from <code>docker-compose logs spring</code>:</p>  <pre><code>Error: Unable to access jarfile /my/project/dir/build/libs/spring-project-0.1.0.jar </code></pre> ",
    "OwnerUserId": "5703530",
    "LastEditorUserId": "5703530",
    "LastEditDate": "2018-05-07T18:25:15.080",
    "LastActivityDate": "2022-09-12T12:19:49.007",
    "Title": "Docker unable to access jar file",
    "Tags": "<java><docker><spring-boot><jar><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "4",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "53407287",
    "PostTypeId": "1",
    "CreationDate": "2018-11-21T07:39:54.870",
    "Score": "8",
    "ViewCount": "18758",
    "Body": "<p>I have a spring boot project which I'd like to containerize using docker. I have a couple of spring boot applications which connect to same MySql server.</p>  <p>My spring applications requires the database to be completely setup (i.e. all the tables to be created and some data to be inserted in some of the tables) in order to start.</p>  <p>I am using <strong>Docker</strong> version <strong>18.09.0</strong> and <strong>docker-compose</strong> version <strong>1.23.1</strong> and ubuntu <strong>16.04</strong> LTS</p>  <hr>  <p>I have two files <strong><code>create.sql</code></strong> and <strong><code>insert.sql</code></strong>, which I use to initialise the database to be used by the application.</p>  <p>I create the images using the command <strong><code>docker-compose.yml</code></strong> and it runs successfully and creates the images.</p>  <p>I have the following questions.</p>  <ol> <li><p>I assume when using docker-compose, a container starts as soon as all its dependent containers have started. Is there a way to wait for the mysql server to be up and ready to accept connections, before my API container gets started?</p></li> <li><p>If I chose to create containers separately for the applications and mysql, and not use docker-compose, how do I make sure that my applications connect to the mysql container?</p></li> <li><p>Is there any other tool which might help me achieve this?</p></li> </ol>  <p><strong>Note:</strong> I have tried to use <strong><code>docker inspect &lt;container_id&gt;</code></strong> to find the the IpAddress for the mysql container and use it to connect, but it doesn't work as well.</p>  <hr>  <p>The following are the files I am using to create images.</p>  <p><strong><code>docker-compose.yml</code></strong> file.</p>  <pre><code>version: '3'  services:   demo-mysql:     image: demo-mysql     build: ./demo-mysql     volumes:       - /mnt/data/mysql-data:/var/lib/mysql     ports:       - 3306:3306     environment:       - MYSQL_ROOT_PASSWORD=root       - MYSQL_DATABASE=demo       - MYSQL_PASSWORD=root    demo-api:     image: demo-api-1.0     build: ./api     depends_on:       - demo-mysql     ports:       - 8080:8080     environment:       - DATABASE_HOST=demo-mysql       - DATABASE_USER=root       - DATABASE_PASSWORD=root       - DATABASE_NAME=demo       - DATABASE_PORT=3306    demo1-app:     image: demo1-app-1.0     build: ./demo1     depends_on:       - demo-mysql     ports:       - 8090:8090     environment:       - DATABASE_HOST=demo-mysql       - DATABASE_USER=root       - DATABASE_PASSWORD=root       - DATABASE_NAME=demo       - DATABASE_PORT=3306 </code></pre>  <p>The following is the <strong><code>Dockerfile</code></strong> for the spring boot project</p>  <pre><code>FROM java:8  VOLUME /tmp  ARG DATA_PATH=/src/main/resources ARG APP_PORT=8080  EXPOSE ${APP_PORT}  ADD /build/libs/demo-api.jar demo-api.jar  ENTRYPOINT ['java','-jar','demo-api.jar'] </code></pre>  <p>The following is the <strong><code>Dockerfile</code></strong> I used to create my mysql image</p>  <pre><code>FROM mysql:5.7  ENV MYSQL_DATABASE=demo \\     MYSQL_USER=root \\     MYSQL_ROOT_PASSWORD=root  ADD ./1.0/create.sql /docker-entrypoint-initdb.d ADD ./1.0/insert.sql /docker-entrypoint-initdb.d  EXPOSE 3306 </code></pre> ",
    "OwnerUserId": "5788945",
    "LastActivityDate": "2023-10-15T19:43:52.260",
    "Title": "Docker compose wait for database service initialisation",
    "Tags": "<mysql><spring-boot><docker><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "53407287",
    "PostTypeId": "1",
    "CreationDate": "2018-11-21T07:39:54.870",
    "Score": "8",
    "ViewCount": "18758",
    "Body": "<p>I have a spring boot project which I'd like to containerize using docker. I have a couple of spring boot applications which connect to same MySql server.</p>  <p>My spring applications requires the database to be completely setup (i.e. all the tables to be created and some data to be inserted in some of the tables) in order to start.</p>  <p>I am using <strong>Docker</strong> version <strong>18.09.0</strong> and <strong>docker-compose</strong> version <strong>1.23.1</strong> and ubuntu <strong>16.04</strong> LTS</p>  <hr>  <p>I have two files <strong><code>create.sql</code></strong> and <strong><code>insert.sql</code></strong>, which I use to initialise the database to be used by the application.</p>  <p>I create the images using the command <strong><code>docker-compose.yml</code></strong> and it runs successfully and creates the images.</p>  <p>I have the following questions.</p>  <ol> <li><p>I assume when using docker-compose, a container starts as soon as all its dependent containers have started. Is there a way to wait for the mysql server to be up and ready to accept connections, before my API container gets started?</p></li> <li><p>If I chose to create containers separately for the applications and mysql, and not use docker-compose, how do I make sure that my applications connect to the mysql container?</p></li> <li><p>Is there any other tool which might help me achieve this?</p></li> </ol>  <p><strong>Note:</strong> I have tried to use <strong><code>docker inspect &lt;container_id&gt;</code></strong> to find the the IpAddress for the mysql container and use it to connect, but it doesn't work as well.</p>  <hr>  <p>The following are the files I am using to create images.</p>  <p><strong><code>docker-compose.yml</code></strong> file.</p>  <pre><code>version: '3'  services:   demo-mysql:     image: demo-mysql     build: ./demo-mysql     volumes:       - /mnt/data/mysql-data:/var/lib/mysql     ports:       - 3306:3306     environment:       - MYSQL_ROOT_PASSWORD=root       - MYSQL_DATABASE=demo       - MYSQL_PASSWORD=root    demo-api:     image: demo-api-1.0     build: ./api     depends_on:       - demo-mysql     ports:       - 8080:8080     environment:       - DATABASE_HOST=demo-mysql       - DATABASE_USER=root       - DATABASE_PASSWORD=root       - DATABASE_NAME=demo       - DATABASE_PORT=3306    demo1-app:     image: demo1-app-1.0     build: ./demo1     depends_on:       - demo-mysql     ports:       - 8090:8090     environment:       - DATABASE_HOST=demo-mysql       - DATABASE_USER=root       - DATABASE_PASSWORD=root       - DATABASE_NAME=demo       - DATABASE_PORT=3306 </code></pre>  <p>The following is the <strong><code>Dockerfile</code></strong> for the spring boot project</p>  <pre><code>FROM java:8  VOLUME /tmp  ARG DATA_PATH=/src/main/resources ARG APP_PORT=8080  EXPOSE ${APP_PORT}  ADD /build/libs/demo-api.jar demo-api.jar  ENTRYPOINT ['java','-jar','demo-api.jar'] </code></pre>  <p>The following is the <strong><code>Dockerfile</code></strong> I used to create my mysql image</p>  <pre><code>FROM mysql:5.7  ENV MYSQL_DATABASE=demo \\     MYSQL_USER=root \\     MYSQL_ROOT_PASSWORD=root  ADD ./1.0/create.sql /docker-entrypoint-initdb.d ADD ./1.0/insert.sql /docker-entrypoint-initdb.d  EXPOSE 3306 </code></pre> ",
    "OwnerUserId": "5788945",
    "LastActivityDate": "2023-10-15T19:43:52.260",
    "Title": "Docker compose wait for database service initialisation",
    "Tags": "<mysql><spring-boot><docker><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "53407287",
    "PostTypeId": "1",
    "CreationDate": "2018-11-21T07:39:54.870",
    "Score": "8",
    "ViewCount": "18758",
    "Body": "<p>I have a spring boot project which I'd like to containerize using docker. I have a couple of spring boot applications which connect to same MySql server.</p>  <p>My spring applications requires the database to be completely setup (i.e. all the tables to be created and some data to be inserted in some of the tables) in order to start.</p>  <p>I am using <strong>Docker</strong> version <strong>18.09.0</strong> and <strong>docker-compose</strong> version <strong>1.23.1</strong> and ubuntu <strong>16.04</strong> LTS</p>  <hr>  <p>I have two files <strong><code>create.sql</code></strong> and <strong><code>insert.sql</code></strong>, which I use to initialise the database to be used by the application.</p>  <p>I create the images using the command <strong><code>docker-compose.yml</code></strong> and it runs successfully and creates the images.</p>  <p>I have the following questions.</p>  <ol> <li><p>I assume when using docker-compose, a container starts as soon as all its dependent containers have started. Is there a way to wait for the mysql server to be up and ready to accept connections, before my API container gets started?</p></li> <li><p>If I chose to create containers separately for the applications and mysql, and not use docker-compose, how do I make sure that my applications connect to the mysql container?</p></li> <li><p>Is there any other tool which might help me achieve this?</p></li> </ol>  <p><strong>Note:</strong> I have tried to use <strong><code>docker inspect &lt;container_id&gt;</code></strong> to find the the IpAddress for the mysql container and use it to connect, but it doesn't work as well.</p>  <hr>  <p>The following are the files I am using to create images.</p>  <p><strong><code>docker-compose.yml</code></strong> file.</p>  <pre><code>version: '3'  services:   demo-mysql:     image: demo-mysql     build: ./demo-mysql     volumes:       - /mnt/data/mysql-data:/var/lib/mysql     ports:       - 3306:3306     environment:       - MYSQL_ROOT_PASSWORD=root       - MYSQL_DATABASE=demo       - MYSQL_PASSWORD=root    demo-api:     image: demo-api-1.0     build: ./api     depends_on:       - demo-mysql     ports:       - 8080:8080     environment:       - DATABASE_HOST=demo-mysql       - DATABASE_USER=root       - DATABASE_PASSWORD=root       - DATABASE_NAME=demo       - DATABASE_PORT=3306    demo1-app:     image: demo1-app-1.0     build: ./demo1     depends_on:       - demo-mysql     ports:       - 8090:8090     environment:       - DATABASE_HOST=demo-mysql       - DATABASE_USER=root       - DATABASE_PASSWORD=root       - DATABASE_NAME=demo       - DATABASE_PORT=3306 </code></pre>  <p>The following is the <strong><code>Dockerfile</code></strong> for the spring boot project</p>  <pre><code>FROM java:8  VOLUME /tmp  ARG DATA_PATH=/src/main/resources ARG APP_PORT=8080  EXPOSE ${APP_PORT}  ADD /build/libs/demo-api.jar demo-api.jar  ENTRYPOINT ['java','-jar','demo-api.jar'] </code></pre>  <p>The following is the <strong><code>Dockerfile</code></strong> I used to create my mysql image</p>  <pre><code>FROM mysql:5.7  ENV MYSQL_DATABASE=demo \\     MYSQL_USER=root \\     MYSQL_ROOT_PASSWORD=root  ADD ./1.0/create.sql /docker-entrypoint-initdb.d ADD ./1.0/insert.sql /docker-entrypoint-initdb.d  EXPOSE 3306 </code></pre> ",
    "OwnerUserId": "5788945",
    "LastActivityDate": "2023-10-15T19:43:52.260",
    "Title": "Docker compose wait for database service initialisation",
    "Tags": "<mysql><spring-boot><docker><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "56441497",
    "PostTypeId": "1",
    "AcceptedAnswerId": "56441664",
    "CreationDate": "2019-06-04T09:52:04.153",
    "Score": "8",
    "ViewCount": "19487",
    "Body": "<p>What I'm trying to do is, connect from my spring-boot app to mysql database in Docker. Each in their own container.</p>  <p>But I must be having something wrong because I can't do it.</p>  <p><strong>To keep it simple :</strong></p>  <p>application-properties :</p>  <pre><code># URL for the mysql db spring.datasource.url=jdbc:mysql://workaround-mysql:3308/workaround?serverTimezone=UTC&amp;max_allowed_packet=15728640 # User name in mysql spring.datasource.username=springuser # Password for mysql spring.datasource.password=admin #Port at which application runs server.port=8080 </code></pre>  <p>docker-compose for MySQL:</p>  <pre><code>version: '3' services:   workaround-mysql:     container_name: workaround-mysql     image: mysql     environment:       MYSQL_DATABASE: workaround       MYSQL_USER: springuser       MYSQL_PASSWORD: admin       MYSQL_ROOT_PASSWORD: admin       MYSQL_ROOT_HOST: '%'     ports:       - '3308:3306'     restart: always </code></pre>  <p>So pretty simple right ? Database I start with <code>docker-compose up</code>:</p>  <p><a href='https://i.stack.imgur.com/NKfvA.png' rel='noreferrer'><img src='https://i.stack.imgur.com/NKfvA.png' alt='enter image description here'></a></p>  <p>All seems to be working fine so far.</p>  <p>Now that I have db started, to the application, this is its <code>docker-compose.yml</code>:</p>  <pre><code>version: '3' services:    workaround:     restart: always     # will build ./docker/workaround/Dockerfile     build: ./docker/workaround     working_dir: /workaround     volumes:       - ./:/workaround       - ~/.m2:/root/.m2     expose:       - '8080'     command: 'mvn clean spring-boot:run' </code></pre>  <p>For its <code>Dockerfile</code> I use Linux Alpine and Java.</p>  <pre><code>FROM alpine:3.9 ....add java... RUN apk update RUN apk add dos2unix --update-cache --repository http://dl-3.alpinelinux.org/alpine/edge/community/ --allow-untrusted RUN apk add bash RUN apk add maven </code></pre>  <p>Super simple. Now let's start the application :</p>  <p><a href='https://i.stack.imgur.com/VFGe0.png' rel='noreferrer'><img src='https://i.stack.imgur.com/VFGe0.png' alt='enter image description here'></a></p>  <p><a href='https://i.stack.imgur.com/WEpR6.png' rel='noreferrer'><img src='https://i.stack.imgur.com/WEpR6.png' alt='enter image description here'></a></p>  <p><a href='https://i.stack.imgur.com/w6o93.png' rel='noreferrer'><img src='https://i.stack.imgur.com/w6o93.png' alt='enter image description here'></a></p>  <p>Unknown host, so let's try the IP then :</p>  <pre><code>    docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' workaround-mysql  # URL for the mysql db spring.datasource.url=jdbc:mysql://172.20.0.2:3308/workaround?serverTimezone=UTC&amp;max_allowed_packet=15728640 </code></pre>  <p>Now I get timeout:</p>  <p><a href='https://i.stack.imgur.com/AOtVs.png' rel='noreferrer'><img src='https://i.stack.imgur.com/AOtVs.png' alt='enter image description here'></a></p>  <p>As you can see I get error. What is wrong with my setup and how to fix this? Either I have unknown host exception or Refused to connect or connection timeout.</p>  <p>I have tried:</p>  <ul> <li>Using ip of a container in my application.properties, didn't work</li> <li>Different ports for MySQL and application </li> <li>Different images and versions of MySQL </li> <li>Having everything in one docker compose with wait</li> <li>timer for database.</li> <li>Minimal setup with <a href='https://github.com/hellokoding/hellokoding-courses/tree/master/docker-examples/dockercompose-springboot-mysql-nginx' rel='noreferrer'>https://github.com/hellokoding/hellokoding-courses/tree/master/docker-examples/dockercompose-springboot-mysql-nginx</a> Also resulted in communication link failure, Site was accessible but I doubt that db was connected properly.</li> </ul>  <p><strong>Notes</strong>: </p>  <ul> <li><p>I run this all on one computer I use port 3308 because I have local MySQL db at 3306.</p></li> <li><p>Here is <code>docker ps -a</code></p></li> </ul>  <p><a href='https://i.stack.imgur.com/z7YJK.png' rel='noreferrer'><img src='https://i.stack.imgur.com/z7YJK.png' alt='enter image description here'></a></p>  <p>@Vusal ANSWER output :</p>  <p><a href='https://i.stack.imgur.com/EIUFN.png' rel='noreferrer'><img src='https://i.stack.imgur.com/EIUFN.png' alt='enter image description here'></a></p>  <p>Only thing different from code in answer I did wait for database to be ready 30 seconds</p>  <pre><code>command: /bin/bash -c 'sleep 30;mvn clean spring-boot:run;' </code></pre> ",
    "OwnerUserId": "2733333",
    "LastEditorUserId": "472495",
    "LastEditDate": "2019-06-04T21:39:08.083",
    "LastActivityDate": "2020-07-19T06:01:40.877",
    "Title": "Docker MySQL - can't connect from Spring Boot app to MySQL database",
    "Tags": "<mysql><spring><spring-boot><docker><docker-compose>",
    "AnswerCount": "4",
    "CommentCount": "7",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "56441497",
    "PostTypeId": "1",
    "AcceptedAnswerId": "56441664",
    "CreationDate": "2019-06-04T09:52:04.153",
    "Score": "8",
    "ViewCount": "19487",
    "Body": "<p>What I'm trying to do is, connect from my spring-boot app to mysql database in Docker. Each in their own container.</p>  <p>But I must be having something wrong because I can't do it.</p>  <p><strong>To keep it simple :</strong></p>  <p>application-properties :</p>  <pre><code># URL for the mysql db spring.datasource.url=jdbc:mysql://workaround-mysql:3308/workaround?serverTimezone=UTC&amp;max_allowed_packet=15728640 # User name in mysql spring.datasource.username=springuser # Password for mysql spring.datasource.password=admin #Port at which application runs server.port=8080 </code></pre>  <p>docker-compose for MySQL:</p>  <pre><code>version: '3' services:   workaround-mysql:     container_name: workaround-mysql     image: mysql     environment:       MYSQL_DATABASE: workaround       MYSQL_USER: springuser       MYSQL_PASSWORD: admin       MYSQL_ROOT_PASSWORD: admin       MYSQL_ROOT_HOST: '%'     ports:       - '3308:3306'     restart: always </code></pre>  <p>So pretty simple right ? Database I start with <code>docker-compose up</code>:</p>  <p><a href='https://i.stack.imgur.com/NKfvA.png' rel='noreferrer'><img src='https://i.stack.imgur.com/NKfvA.png' alt='enter image description here'></a></p>  <p>All seems to be working fine so far.</p>  <p>Now that I have db started, to the application, this is its <code>docker-compose.yml</code>:</p>  <pre><code>version: '3' services:    workaround:     restart: always     # will build ./docker/workaround/Dockerfile     build: ./docker/workaround     working_dir: /workaround     volumes:       - ./:/workaround       - ~/.m2:/root/.m2     expose:       - '8080'     command: 'mvn clean spring-boot:run' </code></pre>  <p>For its <code>Dockerfile</code> I use Linux Alpine and Java.</p>  <pre><code>FROM alpine:3.9 ....add java... RUN apk update RUN apk add dos2unix --update-cache --repository http://dl-3.alpinelinux.org/alpine/edge/community/ --allow-untrusted RUN apk add bash RUN apk add maven </code></pre>  <p>Super simple. Now let's start the application :</p>  <p><a href='https://i.stack.imgur.com/VFGe0.png' rel='noreferrer'><img src='https://i.stack.imgur.com/VFGe0.png' alt='enter image description here'></a></p>  <p><a href='https://i.stack.imgur.com/WEpR6.png' rel='noreferrer'><img src='https://i.stack.imgur.com/WEpR6.png' alt='enter image description here'></a></p>  <p><a href='https://i.stack.imgur.com/w6o93.png' rel='noreferrer'><img src='https://i.stack.imgur.com/w6o93.png' alt='enter image description here'></a></p>  <p>Unknown host, so let's try the IP then :</p>  <pre><code>    docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' workaround-mysql  # URL for the mysql db spring.datasource.url=jdbc:mysql://172.20.0.2:3308/workaround?serverTimezone=UTC&amp;max_allowed_packet=15728640 </code></pre>  <p>Now I get timeout:</p>  <p><a href='https://i.stack.imgur.com/AOtVs.png' rel='noreferrer'><img src='https://i.stack.imgur.com/AOtVs.png' alt='enter image description here'></a></p>  <p>As you can see I get error. What is wrong with my setup and how to fix this? Either I have unknown host exception or Refused to connect or connection timeout.</p>  <p>I have tried:</p>  <ul> <li>Using ip of a container in my application.properties, didn't work</li> <li>Different ports for MySQL and application </li> <li>Different images and versions of MySQL </li> <li>Having everything in one docker compose with wait</li> <li>timer for database.</li> <li>Minimal setup with <a href='https://github.com/hellokoding/hellokoding-courses/tree/master/docker-examples/dockercompose-springboot-mysql-nginx' rel='noreferrer'>https://github.com/hellokoding/hellokoding-courses/tree/master/docker-examples/dockercompose-springboot-mysql-nginx</a> Also resulted in communication link failure, Site was accessible but I doubt that db was connected properly.</li> </ul>  <p><strong>Notes</strong>: </p>  <ul> <li><p>I run this all on one computer I use port 3308 because I have local MySQL db at 3306.</p></li> <li><p>Here is <code>docker ps -a</code></p></li> </ul>  <p><a href='https://i.stack.imgur.com/z7YJK.png' rel='noreferrer'><img src='https://i.stack.imgur.com/z7YJK.png' alt='enter image description here'></a></p>  <p>@Vusal ANSWER output :</p>  <p><a href='https://i.stack.imgur.com/EIUFN.png' rel='noreferrer'><img src='https://i.stack.imgur.com/EIUFN.png' alt='enter image description here'></a></p>  <p>Only thing different from code in answer I did wait for database to be ready 30 seconds</p>  <pre><code>command: /bin/bash -c 'sleep 30;mvn clean spring-boot:run;' </code></pre> ",
    "OwnerUserId": "2733333",
    "LastEditorUserId": "472495",
    "LastEditDate": "2019-06-04T21:39:08.083",
    "LastActivityDate": "2020-07-19T06:01:40.877",
    "Title": "Docker MySQL - can't connect from Spring Boot app to MySQL database",
    "Tags": "<mysql><spring><spring-boot><docker><docker-compose>",
    "AnswerCount": "4",
    "CommentCount": "7",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "56441497",
    "PostTypeId": "1",
    "AcceptedAnswerId": "56441664",
    "CreationDate": "2019-06-04T09:52:04.153",
    "Score": "8",
    "ViewCount": "19487",
    "Body": "<p>What I'm trying to do is, connect from my spring-boot app to mysql database in Docker. Each in their own container.</p>  <p>But I must be having something wrong because I can't do it.</p>  <p><strong>To keep it simple :</strong></p>  <p>application-properties :</p>  <pre><code># URL for the mysql db spring.datasource.url=jdbc:mysql://workaround-mysql:3308/workaround?serverTimezone=UTC&amp;max_allowed_packet=15728640 # User name in mysql spring.datasource.username=springuser # Password for mysql spring.datasource.password=admin #Port at which application runs server.port=8080 </code></pre>  <p>docker-compose for MySQL:</p>  <pre><code>version: '3' services:   workaround-mysql:     container_name: workaround-mysql     image: mysql     environment:       MYSQL_DATABASE: workaround       MYSQL_USER: springuser       MYSQL_PASSWORD: admin       MYSQL_ROOT_PASSWORD: admin       MYSQL_ROOT_HOST: '%'     ports:       - '3308:3306'     restart: always </code></pre>  <p>So pretty simple right ? Database I start with <code>docker-compose up</code>:</p>  <p><a href='https://i.stack.imgur.com/NKfvA.png' rel='noreferrer'><img src='https://i.stack.imgur.com/NKfvA.png' alt='enter image description here'></a></p>  <p>All seems to be working fine so far.</p>  <p>Now that I have db started, to the application, this is its <code>docker-compose.yml</code>:</p>  <pre><code>version: '3' services:    workaround:     restart: always     # will build ./docker/workaround/Dockerfile     build: ./docker/workaround     working_dir: /workaround     volumes:       - ./:/workaround       - ~/.m2:/root/.m2     expose:       - '8080'     command: 'mvn clean spring-boot:run' </code></pre>  <p>For its <code>Dockerfile</code> I use Linux Alpine and Java.</p>  <pre><code>FROM alpine:3.9 ....add java... RUN apk update RUN apk add dos2unix --update-cache --repository http://dl-3.alpinelinux.org/alpine/edge/community/ --allow-untrusted RUN apk add bash RUN apk add maven </code></pre>  <p>Super simple. Now let's start the application :</p>  <p><a href='https://i.stack.imgur.com/VFGe0.png' rel='noreferrer'><img src='https://i.stack.imgur.com/VFGe0.png' alt='enter image description here'></a></p>  <p><a href='https://i.stack.imgur.com/WEpR6.png' rel='noreferrer'><img src='https://i.stack.imgur.com/WEpR6.png' alt='enter image description here'></a></p>  <p><a href='https://i.stack.imgur.com/w6o93.png' rel='noreferrer'><img src='https://i.stack.imgur.com/w6o93.png' alt='enter image description here'></a></p>  <p>Unknown host, so let's try the IP then :</p>  <pre><code>    docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' workaround-mysql  # URL for the mysql db spring.datasource.url=jdbc:mysql://172.20.0.2:3308/workaround?serverTimezone=UTC&amp;max_allowed_packet=15728640 </code></pre>  <p>Now I get timeout:</p>  <p><a href='https://i.stack.imgur.com/AOtVs.png' rel='noreferrer'><img src='https://i.stack.imgur.com/AOtVs.png' alt='enter image description here'></a></p>  <p>As you can see I get error. What is wrong with my setup and how to fix this? Either I have unknown host exception or Refused to connect or connection timeout.</p>  <p>I have tried:</p>  <ul> <li>Using ip of a container in my application.properties, didn't work</li> <li>Different ports for MySQL and application </li> <li>Different images and versions of MySQL </li> <li>Having everything in one docker compose with wait</li> <li>timer for database.</li> <li>Minimal setup with <a href='https://github.com/hellokoding/hellokoding-courses/tree/master/docker-examples/dockercompose-springboot-mysql-nginx' rel='noreferrer'>https://github.com/hellokoding/hellokoding-courses/tree/master/docker-examples/dockercompose-springboot-mysql-nginx</a> Also resulted in communication link failure, Site was accessible but I doubt that db was connected properly.</li> </ul>  <p><strong>Notes</strong>: </p>  <ul> <li><p>I run this all on one computer I use port 3308 because I have local MySQL db at 3306.</p></li> <li><p>Here is <code>docker ps -a</code></p></li> </ul>  <p><a href='https://i.stack.imgur.com/z7YJK.png' rel='noreferrer'><img src='https://i.stack.imgur.com/z7YJK.png' alt='enter image description here'></a></p>  <p>@Vusal ANSWER output :</p>  <p><a href='https://i.stack.imgur.com/EIUFN.png' rel='noreferrer'><img src='https://i.stack.imgur.com/EIUFN.png' alt='enter image description here'></a></p>  <p>Only thing different from code in answer I did wait for database to be ready 30 seconds</p>  <pre><code>command: /bin/bash -c 'sleep 30;mvn clean spring-boot:run;' </code></pre> ",
    "OwnerUserId": "2733333",
    "LastEditorUserId": "472495",
    "LastEditDate": "2019-06-04T21:39:08.083",
    "LastActivityDate": "2020-07-19T06:01:40.877",
    "Title": "Docker MySQL - can't connect from Spring Boot app to MySQL database",
    "Tags": "<mysql><spring><spring-boot><docker><docker-compose>",
    "AnswerCount": "4",
    "CommentCount": "7",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "56938511",
    "PostTypeId": "1",
    "CreationDate": "2019-07-08T15:50:21.217",
    "Score": "8",
    "ViewCount": "7029",
    "Body": "<p>I have a Spring Boot Application and developed it with a mongo db which was running in brew services. </p>  <p>To get a connection to the db I just had to put the following into application.properties in Spring Boot </p>  <pre><code>spring.data.mongodb.uri=mongodb://localhost:27017/db </code></pre>  <p>changing the application properties to </p>  <pre><code>spring.data.mongodb.uri=mongodb://mongo:27017/db </code></pre>  <p>didtn't change anything, same Error as before.</p>  <p>Now I'm trying to put the SpringBoot Application and the MongoDB into Docker-Containers, but cant get any connection working.</p>  <p>So this is my Dockerfile in the SpringBoot Application:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp EXPOSE 8080 ADD /build/libs/dg-0.0.1-SNAPSHOT.jar dg-0.0.1-SNAPSHOT.jar ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/dg-0.0.1-SNAPSHOT.jar'] </code></pre>  <p>This is my Docker-Compose.yml file:</p>  <pre><code>version: '3'  services:  mongo:  container_name: docker-mongo  image: mongo:latest  ports:    - '27017:27017'  volumes:   - ./data/db:/data/db  spring:  depends_on:    - mongo  image:    docker-spring-http-alpine  ports:    - '8080:8080'  links:    - mongo </code></pre>  <p>After executing Docker-Compose with </p>  <pre><code>docker-compose up </code></pre>  <p>I get the following error: (this is the actual error message )</p>  <pre><code>2019-07-08 23:10:19.990  INFO 1 --- [localhost:27017] org.mongodb.driver.cluster: Exception in monitor thread while connecting to server localhost:27017       com.mongodb.MongoSocketOpenException: Exception opening socket at com.mongodb.internal.connection.SocketStream.open(SocketStream.java:67) ~[mongodb-driver-core-3.8.2.jar!/:na] at com.mongodb.internal.connection.InternalStreamConnection.open(InternalStreamConnection.java:126) ~[mongodb-driver-core-3.8.2.jar!/:na] at com.mongodb.internal.connection.DefaultServerMonitor$ServerMonitorRunnable.run(DefaultServerMonitor.java:117) ~[mongodb-driver-core-3.8.2.jar!/:na] at java.lang.Thread.run(Thread.java:748) [na:1.8.0_212] Caused by: java.net.ConnectException: Connection refused (Connection refused) at java.net.PlainSocketImpl.socketConnect(Native Method) ~[na:1.8.0_212] at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350) ~[na:1.8.0_212] at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206) ~[na:1.8.0_212] at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188) ~[na:1.8.0_212] at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392) ~[na:1.8.0_212] at java.net.Socket.connect(Socket.java:589) ~[na:1.8.0_212] at com.mongodb.internal.connection.SocketStreamHelper.initialize(SocketStreamHelper.java:64) ~[mongodb-driver-core-3.8.2.jar!/:na] at com.mongodb.internal.connection.SocketStream.open(SocketStream.java:62) ~[mongodb-driver-core-3.8.2.jar!/:na] ... 3 common frames omitted </code></pre>  <p>Does someone know whats the problem here? In development environment it works like a charm.</p>  <p>Thanks in advance</p>  <p>Adding the following line to the Dockerfile </p>  <pre><code>'-Dspring.data.mongodb.uri=mongodb://mongo:27017/dg' </code></pre>  <p>into Entrypoint like this solved the connection issue</p>  <pre><code>ENTRYPOINT ['java', '-Dspring.data.mongodb.uri=mongodb://mongo:27017/dg','-Djava.security.egd=file:/dev/./urandom','-jar','/dg-0.0.1-SNAPSHOT.jar'] </code></pre>  <p>I was able to get connection to the db without the mentioned line above in the Entrypoint in the Dockerfile. I guess this is if you like to connect your db over 'links'</p>  <p>But now I was able to connect over Network, this is my code:</p>  <pre><code>version: '3.6'  services:   mongo:  container_name: docker_mongo  networks:    - gateway  ports:    - '27017:27017'  hostname: mongo  image: mongo:latest  volumes:    - ./data/db:/data/db   spring:  container_name: docker-spring  networks:    - gateway  ports:    - '8080:8080'  hostname: spring  depends_on:    - mongo  image: dg-docker-spring-http-alpine-j  networks: gateway: driver: 'bridge' </code></pre>  <p>and the following in application properties</p>  <pre><code>spring.data.mongodb.host=docker_mongo spring.data.mongodb.port=27017 spring.data.mongodb.database=db </code></pre>  <p>So it looks like the connection is working over Network now. The same code did not work with Version 3.0</p>  <p>To prevent SpringBoot to connect automatically to mongo over localhost it's also necessary to exclude MongoAutoConfiguration!</p>  <pre><code>@SpringBootApplication(exclude={MongoAutoConfiguration.class}) </code></pre>  <p>Thank you all for your help</p> ",
    "OwnerUserId": "4461271",
    "LastEditorUserId": "4461271",
    "LastEditDate": "2019-07-12T13:51:34.053",
    "LastActivityDate": "2019-07-12T13:51:34.053",
    "Title": "SpringBoot in Docker not connecting to Mongo in Docker",
    "Tags": "<mongodb><spring-boot><docker><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "56938511",
    "PostTypeId": "1",
    "CreationDate": "2019-07-08T15:50:21.217",
    "Score": "8",
    "ViewCount": "7029",
    "Body": "<p>I have a Spring Boot Application and developed it with a mongo db which was running in brew services. </p>  <p>To get a connection to the db I just had to put the following into application.properties in Spring Boot </p>  <pre><code>spring.data.mongodb.uri=mongodb://localhost:27017/db </code></pre>  <p>changing the application properties to </p>  <pre><code>spring.data.mongodb.uri=mongodb://mongo:27017/db </code></pre>  <p>didtn't change anything, same Error as before.</p>  <p>Now I'm trying to put the SpringBoot Application and the MongoDB into Docker-Containers, but cant get any connection working.</p>  <p>So this is my Dockerfile in the SpringBoot Application:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp EXPOSE 8080 ADD /build/libs/dg-0.0.1-SNAPSHOT.jar dg-0.0.1-SNAPSHOT.jar ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/dg-0.0.1-SNAPSHOT.jar'] </code></pre>  <p>This is my Docker-Compose.yml file:</p>  <pre><code>version: '3'  services:  mongo:  container_name: docker-mongo  image: mongo:latest  ports:    - '27017:27017'  volumes:   - ./data/db:/data/db  spring:  depends_on:    - mongo  image:    docker-spring-http-alpine  ports:    - '8080:8080'  links:    - mongo </code></pre>  <p>After executing Docker-Compose with </p>  <pre><code>docker-compose up </code></pre>  <p>I get the following error: (this is the actual error message )</p>  <pre><code>2019-07-08 23:10:19.990  INFO 1 --- [localhost:27017] org.mongodb.driver.cluster: Exception in monitor thread while connecting to server localhost:27017       com.mongodb.MongoSocketOpenException: Exception opening socket at com.mongodb.internal.connection.SocketStream.open(SocketStream.java:67) ~[mongodb-driver-core-3.8.2.jar!/:na] at com.mongodb.internal.connection.InternalStreamConnection.open(InternalStreamConnection.java:126) ~[mongodb-driver-core-3.8.2.jar!/:na] at com.mongodb.internal.connection.DefaultServerMonitor$ServerMonitorRunnable.run(DefaultServerMonitor.java:117) ~[mongodb-driver-core-3.8.2.jar!/:na] at java.lang.Thread.run(Thread.java:748) [na:1.8.0_212] Caused by: java.net.ConnectException: Connection refused (Connection refused) at java.net.PlainSocketImpl.socketConnect(Native Method) ~[na:1.8.0_212] at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350) ~[na:1.8.0_212] at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206) ~[na:1.8.0_212] at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188) ~[na:1.8.0_212] at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392) ~[na:1.8.0_212] at java.net.Socket.connect(Socket.java:589) ~[na:1.8.0_212] at com.mongodb.internal.connection.SocketStreamHelper.initialize(SocketStreamHelper.java:64) ~[mongodb-driver-core-3.8.2.jar!/:na] at com.mongodb.internal.connection.SocketStream.open(SocketStream.java:62) ~[mongodb-driver-core-3.8.2.jar!/:na] ... 3 common frames omitted </code></pre>  <p>Does someone know whats the problem here? In development environment it works like a charm.</p>  <p>Thanks in advance</p>  <p>Adding the following line to the Dockerfile </p>  <pre><code>'-Dspring.data.mongodb.uri=mongodb://mongo:27017/dg' </code></pre>  <p>into Entrypoint like this solved the connection issue</p>  <pre><code>ENTRYPOINT ['java', '-Dspring.data.mongodb.uri=mongodb://mongo:27017/dg','-Djava.security.egd=file:/dev/./urandom','-jar','/dg-0.0.1-SNAPSHOT.jar'] </code></pre>  <p>I was able to get connection to the db without the mentioned line above in the Entrypoint in the Dockerfile. I guess this is if you like to connect your db over 'links'</p>  <p>But now I was able to connect over Network, this is my code:</p>  <pre><code>version: '3.6'  services:   mongo:  container_name: docker_mongo  networks:    - gateway  ports:    - '27017:27017'  hostname: mongo  image: mongo:latest  volumes:    - ./data/db:/data/db   spring:  container_name: docker-spring  networks:    - gateway  ports:    - '8080:8080'  hostname: spring  depends_on:    - mongo  image: dg-docker-spring-http-alpine-j  networks: gateway: driver: 'bridge' </code></pre>  <p>and the following in application properties</p>  <pre><code>spring.data.mongodb.host=docker_mongo spring.data.mongodb.port=27017 spring.data.mongodb.database=db </code></pre>  <p>So it looks like the connection is working over Network now. The same code did not work with Version 3.0</p>  <p>To prevent SpringBoot to connect automatically to mongo over localhost it's also necessary to exclude MongoAutoConfiguration!</p>  <pre><code>@SpringBootApplication(exclude={MongoAutoConfiguration.class}) </code></pre>  <p>Thank you all for your help</p> ",
    "OwnerUserId": "4461271",
    "LastEditorUserId": "4461271",
    "LastEditDate": "2019-07-12T13:51:34.053",
    "LastActivityDate": "2019-07-12T13:51:34.053",
    "Title": "SpringBoot in Docker not connecting to Mongo in Docker",
    "Tags": "<mongodb><spring-boot><docker><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "56938511",
    "PostTypeId": "1",
    "CreationDate": "2019-07-08T15:50:21.217",
    "Score": "8",
    "ViewCount": "7029",
    "Body": "<p>I have a Spring Boot Application and developed it with a mongo db which was running in brew services. </p>  <p>To get a connection to the db I just had to put the following into application.properties in Spring Boot </p>  <pre><code>spring.data.mongodb.uri=mongodb://localhost:27017/db </code></pre>  <p>changing the application properties to </p>  <pre><code>spring.data.mongodb.uri=mongodb://mongo:27017/db </code></pre>  <p>didtn't change anything, same Error as before.</p>  <p>Now I'm trying to put the SpringBoot Application and the MongoDB into Docker-Containers, but cant get any connection working.</p>  <p>So this is my Dockerfile in the SpringBoot Application:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp EXPOSE 8080 ADD /build/libs/dg-0.0.1-SNAPSHOT.jar dg-0.0.1-SNAPSHOT.jar ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/dg-0.0.1-SNAPSHOT.jar'] </code></pre>  <p>This is my Docker-Compose.yml file:</p>  <pre><code>version: '3'  services:  mongo:  container_name: docker-mongo  image: mongo:latest  ports:    - '27017:27017'  volumes:   - ./data/db:/data/db  spring:  depends_on:    - mongo  image:    docker-spring-http-alpine  ports:    - '8080:8080'  links:    - mongo </code></pre>  <p>After executing Docker-Compose with </p>  <pre><code>docker-compose up </code></pre>  <p>I get the following error: (this is the actual error message )</p>  <pre><code>2019-07-08 23:10:19.990  INFO 1 --- [localhost:27017] org.mongodb.driver.cluster: Exception in monitor thread while connecting to server localhost:27017       com.mongodb.MongoSocketOpenException: Exception opening socket at com.mongodb.internal.connection.SocketStream.open(SocketStream.java:67) ~[mongodb-driver-core-3.8.2.jar!/:na] at com.mongodb.internal.connection.InternalStreamConnection.open(InternalStreamConnection.java:126) ~[mongodb-driver-core-3.8.2.jar!/:na] at com.mongodb.internal.connection.DefaultServerMonitor$ServerMonitorRunnable.run(DefaultServerMonitor.java:117) ~[mongodb-driver-core-3.8.2.jar!/:na] at java.lang.Thread.run(Thread.java:748) [na:1.8.0_212] Caused by: java.net.ConnectException: Connection refused (Connection refused) at java.net.PlainSocketImpl.socketConnect(Native Method) ~[na:1.8.0_212] at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350) ~[na:1.8.0_212] at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206) ~[na:1.8.0_212] at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188) ~[na:1.8.0_212] at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392) ~[na:1.8.0_212] at java.net.Socket.connect(Socket.java:589) ~[na:1.8.0_212] at com.mongodb.internal.connection.SocketStreamHelper.initialize(SocketStreamHelper.java:64) ~[mongodb-driver-core-3.8.2.jar!/:na] at com.mongodb.internal.connection.SocketStream.open(SocketStream.java:62) ~[mongodb-driver-core-3.8.2.jar!/:na] ... 3 common frames omitted </code></pre>  <p>Does someone know whats the problem here? In development environment it works like a charm.</p>  <p>Thanks in advance</p>  <p>Adding the following line to the Dockerfile </p>  <pre><code>'-Dspring.data.mongodb.uri=mongodb://mongo:27017/dg' </code></pre>  <p>into Entrypoint like this solved the connection issue</p>  <pre><code>ENTRYPOINT ['java', '-Dspring.data.mongodb.uri=mongodb://mongo:27017/dg','-Djava.security.egd=file:/dev/./urandom','-jar','/dg-0.0.1-SNAPSHOT.jar'] </code></pre>  <p>I was able to get connection to the db without the mentioned line above in the Entrypoint in the Dockerfile. I guess this is if you like to connect your db over 'links'</p>  <p>But now I was able to connect over Network, this is my code:</p>  <pre><code>version: '3.6'  services:   mongo:  container_name: docker_mongo  networks:    - gateway  ports:    - '27017:27017'  hostname: mongo  image: mongo:latest  volumes:    - ./data/db:/data/db   spring:  container_name: docker-spring  networks:    - gateway  ports:    - '8080:8080'  hostname: spring  depends_on:    - mongo  image: dg-docker-spring-http-alpine-j  networks: gateway: driver: 'bridge' </code></pre>  <p>and the following in application properties</p>  <pre><code>spring.data.mongodb.host=docker_mongo spring.data.mongodb.port=27017 spring.data.mongodb.database=db </code></pre>  <p>So it looks like the connection is working over Network now. The same code did not work with Version 3.0</p>  <p>To prevent SpringBoot to connect automatically to mongo over localhost it's also necessary to exclude MongoAutoConfiguration!</p>  <pre><code>@SpringBootApplication(exclude={MongoAutoConfiguration.class}) </code></pre>  <p>Thank you all for your help</p> ",
    "OwnerUserId": "4461271",
    "LastEditorUserId": "4461271",
    "LastEditDate": "2019-07-12T13:51:34.053",
    "LastActivityDate": "2019-07-12T13:51:34.053",
    "Title": "SpringBoot in Docker not connecting to Mongo in Docker",
    "Tags": "<mongodb><spring-boot><docker><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "33660966",
    "PostTypeId": "1",
    "CreationDate": "2015-11-11T22:22:02.403",
    "Score": "7",
    "ViewCount": "1925",
    "Body": "<p>We've three Spring Boot applications:</p>  <ul> <li>Eureka Service</li> <li>Config Server</li> <li>Simple Web Service making use of Eureka and Config Server</li> </ul>  <p>I've set up the services so that we use a Eureka First Discovery, i.e. the simple web application finds out about the config server from the eureka service. </p>  <p>When started separately (either locally or by starting them as individual docker images) everything is ok, i.e. start config server after discovery service is running, and the Simple web service is started once the config server is running.</p>  <p>When docker-compose is used to start the services, they obviously start at the same time and essentially race to get up and running. This isn't an issue as we've added failFast: true and retry values to the simple web service and also have the docker container restarting so that the simple web service will eventually restart at a time when the discovery service and config server are both running but this doesn't feel optimal. </p>  <p>The unexpected behaviour we noticed was the following:</p>  <ul> <li>The simple web service reattempts a number of times to connect to the discovery service. This is sensible and expected</li> <li>At the same time the simple web service attempts to contact the config server. Because it cannot contact the discovery service, it retries to connect to a config server on localhost, e.g. logs show retries going to <a href='http://localhost:8888' rel='noreferrer'>http://localhost:8888</a>. This wasn't expected.</li> <li>The simple web service will eventually successfully connect to the discovery service but the logs show it stills tries to establish communication to the config server by going to <a href='http://localhost:8888' rel='noreferrer'>http://localhost:8888</a>. Again, this wasn't ideal.</li> </ul>  <p>Three questions/observations:</p>  <ul> <li>Is it a sensible strategy for the config client to fall back to trying localhost:8888 when it has been configured to use discovery to find the config server?</li> <li>When the eureka connections is established, should the retry mechanism not now switch to trying the config server endpoint as indicated by Eureka? Essentially putting in higher/longer retry intervals and periods for the config server connection is pointless in this case as it's never going to connect to it if it's looking at localhost so we're better just failing fast.</li> <li>Are there any properties that can override this behaviour?</li> </ul>  <p>I've created a sample github repo that demonstrates this behaviour:</p>  <p><a href='https://github.com/KramKroc/eurekafirstdiscovery/' rel='noreferrer'>https://github.com/KramKroc/eurekafirstdiscovery/tree/master</a></p> ",
    "OwnerUserId": "530846",
    "LastEditorUserId": "530846",
    "LastEditDate": "2015-11-12T15:51:39.393",
    "LastActivityDate": "2015-11-12T15:51:39.393",
    "Title": "Eureka First Discovery & Config Client Retry with Docker Compose",
    "Tags": "<spring-boot><spring-cloud><docker-compose><netflix-eureka>",
    "AnswerCount": "0",
    "CommentCount": "5",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "33660966",
    "PostTypeId": "1",
    "CreationDate": "2015-11-11T22:22:02.403",
    "Score": "7",
    "ViewCount": "1925",
    "Body": "<p>We've three Spring Boot applications:</p>  <ul> <li>Eureka Service</li> <li>Config Server</li> <li>Simple Web Service making use of Eureka and Config Server</li> </ul>  <p>I've set up the services so that we use a Eureka First Discovery, i.e. the simple web application finds out about the config server from the eureka service. </p>  <p>When started separately (either locally or by starting them as individual docker images) everything is ok, i.e. start config server after discovery service is running, and the Simple web service is started once the config server is running.</p>  <p>When docker-compose is used to start the services, they obviously start at the same time and essentially race to get up and running. This isn't an issue as we've added failFast: true and retry values to the simple web service and also have the docker container restarting so that the simple web service will eventually restart at a time when the discovery service and config server are both running but this doesn't feel optimal. </p>  <p>The unexpected behaviour we noticed was the following:</p>  <ul> <li>The simple web service reattempts a number of times to connect to the discovery service. This is sensible and expected</li> <li>At the same time the simple web service attempts to contact the config server. Because it cannot contact the discovery service, it retries to connect to a config server on localhost, e.g. logs show retries going to <a href='http://localhost:8888' rel='noreferrer'>http://localhost:8888</a>. This wasn't expected.</li> <li>The simple web service will eventually successfully connect to the discovery service but the logs show it stills tries to establish communication to the config server by going to <a href='http://localhost:8888' rel='noreferrer'>http://localhost:8888</a>. Again, this wasn't ideal.</li> </ul>  <p>Three questions/observations:</p>  <ul> <li>Is it a sensible strategy for the config client to fall back to trying localhost:8888 when it has been configured to use discovery to find the config server?</li> <li>When the eureka connections is established, should the retry mechanism not now switch to trying the config server endpoint as indicated by Eureka? Essentially putting in higher/longer retry intervals and periods for the config server connection is pointless in this case as it's never going to connect to it if it's looking at localhost so we're better just failing fast.</li> <li>Are there any properties that can override this behaviour?</li> </ul>  <p>I've created a sample github repo that demonstrates this behaviour:</p>  <p><a href='https://github.com/KramKroc/eurekafirstdiscovery/' rel='noreferrer'>https://github.com/KramKroc/eurekafirstdiscovery/tree/master</a></p> ",
    "OwnerUserId": "530846",
    "LastEditorUserId": "530846",
    "LastEditDate": "2015-11-12T15:51:39.393",
    "LastActivityDate": "2015-11-12T15:51:39.393",
    "Title": "Eureka First Discovery & Config Client Retry with Docker Compose",
    "Tags": "<spring-boot><spring-cloud><docker-compose><netflix-eureka>",
    "AnswerCount": "0",
    "CommentCount": "5",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "33660966",
    "PostTypeId": "1",
    "CreationDate": "2015-11-11T22:22:02.403",
    "Score": "7",
    "ViewCount": "1925",
    "Body": "<p>We've three Spring Boot applications:</p>  <ul> <li>Eureka Service</li> <li>Config Server</li> <li>Simple Web Service making use of Eureka and Config Server</li> </ul>  <p>I've set up the services so that we use a Eureka First Discovery, i.e. the simple web application finds out about the config server from the eureka service. </p>  <p>When started separately (either locally or by starting them as individual docker images) everything is ok, i.e. start config server after discovery service is running, and the Simple web service is started once the config server is running.</p>  <p>When docker-compose is used to start the services, they obviously start at the same time and essentially race to get up and running. This isn't an issue as we've added failFast: true and retry values to the simple web service and also have the docker container restarting so that the simple web service will eventually restart at a time when the discovery service and config server are both running but this doesn't feel optimal. </p>  <p>The unexpected behaviour we noticed was the following:</p>  <ul> <li>The simple web service reattempts a number of times to connect to the discovery service. This is sensible and expected</li> <li>At the same time the simple web service attempts to contact the config server. Because it cannot contact the discovery service, it retries to connect to a config server on localhost, e.g. logs show retries going to <a href='http://localhost:8888' rel='noreferrer'>http://localhost:8888</a>. This wasn't expected.</li> <li>The simple web service will eventually successfully connect to the discovery service but the logs show it stills tries to establish communication to the config server by going to <a href='http://localhost:8888' rel='noreferrer'>http://localhost:8888</a>. Again, this wasn't ideal.</li> </ul>  <p>Three questions/observations:</p>  <ul> <li>Is it a sensible strategy for the config client to fall back to trying localhost:8888 when it has been configured to use discovery to find the config server?</li> <li>When the eureka connections is established, should the retry mechanism not now switch to trying the config server endpoint as indicated by Eureka? Essentially putting in higher/longer retry intervals and periods for the config server connection is pointless in this case as it's never going to connect to it if it's looking at localhost so we're better just failing fast.</li> <li>Are there any properties that can override this behaviour?</li> </ul>  <p>I've created a sample github repo that demonstrates this behaviour:</p>  <p><a href='https://github.com/KramKroc/eurekafirstdiscovery/' rel='noreferrer'>https://github.com/KramKroc/eurekafirstdiscovery/tree/master</a></p> ",
    "OwnerUserId": "530846",
    "LastEditorUserId": "530846",
    "LastEditDate": "2015-11-12T15:51:39.393",
    "LastActivityDate": "2015-11-12T15:51:39.393",
    "Title": "Eureka First Discovery & Config Client Retry with Docker Compose",
    "Tags": "<spring-boot><spring-cloud><docker-compose><netflix-eureka>",
    "AnswerCount": "0",
    "CommentCount": "5",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "37490324",
    "PostTypeId": "1",
    "AcceptedAnswerId": "37490325",
    "CreationDate": "2016-05-27T18:40:07.273",
    "Score": "7",
    "ViewCount": "8961",
    "Body": "<p>I've got a Spring Boot application implementing a service which I want to run in a Docker container. I've followed the guideline of the official <a href='https://spring.io/guides/gs/spring-boot-docker/' rel='nofollow noreferrer'>Spring docs</a> which suggest to create a DockerFile similar to this:</p>  <pre><code>FROM frolvlad/alpine-oraclejdk8:slim VOLUME /tmp ADD gs-spring-boot-docker-0.1.0.jar app.jar RUN sh -c 'touch /app.jar' ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre>  <p>Then once the image is pushed to Docker I use <a href='https://docs.docker.com/compose/' rel='nofollow noreferrer'>Docker Compose</a> to launch it this way:</p>  <pre><code>  spring-boot-docker:     ports:     - '80:80'     expose:     - '80'     image: my-repo/spring-boot-docker:0.1.0-SNAPSHOT     container_name: spring-boot-docker     environment:       JAVA_OPTS: '-Xmx64m' </code></pre>  <p>Here I've got the <code>JAVA_OPTS</code> variable which limits the memory allocation, however, when I execute <code>docker stats spring-boot-docker</code>, the memory taken by the container is excessive (I understand the total memory taken by the JVM might be much more than 64M, but in this case is totally boundless).</p>  <p>I've also tried with the <a href='https://stackoverflow.com/questions/28837544/can-i-use-mem-limit-in-docker-compose-and-how'><code>mem_limit</code> param</a>, but this slows down the application noticeably.</p> ",
    "OwnerUserId": "1199132",
    "LastEditorUserId": "-1",
    "LastEditDate": "2017-05-23T12:02:31.193",
    "LastActivityDate": "2016-05-29T07:48:44.820",
    "Title": "Limit JVM memory consumption in a Docker container",
    "Tags": "<java><docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "37490324",
    "PostTypeId": "1",
    "AcceptedAnswerId": "37490325",
    "CreationDate": "2016-05-27T18:40:07.273",
    "Score": "7",
    "ViewCount": "8961",
    "Body": "<p>I've got a Spring Boot application implementing a service which I want to run in a Docker container. I've followed the guideline of the official <a href='https://spring.io/guides/gs/spring-boot-docker/' rel='nofollow noreferrer'>Spring docs</a> which suggest to create a DockerFile similar to this:</p>  <pre><code>FROM frolvlad/alpine-oraclejdk8:slim VOLUME /tmp ADD gs-spring-boot-docker-0.1.0.jar app.jar RUN sh -c 'touch /app.jar' ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre>  <p>Then once the image is pushed to Docker I use <a href='https://docs.docker.com/compose/' rel='nofollow noreferrer'>Docker Compose</a> to launch it this way:</p>  <pre><code>  spring-boot-docker:     ports:     - '80:80'     expose:     - '80'     image: my-repo/spring-boot-docker:0.1.0-SNAPSHOT     container_name: spring-boot-docker     environment:       JAVA_OPTS: '-Xmx64m' </code></pre>  <p>Here I've got the <code>JAVA_OPTS</code> variable which limits the memory allocation, however, when I execute <code>docker stats spring-boot-docker</code>, the memory taken by the container is excessive (I understand the total memory taken by the JVM might be much more than 64M, but in this case is totally boundless).</p>  <p>I've also tried with the <a href='https://stackoverflow.com/questions/28837544/can-i-use-mem-limit-in-docker-compose-and-how'><code>mem_limit</code> param</a>, but this slows down the application noticeably.</p> ",
    "OwnerUserId": "1199132",
    "LastEditorUserId": "-1",
    "LastEditDate": "2017-05-23T12:02:31.193",
    "LastActivityDate": "2016-05-29T07:48:44.820",
    "Title": "Limit JVM memory consumption in a Docker container",
    "Tags": "<java><docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "37490324",
    "PostTypeId": "1",
    "AcceptedAnswerId": "37490325",
    "CreationDate": "2016-05-27T18:40:07.273",
    "Score": "7",
    "ViewCount": "8961",
    "Body": "<p>I've got a Spring Boot application implementing a service which I want to run in a Docker container. I've followed the guideline of the official <a href='https://spring.io/guides/gs/spring-boot-docker/' rel='nofollow noreferrer'>Spring docs</a> which suggest to create a DockerFile similar to this:</p>  <pre><code>FROM frolvlad/alpine-oraclejdk8:slim VOLUME /tmp ADD gs-spring-boot-docker-0.1.0.jar app.jar RUN sh -c 'touch /app.jar' ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre>  <p>Then once the image is pushed to Docker I use <a href='https://docs.docker.com/compose/' rel='nofollow noreferrer'>Docker Compose</a> to launch it this way:</p>  <pre><code>  spring-boot-docker:     ports:     - '80:80'     expose:     - '80'     image: my-repo/spring-boot-docker:0.1.0-SNAPSHOT     container_name: spring-boot-docker     environment:       JAVA_OPTS: '-Xmx64m' </code></pre>  <p>Here I've got the <code>JAVA_OPTS</code> variable which limits the memory allocation, however, when I execute <code>docker stats spring-boot-docker</code>, the memory taken by the container is excessive (I understand the total memory taken by the JVM might be much more than 64M, but in this case is totally boundless).</p>  <p>I've also tried with the <a href='https://stackoverflow.com/questions/28837544/can-i-use-mem-limit-in-docker-compose-and-how'><code>mem_limit</code> param</a>, but this slows down the application noticeably.</p> ",
    "OwnerUserId": "1199132",
    "LastEditorUserId": "-1",
    "LastEditDate": "2017-05-23T12:02:31.193",
    "LastActivityDate": "2016-05-29T07:48:44.820",
    "Title": "Limit JVM memory consumption in a Docker container",
    "Tags": "<java><docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "42175951",
    "PostTypeId": "1",
    "AcceptedAnswerId": "42175990",
    "CreationDate": "2017-02-11T12:38:20.267",
    "Score": "7",
    "ViewCount": "16754",
    "Body": "<p>I am setting up a Spring application to run using compose. The application needs to establish a connection to ActiveMQ either running locally for developers or to existing instances for staging/production.</p>  <p>I setup the following which is working great for local dev:</p>  <pre><code>amq:     image: rmohr/activemq:latest     ports:       - '61616:61616'       - '8161:8161' legacy-bridge:     image:  myco/myservice     links:       - amq </code></pre>  <p>and in the application configuration I am declaring the AMQ connection as </p>  <pre><code>broker-url=tcp://amq:61616 </code></pre>  <p>Running docker-compose up is working great, activeMQ is fired up locally and my application constiner starts and connects to it.</p>  <p>Now I need to set this up for staging/production where the ActiveMQ instances are running on existing hardware within the infrastructure. My thoughts are to either use spring profiles to handle a different configurations in which case the application configuration entry for 'broker-url=tcp://amq:61616' would become something like <code>broker-url=tcp://some.host.here:61616</code> or find some way to create a dns entry within my production docker-compose.yml which will point an <code>amq</code> dns entry to the associated staging or production queues.</p>  <p>What is the best approach here and if it is DNS, how to I set that up in compose?</p>  <p>Thanks!</p> ",
    "OwnerUserId": "1232376",
    "LastActivityDate": "2023-06-25T00:49:27.493",
    "Title": "How to configure dns entries for Docker Compose",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "42175951",
    "PostTypeId": "1",
    "AcceptedAnswerId": "42175990",
    "CreationDate": "2017-02-11T12:38:20.267",
    "Score": "7",
    "ViewCount": "16754",
    "Body": "<p>I am setting up a Spring application to run using compose. The application needs to establish a connection to ActiveMQ either running locally for developers or to existing instances for staging/production.</p>  <p>I setup the following which is working great for local dev:</p>  <pre><code>amq:     image: rmohr/activemq:latest     ports:       - '61616:61616'       - '8161:8161' legacy-bridge:     image:  myco/myservice     links:       - amq </code></pre>  <p>and in the application configuration I am declaring the AMQ connection as </p>  <pre><code>broker-url=tcp://amq:61616 </code></pre>  <p>Running docker-compose up is working great, activeMQ is fired up locally and my application constiner starts and connects to it.</p>  <p>Now I need to set this up for staging/production where the ActiveMQ instances are running on existing hardware within the infrastructure. My thoughts are to either use spring profiles to handle a different configurations in which case the application configuration entry for 'broker-url=tcp://amq:61616' would become something like <code>broker-url=tcp://some.host.here:61616</code> or find some way to create a dns entry within my production docker-compose.yml which will point an <code>amq</code> dns entry to the associated staging or production queues.</p>  <p>What is the best approach here and if it is DNS, how to I set that up in compose?</p>  <p>Thanks!</p> ",
    "OwnerUserId": "1232376",
    "LastActivityDate": "2023-06-25T00:49:27.493",
    "Title": "How to configure dns entries for Docker Compose",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "42175951",
    "PostTypeId": "1",
    "AcceptedAnswerId": "42175990",
    "CreationDate": "2017-02-11T12:38:20.267",
    "Score": "7",
    "ViewCount": "16754",
    "Body": "<p>I am setting up a Spring application to run using compose. The application needs to establish a connection to ActiveMQ either running locally for developers or to existing instances for staging/production.</p>  <p>I setup the following which is working great for local dev:</p>  <pre><code>amq:     image: rmohr/activemq:latest     ports:       - '61616:61616'       - '8161:8161' legacy-bridge:     image:  myco/myservice     links:       - amq </code></pre>  <p>and in the application configuration I am declaring the AMQ connection as </p>  <pre><code>broker-url=tcp://amq:61616 </code></pre>  <p>Running docker-compose up is working great, activeMQ is fired up locally and my application constiner starts and connects to it.</p>  <p>Now I need to set this up for staging/production where the ActiveMQ instances are running on existing hardware within the infrastructure. My thoughts are to either use spring profiles to handle a different configurations in which case the application configuration entry for 'broker-url=tcp://amq:61616' would become something like <code>broker-url=tcp://some.host.here:61616</code> or find some way to create a dns entry within my production docker-compose.yml which will point an <code>amq</code> dns entry to the associated staging or production queues.</p>  <p>What is the best approach here and if it is DNS, how to I set that up in compose?</p>  <p>Thanks!</p> ",
    "OwnerUserId": "1232376",
    "LastActivityDate": "2023-06-25T00:49:27.493",
    "Title": "How to configure dns entries for Docker Compose",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "45996171",
    "PostTypeId": "1",
    "AcceptedAnswerId": "46000034",
    "CreationDate": "2017-09-01T08:32:44.300",
    "Score": "7",
    "ViewCount": "4794",
    "Body": "<p>I'm running Elasticsearch instance from Docker. The image is from jHipster docker hub repo: <a href='https://hub.docker.com/r/jhipster/jhipster-elasticsearch/' rel='noreferrer'>jhipster/jhipster-elasticsearch/</a> - I'm using image v1.3.2 because I need Elasticsearch 2.4.0 (to be in line with Spring Boot version of the project).</p>  <p>I'm starting ES container along with Logstash and Kibana images, with <code>docker-compose</code>. This are the settings for starting ES container:</p>  <pre><code>jhipster-elasticsearch:     image: jhipster/jhipster-elasticsearch:v1.3.2     ports:         - 9400:9200         - 9500:9300     volumes:        - ./log-es-config/elasticsearch_custom.yml:/usr/share/elasticsearch/config/elasticsearch.yml </code></pre>  <p>So I'm using 9400 for REST and 9500 for transport communication.</p>  <p>This is configuration inside <code>elasticsearch_custom.yml</code> that is mounted to ES config:</p>  <pre><code>cluster.name: 'log-cluster' node.name: 'log-node' http.host: 0.0.0.0 transport.host: 127.0.0.1 transport.tcp.port: 9500 transport.publish_port: 9500 </code></pre>  <p>When I start container, this is what I get from <code>http://localhost:9400/_nodes</code>:</p>  <pre><code>'cluster_name': 'log-cluster',   'nodes': {     'xLsGj2DyTdCF89I7sAToVw': {       'name': 'log-node',       'transport_address': '127.0.0.1:9500',       'host': '127.0.0.1',       'ip': '127.0.0.1',       'version': '2.4.0',       'build': 'ce9f0c7',       'http_address': '172.18.0.5:9200',       'settings': {         'cluster': {           'name': 'log-cluster'         },         ... (I can put all response if needed) </code></pre>  <p><strong>JAVA API:</strong></p>  <p>Now I'm trying to connect to this ES node like this:</p>  <pre><code>    @Bean     public ElasticsearchOperations logsElasticsearchOperations() throws UnknownHostException {         Settings settings = Settings.settingsBuilder()             .put('cluster.name', 'log-cluster')             .put('node.name', 'log-node')             .build();          Client client = TransportClient.builder()             .settings(settings)             .build()             .addTransportAddress(new InetSocketTransportAddress(new InetSocketAddress('127.0.0.1', 9500)));           ElasticsearchTemplate template = new ElasticsearchTemplate(client);         template.createIndex(ProcessLog.class);         log.debug('Elasticsearch for logs configured.');         return template;     } </code></pre>  <p>The error I'm getting is the most famous one:</p>  <p><strong><code>Caused by: org.elasticsearch.client.transport.NoNodeAvailableException: None of the configured nodes are available: [{#transport#-1}{127.0.0.1}{127.0.0.1:9500}]</code></strong></p>  <p>I googled and tried different config approaches, also with <code>client.transport.sniff</code> set to <code>false</code>, but non of those worked. Now I spent lots of time trying to configure this one and I'm still missing something.</p>  <p>Thanks in advance for help. </p>  <p><strong>UPDATE:</strong></p>  <p>There is also embedded ES instance running when I start the app. So host ports config is like this:</p>  <ul> <li>Embedded ES: 9200 (http), 9300 (tcp)</li> <li>Docker's ES: 9400 (http), 9500 (tcp)</li> </ul>  <p>Here is full <code>docker-compose.yml</code>:</p>  <pre><code>    version: '2'     services:     jhipster-elasticsearch:         # elasticsearch 2.4.0 - to be in line with spring boot version         image: jhipster/jhipster-elasticsearch:v1.3.2         ports:             - 9400:9200             - 9500:9300         volumes:            - ./log-es-config/elasticsearch_custom.yml:/usr/share/elasticsearch/config/elasticsearch.yml     jhipster-logstash:         image: jhipster/jhipster-logstash:v2.2.1         command: logstash -f /conf/logstash_custom.conf         ports:             - 5000:5000/udp             - 6000:6000/tcp         volumes:             - ./logstash-log-es-conf/:/conf     jhipster-console:         image: jhipster/jhipster-console:v2.0.1         ports:             - 5601:5601     jhipster-zipkin:         image: jhipster/jhipster-zipkin:v2.0.1         ports:             - 9411:9411         environment:             - ES_HOSTS=http://jhipster-elasticsearch:9400             - ZIPKIN_UI_LOGS_URL=http://localhost:5601/app/kibana#/dashboard/logs-dashboard?_g=(refreshInterval:(display:Off,pause:!f,value:0),time:(from:now-1h,mode:quick,to:now))&amp;_a=(filters:!(),options:(darkTheme:!f),panels:!((col:1,id:logs-levels,panelIndex:2,row:1,size_x:6,size_y:3,type:visualization),(col:7,columns:!(stack_trace),id:Stacktraces,panelIndex:7,row:1,size_x:4,size_y:3,sort:!('@timestamp',desc),type:search),(col:11,id:Log-forwarding-instructions,panelIndex:8,row:1,size_x:2,size_y:3,type:visualization),(col:1,columns:!(app_name,level,message),id:All-logs,panelIndex:9,row:4,size_x:12,size_y:7,sort:!('@timestamp',asc),type:search)),query:(query_string:(analyze_wildcard:!t,query:'{traceId}')),title:logs-dashboard,uiState:()) </code></pre> ",
    "OwnerUserId": "5250885",
    "LastEditorUserId": "5250885",
    "LastEditDate": "2017-09-01T09:04:49.137",
    "LastActivityDate": "2017-09-01T13:59:55.687",
    "Title": "Connecting to Docker Elasticsearch instance through Java/Spring Boot",
    "Tags": "<java><elasticsearch><docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "45996171",
    "PostTypeId": "1",
    "AcceptedAnswerId": "46000034",
    "CreationDate": "2017-09-01T08:32:44.300",
    "Score": "7",
    "ViewCount": "4794",
    "Body": "<p>I'm running Elasticsearch instance from Docker. The image is from jHipster docker hub repo: <a href='https://hub.docker.com/r/jhipster/jhipster-elasticsearch/' rel='noreferrer'>jhipster/jhipster-elasticsearch/</a> - I'm using image v1.3.2 because I need Elasticsearch 2.4.0 (to be in line with Spring Boot version of the project).</p>  <p>I'm starting ES container along with Logstash and Kibana images, with <code>docker-compose</code>. This are the settings for starting ES container:</p>  <pre><code>jhipster-elasticsearch:     image: jhipster/jhipster-elasticsearch:v1.3.2     ports:         - 9400:9200         - 9500:9300     volumes:        - ./log-es-config/elasticsearch_custom.yml:/usr/share/elasticsearch/config/elasticsearch.yml </code></pre>  <p>So I'm using 9400 for REST and 9500 for transport communication.</p>  <p>This is configuration inside <code>elasticsearch_custom.yml</code> that is mounted to ES config:</p>  <pre><code>cluster.name: 'log-cluster' node.name: 'log-node' http.host: 0.0.0.0 transport.host: 127.0.0.1 transport.tcp.port: 9500 transport.publish_port: 9500 </code></pre>  <p>When I start container, this is what I get from <code>http://localhost:9400/_nodes</code>:</p>  <pre><code>'cluster_name': 'log-cluster',   'nodes': {     'xLsGj2DyTdCF89I7sAToVw': {       'name': 'log-node',       'transport_address': '127.0.0.1:9500',       'host': '127.0.0.1',       'ip': '127.0.0.1',       'version': '2.4.0',       'build': 'ce9f0c7',       'http_address': '172.18.0.5:9200',       'settings': {         'cluster': {           'name': 'log-cluster'         },         ... (I can put all response if needed) </code></pre>  <p><strong>JAVA API:</strong></p>  <p>Now I'm trying to connect to this ES node like this:</p>  <pre><code>    @Bean     public ElasticsearchOperations logsElasticsearchOperations() throws UnknownHostException {         Settings settings = Settings.settingsBuilder()             .put('cluster.name', 'log-cluster')             .put('node.name', 'log-node')             .build();          Client client = TransportClient.builder()             .settings(settings)             .build()             .addTransportAddress(new InetSocketTransportAddress(new InetSocketAddress('127.0.0.1', 9500)));           ElasticsearchTemplate template = new ElasticsearchTemplate(client);         template.createIndex(ProcessLog.class);         log.debug('Elasticsearch for logs configured.');         return template;     } </code></pre>  <p>The error I'm getting is the most famous one:</p>  <p><strong><code>Caused by: org.elasticsearch.client.transport.NoNodeAvailableException: None of the configured nodes are available: [{#transport#-1}{127.0.0.1}{127.0.0.1:9500}]</code></strong></p>  <p>I googled and tried different config approaches, also with <code>client.transport.sniff</code> set to <code>false</code>, but non of those worked. Now I spent lots of time trying to configure this one and I'm still missing something.</p>  <p>Thanks in advance for help. </p>  <p><strong>UPDATE:</strong></p>  <p>There is also embedded ES instance running when I start the app. So host ports config is like this:</p>  <ul> <li>Embedded ES: 9200 (http), 9300 (tcp)</li> <li>Docker's ES: 9400 (http), 9500 (tcp)</li> </ul>  <p>Here is full <code>docker-compose.yml</code>:</p>  <pre><code>    version: '2'     services:     jhipster-elasticsearch:         # elasticsearch 2.4.0 - to be in line with spring boot version         image: jhipster/jhipster-elasticsearch:v1.3.2         ports:             - 9400:9200             - 9500:9300         volumes:            - ./log-es-config/elasticsearch_custom.yml:/usr/share/elasticsearch/config/elasticsearch.yml     jhipster-logstash:         image: jhipster/jhipster-logstash:v2.2.1         command: logstash -f /conf/logstash_custom.conf         ports:             - 5000:5000/udp             - 6000:6000/tcp         volumes:             - ./logstash-log-es-conf/:/conf     jhipster-console:         image: jhipster/jhipster-console:v2.0.1         ports:             - 5601:5601     jhipster-zipkin:         image: jhipster/jhipster-zipkin:v2.0.1         ports:             - 9411:9411         environment:             - ES_HOSTS=http://jhipster-elasticsearch:9400             - ZIPKIN_UI_LOGS_URL=http://localhost:5601/app/kibana#/dashboard/logs-dashboard?_g=(refreshInterval:(display:Off,pause:!f,value:0),time:(from:now-1h,mode:quick,to:now))&amp;_a=(filters:!(),options:(darkTheme:!f),panels:!((col:1,id:logs-levels,panelIndex:2,row:1,size_x:6,size_y:3,type:visualization),(col:7,columns:!(stack_trace),id:Stacktraces,panelIndex:7,row:1,size_x:4,size_y:3,sort:!('@timestamp',desc),type:search),(col:11,id:Log-forwarding-instructions,panelIndex:8,row:1,size_x:2,size_y:3,type:visualization),(col:1,columns:!(app_name,level,message),id:All-logs,panelIndex:9,row:4,size_x:12,size_y:7,sort:!('@timestamp',asc),type:search)),query:(query_string:(analyze_wildcard:!t,query:'{traceId}')),title:logs-dashboard,uiState:()) </code></pre> ",
    "OwnerUserId": "5250885",
    "LastEditorUserId": "5250885",
    "LastEditDate": "2017-09-01T09:04:49.137",
    "LastActivityDate": "2017-09-01T13:59:55.687",
    "Title": "Connecting to Docker Elasticsearch instance through Java/Spring Boot",
    "Tags": "<java><elasticsearch><docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "45996171",
    "PostTypeId": "1",
    "AcceptedAnswerId": "46000034",
    "CreationDate": "2017-09-01T08:32:44.300",
    "Score": "7",
    "ViewCount": "4794",
    "Body": "<p>I'm running Elasticsearch instance from Docker. The image is from jHipster docker hub repo: <a href='https://hub.docker.com/r/jhipster/jhipster-elasticsearch/' rel='noreferrer'>jhipster/jhipster-elasticsearch/</a> - I'm using image v1.3.2 because I need Elasticsearch 2.4.0 (to be in line with Spring Boot version of the project).</p>  <p>I'm starting ES container along with Logstash and Kibana images, with <code>docker-compose</code>. This are the settings for starting ES container:</p>  <pre><code>jhipster-elasticsearch:     image: jhipster/jhipster-elasticsearch:v1.3.2     ports:         - 9400:9200         - 9500:9300     volumes:        - ./log-es-config/elasticsearch_custom.yml:/usr/share/elasticsearch/config/elasticsearch.yml </code></pre>  <p>So I'm using 9400 for REST and 9500 for transport communication.</p>  <p>This is configuration inside <code>elasticsearch_custom.yml</code> that is mounted to ES config:</p>  <pre><code>cluster.name: 'log-cluster' node.name: 'log-node' http.host: 0.0.0.0 transport.host: 127.0.0.1 transport.tcp.port: 9500 transport.publish_port: 9500 </code></pre>  <p>When I start container, this is what I get from <code>http://localhost:9400/_nodes</code>:</p>  <pre><code>'cluster_name': 'log-cluster',   'nodes': {     'xLsGj2DyTdCF89I7sAToVw': {       'name': 'log-node',       'transport_address': '127.0.0.1:9500',       'host': '127.0.0.1',       'ip': '127.0.0.1',       'version': '2.4.0',       'build': 'ce9f0c7',       'http_address': '172.18.0.5:9200',       'settings': {         'cluster': {           'name': 'log-cluster'         },         ... (I can put all response if needed) </code></pre>  <p><strong>JAVA API:</strong></p>  <p>Now I'm trying to connect to this ES node like this:</p>  <pre><code>    @Bean     public ElasticsearchOperations logsElasticsearchOperations() throws UnknownHostException {         Settings settings = Settings.settingsBuilder()             .put('cluster.name', 'log-cluster')             .put('node.name', 'log-node')             .build();          Client client = TransportClient.builder()             .settings(settings)             .build()             .addTransportAddress(new InetSocketTransportAddress(new InetSocketAddress('127.0.0.1', 9500)));           ElasticsearchTemplate template = new ElasticsearchTemplate(client);         template.createIndex(ProcessLog.class);         log.debug('Elasticsearch for logs configured.');         return template;     } </code></pre>  <p>The error I'm getting is the most famous one:</p>  <p><strong><code>Caused by: org.elasticsearch.client.transport.NoNodeAvailableException: None of the configured nodes are available: [{#transport#-1}{127.0.0.1}{127.0.0.1:9500}]</code></strong></p>  <p>I googled and tried different config approaches, also with <code>client.transport.sniff</code> set to <code>false</code>, but non of those worked. Now I spent lots of time trying to configure this one and I'm still missing something.</p>  <p>Thanks in advance for help. </p>  <p><strong>UPDATE:</strong></p>  <p>There is also embedded ES instance running when I start the app. So host ports config is like this:</p>  <ul> <li>Embedded ES: 9200 (http), 9300 (tcp)</li> <li>Docker's ES: 9400 (http), 9500 (tcp)</li> </ul>  <p>Here is full <code>docker-compose.yml</code>:</p>  <pre><code>    version: '2'     services:     jhipster-elasticsearch:         # elasticsearch 2.4.0 - to be in line with spring boot version         image: jhipster/jhipster-elasticsearch:v1.3.2         ports:             - 9400:9200             - 9500:9300         volumes:            - ./log-es-config/elasticsearch_custom.yml:/usr/share/elasticsearch/config/elasticsearch.yml     jhipster-logstash:         image: jhipster/jhipster-logstash:v2.2.1         command: logstash -f /conf/logstash_custom.conf         ports:             - 5000:5000/udp             - 6000:6000/tcp         volumes:             - ./logstash-log-es-conf/:/conf     jhipster-console:         image: jhipster/jhipster-console:v2.0.1         ports:             - 5601:5601     jhipster-zipkin:         image: jhipster/jhipster-zipkin:v2.0.1         ports:             - 9411:9411         environment:             - ES_HOSTS=http://jhipster-elasticsearch:9400             - ZIPKIN_UI_LOGS_URL=http://localhost:5601/app/kibana#/dashboard/logs-dashboard?_g=(refreshInterval:(display:Off,pause:!f,value:0),time:(from:now-1h,mode:quick,to:now))&amp;_a=(filters:!(),options:(darkTheme:!f),panels:!((col:1,id:logs-levels,panelIndex:2,row:1,size_x:6,size_y:3,type:visualization),(col:7,columns:!(stack_trace),id:Stacktraces,panelIndex:7,row:1,size_x:4,size_y:3,sort:!('@timestamp',desc),type:search),(col:11,id:Log-forwarding-instructions,panelIndex:8,row:1,size_x:2,size_y:3,type:visualization),(col:1,columns:!(app_name,level,message),id:All-logs,panelIndex:9,row:4,size_x:12,size_y:7,sort:!('@timestamp',asc),type:search)),query:(query_string:(analyze_wildcard:!t,query:'{traceId}')),title:logs-dashboard,uiState:()) </code></pre> ",
    "OwnerUserId": "5250885",
    "LastEditorUserId": "5250885",
    "LastEditDate": "2017-09-01T09:04:49.137",
    "LastActivityDate": "2017-09-01T13:59:55.687",
    "Title": "Connecting to Docker Elasticsearch instance through Java/Spring Boot",
    "Tags": "<java><elasticsearch><docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "53152471",
    "PostTypeId": "1",
    "CreationDate": "2018-11-05T10:25:04.230",
    "Score": "7",
    "ViewCount": "7176",
    "Body": "<p>is there a way to choose if I want to have a logback appender or not, via environment variable?<br> <br> I have a dockerized spring boot Microservice and added now the ELK stack.<br> That works fine so far.<br> But now if I want to start my service without ELK stack, the application throws an error, that it doesn't know the host of Logstash:</p>  <pre><code>app | 10:09:23,537 |-ERROR in ch.qos.logback.classic.net.SyslogAppender[SYSLOG] - Could not create SyslogWriter java.net.UnknownHostException: logstash: Name or service not known app |   at java.net.UnknownHostException: logstash: Name or service not known </code></pre>  <p>Here is my logback.xml file:</p>  <pre><code>&lt;?xml version='1.0' encoding='UTF-8'?&gt; &lt;configuration&gt;      &lt;appender name='SYSLOG' class='ch.qos.logback.classic.net.SyslogAppender'&gt;         &lt;syslogHost&gt;logstash&lt;/syslogHost&gt;         &lt;port&gt;5000&lt;/port&gt;         &lt;facility&gt;LOCAL1&lt;/facility&gt;         &lt;suffixPattern&gt;[%thread] %logger %msg&lt;/suffixPattern&gt;     &lt;/appender&gt;      &lt;root level='INFO'&gt;         &lt;appender-ref ref='SYSLOG'/&gt;     &lt;/root&gt;  &lt;/configuration&gt; </code></pre>  <p>I know this is a very simple version, but I am new in logging with logback/ELK stack.<br> <br> So is there a way to inject something with an environment variable like in yaml files e.g. <code>active=${LOGBACK_ACTIVE:false}</code> like I can do it with my prometheus metrics?</p> ",
    "OwnerUserId": "8344100",
    "LastEditorUserId": "8344100",
    "LastEditDate": "2018-11-05T10:27:43.633",
    "LastActivityDate": "2020-05-25T18:10:37.513",
    "Title": "How can I dynamically (by env variable) activate/deactivate logback or logback appender?",
    "Tags": "<spring-boot><logging><docker-compose><logback><elastic-stack>",
    "AnswerCount": "2",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "53152471",
    "PostTypeId": "1",
    "CreationDate": "2018-11-05T10:25:04.230",
    "Score": "7",
    "ViewCount": "7176",
    "Body": "<p>is there a way to choose if I want to have a logback appender or not, via environment variable?<br> <br> I have a dockerized spring boot Microservice and added now the ELK stack.<br> That works fine so far.<br> But now if I want to start my service without ELK stack, the application throws an error, that it doesn't know the host of Logstash:</p>  <pre><code>app | 10:09:23,537 |-ERROR in ch.qos.logback.classic.net.SyslogAppender[SYSLOG] - Could not create SyslogWriter java.net.UnknownHostException: logstash: Name or service not known app |   at java.net.UnknownHostException: logstash: Name or service not known </code></pre>  <p>Here is my logback.xml file:</p>  <pre><code>&lt;?xml version='1.0' encoding='UTF-8'?&gt; &lt;configuration&gt;      &lt;appender name='SYSLOG' class='ch.qos.logback.classic.net.SyslogAppender'&gt;         &lt;syslogHost&gt;logstash&lt;/syslogHost&gt;         &lt;port&gt;5000&lt;/port&gt;         &lt;facility&gt;LOCAL1&lt;/facility&gt;         &lt;suffixPattern&gt;[%thread] %logger %msg&lt;/suffixPattern&gt;     &lt;/appender&gt;      &lt;root level='INFO'&gt;         &lt;appender-ref ref='SYSLOG'/&gt;     &lt;/root&gt;  &lt;/configuration&gt; </code></pre>  <p>I know this is a very simple version, but I am new in logging with logback/ELK stack.<br> <br> So is there a way to inject something with an environment variable like in yaml files e.g. <code>active=${LOGBACK_ACTIVE:false}</code> like I can do it with my prometheus metrics?</p> ",
    "OwnerUserId": "8344100",
    "LastEditorUserId": "8344100",
    "LastEditDate": "2018-11-05T10:27:43.633",
    "LastActivityDate": "2020-05-25T18:10:37.513",
    "Title": "How can I dynamically (by env variable) activate/deactivate logback or logback appender?",
    "Tags": "<spring-boot><logging><docker-compose><logback><elastic-stack>",
    "AnswerCount": "2",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "53152471",
    "PostTypeId": "1",
    "CreationDate": "2018-11-05T10:25:04.230",
    "Score": "7",
    "ViewCount": "7176",
    "Body": "<p>is there a way to choose if I want to have a logback appender or not, via environment variable?<br> <br> I have a dockerized spring boot Microservice and added now the ELK stack.<br> That works fine so far.<br> But now if I want to start my service without ELK stack, the application throws an error, that it doesn't know the host of Logstash:</p>  <pre><code>app | 10:09:23,537 |-ERROR in ch.qos.logback.classic.net.SyslogAppender[SYSLOG] - Could not create SyslogWriter java.net.UnknownHostException: logstash: Name or service not known app |   at java.net.UnknownHostException: logstash: Name or service not known </code></pre>  <p>Here is my logback.xml file:</p>  <pre><code>&lt;?xml version='1.0' encoding='UTF-8'?&gt; &lt;configuration&gt;      &lt;appender name='SYSLOG' class='ch.qos.logback.classic.net.SyslogAppender'&gt;         &lt;syslogHost&gt;logstash&lt;/syslogHost&gt;         &lt;port&gt;5000&lt;/port&gt;         &lt;facility&gt;LOCAL1&lt;/facility&gt;         &lt;suffixPattern&gt;[%thread] %logger %msg&lt;/suffixPattern&gt;     &lt;/appender&gt;      &lt;root level='INFO'&gt;         &lt;appender-ref ref='SYSLOG'/&gt;     &lt;/root&gt;  &lt;/configuration&gt; </code></pre>  <p>I know this is a very simple version, but I am new in logging with logback/ELK stack.<br> <br> So is there a way to inject something with an environment variable like in yaml files e.g. <code>active=${LOGBACK_ACTIVE:false}</code> like I can do it with my prometheus metrics?</p> ",
    "OwnerUserId": "8344100",
    "LastEditorUserId": "8344100",
    "LastEditDate": "2018-11-05T10:27:43.633",
    "LastActivityDate": "2020-05-25T18:10:37.513",
    "Title": "How can I dynamically (by env variable) activate/deactivate logback or logback appender?",
    "Tags": "<spring-boot><logging><docker-compose><logback><elastic-stack>",
    "AnswerCount": "2",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "53429062",
    "PostTypeId": "1",
    "CreationDate": "2018-11-22T10:38:36.987",
    "Score": "7",
    "ViewCount": "14310",
    "Body": "<p>I am building my first Springboot 2.0 application. I am trying to put my Springboot application into one docker container and my PostgresDB into another container.  </p>  <p><strong>My Dockerfile</strong></p>  <pre><code>    FROM frolvlad/alpine-oraclejdk8:slim     VOLUME /tmp     ADD springboot-api-demo-0.1*.jar app.jar     RUN sh -c 'touch /app.jar'     EXPOSE 9443     ENTRYPOINT [ 'sh', '-c', 'java $JAVA_OPTS -Djava.security.egd=file:/dev/urandom -jar /app.jar' ] </code></pre>  <p><strong>My docker-compose.yml file</strong></p>  <pre><code>version: '2.1'  services:   springboot-api-demo:     image: 'fw/springboot-api-demo'     mem_limit: 1024m     ports:       - '8080:8080'     environment:       - SPRING_PROFILES_ACTIVE=local       - AWS_REGION=local       - ENVIRONMENT=local       - AUTH_ENABLED=false   postgres:     container_name: pgdb     image: postgres:9.6-alpine     environment:     - 'POSTGRES_ROOT_PASSWORD=postgres'     - 'POSTGRES_USER=postgres'     - 'POSTGRES_PASSWORD=postgres'     ports:     - '54321:5432' </code></pre>  <p>I am using Springboot JPA Data 2.0 with below config data in my <strong>application.properties</strong></p>  <pre><code>spring.datasource.url= jdbc:postgresql://localhost:54321/java_learning spring.datasource.username=postgres spring.datasource.password=postgres </code></pre>  <p>I can test that Both of the Images are up. Also from docker log and docker events, I see that postgres  Container is running fine, even I can access it and also created a DB too. But springboot container started but i died because it could not connect to postgress and throwing error below. </p>  <blockquote>   <p>Unable to obtain connection from database: The connection attempt   failed</p> </blockquote>  <p>Note that my host machine already has Postgres on port 5432 thats why I did a port mapping ofr 54321:5432 on my postgres container. Here is Proof :) -</p>  <pre><code>\u279c  springboot-api-demo git:(master) \u2717 lsof -i:54321               COMMAND     PID             USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME com.docke 44345 shailendra.singh   18u  IPv4 0xf62897fbdd69e31d      0t0  TCP *:54321 (LISTEN) com.docke 44345 shailendra.singh   21u  IPv6 0xf62897fbdd119975      0t0  TCP localhost:54321 (LISTEN)  \u279c  springboot-api-demo git:(master) \u2717 lsof -i:5432  COMMAND  PID             USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME postgres 715 shailendra.singh    5u  IPv6 0xf62897fbb43e03b5      0t0  TCP localhost:postgresql (LISTEN) postgres 715 shailendra.singh    6u  IPv4 0xf62897fbbaeea9bd      0t0  TCP localhost:postgresql (LISTEN) </code></pre>  <p>I am not sure what is the problem. But my Springboot application is not able to connect my postgres container which is running fine with proper creadentials. </p> ",
    "OwnerUserId": "3511619",
    "LastEditorUserId": "2275818",
    "LastEditDate": "2018-11-22T10:52:45.053",
    "LastActivityDate": "2022-06-09T04:12:13.973",
    "Title": "Docker: Springboot container can not connect to PostgreSql Container Connection error",
    "Tags": "<postgresql><spring-boot><docker><docker-compose>",
    "AnswerCount": "4",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "53429062",
    "PostTypeId": "1",
    "CreationDate": "2018-11-22T10:38:36.987",
    "Score": "7",
    "ViewCount": "14310",
    "Body": "<p>I am building my first Springboot 2.0 application. I am trying to put my Springboot application into one docker container and my PostgresDB into another container.  </p>  <p><strong>My Dockerfile</strong></p>  <pre><code>    FROM frolvlad/alpine-oraclejdk8:slim     VOLUME /tmp     ADD springboot-api-demo-0.1*.jar app.jar     RUN sh -c 'touch /app.jar'     EXPOSE 9443     ENTRYPOINT [ 'sh', '-c', 'java $JAVA_OPTS -Djava.security.egd=file:/dev/urandom -jar /app.jar' ] </code></pre>  <p><strong>My docker-compose.yml file</strong></p>  <pre><code>version: '2.1'  services:   springboot-api-demo:     image: 'fw/springboot-api-demo'     mem_limit: 1024m     ports:       - '8080:8080'     environment:       - SPRING_PROFILES_ACTIVE=local       - AWS_REGION=local       - ENVIRONMENT=local       - AUTH_ENABLED=false   postgres:     container_name: pgdb     image: postgres:9.6-alpine     environment:     - 'POSTGRES_ROOT_PASSWORD=postgres'     - 'POSTGRES_USER=postgres'     - 'POSTGRES_PASSWORD=postgres'     ports:     - '54321:5432' </code></pre>  <p>I am using Springboot JPA Data 2.0 with below config data in my <strong>application.properties</strong></p>  <pre><code>spring.datasource.url= jdbc:postgresql://localhost:54321/java_learning spring.datasource.username=postgres spring.datasource.password=postgres </code></pre>  <p>I can test that Both of the Images are up. Also from docker log and docker events, I see that postgres  Container is running fine, even I can access it and also created a DB too. But springboot container started but i died because it could not connect to postgress and throwing error below. </p>  <blockquote>   <p>Unable to obtain connection from database: The connection attempt   failed</p> </blockquote>  <p>Note that my host machine already has Postgres on port 5432 thats why I did a port mapping ofr 54321:5432 on my postgres container. Here is Proof :) -</p>  <pre><code>\u279c  springboot-api-demo git:(master) \u2717 lsof -i:54321               COMMAND     PID             USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME com.docke 44345 shailendra.singh   18u  IPv4 0xf62897fbdd69e31d      0t0  TCP *:54321 (LISTEN) com.docke 44345 shailendra.singh   21u  IPv6 0xf62897fbdd119975      0t0  TCP localhost:54321 (LISTEN)  \u279c  springboot-api-demo git:(master) \u2717 lsof -i:5432  COMMAND  PID             USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME postgres 715 shailendra.singh    5u  IPv6 0xf62897fbb43e03b5      0t0  TCP localhost:postgresql (LISTEN) postgres 715 shailendra.singh    6u  IPv4 0xf62897fbbaeea9bd      0t0  TCP localhost:postgresql (LISTEN) </code></pre>  <p>I am not sure what is the problem. But my Springboot application is not able to connect my postgres container which is running fine with proper creadentials. </p> ",
    "OwnerUserId": "3511619",
    "LastEditorUserId": "2275818",
    "LastEditDate": "2018-11-22T10:52:45.053",
    "LastActivityDate": "2022-06-09T04:12:13.973",
    "Title": "Docker: Springboot container can not connect to PostgreSql Container Connection error",
    "Tags": "<postgresql><spring-boot><docker><docker-compose>",
    "AnswerCount": "4",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "53429062",
    "PostTypeId": "1",
    "CreationDate": "2018-11-22T10:38:36.987",
    "Score": "7",
    "ViewCount": "14310",
    "Body": "<p>I am building my first Springboot 2.0 application. I am trying to put my Springboot application into one docker container and my PostgresDB into another container.  </p>  <p><strong>My Dockerfile</strong></p>  <pre><code>    FROM frolvlad/alpine-oraclejdk8:slim     VOLUME /tmp     ADD springboot-api-demo-0.1*.jar app.jar     RUN sh -c 'touch /app.jar'     EXPOSE 9443     ENTRYPOINT [ 'sh', '-c', 'java $JAVA_OPTS -Djava.security.egd=file:/dev/urandom -jar /app.jar' ] </code></pre>  <p><strong>My docker-compose.yml file</strong></p>  <pre><code>version: '2.1'  services:   springboot-api-demo:     image: 'fw/springboot-api-demo'     mem_limit: 1024m     ports:       - '8080:8080'     environment:       - SPRING_PROFILES_ACTIVE=local       - AWS_REGION=local       - ENVIRONMENT=local       - AUTH_ENABLED=false   postgres:     container_name: pgdb     image: postgres:9.6-alpine     environment:     - 'POSTGRES_ROOT_PASSWORD=postgres'     - 'POSTGRES_USER=postgres'     - 'POSTGRES_PASSWORD=postgres'     ports:     - '54321:5432' </code></pre>  <p>I am using Springboot JPA Data 2.0 with below config data in my <strong>application.properties</strong></p>  <pre><code>spring.datasource.url= jdbc:postgresql://localhost:54321/java_learning spring.datasource.username=postgres spring.datasource.password=postgres </code></pre>  <p>I can test that Both of the Images are up. Also from docker log and docker events, I see that postgres  Container is running fine, even I can access it and also created a DB too. But springboot container started but i died because it could not connect to postgress and throwing error below. </p>  <blockquote>   <p>Unable to obtain connection from database: The connection attempt   failed</p> </blockquote>  <p>Note that my host machine already has Postgres on port 5432 thats why I did a port mapping ofr 54321:5432 on my postgres container. Here is Proof :) -</p>  <pre><code>\u279c  springboot-api-demo git:(master) \u2717 lsof -i:54321               COMMAND     PID             USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME com.docke 44345 shailendra.singh   18u  IPv4 0xf62897fbdd69e31d      0t0  TCP *:54321 (LISTEN) com.docke 44345 shailendra.singh   21u  IPv6 0xf62897fbdd119975      0t0  TCP localhost:54321 (LISTEN)  \u279c  springboot-api-demo git:(master) \u2717 lsof -i:5432  COMMAND  PID             USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME postgres 715 shailendra.singh    5u  IPv6 0xf62897fbb43e03b5      0t0  TCP localhost:postgresql (LISTEN) postgres 715 shailendra.singh    6u  IPv4 0xf62897fbbaeea9bd      0t0  TCP localhost:postgresql (LISTEN) </code></pre>  <p>I am not sure what is the problem. But my Springboot application is not able to connect my postgres container which is running fine with proper creadentials. </p> ",
    "OwnerUserId": "3511619",
    "LastEditorUserId": "2275818",
    "LastEditDate": "2018-11-22T10:52:45.053",
    "LastActivityDate": "2022-06-09T04:12:13.973",
    "Title": "Docker: Springboot container can not connect to PostgreSql Container Connection error",
    "Tags": "<postgresql><spring-boot><docker><docker-compose>",
    "AnswerCount": "4",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "59330607",
    "PostTypeId": "1",
    "AcceptedAnswerId": "59339438",
    "CreationDate": "2019-12-13T22:32:51.567",
    "Score": "6",
    "ViewCount": "8806",
    "Body": "<p>My web app can't connect to the MongoDB container</p> <p>here are my application.yml</p> <pre class='lang-yaml prettyprint-override'><code>spring:   data:     mongodb:       uri: mongodb://mongo:27017       host: mongo       port: 27017       database: my-db-name </code></pre> <p>and this is my Docker-Compose</p> <pre class='lang-yaml prettyprint-override'><code>version: &quot;3&quot; services:    java:     build:       context: ./     ports:       - &quot;8080:8080&quot;     links:       - mongo     depends_on:       - mongo     networks:       - shared-net    mongo:     image: 'mongo'     ports:       - 27017:27017     hostname: mongo     volumes:       - ./data/db:/data/db     networks:       - shared-net  networks:   shared-net:     driver: bridge </code></pre> <p>and this is the Dockerfile wrote for running java</p> <pre><code>FROM openjdk:11 COPY ./code/lemon-backend/target/lemon-0.0.1-SNAPSHOT.jar /usr/src/ WORKDIR /usr/src/ EXPOSE 8080 CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;lemon-0.0.1-SNAPSHOT.jar&quot;] </code></pre> <p>I can't even build the application using these options I get this exception:</p> <p><code>org.mongodb.driver.cluster: Exception in monitor thread while connecting to server mongo:27017</code></p> <p>if possible try giving solutions with docker-compose, thanks</p> ",
    "OwnerUserId": "9614342",
    "LastEditorUserId": "9614342",
    "LastEditDate": "2021-01-23T14:16:50.327",
    "LastActivityDate": "2021-01-23T14:35:11.350",
    "Title": "Connect To Docker Compose MongoDb Via Spring boot application",
    "Tags": "<java><mongodb><spring-boot><docker><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "59330607",
    "PostTypeId": "1",
    "AcceptedAnswerId": "59339438",
    "CreationDate": "2019-12-13T22:32:51.567",
    "Score": "6",
    "ViewCount": "8806",
    "Body": "<p>My web app can't connect to the MongoDB container</p> <p>here are my application.yml</p> <pre class='lang-yaml prettyprint-override'><code>spring:   data:     mongodb:       uri: mongodb://mongo:27017       host: mongo       port: 27017       database: my-db-name </code></pre> <p>and this is my Docker-Compose</p> <pre class='lang-yaml prettyprint-override'><code>version: &quot;3&quot; services:    java:     build:       context: ./     ports:       - &quot;8080:8080&quot;     links:       - mongo     depends_on:       - mongo     networks:       - shared-net    mongo:     image: 'mongo'     ports:       - 27017:27017     hostname: mongo     volumes:       - ./data/db:/data/db     networks:       - shared-net  networks:   shared-net:     driver: bridge </code></pre> <p>and this is the Dockerfile wrote for running java</p> <pre><code>FROM openjdk:11 COPY ./code/lemon-backend/target/lemon-0.0.1-SNAPSHOT.jar /usr/src/ WORKDIR /usr/src/ EXPOSE 8080 CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;lemon-0.0.1-SNAPSHOT.jar&quot;] </code></pre> <p>I can't even build the application using these options I get this exception:</p> <p><code>org.mongodb.driver.cluster: Exception in monitor thread while connecting to server mongo:27017</code></p> <p>if possible try giving solutions with docker-compose, thanks</p> ",
    "OwnerUserId": "9614342",
    "LastEditorUserId": "9614342",
    "LastEditDate": "2021-01-23T14:16:50.327",
    "LastActivityDate": "2021-01-23T14:35:11.350",
    "Title": "Connect To Docker Compose MongoDb Via Spring boot application",
    "Tags": "<java><mongodb><spring-boot><docker><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "59330607",
    "PostTypeId": "1",
    "AcceptedAnswerId": "59339438",
    "CreationDate": "2019-12-13T22:32:51.567",
    "Score": "6",
    "ViewCount": "8806",
    "Body": "<p>My web app can't connect to the MongoDB container</p> <p>here are my application.yml</p> <pre class='lang-yaml prettyprint-override'><code>spring:   data:     mongodb:       uri: mongodb://mongo:27017       host: mongo       port: 27017       database: my-db-name </code></pre> <p>and this is my Docker-Compose</p> <pre class='lang-yaml prettyprint-override'><code>version: &quot;3&quot; services:    java:     build:       context: ./     ports:       - &quot;8080:8080&quot;     links:       - mongo     depends_on:       - mongo     networks:       - shared-net    mongo:     image: 'mongo'     ports:       - 27017:27017     hostname: mongo     volumes:       - ./data/db:/data/db     networks:       - shared-net  networks:   shared-net:     driver: bridge </code></pre> <p>and this is the Dockerfile wrote for running java</p> <pre><code>FROM openjdk:11 COPY ./code/lemon-backend/target/lemon-0.0.1-SNAPSHOT.jar /usr/src/ WORKDIR /usr/src/ EXPOSE 8080 CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;lemon-0.0.1-SNAPSHOT.jar&quot;] </code></pre> <p>I can't even build the application using these options I get this exception:</p> <p><code>org.mongodb.driver.cluster: Exception in monitor thread while connecting to server mongo:27017</code></p> <p>if possible try giving solutions with docker-compose, thanks</p> ",
    "OwnerUserId": "9614342",
    "LastEditorUserId": "9614342",
    "LastEditDate": "2021-01-23T14:16:50.327",
    "LastActivityDate": "2021-01-23T14:35:11.350",
    "Title": "Connect To Docker Compose MongoDb Via Spring boot application",
    "Tags": "<java><mongodb><spring-boot><docker><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "60109556",
    "PostTypeId": "1",
    "CreationDate": "2020-02-07T08:21:38.050",
    "Score": "6",
    "ViewCount": "6444",
    "Body": "<p>I need multiple instance of same application, for that I am using  <code>server.port=0</code> to run application in random port.  my question is how can I map randomly generated port to docker-compose.yml to create multiple instances.  I am using spring boot at the back-end. I am unable to find any solution.  Any help much appreciated. </p> ",
    "OwnerUserId": "8133014",
    "LastActivityDate": "2020-02-07T10:16:29.903",
    "Title": "Expose random port to docker-compose.yml",
    "Tags": "<java><spring><spring-boot><docker><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "60109556",
    "PostTypeId": "1",
    "CreationDate": "2020-02-07T08:21:38.050",
    "Score": "6",
    "ViewCount": "6444",
    "Body": "<p>I need multiple instance of same application, for that I am using  <code>server.port=0</code> to run application in random port.  my question is how can I map randomly generated port to docker-compose.yml to create multiple instances.  I am using spring boot at the back-end. I am unable to find any solution.  Any help much appreciated. </p> ",
    "OwnerUserId": "8133014",
    "LastActivityDate": "2020-02-07T10:16:29.903",
    "Title": "Expose random port to docker-compose.yml",
    "Tags": "<java><spring><spring-boot><docker><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "60109556",
    "PostTypeId": "1",
    "CreationDate": "2020-02-07T08:21:38.050",
    "Score": "6",
    "ViewCount": "6444",
    "Body": "<p>I need multiple instance of same application, for that I am using  <code>server.port=0</code> to run application in random port.  my question is how can I map randomly generated port to docker-compose.yml to create multiple instances.  I am using spring boot at the back-end. I am unable to find any solution.  Any help much appreciated. </p> ",
    "OwnerUserId": "8133014",
    "LastActivityDate": "2020-02-07T10:16:29.903",
    "Title": "Expose random port to docker-compose.yml",
    "Tags": "<java><spring><spring-boot><docker><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "60945565",
    "PostTypeId": "1",
    "AcceptedAnswerId": "60961132",
    "CreationDate": "2020-03-31T07:40:57.793",
    "Score": "6",
    "ViewCount": "3085",
    "Body": "<p>This is my docker-compose.yaml:</p>  <pre><code>version: '2.0' services:   mongo_container:     image: mongo:latest     environment:       MONGO_INITDB_ROOT_USERNAME: root       MONGO_INITDB_ROOT_PASSWORD: example       MONGO_INITDB_DATABASE: testdb     ports:       - '27017:27017'     volumes:       - ./mongodata:/data/db </code></pre>  <p>And this in my spring configuration:</p>  <pre><code>spring.data.mongodb.host=localhost spring.data.mongodb.port=27017 spring.data.mongodb.username=root spring.data.mongodb.password=example spring.data.mongodb.database=testdb </code></pre>  <p>But everytime when I try to connect my app to Mongo I get following error in Docker console:</p>  <pre><code>mongo_container_1  | 2020-03-31T07:37:24.803+0000 I  ACCESS   [conn2] SASL SCRAM-SHA-1 authentication failed for root on testdb from client 172.29.0.1:36628 ; UserNotFound: Could not find user 'root' for db 'testdb' </code></pre>  <p>What am I doing wrong? I tried to remove all containers with <code>docker system prune</code> and run it again but it still gives the same error.</p> ",
    "OwnerUserId": "4650497",
    "LastEditorUserId": "4650497",
    "LastEditDate": "2020-03-31T07:46:33.423",
    "LastActivityDate": "2020-03-31T22:49:43.027",
    "Title": "Mongodb with docker-compose - create user",
    "Tags": "<mongodb><spring-boot><docker><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "60945565",
    "PostTypeId": "1",
    "AcceptedAnswerId": "60961132",
    "CreationDate": "2020-03-31T07:40:57.793",
    "Score": "6",
    "ViewCount": "3085",
    "Body": "<p>This is my docker-compose.yaml:</p>  <pre><code>version: '2.0' services:   mongo_container:     image: mongo:latest     environment:       MONGO_INITDB_ROOT_USERNAME: root       MONGO_INITDB_ROOT_PASSWORD: example       MONGO_INITDB_DATABASE: testdb     ports:       - '27017:27017'     volumes:       - ./mongodata:/data/db </code></pre>  <p>And this in my spring configuration:</p>  <pre><code>spring.data.mongodb.host=localhost spring.data.mongodb.port=27017 spring.data.mongodb.username=root spring.data.mongodb.password=example spring.data.mongodb.database=testdb </code></pre>  <p>But everytime when I try to connect my app to Mongo I get following error in Docker console:</p>  <pre><code>mongo_container_1  | 2020-03-31T07:37:24.803+0000 I  ACCESS   [conn2] SASL SCRAM-SHA-1 authentication failed for root on testdb from client 172.29.0.1:36628 ; UserNotFound: Could not find user 'root' for db 'testdb' </code></pre>  <p>What am I doing wrong? I tried to remove all containers with <code>docker system prune</code> and run it again but it still gives the same error.</p> ",
    "OwnerUserId": "4650497",
    "LastEditorUserId": "4650497",
    "LastEditDate": "2020-03-31T07:46:33.423",
    "LastActivityDate": "2020-03-31T22:49:43.027",
    "Title": "Mongodb with docker-compose - create user",
    "Tags": "<mongodb><spring-boot><docker><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "60945565",
    "PostTypeId": "1",
    "AcceptedAnswerId": "60961132",
    "CreationDate": "2020-03-31T07:40:57.793",
    "Score": "6",
    "ViewCount": "3085",
    "Body": "<p>This is my docker-compose.yaml:</p>  <pre><code>version: '2.0' services:   mongo_container:     image: mongo:latest     environment:       MONGO_INITDB_ROOT_USERNAME: root       MONGO_INITDB_ROOT_PASSWORD: example       MONGO_INITDB_DATABASE: testdb     ports:       - '27017:27017'     volumes:       - ./mongodata:/data/db </code></pre>  <p>And this in my spring configuration:</p>  <pre><code>spring.data.mongodb.host=localhost spring.data.mongodb.port=27017 spring.data.mongodb.username=root spring.data.mongodb.password=example spring.data.mongodb.database=testdb </code></pre>  <p>But everytime when I try to connect my app to Mongo I get following error in Docker console:</p>  <pre><code>mongo_container_1  | 2020-03-31T07:37:24.803+0000 I  ACCESS   [conn2] SASL SCRAM-SHA-1 authentication failed for root on testdb from client 172.29.0.1:36628 ; UserNotFound: Could not find user 'root' for db 'testdb' </code></pre>  <p>What am I doing wrong? I tried to remove all containers with <code>docker system prune</code> and run it again but it still gives the same error.</p> ",
    "OwnerUserId": "4650497",
    "LastEditorUserId": "4650497",
    "LastEditDate": "2020-03-31T07:46:33.423",
    "LastActivityDate": "2020-03-31T22:49:43.027",
    "Title": "Mongodb with docker-compose - create user",
    "Tags": "<mongodb><spring-boot><docker><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "77385146",
    "PostTypeId": "1",
    "AcceptedAnswerId": "77393967",
    "CreationDate": "2023-10-29T20:48:18.027",
    "Score": "6",
    "ViewCount": "2443",
    "Body": "<p>I tried to remake a SpringBoot project from scratch, and i met this error <code>spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning</code> and nothing that i found online worked. I tried to reinstall docker and now all of my projects wont start. i always get this error in my terminal:</p> <pre><code>Cannot invoke &quot;org.springframework.boot.docker.compose.core.DockerCliInspectResponse.hostConfig()&quot; because &quot;inspectResponse&quot; is null     at org.springframework.boot.docker.compose.core.DefaultConnectionPorts.isHostNetworkMode(DefaultConnectionPorts.java:56) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.core.DefaultConnectionPorts.&lt;init&gt;(DefaultConnectionPorts.java:47) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.core.DefaultRunningService.&lt;init&gt;(DefaultRunningService.java:55) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.core.DefaultDockerCompose.getRunningServices(DefaultDockerCompose.java:83) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.lifecycle.DockerComposeLifecycleManager.start(DockerComposeLifecycleManager.java:120) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.lifecycle.DockerComposeListener.onApplicationEvent(DockerComposeListener.java:53) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.lifecycle.DockerComposeListener.onApplicationEvent(DockerComposeListener.java:35) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) ~[spring-context-6.0.11.jar:6.0.11]     at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) ~[spring-context-6.0.11.jar:6.0.11]     at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:143) ~[spring-context-6.0.11.jar:6.0.11]     at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:131) ~[spring-context-6.0.11.jar:6.0.11]     at org.springframework.boot.context.event.EventPublishingRunListener.multicastInitialEvent(EventPublishingRunListener.java:136) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.context.event.EventPublishingRunListener.contextLoaded(EventPublishingRunListener.java:98) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplicationRunListeners.lambda$contextLoaded$4(SpringApplicationRunListeners.java:72) ~[spring-boot-3.1.2.jar:3.1.2]     at java.base/java.lang.Iterable.forEach(Iterable.java:75) ~[na:na]     at org.springframework.boot.SpringApplicationRunListeners.doWithListeners(SpringApplicationRunListeners.java:118) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplicationRunListeners.doWithListeners(SpringApplicationRunListeners.java:112) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplicationRunListeners.contextLoaded(SpringApplicationRunListeners.java:72) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplication.prepareContext(SpringApplication.java:416) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplication.run(SpringApplication.java:311) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295) ~[spring-boot-3.1.2.jar:3.1.2]     at com.example.springboot3jwtauthenticationserver.SpringBoot3JwtAuthenticationServerApplication.main(SpringBoot3JwtAuthenticationServerApplication.java:10) ~[classes/:na]     at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]     at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) ~[na:na]     at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]     at java.base/java.lang.reflect.Method.invoke(Method.java:568) ~[na:na]     at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:50) ~[spring-boot-devtools-3.1.2.jar:3.1.2] </code></pre> <p>Does anyone have a solution?</p> ",
    "OwnerUserId": "13436670",
    "LastActivityDate": "2023-11-09T19:34:18.873",
    "Title": "Springboot-docker error: cannot invoke 'DockerCliInspectResponse.hostConfig()' because 'inspectResponse' is null",
    "Tags": "<spring-boot><docker><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "77385146",
    "PostTypeId": "1",
    "AcceptedAnswerId": "77393967",
    "CreationDate": "2023-10-29T20:48:18.027",
    "Score": "6",
    "ViewCount": "2443",
    "Body": "<p>I tried to remake a SpringBoot project from scratch, and i met this error <code>spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning</code> and nothing that i found online worked. I tried to reinstall docker and now all of my projects wont start. i always get this error in my terminal:</p> <pre><code>Cannot invoke &quot;org.springframework.boot.docker.compose.core.DockerCliInspectResponse.hostConfig()&quot; because &quot;inspectResponse&quot; is null     at org.springframework.boot.docker.compose.core.DefaultConnectionPorts.isHostNetworkMode(DefaultConnectionPorts.java:56) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.core.DefaultConnectionPorts.&lt;init&gt;(DefaultConnectionPorts.java:47) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.core.DefaultRunningService.&lt;init&gt;(DefaultRunningService.java:55) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.core.DefaultDockerCompose.getRunningServices(DefaultDockerCompose.java:83) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.lifecycle.DockerComposeLifecycleManager.start(DockerComposeLifecycleManager.java:120) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.lifecycle.DockerComposeListener.onApplicationEvent(DockerComposeListener.java:53) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.lifecycle.DockerComposeListener.onApplicationEvent(DockerComposeListener.java:35) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) ~[spring-context-6.0.11.jar:6.0.11]     at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) ~[spring-context-6.0.11.jar:6.0.11]     at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:143) ~[spring-context-6.0.11.jar:6.0.11]     at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:131) ~[spring-context-6.0.11.jar:6.0.11]     at org.springframework.boot.context.event.EventPublishingRunListener.multicastInitialEvent(EventPublishingRunListener.java:136) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.context.event.EventPublishingRunListener.contextLoaded(EventPublishingRunListener.java:98) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplicationRunListeners.lambda$contextLoaded$4(SpringApplicationRunListeners.java:72) ~[spring-boot-3.1.2.jar:3.1.2]     at java.base/java.lang.Iterable.forEach(Iterable.java:75) ~[na:na]     at org.springframework.boot.SpringApplicationRunListeners.doWithListeners(SpringApplicationRunListeners.java:118) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplicationRunListeners.doWithListeners(SpringApplicationRunListeners.java:112) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplicationRunListeners.contextLoaded(SpringApplicationRunListeners.java:72) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplication.prepareContext(SpringApplication.java:416) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplication.run(SpringApplication.java:311) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295) ~[spring-boot-3.1.2.jar:3.1.2]     at com.example.springboot3jwtauthenticationserver.SpringBoot3JwtAuthenticationServerApplication.main(SpringBoot3JwtAuthenticationServerApplication.java:10) ~[classes/:na]     at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]     at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) ~[na:na]     at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]     at java.base/java.lang.reflect.Method.invoke(Method.java:568) ~[na:na]     at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:50) ~[spring-boot-devtools-3.1.2.jar:3.1.2] </code></pre> <p>Does anyone have a solution?</p> ",
    "OwnerUserId": "13436670",
    "LastActivityDate": "2023-11-09T19:34:18.873",
    "Title": "Springboot-docker error: cannot invoke 'DockerCliInspectResponse.hostConfig()' because 'inspectResponse' is null",
    "Tags": "<spring-boot><docker><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "77385146",
    "PostTypeId": "1",
    "AcceptedAnswerId": "77393967",
    "CreationDate": "2023-10-29T20:48:18.027",
    "Score": "6",
    "ViewCount": "2443",
    "Body": "<p>I tried to remake a SpringBoot project from scratch, and i met this error <code>spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning</code> and nothing that i found online worked. I tried to reinstall docker and now all of my projects wont start. i always get this error in my terminal:</p> <pre><code>Cannot invoke &quot;org.springframework.boot.docker.compose.core.DockerCliInspectResponse.hostConfig()&quot; because &quot;inspectResponse&quot; is null     at org.springframework.boot.docker.compose.core.DefaultConnectionPorts.isHostNetworkMode(DefaultConnectionPorts.java:56) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.core.DefaultConnectionPorts.&lt;init&gt;(DefaultConnectionPorts.java:47) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.core.DefaultRunningService.&lt;init&gt;(DefaultRunningService.java:55) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.core.DefaultDockerCompose.getRunningServices(DefaultDockerCompose.java:83) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.lifecycle.DockerComposeLifecycleManager.start(DockerComposeLifecycleManager.java:120) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.lifecycle.DockerComposeListener.onApplicationEvent(DockerComposeListener.java:53) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.lifecycle.DockerComposeListener.onApplicationEvent(DockerComposeListener.java:35) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) ~[spring-context-6.0.11.jar:6.0.11]     at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) ~[spring-context-6.0.11.jar:6.0.11]     at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:143) ~[spring-context-6.0.11.jar:6.0.11]     at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:131) ~[spring-context-6.0.11.jar:6.0.11]     at org.springframework.boot.context.event.EventPublishingRunListener.multicastInitialEvent(EventPublishingRunListener.java:136) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.context.event.EventPublishingRunListener.contextLoaded(EventPublishingRunListener.java:98) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplicationRunListeners.lambda$contextLoaded$4(SpringApplicationRunListeners.java:72) ~[spring-boot-3.1.2.jar:3.1.2]     at java.base/java.lang.Iterable.forEach(Iterable.java:75) ~[na:na]     at org.springframework.boot.SpringApplicationRunListeners.doWithListeners(SpringApplicationRunListeners.java:118) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplicationRunListeners.doWithListeners(SpringApplicationRunListeners.java:112) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplicationRunListeners.contextLoaded(SpringApplicationRunListeners.java:72) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplication.prepareContext(SpringApplication.java:416) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplication.run(SpringApplication.java:311) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295) ~[spring-boot-3.1.2.jar:3.1.2]     at com.example.springboot3jwtauthenticationserver.SpringBoot3JwtAuthenticationServerApplication.main(SpringBoot3JwtAuthenticationServerApplication.java:10) ~[classes/:na]     at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]     at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) ~[na:na]     at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]     at java.base/java.lang.reflect.Method.invoke(Method.java:568) ~[na:na]     at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:50) ~[spring-boot-devtools-3.1.2.jar:3.1.2] </code></pre> <p>Does anyone have a solution?</p> ",
    "OwnerUserId": "13436670",
    "LastActivityDate": "2023-11-09T19:34:18.873",
    "Title": "Springboot-docker error: cannot invoke 'DockerCliInspectResponse.hostConfig()' because 'inspectResponse' is null",
    "Tags": "<spring-boot><docker><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "39967945",
    "PostTypeId": "1",
    "CreationDate": "2016-10-10T22:53:52.573",
    "Score": "5",
    "ViewCount": "4195",
    "Body": "<p>I have a spring-boot app which talks to couchbase. I build the spring app as a docker image. There are some preconditions that need to be fulfilled in couchbase set up in order for the app to run. When I run my couchbase image first and then run my spring-boot app image everything runs fine. However, I need this to be automated and run from a docker-compose file meaning by a single docker-compose up command I should be able to run the couchbase image first, configure it with all presettings and then start to run the spring-boot app. I ran into quite a few discussion threads, but unfortunately I am not able to make it work somehow. I tried using cmd and entrypoint, but without success. Here is my docker-compose file</p>  <pre><code>version: '2' services:   expensetracker-cb:     image: chakrar27/expensetracker-cb     command: sh test_hello.sh     ports:       - 8080:8080     depends_on:       - mycouchbase    mycouchbase:     image: chakrar27/couchbase_new_10_08_2016     ports:       - 8091:8091       - 8092:8092        - 8093:8093        - 8094:8094       - 11210:11210 </code></pre>  <p>In fact it doesn't trigger the test_hello.sh at all. Here's the dockerfile for the spring-boot expensetracker app</p>  <pre><code>FROM frolvlad/alpine-oraclejdk8:slim VOLUME /tmp ADD expensetracker-cb-0.1.0.jar app.jar RUN sh -c 'touch /app.jar' ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre>  <p>Can someone please help? </p> ",
    "OwnerUserId": "2943994",
    "LastEditorUserId": "5237",
    "LastEditDate": "2019-11-12T16:07:07.140",
    "LastActivityDate": "2019-11-12T16:07:07.140",
    "Title": "How do i wait for a db container to be up before my spring-boot app starts",
    "Tags": "<spring-boot><docker><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "39967945",
    "PostTypeId": "1",
    "CreationDate": "2016-10-10T22:53:52.573",
    "Score": "5",
    "ViewCount": "4195",
    "Body": "<p>I have a spring-boot app which talks to couchbase. I build the spring app as a docker image. There are some preconditions that need to be fulfilled in couchbase set up in order for the app to run. When I run my couchbase image first and then run my spring-boot app image everything runs fine. However, I need this to be automated and run from a docker-compose file meaning by a single docker-compose up command I should be able to run the couchbase image first, configure it with all presettings and then start to run the spring-boot app. I ran into quite a few discussion threads, but unfortunately I am not able to make it work somehow. I tried using cmd and entrypoint, but without success. Here is my docker-compose file</p>  <pre><code>version: '2' services:   expensetracker-cb:     image: chakrar27/expensetracker-cb     command: sh test_hello.sh     ports:       - 8080:8080     depends_on:       - mycouchbase    mycouchbase:     image: chakrar27/couchbase_new_10_08_2016     ports:       - 8091:8091       - 8092:8092        - 8093:8093        - 8094:8094       - 11210:11210 </code></pre>  <p>In fact it doesn't trigger the test_hello.sh at all. Here's the dockerfile for the spring-boot expensetracker app</p>  <pre><code>FROM frolvlad/alpine-oraclejdk8:slim VOLUME /tmp ADD expensetracker-cb-0.1.0.jar app.jar RUN sh -c 'touch /app.jar' ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre>  <p>Can someone please help? </p> ",
    "OwnerUserId": "2943994",
    "LastEditorUserId": "5237",
    "LastEditDate": "2019-11-12T16:07:07.140",
    "LastActivityDate": "2019-11-12T16:07:07.140",
    "Title": "How do i wait for a db container to be up before my spring-boot app starts",
    "Tags": "<spring-boot><docker><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "39967945",
    "PostTypeId": "1",
    "CreationDate": "2016-10-10T22:53:52.573",
    "Score": "5",
    "ViewCount": "4195",
    "Body": "<p>I have a spring-boot app which talks to couchbase. I build the spring app as a docker image. There are some preconditions that need to be fulfilled in couchbase set up in order for the app to run. When I run my couchbase image first and then run my spring-boot app image everything runs fine. However, I need this to be automated and run from a docker-compose file meaning by a single docker-compose up command I should be able to run the couchbase image first, configure it with all presettings and then start to run the spring-boot app. I ran into quite a few discussion threads, but unfortunately I am not able to make it work somehow. I tried using cmd and entrypoint, but without success. Here is my docker-compose file</p>  <pre><code>version: '2' services:   expensetracker-cb:     image: chakrar27/expensetracker-cb     command: sh test_hello.sh     ports:       - 8080:8080     depends_on:       - mycouchbase    mycouchbase:     image: chakrar27/couchbase_new_10_08_2016     ports:       - 8091:8091       - 8092:8092        - 8093:8093        - 8094:8094       - 11210:11210 </code></pre>  <p>In fact it doesn't trigger the test_hello.sh at all. Here's the dockerfile for the spring-boot expensetracker app</p>  <pre><code>FROM frolvlad/alpine-oraclejdk8:slim VOLUME /tmp ADD expensetracker-cb-0.1.0.jar app.jar RUN sh -c 'touch /app.jar' ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre>  <p>Can someone please help? </p> ",
    "OwnerUserId": "2943994",
    "LastEditorUserId": "5237",
    "LastEditDate": "2019-11-12T16:07:07.140",
    "LastActivityDate": "2019-11-12T16:07:07.140",
    "Title": "How do i wait for a db container to be up before my spring-boot app starts",
    "Tags": "<spring-boot><docker><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "46315744",
    "PostTypeId": "1",
    "AcceptedAnswerId": "46318061",
    "CreationDate": "2017-09-20T07:26:30.170",
    "Score": "5",
    "ViewCount": "13670",
    "Body": "<p>I've got a spring boot application which uses <code>com.spotify.dockerfile-maven-plugin</code> to build a docker image of my application org.rtu/some-importer</p>  <p>My docker-compose.yml is:</p>  <pre><code>version: '3' services:   some-importer:     image: org.rtu/some-importer     build: .   zookeeper:     image: wurstmeister/zookeeper     ports:       - '2181:2181'   kafka:      image: wurstmeister/kafka     ports:       - '9092:9092'     environment:       KAFKA_ADVERTISED_HOST_NAME: 172.17.0.1       KAFKA_CREATE_TOPICS: 'test:1:1'       KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181     volumes:       - /var/run/docker.sock:/var/run/docker.sock </code></pre>  <p>How can I say the during <code>docker-compose up</code> that it should be used an external <code>config.properties</code> from <code>/data/some-importer/config</code> folder?</p> ",
    "OwnerUserId": "1485401",
    "LastActivityDate": "2017-09-20T09:37:34.470",
    "Title": "Using external config in spring boot application within docker-compose",
    "Tags": "<spring><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "1",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "46315744",
    "PostTypeId": "1",
    "AcceptedAnswerId": "46318061",
    "CreationDate": "2017-09-20T07:26:30.170",
    "Score": "5",
    "ViewCount": "13670",
    "Body": "<p>I've got a spring boot application which uses <code>com.spotify.dockerfile-maven-plugin</code> to build a docker image of my application org.rtu/some-importer</p>  <p>My docker-compose.yml is:</p>  <pre><code>version: '3' services:   some-importer:     image: org.rtu/some-importer     build: .   zookeeper:     image: wurstmeister/zookeeper     ports:       - '2181:2181'   kafka:      image: wurstmeister/kafka     ports:       - '9092:9092'     environment:       KAFKA_ADVERTISED_HOST_NAME: 172.17.0.1       KAFKA_CREATE_TOPICS: 'test:1:1'       KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181     volumes:       - /var/run/docker.sock:/var/run/docker.sock </code></pre>  <p>How can I say the during <code>docker-compose up</code> that it should be used an external <code>config.properties</code> from <code>/data/some-importer/config</code> folder?</p> ",
    "OwnerUserId": "1485401",
    "LastActivityDate": "2017-09-20T09:37:34.470",
    "Title": "Using external config in spring boot application within docker-compose",
    "Tags": "<spring><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "1",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "46315744",
    "PostTypeId": "1",
    "AcceptedAnswerId": "46318061",
    "CreationDate": "2017-09-20T07:26:30.170",
    "Score": "5",
    "ViewCount": "13670",
    "Body": "<p>I've got a spring boot application which uses <code>com.spotify.dockerfile-maven-plugin</code> to build a docker image of my application org.rtu/some-importer</p>  <p>My docker-compose.yml is:</p>  <pre><code>version: '3' services:   some-importer:     image: org.rtu/some-importer     build: .   zookeeper:     image: wurstmeister/zookeeper     ports:       - '2181:2181'   kafka:      image: wurstmeister/kafka     ports:       - '9092:9092'     environment:       KAFKA_ADVERTISED_HOST_NAME: 172.17.0.1       KAFKA_CREATE_TOPICS: 'test:1:1'       KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181     volumes:       - /var/run/docker.sock:/var/run/docker.sock </code></pre>  <p>How can I say the during <code>docker-compose up</code> that it should be used an external <code>config.properties</code> from <code>/data/some-importer/config</code> folder?</p> ",
    "OwnerUserId": "1485401",
    "LastActivityDate": "2017-09-20T09:37:34.470",
    "Title": "Using external config in spring boot application within docker-compose",
    "Tags": "<spring><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "1",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "48121123",
    "PostTypeId": "1",
    "AcceptedAnswerId": "66119737",
    "CreationDate": "2018-01-05T20:53:38.520",
    "Score": "5",
    "ViewCount": "3706",
    "Body": "<pre><code>creditcard-monk:  build:   context: ./creditcard   dockerfile: Dockerfile   args:     JAR_FILE: target/creditcard-1.0.0.jar </code></pre>  <p>Docker compose version 3.0. The jar_file argument is used to copy the jar-file to spring-boot jar under docker container</p>  <p>I get the error <code>failed to build: COPY failed: stat /var/lib/docker/tmp/docker-builder347176151/target/creditcard-1.0.0.jar: no such file or directory</code></p>  <p>i thought the mentioning of context ,will read jar from target folder .but it seems docker-compose is not reading the file from context specified</p>  <p>Please help. Note:- the docker file is simple, built from alpine-java-8 and a copy command to copy jar to container to start spring boot app</p> ",
    "OwnerUserId": "1132758",
    "LastActivityDate": "2021-02-09T13:14:08.253",
    "Title": "Docker compose build relative path",
    "Tags": "<java><docker><spring-boot><build><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "48121123",
    "PostTypeId": "1",
    "AcceptedAnswerId": "66119737",
    "CreationDate": "2018-01-05T20:53:38.520",
    "Score": "5",
    "ViewCount": "3706",
    "Body": "<pre><code>creditcard-monk:  build:   context: ./creditcard   dockerfile: Dockerfile   args:     JAR_FILE: target/creditcard-1.0.0.jar </code></pre>  <p>Docker compose version 3.0. The jar_file argument is used to copy the jar-file to spring-boot jar under docker container</p>  <p>I get the error <code>failed to build: COPY failed: stat /var/lib/docker/tmp/docker-builder347176151/target/creditcard-1.0.0.jar: no such file or directory</code></p>  <p>i thought the mentioning of context ,will read jar from target folder .but it seems docker-compose is not reading the file from context specified</p>  <p>Please help. Note:- the docker file is simple, built from alpine-java-8 and a copy command to copy jar to container to start spring boot app</p> ",
    "OwnerUserId": "1132758",
    "LastActivityDate": "2021-02-09T13:14:08.253",
    "Title": "Docker compose build relative path",
    "Tags": "<java><docker><spring-boot><build><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "48121123",
    "PostTypeId": "1",
    "AcceptedAnswerId": "66119737",
    "CreationDate": "2018-01-05T20:53:38.520",
    "Score": "5",
    "ViewCount": "3706",
    "Body": "<pre><code>creditcard-monk:  build:   context: ./creditcard   dockerfile: Dockerfile   args:     JAR_FILE: target/creditcard-1.0.0.jar </code></pre>  <p>Docker compose version 3.0. The jar_file argument is used to copy the jar-file to spring-boot jar under docker container</p>  <p>I get the error <code>failed to build: COPY failed: stat /var/lib/docker/tmp/docker-builder347176151/target/creditcard-1.0.0.jar: no such file or directory</code></p>  <p>i thought the mentioning of context ,will read jar from target folder .but it seems docker-compose is not reading the file from context specified</p>  <p>Please help. Note:- the docker file is simple, built from alpine-java-8 and a copy command to copy jar to container to start spring boot app</p> ",
    "OwnerUserId": "1132758",
    "LastActivityDate": "2021-02-09T13:14:08.253",
    "Title": "Docker compose build relative path",
    "Tags": "<java><docker><spring-boot><build><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 3.0"
  },
  {
    "Id": "50573224",
    "PostTypeId": "1",
    "AcceptedAnswerId": "50575615",
    "CreationDate": "2018-05-28T20:41:53.570",
    "Score": "5",
    "ViewCount": "4313",
    "Body": "<p>I'm trying to run a Spring Boot app as one of the services in a Docker Compose setup, but whenever I run <code>docker-compose up -d</code> the container running the Spring Boot app fails and exits immediately. For purposes of this post I'm using generic names like 'mycontainer' and 'myfile'.</p>  <p>Running <code>docker-compose logs core</code> shows that the error message is:</p>  <p><code>mycontainer | Error: unable to access jarfile myjar.jar</code></p>  <p>My docker-compose file is:</p>  <pre><code>version: '3.3'  services:   webapp:     image: webapp_image     container_name: webapp-container     build:       context: ./webapp       dockerfile: Dockerfile     volumes:       - './webapp:/usr/src/app'     ports:       - 3000:3000       - 35729:35729     environment:       - NODE_ENV=development       - env_file=./webapp/.env    core:     image: core_image     container_name: core-container     build:       context: ./core       dockerfile: Dockerfile     volumes:       - './core:/usr/src/core'       - './algorithms:/usr/src/algorithms'     ports:       - 8080:8080     environment:       - JARFILE=myjar.jar       - JAVA_OPTIONS=-Djava.security.egd=file:/dev/./urandom </code></pre>  <p>The Dockerfile for the <code>core</code> service, which is the one running the Spring Boot app, is this:</p>  <pre><code>FROM openjdk:8-jdk-alpine RUN mkdir -p /usr/src/core RUN mkdir -p /usr/src/algorithms ADD ./myproject/target/myjar.jar /usr/src/core ADD ./algorithms /usr/src/algorithms WORKDIR /usr/src/core  CMD java $JAVA_OPTIONS -jar $JARFILE </code></pre>  <p>If I run an individual container from the <code>core_image</code> image, and set the same environment vars that I defined in the docker-compose file, I can launch the Spring Boot app successfully, like so:</p>  <pre><code>$ docker run -it -p 8080:8080 --name mycontainer core_image sh $ /usr/src/core # ls -l total 15852 -rwxr-xr-x    1 root     root      16228579 Apr 21 22:44 myjar.jar $ /usr/src/core # java $JAVA_OPTIONS -jar $JARFILE </code></pre>  <p>But if I run a container from the same image as part of <code>docker-compose up -d</code> the container fails with the error that Java couldn't access the jarfile. I've tried specifying the absolute path to the jarfile in the <code>CMD</code> of the Dockerfile, but that doesn't help when running from Docker Compose.</p>  <p>Does anyone know what might be causing this? I'm on a Windows 10 host. Any help is greatly appreciated.</p> ",
    "OwnerUserId": "1565742",
    "LastActivityDate": "2018-05-29T02:43:23.803",
    "Title": "docker-compose java cannot access jarfile",
    "Tags": "<java><shell><docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "50573224",
    "PostTypeId": "1",
    "AcceptedAnswerId": "50575615",
    "CreationDate": "2018-05-28T20:41:53.570",
    "Score": "5",
    "ViewCount": "4313",
    "Body": "<p>I'm trying to run a Spring Boot app as one of the services in a Docker Compose setup, but whenever I run <code>docker-compose up -d</code> the container running the Spring Boot app fails and exits immediately. For purposes of this post I'm using generic names like 'mycontainer' and 'myfile'.</p>  <p>Running <code>docker-compose logs core</code> shows that the error message is:</p>  <p><code>mycontainer | Error: unable to access jarfile myjar.jar</code></p>  <p>My docker-compose file is:</p>  <pre><code>version: '3.3'  services:   webapp:     image: webapp_image     container_name: webapp-container     build:       context: ./webapp       dockerfile: Dockerfile     volumes:       - './webapp:/usr/src/app'     ports:       - 3000:3000       - 35729:35729     environment:       - NODE_ENV=development       - env_file=./webapp/.env    core:     image: core_image     container_name: core-container     build:       context: ./core       dockerfile: Dockerfile     volumes:       - './core:/usr/src/core'       - './algorithms:/usr/src/algorithms'     ports:       - 8080:8080     environment:       - JARFILE=myjar.jar       - JAVA_OPTIONS=-Djava.security.egd=file:/dev/./urandom </code></pre>  <p>The Dockerfile for the <code>core</code> service, which is the one running the Spring Boot app, is this:</p>  <pre><code>FROM openjdk:8-jdk-alpine RUN mkdir -p /usr/src/core RUN mkdir -p /usr/src/algorithms ADD ./myproject/target/myjar.jar /usr/src/core ADD ./algorithms /usr/src/algorithms WORKDIR /usr/src/core  CMD java $JAVA_OPTIONS -jar $JARFILE </code></pre>  <p>If I run an individual container from the <code>core_image</code> image, and set the same environment vars that I defined in the docker-compose file, I can launch the Spring Boot app successfully, like so:</p>  <pre><code>$ docker run -it -p 8080:8080 --name mycontainer core_image sh $ /usr/src/core # ls -l total 15852 -rwxr-xr-x    1 root     root      16228579 Apr 21 22:44 myjar.jar $ /usr/src/core # java $JAVA_OPTIONS -jar $JARFILE </code></pre>  <p>But if I run a container from the same image as part of <code>docker-compose up -d</code> the container fails with the error that Java couldn't access the jarfile. I've tried specifying the absolute path to the jarfile in the <code>CMD</code> of the Dockerfile, but that doesn't help when running from Docker Compose.</p>  <p>Does anyone know what might be causing this? I'm on a Windows 10 host. Any help is greatly appreciated.</p> ",
    "OwnerUserId": "1565742",
    "LastActivityDate": "2018-05-29T02:43:23.803",
    "Title": "docker-compose java cannot access jarfile",
    "Tags": "<java><shell><docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "50573224",
    "PostTypeId": "1",
    "AcceptedAnswerId": "50575615",
    "CreationDate": "2018-05-28T20:41:53.570",
    "Score": "5",
    "ViewCount": "4313",
    "Body": "<p>I'm trying to run a Spring Boot app as one of the services in a Docker Compose setup, but whenever I run <code>docker-compose up -d</code> the container running the Spring Boot app fails and exits immediately. For purposes of this post I'm using generic names like 'mycontainer' and 'myfile'.</p>  <p>Running <code>docker-compose logs core</code> shows that the error message is:</p>  <p><code>mycontainer | Error: unable to access jarfile myjar.jar</code></p>  <p>My docker-compose file is:</p>  <pre><code>version: '3.3'  services:   webapp:     image: webapp_image     container_name: webapp-container     build:       context: ./webapp       dockerfile: Dockerfile     volumes:       - './webapp:/usr/src/app'     ports:       - 3000:3000       - 35729:35729     environment:       - NODE_ENV=development       - env_file=./webapp/.env    core:     image: core_image     container_name: core-container     build:       context: ./core       dockerfile: Dockerfile     volumes:       - './core:/usr/src/core'       - './algorithms:/usr/src/algorithms'     ports:       - 8080:8080     environment:       - JARFILE=myjar.jar       - JAVA_OPTIONS=-Djava.security.egd=file:/dev/./urandom </code></pre>  <p>The Dockerfile for the <code>core</code> service, which is the one running the Spring Boot app, is this:</p>  <pre><code>FROM openjdk:8-jdk-alpine RUN mkdir -p /usr/src/core RUN mkdir -p /usr/src/algorithms ADD ./myproject/target/myjar.jar /usr/src/core ADD ./algorithms /usr/src/algorithms WORKDIR /usr/src/core  CMD java $JAVA_OPTIONS -jar $JARFILE </code></pre>  <p>If I run an individual container from the <code>core_image</code> image, and set the same environment vars that I defined in the docker-compose file, I can launch the Spring Boot app successfully, like so:</p>  <pre><code>$ docker run -it -p 8080:8080 --name mycontainer core_image sh $ /usr/src/core # ls -l total 15852 -rwxr-xr-x    1 root     root      16228579 Apr 21 22:44 myjar.jar $ /usr/src/core # java $JAVA_OPTIONS -jar $JARFILE </code></pre>  <p>But if I run a container from the same image as part of <code>docker-compose up -d</code> the container fails with the error that Java couldn't access the jarfile. I've tried specifying the absolute path to the jarfile in the <code>CMD</code> of the Dockerfile, but that doesn't help when running from Docker Compose.</p>  <p>Does anyone know what might be causing this? I'm on a Windows 10 host. Any help is greatly appreciated.</p> ",
    "OwnerUserId": "1565742",
    "LastActivityDate": "2018-05-29T02:43:23.803",
    "Title": "docker-compose java cannot access jarfile",
    "Tags": "<java><shell><docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "51176617",
    "PostTypeId": "1",
    "CreationDate": "2018-07-04T15:04:48.813",
    "Score": "5",
    "ViewCount": "8918",
    "Body": "<p>I've looked at SO posts related to this questions <a href='https://stackoverflow.com/questions/48350843/how-to-connect-from-docker-compose-to-host-postgresql'>here</a>, <a href='https://stackoverflow.com/questions/38199851/mongodb-connection-refused-docker-compose'>here</a>, <a href='https://stackoverflow.com/questions/45122028/docker-compose-up-connection-refused'>here</a>, and <a href='https://stackoverflow.com/questions/33357567/econnrefused-for-postgres-on-nodejs-with-dockers'>here</a> but I haven't had any luck with the fixes proposed.  Whenever I run the command <code>docker-compose -f stack.yml up</code> I receive the following stack trace:</p>  <pre><code>Attaching to weg-api_db_1, weg-api_weg-api_1 db_1       | 2018-07-04 14:57:15.384 UTC [1] LOG:  listening on IPv4 address '0.0.0.0', port 5432 db_1       | 2018-07-04 14:57:15.384 UTC [1] LOG:  listening on IPv6 address '::', port 5432 db_1       | 2018-07-04 14:57:15.388 UTC [1] LOG:  listening on Unix socket '/var/run/postgresql/.s.PGSQL.5432' db_1       | 2018-07-04 14:57:15.402 UTC [23] LOG:  database system was interrupted; last known up at 2018-07-04 14:45:24 UTC db_1       | 2018-07-04 14:57:15.513 UTC [23] LOG:  database system was not properly shut down; automatic recovery in progress db_1       | 2018-07-04 14:57:15.515 UTC [23] LOG:  redo starts at 0/16341E0 db_1       | 2018-07-04 14:57:15.515 UTC [23] LOG:  invalid record length at 0/1634218: wanted 24, got 0 db_1       | 2018-07-04 14:57:15.515 UTC [23] LOG:  redo done at 0/16341E0 db_1       | 2018-07-04 14:57:15.525 UTC [1] LOG:  database system is ready to accept connections weg-api_1  |  weg-api_1  |   .   ____          _            __ _ _ weg-api_1  |  /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\ weg-api_1  | ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ weg-api_1  |  \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) ) weg-api_1  |   '  |____| .__|_| |_|_| |_\\__, | / / / / weg-api_1  |  =========|_|==============|___/=/_/_/_/ weg-api_1  |  :: Spring Boot ::        (v1.5.3.RELEASE) weg-api_1  |  weg-api_1  | 2018-07-04 14:57:16.908  INFO 7 --- [           main] api.ApiKt                                : Starting ApiKt v0.0.1-SNAPSHOT on f9c58f4f2f27 with PID 7 (/app/spring-jpa-postgresql-spring-boot-0.0.1-SNAPSHOT.jar started by root in /app) weg-api_1  | 2018-07-04 14:57:16.913  INFO 7 --- [           main] api.ApiKt                                : No active profile set, falling back to default profiles: default weg-api_1  | 2018-07-04 14:57:17.008  INFO 7 --- [           main] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@6e5e91e4: startup date [Wed Jul 04 14:57:17 GMT 2018]; root of context hierarchy weg-api_1  | 2018-07-04 14:57:19.082  INFO 7 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http) weg-api_1  | 2018-07-04 14:57:19.102  INFO 7 --- [           main] o.apache.catalina.core.StandardService   : Starting service Tomcat weg-api_1  | 2018-07-04 14:57:19.104  INFO 7 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/8.5.14 weg-api_1  | 2018-07-04 14:57:19.215  INFO 7 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext weg-api_1  | 2018-07-04 14:57:19.215  INFO 7 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 2211 ms weg-api_1  | 2018-07-04 14:57:19.370  INFO 7 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean  : Mapping servlet: 'dispatcherServlet' to [/] weg-api_1  | 2018-07-04 14:57:19.375  INFO 7 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'characterEncodingFilter' to: [/*] weg-api_1  | 2018-07-04 14:57:19.376  INFO 7 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'hiddenHttpMethodFilter' to: [/*] weg-api_1  | 2018-07-04 14:57:19.376  INFO 7 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'httpPutFormContentFilter' to: [/*] weg-api_1  | 2018-07-04 14:57:19.376  INFO 7 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'requestContextFilter' to: [/*] weg-api_1  | 2018-07-04 14:57:19.867 ERROR 7 --- [           main] o.a.tomcat.jdbc.pool.ConnectionPool      : Unable to create initial connections of pool. weg-api_1  |  weg-api_1  | org.postgresql.util.PSQLException: Connection to localhost:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections. </code></pre>  <p>I thought that my .yml file was brain-dead-simple, but I must be missing something vital for the internal routing between the two containers to fail.  </p>  <p><strong>EDIT</strong></p>  <p>My stack.yml is below:</p>  <pre><code>version: '3' services:   db:     image: postgres     restart: always     container_name: db     environment:       POSTGRES_USER: root       POSTGRES_PASSWORD: password       POSTGRES_DB: weg     ports:       - '5432:5432'   weg-api:     image: weg-api     restart: always     container_name: weg-api     ports:       - '8080:8080'     depends_on:       - 'db' </code></pre>  <p><strong>EDIT</strong></p>  <p>My Springboot application properties are below:</p>  <pre><code>spring.datasource.url=jdbc:postgresql://db:5432/weg spring.datasource.username=root spring.datasource.password=password spring.jpa.generate-ddl=true </code></pre>  <p>I'm at a loss as to how to proceed.</p> ",
    "OwnerUserId": "4520965",
    "LastEditorUserId": "4520965",
    "LastEditDate": "2018-07-05T16:34:07.173",
    "LastActivityDate": "2018-07-05T16:34:07.173",
    "Title": "Running docker compose causes 'Connection to localhost:5432 refused.' exception",
    "Tags": "<postgresql><docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "51176617",
    "PostTypeId": "1",
    "CreationDate": "2018-07-04T15:04:48.813",
    "Score": "5",
    "ViewCount": "8918",
    "Body": "<p>I've looked at SO posts related to this questions <a href='https://stackoverflow.com/questions/48350843/how-to-connect-from-docker-compose-to-host-postgresql'>here</a>, <a href='https://stackoverflow.com/questions/38199851/mongodb-connection-refused-docker-compose'>here</a>, <a href='https://stackoverflow.com/questions/45122028/docker-compose-up-connection-refused'>here</a>, and <a href='https://stackoverflow.com/questions/33357567/econnrefused-for-postgres-on-nodejs-with-dockers'>here</a> but I haven't had any luck with the fixes proposed.  Whenever I run the command <code>docker-compose -f stack.yml up</code> I receive the following stack trace:</p>  <pre><code>Attaching to weg-api_db_1, weg-api_weg-api_1 db_1       | 2018-07-04 14:57:15.384 UTC [1] LOG:  listening on IPv4 address '0.0.0.0', port 5432 db_1       | 2018-07-04 14:57:15.384 UTC [1] LOG:  listening on IPv6 address '::', port 5432 db_1       | 2018-07-04 14:57:15.388 UTC [1] LOG:  listening on Unix socket '/var/run/postgresql/.s.PGSQL.5432' db_1       | 2018-07-04 14:57:15.402 UTC [23] LOG:  database system was interrupted; last known up at 2018-07-04 14:45:24 UTC db_1       | 2018-07-04 14:57:15.513 UTC [23] LOG:  database system was not properly shut down; automatic recovery in progress db_1       | 2018-07-04 14:57:15.515 UTC [23] LOG:  redo starts at 0/16341E0 db_1       | 2018-07-04 14:57:15.515 UTC [23] LOG:  invalid record length at 0/1634218: wanted 24, got 0 db_1       | 2018-07-04 14:57:15.515 UTC [23] LOG:  redo done at 0/16341E0 db_1       | 2018-07-04 14:57:15.525 UTC [1] LOG:  database system is ready to accept connections weg-api_1  |  weg-api_1  |   .   ____          _            __ _ _ weg-api_1  |  /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\ weg-api_1  | ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ weg-api_1  |  \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) ) weg-api_1  |   '  |____| .__|_| |_|_| |_\\__, | / / / / weg-api_1  |  =========|_|==============|___/=/_/_/_/ weg-api_1  |  :: Spring Boot ::        (v1.5.3.RELEASE) weg-api_1  |  weg-api_1  | 2018-07-04 14:57:16.908  INFO 7 --- [           main] api.ApiKt                                : Starting ApiKt v0.0.1-SNAPSHOT on f9c58f4f2f27 with PID 7 (/app/spring-jpa-postgresql-spring-boot-0.0.1-SNAPSHOT.jar started by root in /app) weg-api_1  | 2018-07-04 14:57:16.913  INFO 7 --- [           main] api.ApiKt                                : No active profile set, falling back to default profiles: default weg-api_1  | 2018-07-04 14:57:17.008  INFO 7 --- [           main] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@6e5e91e4: startup date [Wed Jul 04 14:57:17 GMT 2018]; root of context hierarchy weg-api_1  | 2018-07-04 14:57:19.082  INFO 7 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http) weg-api_1  | 2018-07-04 14:57:19.102  INFO 7 --- [           main] o.apache.catalina.core.StandardService   : Starting service Tomcat weg-api_1  | 2018-07-04 14:57:19.104  INFO 7 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/8.5.14 weg-api_1  | 2018-07-04 14:57:19.215  INFO 7 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext weg-api_1  | 2018-07-04 14:57:19.215  INFO 7 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 2211 ms weg-api_1  | 2018-07-04 14:57:19.370  INFO 7 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean  : Mapping servlet: 'dispatcherServlet' to [/] weg-api_1  | 2018-07-04 14:57:19.375  INFO 7 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'characterEncodingFilter' to: [/*] weg-api_1  | 2018-07-04 14:57:19.376  INFO 7 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'hiddenHttpMethodFilter' to: [/*] weg-api_1  | 2018-07-04 14:57:19.376  INFO 7 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'httpPutFormContentFilter' to: [/*] weg-api_1  | 2018-07-04 14:57:19.376  INFO 7 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'requestContextFilter' to: [/*] weg-api_1  | 2018-07-04 14:57:19.867 ERROR 7 --- [           main] o.a.tomcat.jdbc.pool.ConnectionPool      : Unable to create initial connections of pool. weg-api_1  |  weg-api_1  | org.postgresql.util.PSQLException: Connection to localhost:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections. </code></pre>  <p>I thought that my .yml file was brain-dead-simple, but I must be missing something vital for the internal routing between the two containers to fail.  </p>  <p><strong>EDIT</strong></p>  <p>My stack.yml is below:</p>  <pre><code>version: '3' services:   db:     image: postgres     restart: always     container_name: db     environment:       POSTGRES_USER: root       POSTGRES_PASSWORD: password       POSTGRES_DB: weg     ports:       - '5432:5432'   weg-api:     image: weg-api     restart: always     container_name: weg-api     ports:       - '8080:8080'     depends_on:       - 'db' </code></pre>  <p><strong>EDIT</strong></p>  <p>My Springboot application properties are below:</p>  <pre><code>spring.datasource.url=jdbc:postgresql://db:5432/weg spring.datasource.username=root spring.datasource.password=password spring.jpa.generate-ddl=true </code></pre>  <p>I'm at a loss as to how to proceed.</p> ",
    "OwnerUserId": "4520965",
    "LastEditorUserId": "4520965",
    "LastEditDate": "2018-07-05T16:34:07.173",
    "LastActivityDate": "2018-07-05T16:34:07.173",
    "Title": "Running docker compose causes 'Connection to localhost:5432 refused.' exception",
    "Tags": "<postgresql><docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "51176617",
    "PostTypeId": "1",
    "CreationDate": "2018-07-04T15:04:48.813",
    "Score": "5",
    "ViewCount": "8918",
    "Body": "<p>I've looked at SO posts related to this questions <a href='https://stackoverflow.com/questions/48350843/how-to-connect-from-docker-compose-to-host-postgresql'>here</a>, <a href='https://stackoverflow.com/questions/38199851/mongodb-connection-refused-docker-compose'>here</a>, <a href='https://stackoverflow.com/questions/45122028/docker-compose-up-connection-refused'>here</a>, and <a href='https://stackoverflow.com/questions/33357567/econnrefused-for-postgres-on-nodejs-with-dockers'>here</a> but I haven't had any luck with the fixes proposed.  Whenever I run the command <code>docker-compose -f stack.yml up</code> I receive the following stack trace:</p>  <pre><code>Attaching to weg-api_db_1, weg-api_weg-api_1 db_1       | 2018-07-04 14:57:15.384 UTC [1] LOG:  listening on IPv4 address '0.0.0.0', port 5432 db_1       | 2018-07-04 14:57:15.384 UTC [1] LOG:  listening on IPv6 address '::', port 5432 db_1       | 2018-07-04 14:57:15.388 UTC [1] LOG:  listening on Unix socket '/var/run/postgresql/.s.PGSQL.5432' db_1       | 2018-07-04 14:57:15.402 UTC [23] LOG:  database system was interrupted; last known up at 2018-07-04 14:45:24 UTC db_1       | 2018-07-04 14:57:15.513 UTC [23] LOG:  database system was not properly shut down; automatic recovery in progress db_1       | 2018-07-04 14:57:15.515 UTC [23] LOG:  redo starts at 0/16341E0 db_1       | 2018-07-04 14:57:15.515 UTC [23] LOG:  invalid record length at 0/1634218: wanted 24, got 0 db_1       | 2018-07-04 14:57:15.515 UTC [23] LOG:  redo done at 0/16341E0 db_1       | 2018-07-04 14:57:15.525 UTC [1] LOG:  database system is ready to accept connections weg-api_1  |  weg-api_1  |   .   ____          _            __ _ _ weg-api_1  |  /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\ weg-api_1  | ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ weg-api_1  |  \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) ) weg-api_1  |   '  |____| .__|_| |_|_| |_\\__, | / / / / weg-api_1  |  =========|_|==============|___/=/_/_/_/ weg-api_1  |  :: Spring Boot ::        (v1.5.3.RELEASE) weg-api_1  |  weg-api_1  | 2018-07-04 14:57:16.908  INFO 7 --- [           main] api.ApiKt                                : Starting ApiKt v0.0.1-SNAPSHOT on f9c58f4f2f27 with PID 7 (/app/spring-jpa-postgresql-spring-boot-0.0.1-SNAPSHOT.jar started by root in /app) weg-api_1  | 2018-07-04 14:57:16.913  INFO 7 --- [           main] api.ApiKt                                : No active profile set, falling back to default profiles: default weg-api_1  | 2018-07-04 14:57:17.008  INFO 7 --- [           main] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@6e5e91e4: startup date [Wed Jul 04 14:57:17 GMT 2018]; root of context hierarchy weg-api_1  | 2018-07-04 14:57:19.082  INFO 7 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http) weg-api_1  | 2018-07-04 14:57:19.102  INFO 7 --- [           main] o.apache.catalina.core.StandardService   : Starting service Tomcat weg-api_1  | 2018-07-04 14:57:19.104  INFO 7 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/8.5.14 weg-api_1  | 2018-07-04 14:57:19.215  INFO 7 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext weg-api_1  | 2018-07-04 14:57:19.215  INFO 7 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 2211 ms weg-api_1  | 2018-07-04 14:57:19.370  INFO 7 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean  : Mapping servlet: 'dispatcherServlet' to [/] weg-api_1  | 2018-07-04 14:57:19.375  INFO 7 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'characterEncodingFilter' to: [/*] weg-api_1  | 2018-07-04 14:57:19.376  INFO 7 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'hiddenHttpMethodFilter' to: [/*] weg-api_1  | 2018-07-04 14:57:19.376  INFO 7 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'httpPutFormContentFilter' to: [/*] weg-api_1  | 2018-07-04 14:57:19.376  INFO 7 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'requestContextFilter' to: [/*] weg-api_1  | 2018-07-04 14:57:19.867 ERROR 7 --- [           main] o.a.tomcat.jdbc.pool.ConnectionPool      : Unable to create initial connections of pool. weg-api_1  |  weg-api_1  | org.postgresql.util.PSQLException: Connection to localhost:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections. </code></pre>  <p>I thought that my .yml file was brain-dead-simple, but I must be missing something vital for the internal routing between the two containers to fail.  </p>  <p><strong>EDIT</strong></p>  <p>My stack.yml is below:</p>  <pre><code>version: '3' services:   db:     image: postgres     restart: always     container_name: db     environment:       POSTGRES_USER: root       POSTGRES_PASSWORD: password       POSTGRES_DB: weg     ports:       - '5432:5432'   weg-api:     image: weg-api     restart: always     container_name: weg-api     ports:       - '8080:8080'     depends_on:       - 'db' </code></pre>  <p><strong>EDIT</strong></p>  <p>My Springboot application properties are below:</p>  <pre><code>spring.datasource.url=jdbc:postgresql://db:5432/weg spring.datasource.username=root spring.datasource.password=password spring.jpa.generate-ddl=true </code></pre>  <p>I'm at a loss as to how to proceed.</p> ",
    "OwnerUserId": "4520965",
    "LastEditorUserId": "4520965",
    "LastEditDate": "2018-07-05T16:34:07.173",
    "LastActivityDate": "2018-07-05T16:34:07.173",
    "Title": "Running docker compose causes 'Connection to localhost:5432 refused.' exception",
    "Tags": "<postgresql><docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "52608571",
    "PostTypeId": "1",
    "CreationDate": "2018-10-02T12:41:24.083",
    "Score": "5",
    "ViewCount": "4275",
    "Body": "<p>I'm currently experimenting with Spring Boot-based microservices and getting to grips with docker, but I'm hitting a snag.</p>  <p>Basically what I'm trying to do is containerize 2 small services: a spring cloud config service and a spring cloud eureka service (discovery service). The eureka service fetches its configuration from the config service.</p>  <p>Both services are separate projects with their own Dockerfiles:</p>  <p><strong>Dockerfile-cloud-config-service:</strong></p>  <pre><code>FROM openjdk:10.0.2-13-jre-sid ENV APP_FILE cloud-config-service.jar ENV APP_HOME /usr/apps EXPOSE 8888 COPY target/$APP_FILE $APP_HOME/ WORKDIR $APP_HOME ENTRYPOINT ['sh', '-c'] CMD ['exec java -jar $APP_FILE'] </code></pre>  <p><strong>Dockerfile-discovery-service:</strong></p>  <pre><code>FROM openjdk:10.0.2-13-jre-sid ENV APP_FILE discovery-service.jar ENV APP_HOME /usr/apps EXPOSE 8761 COPY target/$APP_FILE $APP_HOME/ WORKDIR $APP_HOME ENTRYPOINT ['sh', '-c'] CMD ['exec java -jar $APP_FILE'] </code></pre>  <p>Using docker-compose I'm trying to tie them together using the following <strong>docker-compose.yml:</strong></p>  <pre><code>version: '3.7' services:   cloud-config-service:     container_name: cloud-config-service     build:       context: cloud-config-service       dockerfile: Dockerfile-cloud-config-service     image: cloud-config-service:latest     ports:       - 8888:8888     networks:       - emp-network    discovery-service:     container_name: discovery-service     build:       context: discovery-service       dockerfile: Dockerfile-discovery-service     image: discovery-service:latest     ports:       - 8761:8761     networks:       - emp-network     links:       - cloud-config-service  networks:   emp-network:     driver: bridge </code></pre>  <p>At first I configured the discovery-service to fetch its configuration from <em><a href='http://localhost:8888' rel='nofollow noreferrer'>http://localhost:8888</a></em>, but after some digging I found that localhost in a container refers to the container itself and found in the Docker documentation that services can refer to each other using their names. So I changed discovery-service's properties to fetch its config from <em><a href='http://cloud-config-service:8888' rel='nofollow noreferrer'>http://cloud-config-service:8888</a></em>. That doesn't work, hence this post.</p>  <p>Both Dockerfiles build and run just fine, except the fact that the discovery-service fails to GET the config-service on <em><a href='http://cloud-config-service:8888' rel='nofollow noreferrer'>http://cloud-config-service:8888</a></em>.</p>  <p>It does work if I use the <code>host</code> network driver and the <em><a href='http://localhost:8888' rel='nofollow noreferrer'>http://localhost:8888</a></em> endpoint, but this 'feels' hacky and not how it is supposed to be done.</p>  <p>I'm probably missing something trivial, but I'm afraid I can't find what.</p>  <p><strong>EDIT:</strong> Small snippet of discovery-service's console log:</p>  <pre><code>discovery-service       | 2018-10-02 13:14:26.798  INFO 1 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Fetching config from server at : http://cloud-config-service:8888 cloud-config-service    | 2018-10-02 13:14:26.836  INFO 1 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration' of type [org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration$$EnhancerBySpringCGLIB$$8a18e3b3] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying) discovery-service       | 2018-10-02 13:14:27.129  INFO 1 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Connect Timeout Exception on Url - http://cloud-config-service:8888. Will be trying the next url if available discovery-service       | 2018-10-02 13:14:27.129  WARN 1 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Could not locate PropertySource: I/O error on GET request for 'http://cloud-config-service:8888/discovery-service/default': Connection refused (Connection refused); nested exception is java.net.ConnectException: Connection refused (Connection refused) </code></pre> ",
    "OwnerUserId": "5818149",
    "LastEditorUserId": "5818149",
    "LastEditDate": "2018-10-02T13:20:01.067",
    "LastActivityDate": "2018-10-03T06:04:17.057",
    "Title": "docker-compose inter container communication",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "52608571",
    "PostTypeId": "1",
    "CreationDate": "2018-10-02T12:41:24.083",
    "Score": "5",
    "ViewCount": "4275",
    "Body": "<p>I'm currently experimenting with Spring Boot-based microservices and getting to grips with docker, but I'm hitting a snag.</p>  <p>Basically what I'm trying to do is containerize 2 small services: a spring cloud config service and a spring cloud eureka service (discovery service). The eureka service fetches its configuration from the config service.</p>  <p>Both services are separate projects with their own Dockerfiles:</p>  <p><strong>Dockerfile-cloud-config-service:</strong></p>  <pre><code>FROM openjdk:10.0.2-13-jre-sid ENV APP_FILE cloud-config-service.jar ENV APP_HOME /usr/apps EXPOSE 8888 COPY target/$APP_FILE $APP_HOME/ WORKDIR $APP_HOME ENTRYPOINT ['sh', '-c'] CMD ['exec java -jar $APP_FILE'] </code></pre>  <p><strong>Dockerfile-discovery-service:</strong></p>  <pre><code>FROM openjdk:10.0.2-13-jre-sid ENV APP_FILE discovery-service.jar ENV APP_HOME /usr/apps EXPOSE 8761 COPY target/$APP_FILE $APP_HOME/ WORKDIR $APP_HOME ENTRYPOINT ['sh', '-c'] CMD ['exec java -jar $APP_FILE'] </code></pre>  <p>Using docker-compose I'm trying to tie them together using the following <strong>docker-compose.yml:</strong></p>  <pre><code>version: '3.7' services:   cloud-config-service:     container_name: cloud-config-service     build:       context: cloud-config-service       dockerfile: Dockerfile-cloud-config-service     image: cloud-config-service:latest     ports:       - 8888:8888     networks:       - emp-network    discovery-service:     container_name: discovery-service     build:       context: discovery-service       dockerfile: Dockerfile-discovery-service     image: discovery-service:latest     ports:       - 8761:8761     networks:       - emp-network     links:       - cloud-config-service  networks:   emp-network:     driver: bridge </code></pre>  <p>At first I configured the discovery-service to fetch its configuration from <em><a href='http://localhost:8888' rel='nofollow noreferrer'>http://localhost:8888</a></em>, but after some digging I found that localhost in a container refers to the container itself and found in the Docker documentation that services can refer to each other using their names. So I changed discovery-service's properties to fetch its config from <em><a href='http://cloud-config-service:8888' rel='nofollow noreferrer'>http://cloud-config-service:8888</a></em>. That doesn't work, hence this post.</p>  <p>Both Dockerfiles build and run just fine, except the fact that the discovery-service fails to GET the config-service on <em><a href='http://cloud-config-service:8888' rel='nofollow noreferrer'>http://cloud-config-service:8888</a></em>.</p>  <p>It does work if I use the <code>host</code> network driver and the <em><a href='http://localhost:8888' rel='nofollow noreferrer'>http://localhost:8888</a></em> endpoint, but this 'feels' hacky and not how it is supposed to be done.</p>  <p>I'm probably missing something trivial, but I'm afraid I can't find what.</p>  <p><strong>EDIT:</strong> Small snippet of discovery-service's console log:</p>  <pre><code>discovery-service       | 2018-10-02 13:14:26.798  INFO 1 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Fetching config from server at : http://cloud-config-service:8888 cloud-config-service    | 2018-10-02 13:14:26.836  INFO 1 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration' of type [org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration$$EnhancerBySpringCGLIB$$8a18e3b3] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying) discovery-service       | 2018-10-02 13:14:27.129  INFO 1 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Connect Timeout Exception on Url - http://cloud-config-service:8888. Will be trying the next url if available discovery-service       | 2018-10-02 13:14:27.129  WARN 1 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Could not locate PropertySource: I/O error on GET request for 'http://cloud-config-service:8888/discovery-service/default': Connection refused (Connection refused); nested exception is java.net.ConnectException: Connection refused (Connection refused) </code></pre> ",
    "OwnerUserId": "5818149",
    "LastEditorUserId": "5818149",
    "LastEditDate": "2018-10-02T13:20:01.067",
    "LastActivityDate": "2018-10-03T06:04:17.057",
    "Title": "docker-compose inter container communication",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "52608571",
    "PostTypeId": "1",
    "CreationDate": "2018-10-02T12:41:24.083",
    "Score": "5",
    "ViewCount": "4275",
    "Body": "<p>I'm currently experimenting with Spring Boot-based microservices and getting to grips with docker, but I'm hitting a snag.</p>  <p>Basically what I'm trying to do is containerize 2 small services: a spring cloud config service and a spring cloud eureka service (discovery service). The eureka service fetches its configuration from the config service.</p>  <p>Both services are separate projects with their own Dockerfiles:</p>  <p><strong>Dockerfile-cloud-config-service:</strong></p>  <pre><code>FROM openjdk:10.0.2-13-jre-sid ENV APP_FILE cloud-config-service.jar ENV APP_HOME /usr/apps EXPOSE 8888 COPY target/$APP_FILE $APP_HOME/ WORKDIR $APP_HOME ENTRYPOINT ['sh', '-c'] CMD ['exec java -jar $APP_FILE'] </code></pre>  <p><strong>Dockerfile-discovery-service:</strong></p>  <pre><code>FROM openjdk:10.0.2-13-jre-sid ENV APP_FILE discovery-service.jar ENV APP_HOME /usr/apps EXPOSE 8761 COPY target/$APP_FILE $APP_HOME/ WORKDIR $APP_HOME ENTRYPOINT ['sh', '-c'] CMD ['exec java -jar $APP_FILE'] </code></pre>  <p>Using docker-compose I'm trying to tie them together using the following <strong>docker-compose.yml:</strong></p>  <pre><code>version: '3.7' services:   cloud-config-service:     container_name: cloud-config-service     build:       context: cloud-config-service       dockerfile: Dockerfile-cloud-config-service     image: cloud-config-service:latest     ports:       - 8888:8888     networks:       - emp-network    discovery-service:     container_name: discovery-service     build:       context: discovery-service       dockerfile: Dockerfile-discovery-service     image: discovery-service:latest     ports:       - 8761:8761     networks:       - emp-network     links:       - cloud-config-service  networks:   emp-network:     driver: bridge </code></pre>  <p>At first I configured the discovery-service to fetch its configuration from <em><a href='http://localhost:8888' rel='nofollow noreferrer'>http://localhost:8888</a></em>, but after some digging I found that localhost in a container refers to the container itself and found in the Docker documentation that services can refer to each other using their names. So I changed discovery-service's properties to fetch its config from <em><a href='http://cloud-config-service:8888' rel='nofollow noreferrer'>http://cloud-config-service:8888</a></em>. That doesn't work, hence this post.</p>  <p>Both Dockerfiles build and run just fine, except the fact that the discovery-service fails to GET the config-service on <em><a href='http://cloud-config-service:8888' rel='nofollow noreferrer'>http://cloud-config-service:8888</a></em>.</p>  <p>It does work if I use the <code>host</code> network driver and the <em><a href='http://localhost:8888' rel='nofollow noreferrer'>http://localhost:8888</a></em> endpoint, but this 'feels' hacky and not how it is supposed to be done.</p>  <p>I'm probably missing something trivial, but I'm afraid I can't find what.</p>  <p><strong>EDIT:</strong> Small snippet of discovery-service's console log:</p>  <pre><code>discovery-service       | 2018-10-02 13:14:26.798  INFO 1 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Fetching config from server at : http://cloud-config-service:8888 cloud-config-service    | 2018-10-02 13:14:26.836  INFO 1 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration' of type [org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration$$EnhancerBySpringCGLIB$$8a18e3b3] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying) discovery-service       | 2018-10-02 13:14:27.129  INFO 1 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Connect Timeout Exception on Url - http://cloud-config-service:8888. Will be trying the next url if available discovery-service       | 2018-10-02 13:14:27.129  WARN 1 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Could not locate PropertySource: I/O error on GET request for 'http://cloud-config-service:8888/discovery-service/default': Connection refused (Connection refused); nested exception is java.net.ConnectException: Connection refused (Connection refused) </code></pre> ",
    "OwnerUserId": "5818149",
    "LastEditorUserId": "5818149",
    "LastEditDate": "2018-10-02T13:20:01.067",
    "LastActivityDate": "2018-10-03T06:04:17.057",
    "Title": "docker-compose inter container communication",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "54241346",
    "PostTypeId": "1",
    "AcceptedAnswerId": "54265759",
    "CreationDate": "2019-01-17T17:33:03.213",
    "Score": "5",
    "ViewCount": "17633",
    "Body": "<p><em>docker-compose.yml:</em></p>  <pre><code>services:   server:     image: server:latest     environment:     - SPRING_PROFILES_ACTIVE=dev     ports:     - 8080:8080     - 18080:18080 </code></pre>  <p><em>Dockerfile:</em></p>  <pre><code>FROM openjdk:8-jre-alpine  ENV SPRING_OUTPUT_ANSI_ENABLED=ALWAYS \\     SLEEP=0 \\     JAVA_OPTS='' \\  RUN adduser -D -s /bin/sh server WORKDIR /home/server  ADD entrypoint.sh entrypoint.sh RUN chmod 755 entrypoint.sh &amp;&amp; chown server:server entrypoint.sh USER server  ENTRYPOINT ['./entrypoint.sh'] # expose server ports EXPOSE 8080 18080  ADD *.jar server.jar </code></pre>  <p><em>entrypoint.sh:</em></p>  <pre><code>#!/bin/sh  echo 'The application will start in ${SLEEP}s...' &amp;&amp; sleep ${SLEEP} exec java ${JAVA_OPTS} -Djava.security.egd=file:/dev/./urandom -jar '${HOME}/server.jar' '$@' </code></pre>  <p>I have 3 application.yml: <code>application.yml</code>, <code>application-dev.yml</code> and <code>application-prod.yml</code> which differ from database address.</p>  <p>But when I run <code>docker-compose up</code>, the server always use the default setting even I mentionned as in <em>docker-compose.yml</em> that the active profile is dev.</p>  <p>I'd like to know how to enable different profile in docker-compose file. Thanks.</p>  <p><strong>edit:</strong> the <em>server.jar</em> file is built using <code>assemble</code> of gradle.</p> ",
    "OwnerUserId": "5265472",
    "LastEditorUserId": "5265472",
    "LastEditDate": "2019-01-17T17:42:39.810",
    "LastActivityDate": "2019-01-23T21:09:14.720",
    "Title": "Switching spring profile based on docker environment variable does not work",
    "Tags": "<spring-boot><docker><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "54241346",
    "PostTypeId": "1",
    "AcceptedAnswerId": "54265759",
    "CreationDate": "2019-01-17T17:33:03.213",
    "Score": "5",
    "ViewCount": "17633",
    "Body": "<p><em>docker-compose.yml:</em></p>  <pre><code>services:   server:     image: server:latest     environment:     - SPRING_PROFILES_ACTIVE=dev     ports:     - 8080:8080     - 18080:18080 </code></pre>  <p><em>Dockerfile:</em></p>  <pre><code>FROM openjdk:8-jre-alpine  ENV SPRING_OUTPUT_ANSI_ENABLED=ALWAYS \\     SLEEP=0 \\     JAVA_OPTS='' \\  RUN adduser -D -s /bin/sh server WORKDIR /home/server  ADD entrypoint.sh entrypoint.sh RUN chmod 755 entrypoint.sh &amp;&amp; chown server:server entrypoint.sh USER server  ENTRYPOINT ['./entrypoint.sh'] # expose server ports EXPOSE 8080 18080  ADD *.jar server.jar </code></pre>  <p><em>entrypoint.sh:</em></p>  <pre><code>#!/bin/sh  echo 'The application will start in ${SLEEP}s...' &amp;&amp; sleep ${SLEEP} exec java ${JAVA_OPTS} -Djava.security.egd=file:/dev/./urandom -jar '${HOME}/server.jar' '$@' </code></pre>  <p>I have 3 application.yml: <code>application.yml</code>, <code>application-dev.yml</code> and <code>application-prod.yml</code> which differ from database address.</p>  <p>But when I run <code>docker-compose up</code>, the server always use the default setting even I mentionned as in <em>docker-compose.yml</em> that the active profile is dev.</p>  <p>I'd like to know how to enable different profile in docker-compose file. Thanks.</p>  <p><strong>edit:</strong> the <em>server.jar</em> file is built using <code>assemble</code> of gradle.</p> ",
    "OwnerUserId": "5265472",
    "LastEditorUserId": "5265472",
    "LastEditDate": "2019-01-17T17:42:39.810",
    "LastActivityDate": "2019-01-23T21:09:14.720",
    "Title": "Switching spring profile based on docker environment variable does not work",
    "Tags": "<spring-boot><docker><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "54241346",
    "PostTypeId": "1",
    "AcceptedAnswerId": "54265759",
    "CreationDate": "2019-01-17T17:33:03.213",
    "Score": "5",
    "ViewCount": "17633",
    "Body": "<p><em>docker-compose.yml:</em></p>  <pre><code>services:   server:     image: server:latest     environment:     - SPRING_PROFILES_ACTIVE=dev     ports:     - 8080:8080     - 18080:18080 </code></pre>  <p><em>Dockerfile:</em></p>  <pre><code>FROM openjdk:8-jre-alpine  ENV SPRING_OUTPUT_ANSI_ENABLED=ALWAYS \\     SLEEP=0 \\     JAVA_OPTS='' \\  RUN adduser -D -s /bin/sh server WORKDIR /home/server  ADD entrypoint.sh entrypoint.sh RUN chmod 755 entrypoint.sh &amp;&amp; chown server:server entrypoint.sh USER server  ENTRYPOINT ['./entrypoint.sh'] # expose server ports EXPOSE 8080 18080  ADD *.jar server.jar </code></pre>  <p><em>entrypoint.sh:</em></p>  <pre><code>#!/bin/sh  echo 'The application will start in ${SLEEP}s...' &amp;&amp; sleep ${SLEEP} exec java ${JAVA_OPTS} -Djava.security.egd=file:/dev/./urandom -jar '${HOME}/server.jar' '$@' </code></pre>  <p>I have 3 application.yml: <code>application.yml</code>, <code>application-dev.yml</code> and <code>application-prod.yml</code> which differ from database address.</p>  <p>But when I run <code>docker-compose up</code>, the server always use the default setting even I mentionned as in <em>docker-compose.yml</em> that the active profile is dev.</p>  <p>I'd like to know how to enable different profile in docker-compose file. Thanks.</p>  <p><strong>edit:</strong> the <em>server.jar</em> file is built using <code>assemble</code> of gradle.</p> ",
    "OwnerUserId": "5265472",
    "LastEditorUserId": "5265472",
    "LastEditDate": "2019-01-17T17:42:39.810",
    "LastActivityDate": "2019-01-23T21:09:14.720",
    "Title": "Switching spring profile based on docker environment variable does not work",
    "Tags": "<spring-boot><docker><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "56202090",
    "PostTypeId": "1",
    "AcceptedAnswerId": "56202686",
    "CreationDate": "2019-05-18T19:10:43.963",
    "Score": "5",
    "ViewCount": "4154",
    "Body": "<p>The Dockerfile of my spring-boot app:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp COPY target/media-0.0.1-SNAPSHOT.jar app.jar ENTRYPOINT ['java', '-jar', '/app.jar'] </code></pre>  <p><code>application.yml</code></p>  <pre><code>spring:   datasource:     url: jdbc:postgresql://localhost:5432/media     username: postgres     password: postgres     hikari:       connectionTimeout: 30000 </code></pre>  <p>and here is the <code>docker-compose.yml</code>:</p>  <pre><code>version: '3' services:   db:     image: postgres     ports:       - '5432:5432'     environment:       POSTGRES_DB: media       POSTGRES_USER: postgres       POSTGRES_PASSWORD: postgres    app:     build:       context: ./       dockerfile: Dockerfile     depends_on:       - db     ports:       - '8080:8080' </code></pre>  <p>Running <code>docker-compose up --build</code> results in:</p>  <blockquote>   <p>app_1  | org.postgresql.util.PSQLException: Connection to 0.0.0.0:5432   refused. Check that the hostname and port are correct and that the   postmaster is accepting TCP/IP connections. app_1 </p> </blockquote>  <p>My guess is that the spring app tries to connect to postgres before postgres is ready, but I get the following log:</p>  <blockquote>   <p>db_1   | 2019-05-18 19:05:53.692 UTC [1] LOG:  database system is   ready to accept connections</p> </blockquote> ",
    "OwnerUserId": "7451566",
    "LastEditorUserId": "472495",
    "LastEditDate": "2019-05-18T19:32:20.167",
    "LastActivityDate": "2019-05-18T20:40:55.853",
    "Title": "Spring Docker container cannot access Postgres Docker container",
    "Tags": "<postgresql><spring-boot><docker><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "56202090",
    "PostTypeId": "1",
    "AcceptedAnswerId": "56202686",
    "CreationDate": "2019-05-18T19:10:43.963",
    "Score": "5",
    "ViewCount": "4154",
    "Body": "<p>The Dockerfile of my spring-boot app:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp COPY target/media-0.0.1-SNAPSHOT.jar app.jar ENTRYPOINT ['java', '-jar', '/app.jar'] </code></pre>  <p><code>application.yml</code></p>  <pre><code>spring:   datasource:     url: jdbc:postgresql://localhost:5432/media     username: postgres     password: postgres     hikari:       connectionTimeout: 30000 </code></pre>  <p>and here is the <code>docker-compose.yml</code>:</p>  <pre><code>version: '3' services:   db:     image: postgres     ports:       - '5432:5432'     environment:       POSTGRES_DB: media       POSTGRES_USER: postgres       POSTGRES_PASSWORD: postgres    app:     build:       context: ./       dockerfile: Dockerfile     depends_on:       - db     ports:       - '8080:8080' </code></pre>  <p>Running <code>docker-compose up --build</code> results in:</p>  <blockquote>   <p>app_1  | org.postgresql.util.PSQLException: Connection to 0.0.0.0:5432   refused. Check that the hostname and port are correct and that the   postmaster is accepting TCP/IP connections. app_1 </p> </blockquote>  <p>My guess is that the spring app tries to connect to postgres before postgres is ready, but I get the following log:</p>  <blockquote>   <p>db_1   | 2019-05-18 19:05:53.692 UTC [1] LOG:  database system is   ready to accept connections</p> </blockquote> ",
    "OwnerUserId": "7451566",
    "LastEditorUserId": "472495",
    "LastEditDate": "2019-05-18T19:32:20.167",
    "LastActivityDate": "2019-05-18T20:40:55.853",
    "Title": "Spring Docker container cannot access Postgres Docker container",
    "Tags": "<postgresql><spring-boot><docker><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "56202090",
    "PostTypeId": "1",
    "AcceptedAnswerId": "56202686",
    "CreationDate": "2019-05-18T19:10:43.963",
    "Score": "5",
    "ViewCount": "4154",
    "Body": "<p>The Dockerfile of my spring-boot app:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp COPY target/media-0.0.1-SNAPSHOT.jar app.jar ENTRYPOINT ['java', '-jar', '/app.jar'] </code></pre>  <p><code>application.yml</code></p>  <pre><code>spring:   datasource:     url: jdbc:postgresql://localhost:5432/media     username: postgres     password: postgres     hikari:       connectionTimeout: 30000 </code></pre>  <p>and here is the <code>docker-compose.yml</code>:</p>  <pre><code>version: '3' services:   db:     image: postgres     ports:       - '5432:5432'     environment:       POSTGRES_DB: media       POSTGRES_USER: postgres       POSTGRES_PASSWORD: postgres    app:     build:       context: ./       dockerfile: Dockerfile     depends_on:       - db     ports:       - '8080:8080' </code></pre>  <p>Running <code>docker-compose up --build</code> results in:</p>  <blockquote>   <p>app_1  | org.postgresql.util.PSQLException: Connection to 0.0.0.0:5432   refused. Check that the hostname and port are correct and that the   postmaster is accepting TCP/IP connections. app_1 </p> </blockquote>  <p>My guess is that the spring app tries to connect to postgres before postgres is ready, but I get the following log:</p>  <blockquote>   <p>db_1   | 2019-05-18 19:05:53.692 UTC [1] LOG:  database system is   ready to accept connections</p> </blockquote> ",
    "OwnerUserId": "7451566",
    "LastEditorUserId": "472495",
    "LastEditDate": "2019-05-18T19:32:20.167",
    "LastActivityDate": "2019-05-18T20:40:55.853",
    "Title": "Spring Docker container cannot access Postgres Docker container",
    "Tags": "<postgresql><spring-boot><docker><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "56753810",
    "PostTypeId": "1",
    "AcceptedAnswerId": "56754341",
    "CreationDate": "2019-06-25T12:14:26.713",
    "Score": "5",
    "ViewCount": "2260",
    "Body": "<p>I'm pretty new to Docker and I need to startup my Angular/SpringBoot/MySQL project with docker-compose on the docker toolbox. I copied a docker yml file into my project which used the same technologies and changed the paths inside of it to match my project. However when I try docker-compose, it throws the following error:</p>  <pre><code>com.mysql.cj.jdbc.exceptions.CommunicationsException: Communications link failure [...] 84 common frames omitted Caused by: java.net.ConnectException: Connection refused (Connection refused) </code></pre>  <p>the docker-compose.yml looks like:</p>  <pre><code>version: '3'  services:   database:     image: mysql     container_name: database     environment:       MYSQL_ROOT_PASSWORD: ****       MYSQL_DATABASE: db_example       MYSQL_USER: springuser       MYSQL_PASSWORD: ****     ports:       - 3306:3306     volumes:       - db_exampleData:/var/lib/mysql    springapi:     image: openjdk:10-jre-slim     container_name: springapi     ports:       - 8443:8443     depends_on:       - database     volumes:       - ./backend/target/backend-0.1.0.jar:/application.jar     command: ['java', '-jar', 'application.jar']    angular:     image: nginx:alpine     container_name: angular     ports:       - 4200:80     depends_on:       - springapi     volumes:       - ./nginx.conf:/etc/nginx/nginx.conf       - ./frontend/my-app/dist/my-app:/usr/share/nginx/html  volumes:   db_exampleData: </code></pre>  <p>the application.properties:</p>  <pre><code>spring.jpa.hibernate.ddl-auto=none spring.jpa.open-in-view=false spring.datasource.url=jdbc:mysql://localhost:3306/db_example spring.datasource.username=springuser spring.datasource.password=****  server.port=8443 </code></pre>  <p>any suggestion would be helpful!</p> ",
    "OwnerUserId": "9204008",
    "LastEditorUserId": "9204008",
    "LastEditDate": "2019-06-25T12:38:18.313",
    "LastActivityDate": "2019-06-25T12:58:39.813",
    "Title": "docker compose: spring boot connection to mysql database refused",
    "Tags": "<mysql><spring-boot><docker><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "56753810",
    "PostTypeId": "1",
    "AcceptedAnswerId": "56754341",
    "CreationDate": "2019-06-25T12:14:26.713",
    "Score": "5",
    "ViewCount": "2260",
    "Body": "<p>I'm pretty new to Docker and I need to startup my Angular/SpringBoot/MySQL project with docker-compose on the docker toolbox. I copied a docker yml file into my project which used the same technologies and changed the paths inside of it to match my project. However when I try docker-compose, it throws the following error:</p>  <pre><code>com.mysql.cj.jdbc.exceptions.CommunicationsException: Communications link failure [...] 84 common frames omitted Caused by: java.net.ConnectException: Connection refused (Connection refused) </code></pre>  <p>the docker-compose.yml looks like:</p>  <pre><code>version: '3'  services:   database:     image: mysql     container_name: database     environment:       MYSQL_ROOT_PASSWORD: ****       MYSQL_DATABASE: db_example       MYSQL_USER: springuser       MYSQL_PASSWORD: ****     ports:       - 3306:3306     volumes:       - db_exampleData:/var/lib/mysql    springapi:     image: openjdk:10-jre-slim     container_name: springapi     ports:       - 8443:8443     depends_on:       - database     volumes:       - ./backend/target/backend-0.1.0.jar:/application.jar     command: ['java', '-jar', 'application.jar']    angular:     image: nginx:alpine     container_name: angular     ports:       - 4200:80     depends_on:       - springapi     volumes:       - ./nginx.conf:/etc/nginx/nginx.conf       - ./frontend/my-app/dist/my-app:/usr/share/nginx/html  volumes:   db_exampleData: </code></pre>  <p>the application.properties:</p>  <pre><code>spring.jpa.hibernate.ddl-auto=none spring.jpa.open-in-view=false spring.datasource.url=jdbc:mysql://localhost:3306/db_example spring.datasource.username=springuser spring.datasource.password=****  server.port=8443 </code></pre>  <p>any suggestion would be helpful!</p> ",
    "OwnerUserId": "9204008",
    "LastEditorUserId": "9204008",
    "LastEditDate": "2019-06-25T12:38:18.313",
    "LastActivityDate": "2019-06-25T12:58:39.813",
    "Title": "docker compose: spring boot connection to mysql database refused",
    "Tags": "<mysql><spring-boot><docker><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "56753810",
    "PostTypeId": "1",
    "AcceptedAnswerId": "56754341",
    "CreationDate": "2019-06-25T12:14:26.713",
    "Score": "5",
    "ViewCount": "2260",
    "Body": "<p>I'm pretty new to Docker and I need to startup my Angular/SpringBoot/MySQL project with docker-compose on the docker toolbox. I copied a docker yml file into my project which used the same technologies and changed the paths inside of it to match my project. However when I try docker-compose, it throws the following error:</p>  <pre><code>com.mysql.cj.jdbc.exceptions.CommunicationsException: Communications link failure [...] 84 common frames omitted Caused by: java.net.ConnectException: Connection refused (Connection refused) </code></pre>  <p>the docker-compose.yml looks like:</p>  <pre><code>version: '3'  services:   database:     image: mysql     container_name: database     environment:       MYSQL_ROOT_PASSWORD: ****       MYSQL_DATABASE: db_example       MYSQL_USER: springuser       MYSQL_PASSWORD: ****     ports:       - 3306:3306     volumes:       - db_exampleData:/var/lib/mysql    springapi:     image: openjdk:10-jre-slim     container_name: springapi     ports:       - 8443:8443     depends_on:       - database     volumes:       - ./backend/target/backend-0.1.0.jar:/application.jar     command: ['java', '-jar', 'application.jar']    angular:     image: nginx:alpine     container_name: angular     ports:       - 4200:80     depends_on:       - springapi     volumes:       - ./nginx.conf:/etc/nginx/nginx.conf       - ./frontend/my-app/dist/my-app:/usr/share/nginx/html  volumes:   db_exampleData: </code></pre>  <p>the application.properties:</p>  <pre><code>spring.jpa.hibernate.ddl-auto=none spring.jpa.open-in-view=false spring.datasource.url=jdbc:mysql://localhost:3306/db_example spring.datasource.username=springuser spring.datasource.password=****  server.port=8443 </code></pre>  <p>any suggestion would be helpful!</p> ",
    "OwnerUserId": "9204008",
    "LastEditorUserId": "9204008",
    "LastEditDate": "2019-06-25T12:38:18.313",
    "LastActivityDate": "2019-06-25T12:58:39.813",
    "Title": "docker compose: spring boot connection to mysql database refused",
    "Tags": "<mysql><spring-boot><docker><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "63026751",
    "PostTypeId": "1",
    "CreationDate": "2020-07-22T04:12:18.483",
    "Score": "5",
    "ViewCount": "10118",
    "Body": "<p>I am securing the Eureka server with spring security, the eureka server and config server is dockerized in a container and the config server is registered with the Eureka server</p> <p><a href='https://i.stack.imgur.com/iY7EC.png' rel='noreferrer'><img src='https://i.stack.imgur.com/iY7EC.png' alt='enter image description here' /></a></p> <p>Now I am trying to register other services to the Eureka, Other services are running from IDE they are not dockerized. I am using discovery first approach</p> <h1>Eureka server</h1> <pre><code>server:   port: 8761  # Discovery Server Access eureka:   instance:     hostname: localhost   client:     register-with-eureka: false     fetch-registry: false   serviceUrl:     defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ spring:   profiles:     active: dev   security:     basic:       enabled: true     user:       name: fetebird       password: fetebird </code></pre> <h1>Config Server</h1> <pre><code>server:   port: 8085  eureka:   client:     register-with-eureka: true     fetch-registry: true     service-url:       defaultZone: http://fetebird:fetebird@fetebird-eurekaservice:8761/eureka/ </code></pre> <h1>Other service</h1> <pre><code>spring:   application:     name: APIGATEWAY-SERVICE   cloud:     config:       discovery:         service-id: CONFIG-SERVER         enabled: true </code></pre> <h1>Error</h1> <pre><code>org.springframework.core.codec.DecodingException: JSON decoding error: Root name 'timestamp' does not match expected ('applications') for type [simple type, class com.netflix.discovery.shared.Applications]; nested exception is com.fasterxml.jackson.databind.exc.MismatchedInputException: Root name 'timestamp' does not match expected ('applications') for type [simple type, class com.netflix.discovery.shared.Applications]  at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 2] (through reference chain: com.netflix.discovery.shared.Applications[&quot;timestamp&quot;])     at org.springframework.http.codec.json.AbstractJackson2Decoder.processException(AbstractJackson2Decoder.java:215) ~[spring-web-5.2.7.RELEASE.jar:5.2.7.RELEASE]     Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Error has been observed at the following site(s):     |_ checkpoint \u21e2 Body from GET http://localhost:8761/eureka/apps/?regions=us-east-1 [DefaultClientResponse] Stack trace:         at org.springframework.http.codec.json.AbstractJackson2Decoder.processException(AbstractJackson2Decoder.java:215) ~[spring-web-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.http.codec.json.AbstractJackson2Decoder.decode(AbstractJackson2Decoder.java:173) ~[spring-web-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.http.codec.json.AbstractJackson2Decoder.lambda$decodeToMono$1(AbstractJackson2Decoder.java:159) ~[spring-web-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:118) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxContextStart$ContextStartSubscriber.onNext(FluxContextStart.java:96) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:287) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:330) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1782) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:152) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:252) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:252) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.netty.channel.FluxReceive.terminateReceiver(FluxReceive.java:427) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]         at reactor.netty.channel.FluxReceive.drainReceiver(FluxReceive.java:210) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]         at reactor.netty.channel.FluxReceive.request(FluxReceive.java:121) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]         at reactor.core.publisher.FluxMap$MapSubscriber.request(FluxMap.java:155) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxPeek$PeekSubscriber.request(FluxPeek.java:130) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxPeek$PeekSubscriber.request(FluxPeek.java:130) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxMap$MapSubscriber.request(FluxMap.java:155) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.MonoCollect$CollectSubscriber.onSubscribe(MonoCollect.java:112) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:86) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxPeek$PeekSubscriber.onSubscribe(FluxPeek.java:163) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxPeek$PeekSubscriber.onSubscribe(FluxPeek.java:163) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:86) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:300) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]         at reactor.netty.channel.FluxReceive.lambda$subscribe$2(FluxReceive.java:138) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]         at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]         at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]         at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) ~[netty-transport-4.1.50.Final.jar:4.1.50.Final]         at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]         at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]         at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]         at java.base/java.lang.Thread.run(Thread.java:832) ~[na:na]     Suppressed: java.lang.Exception: #block terminated with an error         at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:99) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.Mono.block(Mono.java:1679) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at org.springframework.cloud.netflix.eureka.http.WebClientEurekaHttpClient.getApplicationsInternal(WebClientEurekaHttpClient.java:143) ~[spring-cloud-netflix-eureka-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.netflix.eureka.http.WebClientEurekaHttpClient.getApplications(WebClientEurekaHttpClient.java:124) ~[spring-cloud-netflix-eureka-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.netflix.eureka.config.EurekaConfigServerBootstrapConfiguration.lambda$eurekaConfigServerInstanceProvider$0(EurekaConfigServerBootstrapConfiguration.java:112) ~[spring-cloud-netflix-eureka-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.config.client.ConfigServerInstanceProvider.getConfigServerInstances(ConfigServerInstanceProvider.java:50) ~[spring-cloud-config-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.config.client.DiscoveryClientConfigServiceBootstrapConfiguration$HeartbeatListener.refresh(DiscoveryClientConfigServiceBootstrapConfiguration.java:120) ~[spring-cloud-config-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.config.client.DiscoveryClientConfigServiceBootstrapConfiguration$HeartbeatListener.startup(DiscoveryClientConfigServiceBootstrapConfiguration.java:106) ~[spring-cloud-config-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.config.client.DiscoveryClientConfigServiceBootstrapConfiguration$HeartbeatListener.onApplicationEvent(DiscoveryClientConfigServiceBootstrapConfiguration.java:98) ~[spring-cloud-config-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:404) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:361) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:898) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:554) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:758) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:750) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:315) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.builder.SpringApplicationBuilder.run(SpringApplicationBuilder.java:140) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.cloud.bootstrap.BootstrapApplicationListener.bootstrapServiceContext(BootstrapApplicationListener.java:212) ~[spring-cloud-context-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.bootstrap.BootstrapApplicationListener.onApplicationEvent(BootstrapApplicationListener.java:117) ~[spring-cloud-context-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.bootstrap.BootstrapApplicationListener.onApplicationEvent(BootstrapApplicationListener.java:74) ~[spring-cloud-context-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:127) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.boot.context.event.EventPublishingRunListener.environmentPrepared(EventPublishingRunListener.java:80) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplicationRunListeners.environmentPrepared(SpringApplicationRunListeners.java:53) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.prepareEnvironment(SpringApplication.java:345) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:308) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1237) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at fete.bird.fetebirdapigateway.FeteBirdApiGatewayApplication.main(FeteBirdApiGatewayApplication.java:13) ~[main/:na]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]         at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]         at java.base/java.lang.reflect.Method.invoke(Method.java:564) ~[na:na]         at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:49) ~[spring-boot-devtools-2.3.1.RELEASE.jar:2.3.1.RELEASE] Caused by: com.fasterxml.jackson.databind.exc.MismatchedInputException: Root name 'timestamp' does not match expected ('applications') for type [simple type, class com.netflix.discovery.shared.Applications]  at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 2] (through reference chain: com.netflix.discovery.shared.Applications[&quot;timestamp&quot;])     at com.fasterxml.jackson.databind.exc.MismatchedInputException.from(MismatchedInputException.java:63) ~[jackson-databind-2.11.0.jar:2.11.0]     at com.fasterxml.jackson.databind.DeserializationContext.reportPropertyInputMismatch(DeserializationContext.java:1499) ~[jackson-databind-2.11.0.jar:2.11.0]     at com.fasterxml.jackson.databind.DeserializationContext.reportPropertyInputMismatch(DeserializationContext.java:1515) ~[jackson-databind-2.11.0.jar:2.11.0]     at com.fasterxml.jackson.databind.ObjectReader._unwrapAndDeserialize(ObjectReader.java:2188) ~[jackson-databind-2.11.0.jar:2.11.0]     at com.fasterxml.jackson.databind.ObjectReader._bindAndClose(ObjectReader.java:2054) ~[jackson-databind-2.11.0.jar:2.11.0]     at com.fasterxml.jackson.databind.ObjectReader.readValue(ObjectReader.java:1431) ~[jackson-databind-2.11.0.jar:2.11.0]     at org.springframework.http.codec.json.AbstractJackson2Decoder.decode(AbstractJackson2Decoder.java:168) ~[spring-web-5.2.7.RELEASE.jar:5.2.7.RELEASE]     at org.springframework.http.codec.json.AbstractJackson2Decoder.lambda$decodeToMono$1(AbstractJackson2Decoder.java:159) ~[spring-web-5.2.7.RELEASE.jar:5.2.7.RELEASE]     at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:118) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxContextStart$ContextStartSubscriber.onNext(FluxContextStart.java:96) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:287) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:330) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1782) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:152) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:252) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:252) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.netty.channel.FluxReceive.terminateReceiver(FluxReceive.java:427) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]     at reactor.netty.channel.FluxReceive.drainReceiver(FluxReceive.java:210) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]     at reactor.netty.channel.FluxReceive.request(FluxReceive.java:121) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]     at reactor.core.publisher.FluxMap$MapSubscriber.request(FluxMap.java:155) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxPeek$PeekSubscriber.request(FluxPeek.java:130) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxPeek$PeekSubscriber.request(FluxPeek.java:130) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxMap$MapSubscriber.request(FluxMap.java:155) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.MonoCollect$CollectSubscriber.onSubscribe(MonoCollect.java:112) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:86) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxPeek$PeekSubscriber.onSubscribe(FluxPeek.java:163) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxPeek$PeekSubscriber.onSubscribe(FluxPeek.java:163) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:86) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:300) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]     at reactor.netty.channel.FluxReceive.lambda$subscribe$2(FluxReceive.java:138) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]     at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]     at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]     at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) ~[netty-transport-4.1.50.Final.jar:4.1.50.Final]     at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]     at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]     at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]     at java.base/java.lang.Thread.run(Thread.java:832) ~[na:na] </code></pre> <h1>Docker compose (Application is running successfully on the Docker)</h1> <pre><code>version: '3' services:     fetebird-eurekaservice:         container_name: FeteBird-EurekaService         build:             context: ../../Eureka-Service-Registry/             dockerfile: Dockerfile         image: fetebird/eurekaservice         ports:             - &quot;8761:8761&quot;         networks:             - spring-cloud-network         volumes:             - ./fetebird-eurekaservice/data:/data         logging:             driver: json-file          fetebird-configserver:         container_name: FeteBird-ConfigServer         build:             context: ../../FeteBird-ConfigServer             dockerfile: Dockerfile         image: fetebird/configserver         ports:             - &quot;8085:8085&quot;         links:             - fetebird-eurekaservice         depends_on:             - fetebird-eurekaservice         networks:             - spring-cloud-network         volumes:             - ./fetebird-configserver/data:/data         logging:             driver: json-file                    networks:     spring-cloud-network:         driver: bridge </code></pre> ",
    "OwnerUserId": "1162409",
    "LastActivityDate": "2021-07-21T14:22:39.523",
    "Title": "JSON decoding error: Root name 'timestamp' does not match expected Eureka +spring security + Docker",
    "Tags": "<java><spring><spring-boot><docker-compose><netflix-eureka>",
    "AnswerCount": "1",
    "CommentCount": "4",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "63026751",
    "PostTypeId": "1",
    "CreationDate": "2020-07-22T04:12:18.483",
    "Score": "5",
    "ViewCount": "10118",
    "Body": "<p>I am securing the Eureka server with spring security, the eureka server and config server is dockerized in a container and the config server is registered with the Eureka server</p> <p><a href='https://i.stack.imgur.com/iY7EC.png' rel='noreferrer'><img src='https://i.stack.imgur.com/iY7EC.png' alt='enter image description here' /></a></p> <p>Now I am trying to register other services to the Eureka, Other services are running from IDE they are not dockerized. I am using discovery first approach</p> <h1>Eureka server</h1> <pre><code>server:   port: 8761  # Discovery Server Access eureka:   instance:     hostname: localhost   client:     register-with-eureka: false     fetch-registry: false   serviceUrl:     defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ spring:   profiles:     active: dev   security:     basic:       enabled: true     user:       name: fetebird       password: fetebird </code></pre> <h1>Config Server</h1> <pre><code>server:   port: 8085  eureka:   client:     register-with-eureka: true     fetch-registry: true     service-url:       defaultZone: http://fetebird:fetebird@fetebird-eurekaservice:8761/eureka/ </code></pre> <h1>Other service</h1> <pre><code>spring:   application:     name: APIGATEWAY-SERVICE   cloud:     config:       discovery:         service-id: CONFIG-SERVER         enabled: true </code></pre> <h1>Error</h1> <pre><code>org.springframework.core.codec.DecodingException: JSON decoding error: Root name 'timestamp' does not match expected ('applications') for type [simple type, class com.netflix.discovery.shared.Applications]; nested exception is com.fasterxml.jackson.databind.exc.MismatchedInputException: Root name 'timestamp' does not match expected ('applications') for type [simple type, class com.netflix.discovery.shared.Applications]  at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 2] (through reference chain: com.netflix.discovery.shared.Applications[&quot;timestamp&quot;])     at org.springframework.http.codec.json.AbstractJackson2Decoder.processException(AbstractJackson2Decoder.java:215) ~[spring-web-5.2.7.RELEASE.jar:5.2.7.RELEASE]     Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Error has been observed at the following site(s):     |_ checkpoint \u21e2 Body from GET http://localhost:8761/eureka/apps/?regions=us-east-1 [DefaultClientResponse] Stack trace:         at org.springframework.http.codec.json.AbstractJackson2Decoder.processException(AbstractJackson2Decoder.java:215) ~[spring-web-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.http.codec.json.AbstractJackson2Decoder.decode(AbstractJackson2Decoder.java:173) ~[spring-web-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.http.codec.json.AbstractJackson2Decoder.lambda$decodeToMono$1(AbstractJackson2Decoder.java:159) ~[spring-web-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:118) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxContextStart$ContextStartSubscriber.onNext(FluxContextStart.java:96) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:287) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:330) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1782) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:152) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:252) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:252) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.netty.channel.FluxReceive.terminateReceiver(FluxReceive.java:427) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]         at reactor.netty.channel.FluxReceive.drainReceiver(FluxReceive.java:210) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]         at reactor.netty.channel.FluxReceive.request(FluxReceive.java:121) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]         at reactor.core.publisher.FluxMap$MapSubscriber.request(FluxMap.java:155) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxPeek$PeekSubscriber.request(FluxPeek.java:130) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxPeek$PeekSubscriber.request(FluxPeek.java:130) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxMap$MapSubscriber.request(FluxMap.java:155) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.MonoCollect$CollectSubscriber.onSubscribe(MonoCollect.java:112) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:86) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxPeek$PeekSubscriber.onSubscribe(FluxPeek.java:163) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxPeek$PeekSubscriber.onSubscribe(FluxPeek.java:163) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:86) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:300) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]         at reactor.netty.channel.FluxReceive.lambda$subscribe$2(FluxReceive.java:138) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]         at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]         at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]         at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) ~[netty-transport-4.1.50.Final.jar:4.1.50.Final]         at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]         at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]         at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]         at java.base/java.lang.Thread.run(Thread.java:832) ~[na:na]     Suppressed: java.lang.Exception: #block terminated with an error         at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:99) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.Mono.block(Mono.java:1679) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at org.springframework.cloud.netflix.eureka.http.WebClientEurekaHttpClient.getApplicationsInternal(WebClientEurekaHttpClient.java:143) ~[spring-cloud-netflix-eureka-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.netflix.eureka.http.WebClientEurekaHttpClient.getApplications(WebClientEurekaHttpClient.java:124) ~[spring-cloud-netflix-eureka-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.netflix.eureka.config.EurekaConfigServerBootstrapConfiguration.lambda$eurekaConfigServerInstanceProvider$0(EurekaConfigServerBootstrapConfiguration.java:112) ~[spring-cloud-netflix-eureka-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.config.client.ConfigServerInstanceProvider.getConfigServerInstances(ConfigServerInstanceProvider.java:50) ~[spring-cloud-config-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.config.client.DiscoveryClientConfigServiceBootstrapConfiguration$HeartbeatListener.refresh(DiscoveryClientConfigServiceBootstrapConfiguration.java:120) ~[spring-cloud-config-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.config.client.DiscoveryClientConfigServiceBootstrapConfiguration$HeartbeatListener.startup(DiscoveryClientConfigServiceBootstrapConfiguration.java:106) ~[spring-cloud-config-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.config.client.DiscoveryClientConfigServiceBootstrapConfiguration$HeartbeatListener.onApplicationEvent(DiscoveryClientConfigServiceBootstrapConfiguration.java:98) ~[spring-cloud-config-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:404) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:361) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:898) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:554) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:758) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:750) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:315) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.builder.SpringApplicationBuilder.run(SpringApplicationBuilder.java:140) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.cloud.bootstrap.BootstrapApplicationListener.bootstrapServiceContext(BootstrapApplicationListener.java:212) ~[spring-cloud-context-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.bootstrap.BootstrapApplicationListener.onApplicationEvent(BootstrapApplicationListener.java:117) ~[spring-cloud-context-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.bootstrap.BootstrapApplicationListener.onApplicationEvent(BootstrapApplicationListener.java:74) ~[spring-cloud-context-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:127) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.boot.context.event.EventPublishingRunListener.environmentPrepared(EventPublishingRunListener.java:80) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplicationRunListeners.environmentPrepared(SpringApplicationRunListeners.java:53) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.prepareEnvironment(SpringApplication.java:345) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:308) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1237) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at fete.bird.fetebirdapigateway.FeteBirdApiGatewayApplication.main(FeteBirdApiGatewayApplication.java:13) ~[main/:na]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]         at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]         at java.base/java.lang.reflect.Method.invoke(Method.java:564) ~[na:na]         at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:49) ~[spring-boot-devtools-2.3.1.RELEASE.jar:2.3.1.RELEASE] Caused by: com.fasterxml.jackson.databind.exc.MismatchedInputException: Root name 'timestamp' does not match expected ('applications') for type [simple type, class com.netflix.discovery.shared.Applications]  at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 2] (through reference chain: com.netflix.discovery.shared.Applications[&quot;timestamp&quot;])     at com.fasterxml.jackson.databind.exc.MismatchedInputException.from(MismatchedInputException.java:63) ~[jackson-databind-2.11.0.jar:2.11.0]     at com.fasterxml.jackson.databind.DeserializationContext.reportPropertyInputMismatch(DeserializationContext.java:1499) ~[jackson-databind-2.11.0.jar:2.11.0]     at com.fasterxml.jackson.databind.DeserializationContext.reportPropertyInputMismatch(DeserializationContext.java:1515) ~[jackson-databind-2.11.0.jar:2.11.0]     at com.fasterxml.jackson.databind.ObjectReader._unwrapAndDeserialize(ObjectReader.java:2188) ~[jackson-databind-2.11.0.jar:2.11.0]     at com.fasterxml.jackson.databind.ObjectReader._bindAndClose(ObjectReader.java:2054) ~[jackson-databind-2.11.0.jar:2.11.0]     at com.fasterxml.jackson.databind.ObjectReader.readValue(ObjectReader.java:1431) ~[jackson-databind-2.11.0.jar:2.11.0]     at org.springframework.http.codec.json.AbstractJackson2Decoder.decode(AbstractJackson2Decoder.java:168) ~[spring-web-5.2.7.RELEASE.jar:5.2.7.RELEASE]     at org.springframework.http.codec.json.AbstractJackson2Decoder.lambda$decodeToMono$1(AbstractJackson2Decoder.java:159) ~[spring-web-5.2.7.RELEASE.jar:5.2.7.RELEASE]     at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:118) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxContextStart$ContextStartSubscriber.onNext(FluxContextStart.java:96) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:287) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:330) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1782) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:152) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:252) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:252) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.netty.channel.FluxReceive.terminateReceiver(FluxReceive.java:427) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]     at reactor.netty.channel.FluxReceive.drainReceiver(FluxReceive.java:210) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]     at reactor.netty.channel.FluxReceive.request(FluxReceive.java:121) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]     at reactor.core.publisher.FluxMap$MapSubscriber.request(FluxMap.java:155) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxPeek$PeekSubscriber.request(FluxPeek.java:130) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxPeek$PeekSubscriber.request(FluxPeek.java:130) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxMap$MapSubscriber.request(FluxMap.java:155) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.MonoCollect$CollectSubscriber.onSubscribe(MonoCollect.java:112) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:86) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxPeek$PeekSubscriber.onSubscribe(FluxPeek.java:163) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxPeek$PeekSubscriber.onSubscribe(FluxPeek.java:163) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:86) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:300) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]     at reactor.netty.channel.FluxReceive.lambda$subscribe$2(FluxReceive.java:138) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]     at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]     at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]     at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) ~[netty-transport-4.1.50.Final.jar:4.1.50.Final]     at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]     at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]     at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]     at java.base/java.lang.Thread.run(Thread.java:832) ~[na:na] </code></pre> <h1>Docker compose (Application is running successfully on the Docker)</h1> <pre><code>version: '3' services:     fetebird-eurekaservice:         container_name: FeteBird-EurekaService         build:             context: ../../Eureka-Service-Registry/             dockerfile: Dockerfile         image: fetebird/eurekaservice         ports:             - &quot;8761:8761&quot;         networks:             - spring-cloud-network         volumes:             - ./fetebird-eurekaservice/data:/data         logging:             driver: json-file          fetebird-configserver:         container_name: FeteBird-ConfigServer         build:             context: ../../FeteBird-ConfigServer             dockerfile: Dockerfile         image: fetebird/configserver         ports:             - &quot;8085:8085&quot;         links:             - fetebird-eurekaservice         depends_on:             - fetebird-eurekaservice         networks:             - spring-cloud-network         volumes:             - ./fetebird-configserver/data:/data         logging:             driver: json-file                    networks:     spring-cloud-network:         driver: bridge </code></pre> ",
    "OwnerUserId": "1162409",
    "LastActivityDate": "2021-07-21T14:22:39.523",
    "Title": "JSON decoding error: Root name 'timestamp' does not match expected Eureka +spring security + Docker",
    "Tags": "<java><spring><spring-boot><docker-compose><netflix-eureka>",
    "AnswerCount": "1",
    "CommentCount": "4",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "63026751",
    "PostTypeId": "1",
    "CreationDate": "2020-07-22T04:12:18.483",
    "Score": "5",
    "ViewCount": "10118",
    "Body": "<p>I am securing the Eureka server with spring security, the eureka server and config server is dockerized in a container and the config server is registered with the Eureka server</p> <p><a href='https://i.stack.imgur.com/iY7EC.png' rel='noreferrer'><img src='https://i.stack.imgur.com/iY7EC.png' alt='enter image description here' /></a></p> <p>Now I am trying to register other services to the Eureka, Other services are running from IDE they are not dockerized. I am using discovery first approach</p> <h1>Eureka server</h1> <pre><code>server:   port: 8761  # Discovery Server Access eureka:   instance:     hostname: localhost   client:     register-with-eureka: false     fetch-registry: false   serviceUrl:     defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ spring:   profiles:     active: dev   security:     basic:       enabled: true     user:       name: fetebird       password: fetebird </code></pre> <h1>Config Server</h1> <pre><code>server:   port: 8085  eureka:   client:     register-with-eureka: true     fetch-registry: true     service-url:       defaultZone: http://fetebird:fetebird@fetebird-eurekaservice:8761/eureka/ </code></pre> <h1>Other service</h1> <pre><code>spring:   application:     name: APIGATEWAY-SERVICE   cloud:     config:       discovery:         service-id: CONFIG-SERVER         enabled: true </code></pre> <h1>Error</h1> <pre><code>org.springframework.core.codec.DecodingException: JSON decoding error: Root name 'timestamp' does not match expected ('applications') for type [simple type, class com.netflix.discovery.shared.Applications]; nested exception is com.fasterxml.jackson.databind.exc.MismatchedInputException: Root name 'timestamp' does not match expected ('applications') for type [simple type, class com.netflix.discovery.shared.Applications]  at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 2] (through reference chain: com.netflix.discovery.shared.Applications[&quot;timestamp&quot;])     at org.springframework.http.codec.json.AbstractJackson2Decoder.processException(AbstractJackson2Decoder.java:215) ~[spring-web-5.2.7.RELEASE.jar:5.2.7.RELEASE]     Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Error has been observed at the following site(s):     |_ checkpoint \u21e2 Body from GET http://localhost:8761/eureka/apps/?regions=us-east-1 [DefaultClientResponse] Stack trace:         at org.springframework.http.codec.json.AbstractJackson2Decoder.processException(AbstractJackson2Decoder.java:215) ~[spring-web-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.http.codec.json.AbstractJackson2Decoder.decode(AbstractJackson2Decoder.java:173) ~[spring-web-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.http.codec.json.AbstractJackson2Decoder.lambda$decodeToMono$1(AbstractJackson2Decoder.java:159) ~[spring-web-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:118) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxContextStart$ContextStartSubscriber.onNext(FluxContextStart.java:96) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:287) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:330) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1782) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:152) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:252) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:252) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.netty.channel.FluxReceive.terminateReceiver(FluxReceive.java:427) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]         at reactor.netty.channel.FluxReceive.drainReceiver(FluxReceive.java:210) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]         at reactor.netty.channel.FluxReceive.request(FluxReceive.java:121) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]         at reactor.core.publisher.FluxMap$MapSubscriber.request(FluxMap.java:155) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxPeek$PeekSubscriber.request(FluxPeek.java:130) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxPeek$PeekSubscriber.request(FluxPeek.java:130) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxMap$MapSubscriber.request(FluxMap.java:155) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.MonoCollect$CollectSubscriber.onSubscribe(MonoCollect.java:112) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:86) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxPeek$PeekSubscriber.onSubscribe(FluxPeek.java:163) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxPeek$PeekSubscriber.onSubscribe(FluxPeek.java:163) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:86) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:300) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]         at reactor.netty.channel.FluxReceive.lambda$subscribe$2(FluxReceive.java:138) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]         at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]         at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]         at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) ~[netty-transport-4.1.50.Final.jar:4.1.50.Final]         at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]         at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]         at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]         at java.base/java.lang.Thread.run(Thread.java:832) ~[na:na]     Suppressed: java.lang.Exception: #block terminated with an error         at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:99) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.Mono.block(Mono.java:1679) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at org.springframework.cloud.netflix.eureka.http.WebClientEurekaHttpClient.getApplicationsInternal(WebClientEurekaHttpClient.java:143) ~[spring-cloud-netflix-eureka-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.netflix.eureka.http.WebClientEurekaHttpClient.getApplications(WebClientEurekaHttpClient.java:124) ~[spring-cloud-netflix-eureka-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.netflix.eureka.config.EurekaConfigServerBootstrapConfiguration.lambda$eurekaConfigServerInstanceProvider$0(EurekaConfigServerBootstrapConfiguration.java:112) ~[spring-cloud-netflix-eureka-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.config.client.ConfigServerInstanceProvider.getConfigServerInstances(ConfigServerInstanceProvider.java:50) ~[spring-cloud-config-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.config.client.DiscoveryClientConfigServiceBootstrapConfiguration$HeartbeatListener.refresh(DiscoveryClientConfigServiceBootstrapConfiguration.java:120) ~[spring-cloud-config-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.config.client.DiscoveryClientConfigServiceBootstrapConfiguration$HeartbeatListener.startup(DiscoveryClientConfigServiceBootstrapConfiguration.java:106) ~[spring-cloud-config-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.config.client.DiscoveryClientConfigServiceBootstrapConfiguration$HeartbeatListener.onApplicationEvent(DiscoveryClientConfigServiceBootstrapConfiguration.java:98) ~[spring-cloud-config-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:404) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:361) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:898) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:554) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:758) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:750) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:315) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.builder.SpringApplicationBuilder.run(SpringApplicationBuilder.java:140) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.cloud.bootstrap.BootstrapApplicationListener.bootstrapServiceContext(BootstrapApplicationListener.java:212) ~[spring-cloud-context-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.bootstrap.BootstrapApplicationListener.onApplicationEvent(BootstrapApplicationListener.java:117) ~[spring-cloud-context-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.bootstrap.BootstrapApplicationListener.onApplicationEvent(BootstrapApplicationListener.java:74) ~[spring-cloud-context-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:127) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.boot.context.event.EventPublishingRunListener.environmentPrepared(EventPublishingRunListener.java:80) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplicationRunListeners.environmentPrepared(SpringApplicationRunListeners.java:53) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.prepareEnvironment(SpringApplication.java:345) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:308) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1237) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at fete.bird.fetebirdapigateway.FeteBirdApiGatewayApplication.main(FeteBirdApiGatewayApplication.java:13) ~[main/:na]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]         at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]         at java.base/java.lang.reflect.Method.invoke(Method.java:564) ~[na:na]         at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:49) ~[spring-boot-devtools-2.3.1.RELEASE.jar:2.3.1.RELEASE] Caused by: com.fasterxml.jackson.databind.exc.MismatchedInputException: Root name 'timestamp' does not match expected ('applications') for type [simple type, class com.netflix.discovery.shared.Applications]  at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 2] (through reference chain: com.netflix.discovery.shared.Applications[&quot;timestamp&quot;])     at com.fasterxml.jackson.databind.exc.MismatchedInputException.from(MismatchedInputException.java:63) ~[jackson-databind-2.11.0.jar:2.11.0]     at com.fasterxml.jackson.databind.DeserializationContext.reportPropertyInputMismatch(DeserializationContext.java:1499) ~[jackson-databind-2.11.0.jar:2.11.0]     at com.fasterxml.jackson.databind.DeserializationContext.reportPropertyInputMismatch(DeserializationContext.java:1515) ~[jackson-databind-2.11.0.jar:2.11.0]     at com.fasterxml.jackson.databind.ObjectReader._unwrapAndDeserialize(ObjectReader.java:2188) ~[jackson-databind-2.11.0.jar:2.11.0]     at com.fasterxml.jackson.databind.ObjectReader._bindAndClose(ObjectReader.java:2054) ~[jackson-databind-2.11.0.jar:2.11.0]     at com.fasterxml.jackson.databind.ObjectReader.readValue(ObjectReader.java:1431) ~[jackson-databind-2.11.0.jar:2.11.0]     at org.springframework.http.codec.json.AbstractJackson2Decoder.decode(AbstractJackson2Decoder.java:168) ~[spring-web-5.2.7.RELEASE.jar:5.2.7.RELEASE]     at org.springframework.http.codec.json.AbstractJackson2Decoder.lambda$decodeToMono$1(AbstractJackson2Decoder.java:159) ~[spring-web-5.2.7.RELEASE.jar:5.2.7.RELEASE]     at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:118) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxContextStart$ContextStartSubscriber.onNext(FluxContextStart.java:96) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:287) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:330) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1782) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:152) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:252) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:252) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.netty.channel.FluxReceive.terminateReceiver(FluxReceive.java:427) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]     at reactor.netty.channel.FluxReceive.drainReceiver(FluxReceive.java:210) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]     at reactor.netty.channel.FluxReceive.request(FluxReceive.java:121) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]     at reactor.core.publisher.FluxMap$MapSubscriber.request(FluxMap.java:155) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxPeek$PeekSubscriber.request(FluxPeek.java:130) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxPeek$PeekSubscriber.request(FluxPeek.java:130) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxMap$MapSubscriber.request(FluxMap.java:155) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.MonoCollect$CollectSubscriber.onSubscribe(MonoCollect.java:112) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:86) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxPeek$PeekSubscriber.onSubscribe(FluxPeek.java:163) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxPeek$PeekSubscriber.onSubscribe(FluxPeek.java:163) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:86) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:300) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]     at reactor.netty.channel.FluxReceive.lambda$subscribe$2(FluxReceive.java:138) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]     at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]     at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]     at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) ~[netty-transport-4.1.50.Final.jar:4.1.50.Final]     at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]     at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]     at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]     at java.base/java.lang.Thread.run(Thread.java:832) ~[na:na] </code></pre> <h1>Docker compose (Application is running successfully on the Docker)</h1> <pre><code>version: '3' services:     fetebird-eurekaservice:         container_name: FeteBird-EurekaService         build:             context: ../../Eureka-Service-Registry/             dockerfile: Dockerfile         image: fetebird/eurekaservice         ports:             - &quot;8761:8761&quot;         networks:             - spring-cloud-network         volumes:             - ./fetebird-eurekaservice/data:/data         logging:             driver: json-file          fetebird-configserver:         container_name: FeteBird-ConfigServer         build:             context: ../../FeteBird-ConfigServer             dockerfile: Dockerfile         image: fetebird/configserver         ports:             - &quot;8085:8085&quot;         links:             - fetebird-eurekaservice         depends_on:             - fetebird-eurekaservice         networks:             - spring-cloud-network         volumes:             - ./fetebird-configserver/data:/data         logging:             driver: json-file                    networks:     spring-cloud-network:         driver: bridge </code></pre> ",
    "OwnerUserId": "1162409",
    "LastActivityDate": "2021-07-21T14:22:39.523",
    "Title": "JSON decoding error: Root name 'timestamp' does not match expected Eureka +spring security + Docker",
    "Tags": "<java><spring><spring-boot><docker-compose><netflix-eureka>",
    "AnswerCount": "1",
    "CommentCount": "4",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "68586177",
    "PostTypeId": "1",
    "CreationDate": "2021-07-30T06:08:46.747",
    "Score": "5",
    "ViewCount": "9081",
    "Body": "<p>I'm struggling to create a Docker Compose to create a Redis Cluster. I saw that there is a Redis Cluster image from Bitnami, I tried but it my Spring Boot App cannot connect to it due to the below error: <a href='https://i.stack.imgur.com/BX3mN.jpg' rel='noreferrer'><img src='https://i.stack.imgur.com/BX3mN.jpg' alt='enter image description here' /></a></p> <p>I tried another approach is to create 2 Redis instances master-slave and I can connect to it. Now I'm trying to create 6 Redis Instances and later create a Redis Cluster with 3 master and 3 slaves with the following command:</p> <pre><code>redis-cli --cluster create 127.0.0.1:6380 127.0.0.1:6381 \\ 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 127.0.0.1:6385 --cluster-replicas 1 </code></pre> <p>But when I executed the command it said that</p> <pre><code>Could not connect to Redis at 127.0.0.1:6380: Connection refused </code></pre> <p>Below is my current Docker-compose.yaml:</p> <pre><code>version: '3.8' services:   redis-node-0:     image: redis:latest     container_name: redis-0     ports:       - &quot;6380:6379&quot;     command: [&quot;redis-server&quot;,&quot;--appendonly yes&quot;,&quot;--cluster-enabled yes&quot;,&quot;--cluster-node-timeout 5000&quot;]     volumes:       - redis-cluster_data-0:/redis/data    redis-node-1:     image: redis:latest     container_name: redis-1     ports:       - &quot;6381:6379&quot;     command: [&quot;redis-server&quot;,&quot;--appendonly yes&quot;,&quot;--cluster-enabled yes&quot;,&quot;--cluster-node-timeout 5000&quot;]       volumes:       - redis-cluster_data-1:/redis/data    redis-node-2:     image: redis:latest     container_name: redis-2     ports:       - &quot;6382:6379&quot;     command: [&quot;redis-server&quot;,&quot;--appendonly yes&quot;,&quot;--cluster-enabled yes&quot;,&quot;--cluster-node-timeout 5000&quot;]     volumes:       - redis-cluster_data-2:/redis/data    redis-node-3:     image: redis:latest     container_name: redis-3     ports:       - &quot;6383:6379&quot;     command: [&quot;redis-server&quot;,&quot;--appendonly yes&quot;,&quot;--cluster-enabled yes&quot;,&quot;--cluster-node-timeout 5000&quot;]     volumes:       - redis-cluster_data-3:/redis/data    redis-node-4:     image: redis:latest     container_name: redis-4     ports:       - &quot;6384:6379&quot;     command: [&quot;redis-server&quot;,&quot;--appendonly yes&quot;,&quot;--cluster-enabled yes&quot;,&quot;--cluster-node-timeout 5000&quot;]     volumes:       - redis-cluster_data-4:/redis/data    redis-node-5:     image: redis:latest     container_name: redis-5     ports:       - &quot;6385:6379&quot;     command: [&quot;redis-server&quot;,&quot;--appendonly yes&quot;,&quot;--cluster-enabled yes&quot;,&quot;--cluster-node-timeout 5000&quot;]     volumes:       - redis-cluster_data-5:/redis/data   networks:    default:     name: overlay volumes:   redis-cluster_data-0:     driver: local   redis-cluster_data-1:     driver: local   redis-cluster_data-2:     driver: local   redis-cluster_data-3:     driver: local   redis-cluster_data-4:     driver: local   redis-cluster_data-5:     driver: local </code></pre> <p>I'm totally new to Both Docker and Redis, I'm learning so any help would be really appreciated. Thanks in advance.</p> ",
    "OwnerUserId": "11503182",
    "LastEditorUserId": "11503182",
    "LastEditDate": "2021-07-30T17:13:14.613",
    "LastActivityDate": "2022-12-21T12:49:10.700",
    "Title": "Redis Cluster Docker Compose",
    "Tags": "<spring-boot><docker-compose><redis-cluster>",
    "AnswerCount": "1",
    "CommentCount": "5",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "68586177",
    "PostTypeId": "1",
    "CreationDate": "2021-07-30T06:08:46.747",
    "Score": "5",
    "ViewCount": "9081",
    "Body": "<p>I'm struggling to create a Docker Compose to create a Redis Cluster. I saw that there is a Redis Cluster image from Bitnami, I tried but it my Spring Boot App cannot connect to it due to the below error: <a href='https://i.stack.imgur.com/BX3mN.jpg' rel='noreferrer'><img src='https://i.stack.imgur.com/BX3mN.jpg' alt='enter image description here' /></a></p> <p>I tried another approach is to create 2 Redis instances master-slave and I can connect to it. Now I'm trying to create 6 Redis Instances and later create a Redis Cluster with 3 master and 3 slaves with the following command:</p> <pre><code>redis-cli --cluster create 127.0.0.1:6380 127.0.0.1:6381 \\ 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 127.0.0.1:6385 --cluster-replicas 1 </code></pre> <p>But when I executed the command it said that</p> <pre><code>Could not connect to Redis at 127.0.0.1:6380: Connection refused </code></pre> <p>Below is my current Docker-compose.yaml:</p> <pre><code>version: '3.8' services:   redis-node-0:     image: redis:latest     container_name: redis-0     ports:       - &quot;6380:6379&quot;     command: [&quot;redis-server&quot;,&quot;--appendonly yes&quot;,&quot;--cluster-enabled yes&quot;,&quot;--cluster-node-timeout 5000&quot;]     volumes:       - redis-cluster_data-0:/redis/data    redis-node-1:     image: redis:latest     container_name: redis-1     ports:       - &quot;6381:6379&quot;     command: [&quot;redis-server&quot;,&quot;--appendonly yes&quot;,&quot;--cluster-enabled yes&quot;,&quot;--cluster-node-timeout 5000&quot;]       volumes:       - redis-cluster_data-1:/redis/data    redis-node-2:     image: redis:latest     container_name: redis-2     ports:       - &quot;6382:6379&quot;     command: [&quot;redis-server&quot;,&quot;--appendonly yes&quot;,&quot;--cluster-enabled yes&quot;,&quot;--cluster-node-timeout 5000&quot;]     volumes:       - redis-cluster_data-2:/redis/data    redis-node-3:     image: redis:latest     container_name: redis-3     ports:       - &quot;6383:6379&quot;     command: [&quot;redis-server&quot;,&quot;--appendonly yes&quot;,&quot;--cluster-enabled yes&quot;,&quot;--cluster-node-timeout 5000&quot;]     volumes:       - redis-cluster_data-3:/redis/data    redis-node-4:     image: redis:latest     container_name: redis-4     ports:       - &quot;6384:6379&quot;     command: [&quot;redis-server&quot;,&quot;--appendonly yes&quot;,&quot;--cluster-enabled yes&quot;,&quot;--cluster-node-timeout 5000&quot;]     volumes:       - redis-cluster_data-4:/redis/data    redis-node-5:     image: redis:latest     container_name: redis-5     ports:       - &quot;6385:6379&quot;     command: [&quot;redis-server&quot;,&quot;--appendonly yes&quot;,&quot;--cluster-enabled yes&quot;,&quot;--cluster-node-timeout 5000&quot;]     volumes:       - redis-cluster_data-5:/redis/data   networks:    default:     name: overlay volumes:   redis-cluster_data-0:     driver: local   redis-cluster_data-1:     driver: local   redis-cluster_data-2:     driver: local   redis-cluster_data-3:     driver: local   redis-cluster_data-4:     driver: local   redis-cluster_data-5:     driver: local </code></pre> <p>I'm totally new to Both Docker and Redis, I'm learning so any help would be really appreciated. Thanks in advance.</p> ",
    "OwnerUserId": "11503182",
    "LastEditorUserId": "11503182",
    "LastEditDate": "2021-07-30T17:13:14.613",
    "LastActivityDate": "2022-12-21T12:49:10.700",
    "Title": "Redis Cluster Docker Compose",
    "Tags": "<spring-boot><docker-compose><redis-cluster>",
    "AnswerCount": "1",
    "CommentCount": "5",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "68586177",
    "PostTypeId": "1",
    "CreationDate": "2021-07-30T06:08:46.747",
    "Score": "5",
    "ViewCount": "9081",
    "Body": "<p>I'm struggling to create a Docker Compose to create a Redis Cluster. I saw that there is a Redis Cluster image from Bitnami, I tried but it my Spring Boot App cannot connect to it due to the below error: <a href='https://i.stack.imgur.com/BX3mN.jpg' rel='noreferrer'><img src='https://i.stack.imgur.com/BX3mN.jpg' alt='enter image description here' /></a></p> <p>I tried another approach is to create 2 Redis instances master-slave and I can connect to it. Now I'm trying to create 6 Redis Instances and later create a Redis Cluster with 3 master and 3 slaves with the following command:</p> <pre><code>redis-cli --cluster create 127.0.0.1:6380 127.0.0.1:6381 \\ 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 127.0.0.1:6385 --cluster-replicas 1 </code></pre> <p>But when I executed the command it said that</p> <pre><code>Could not connect to Redis at 127.0.0.1:6380: Connection refused </code></pre> <p>Below is my current Docker-compose.yaml:</p> <pre><code>version: '3.8' services:   redis-node-0:     image: redis:latest     container_name: redis-0     ports:       - &quot;6380:6379&quot;     command: [&quot;redis-server&quot;,&quot;--appendonly yes&quot;,&quot;--cluster-enabled yes&quot;,&quot;--cluster-node-timeout 5000&quot;]     volumes:       - redis-cluster_data-0:/redis/data    redis-node-1:     image: redis:latest     container_name: redis-1     ports:       - &quot;6381:6379&quot;     command: [&quot;redis-server&quot;,&quot;--appendonly yes&quot;,&quot;--cluster-enabled yes&quot;,&quot;--cluster-node-timeout 5000&quot;]       volumes:       - redis-cluster_data-1:/redis/data    redis-node-2:     image: redis:latest     container_name: redis-2     ports:       - &quot;6382:6379&quot;     command: [&quot;redis-server&quot;,&quot;--appendonly yes&quot;,&quot;--cluster-enabled yes&quot;,&quot;--cluster-node-timeout 5000&quot;]     volumes:       - redis-cluster_data-2:/redis/data    redis-node-3:     image: redis:latest     container_name: redis-3     ports:       - &quot;6383:6379&quot;     command: [&quot;redis-server&quot;,&quot;--appendonly yes&quot;,&quot;--cluster-enabled yes&quot;,&quot;--cluster-node-timeout 5000&quot;]     volumes:       - redis-cluster_data-3:/redis/data    redis-node-4:     image: redis:latest     container_name: redis-4     ports:       - &quot;6384:6379&quot;     command: [&quot;redis-server&quot;,&quot;--appendonly yes&quot;,&quot;--cluster-enabled yes&quot;,&quot;--cluster-node-timeout 5000&quot;]     volumes:       - redis-cluster_data-4:/redis/data    redis-node-5:     image: redis:latest     container_name: redis-5     ports:       - &quot;6385:6379&quot;     command: [&quot;redis-server&quot;,&quot;--appendonly yes&quot;,&quot;--cluster-enabled yes&quot;,&quot;--cluster-node-timeout 5000&quot;]     volumes:       - redis-cluster_data-5:/redis/data   networks:    default:     name: overlay volumes:   redis-cluster_data-0:     driver: local   redis-cluster_data-1:     driver: local   redis-cluster_data-2:     driver: local   redis-cluster_data-3:     driver: local   redis-cluster_data-4:     driver: local   redis-cluster_data-5:     driver: local </code></pre> <p>I'm totally new to Both Docker and Redis, I'm learning so any help would be really appreciated. Thanks in advance.</p> ",
    "OwnerUserId": "11503182",
    "LastEditorUserId": "11503182",
    "LastEditDate": "2021-07-30T17:13:14.613",
    "LastActivityDate": "2022-12-21T12:49:10.700",
    "Title": "Redis Cluster Docker Compose",
    "Tags": "<spring-boot><docker-compose><redis-cluster>",
    "AnswerCount": "1",
    "CommentCount": "5",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "72138430",
    "PostTypeId": "1",
    "AcceptedAnswerId": "72138773",
    "CreationDate": "2022-05-06T08:27:47.650",
    "Score": "5",
    "ViewCount": "9264",
    "Body": "<p>Caused by: org.postgresql.util.PSQLException: Connection to localhost:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.</p> <p>I am facing the problem in creation of docker image.</p> <p>when i check postgres port</p> <pre><code>postgres   4318 iqbal    8u  IPv4 0xbccc4b164eb6b423      0t0  TCP 127.0.0.1:5432 (LISTEN) com.docke 11144 iqbal   45u  IPv6 0xbccc4b1b1bb15e0b      0t0  TCP *:5432 (LISTEN) </code></pre> <p>Application.properties file</p> <pre><code>spring.mvc.converters.preferred-json-mapper=gson spring.datasource.url= jdbc:postgresql://localhost:5432/flightbed spring.datasource.username= iqbal spring.datasource.password= postgres  spring.datasource.hikari.connectionTimeout=20000 spring.datasource.hikari.maximumPoolSize=5  spring.jpa.properties.hibernate.dialect= org.hibernate.dialect.PostgreSQLDialect spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true  spring.jpa.hibernate.ddl-auto= update spring.jpa.show-sql=true </code></pre> <p>Docker-compose file is here:</p> <pre><code>    version: '3.1' services:   app:     image: 'docker-spring-boot-postgres:latest'     build:         context: .       container_name: app       depends_on:         - localhost       environment:         - SPRING_DATASOURCE_URL=jdbc:postgresql://postgresqldb:5432/flightbed         - SPRING_DATASOURCE_USERNAME=iqbal         - SPRING_DATASOURCE_PASSWORD=postgres         - SPRING_JPA_HIBERNATE_DDL_AUTO=update    localhost:         image: 'postgres:13.1-alpine'         container_name: postgresqldb         environment:           - POSTGRES_USER=iqbal           - POSTGRES_PASSWORD=postgres  </code></pre> <p>Dockerfile is here :</p> <pre><code>FROM  openjdk:17.0.1-jdk-slim  ADD target/flightdata-0.0.1-SNAPSHOT.jar flightdata-0.0.1-SNAPSHOT.jar  ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;flightdata-0.0.1-SNAPSHOT.jar&quot;] </code></pre> <p>Error log</p> <pre><code>iqbal@MacBook-Pro-von-furqan flightbed % docker run -p 8085:8085 flight1    .   ____          _            __ _ _  /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\ ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\  \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )   '  |____| .__|_| |_|_| |_\\__, | / / / /  =========|_|==============|___/=/_/_/_/  :: Spring Boot ::                (v2.5.3)  2022-05-06 07:44:22.422  INFO 1 --- [           main] flightdata.FlightdataApplication         : Starting FlightdataApplication v0.0.1-SNAPSHOT using Java 17.0.1 on be5bdb7475e9 with PID 1 (/flightdata-0.0.1-SNAPSHOT.jar started by root in /) 2022-05-06 07:44:22.423  INFO 1 --- [           main] flightdata.FlightdataApplication         : No active profile set, falling back to default profiles: default 2022-05-06 07:44:22.919  INFO 1 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode. 2022-05-06 07:44:22.961  INFO 1 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 37 ms. Found 2 JPA repository interfaces. 2022-05-06 07:44:23.334  INFO 1 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 9090 (http) 2022-05-06 07:44:23.341  INFO 1 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat] 2022-05-06 07:44:23.341  INFO 1 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.50] 2022-05-06 07:44:23.379  INFO 1 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext 2022-05-06 07:44:23.380  INFO 1 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 898 ms 2022-05-06 07:44:23.499  INFO 1 --- [           main] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default] 2022-05-06 07:44:23.531  INFO 1 --- [           main] org.hibernate.Version                    : HHH000412: Hibernate ORM core version 5.4.32.Final 2022-05-06 07:44:23.597  INFO 1 --- [           main] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {5.1.2.Final} 2022-05-06 07:44:23.641  INFO 1 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting... 2022-05-06 07:44:24.692 ERROR 1 --- [           main] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Exception during pool initialization.  org.postgresql.util.PSQLException: Connection to localhost:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:303) ~[postgresql-42.2.23.jar!/:42.2.23]         at          at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.9.jar!/:5.3.9]         at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.9.jar!/:5.3.9]         at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.9.jar!/:5.3.9]         at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1154) ~[spring-context-5.3.9.jar!/:5.3.9]         at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:908) ~[spring-context-5.3.9.jar!/:5.3.9]         at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:583) ~[spring-context-5.3.9.jar!/:5.3.9]         at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:145) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:434) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:338) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1343) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1332) ~[spring-boot-2.5.3.jar!/:2.5.3]         at flightdata.FlightdataApplication.main(FlightdataApplication.java:17) ~[classes!/:0.0.1-SNAPSHOT]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) ~[na:na]         at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]         at java.base/java.lang.reflect.Method.invoke(Method.java:568) ~[na:na]         at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:49) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT]         at org.springframework.boot.loader.Launcher.launch(Launcher.java:108) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT]         at org.springframework.boot.loader.Launcher.launch(Launcher.java:58) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT]         at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:88) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT] Caused by: java.net.ConnectException: Connection refused         at java.base/sun.nio.ch.Net.pollConnect(Native Method) ~[na:na]         at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672) ~[na:na]         at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:542) ~[na:na]         at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:597) ~[na:na]         at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327) ~[na:na]         at java.base/java.net.Socket.connect(Socket.java:633) ~[na:na]         at org.postgresql.core.PGStream.createSocket(PGStream.java:231) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.PGStream.&lt;init&gt;(PGStream.java:95) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.v3.ConnectionFactoryImpl.tryConnect(ConnectionFactoryImpl.java:98) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:213) ~[postgresql-42.2.23.jar!/:42.2.23]         ... 58 common frames omitted  2022-05-06 07:44:24.694  WARN 1 --- [           main] o.h.e.j.e.i.JdbcEnvironmentInitiator     : HHH000342: Could not obtain connection to query metadata  org.postgresql.util.PSQLException: Connection to localhost:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:303) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.ConnectionFactory.openConnection(ConnectionFactory.java:51) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.jdbc.PgConnection.&lt;init&gt;(PgConnection.java:223) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.Driver.makeConnection(Driver.java:465) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.Driver.connect(Driver.java:264) ~[postgresql-42.2.23.jar!/:42.2.23]         at com.zaxxer.hikari.util.DriverDataSource.getConnection(DriverDataSource.java:138) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.PoolBase.newConnection(PoolBase.java:364) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.PoolBase.newPoolEntry(PoolBase.java:206) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.createPoolEntry(HikariPool.java:476) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.checkFailFast(HikariPool.java:561) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.&lt;init&gt;(HikariPool.java:115) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:112) ~[HikariCP-4.0.3.jar!/:na]         at org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection(DatasourceConnectionProviderImpl.java:122) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess.obtainConnection(JdbcEnvironmentInitiator.java:180) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.initiateService(JdbcEnvironmentInitiator.java:68) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.initiateService(JdbcEnvironmentInitiator.java:35) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.boot.registry.internal.StandardServiceRegistryImpl.initiateService(StandardServiceRegistryImpl.java:101) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.service.internal.AbstractServiceRegistryImpl.createService(AbstractServiceRegistryImpl.java:263) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.service.internal.AbstractServiceRegistryImpl.initializeService(AbstractServiceRegistryImpl.java:237) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.service.internal.AbstractServiceRegistryImpl.getService(AbstractServiceRegistryImpl.java:214) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.injectServices(DefaultIdentifierGeneratorFactory.java:152) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.service.internal.AbstractServiceRegistryImpl.injectDependencies(AbstractServiceRegistryImpl.java:286) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.service.internal.AbstractServiceRegistryImpl.initializeService(AbstractServiceRegistryImpl.java:243) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.service.internal.AbstractServiceRegistryImpl.getService(AbstractServiceRegistryImpl.java:214) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.boot.internal.InFlightMetadataCollectorImpl.&lt;init&gt;(InFlightMetadataCollectorImpl.java:176) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.boot.model.process.spi.MetadataBuildingProcess.complete(MetadataBuildingProcess.java:127) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.metadata(EntityManagerFactoryBuilderImpl.java:1224) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build(EntityManagerFactoryBuilderImpl.java:1255) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.springframework.orm.jpa.vendor.SpringHibernateJpaPersistenceProvider.createContainerEntityManagerFactory(SpringHibernateJpaPersistenceProvider.java:58) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.createNativeEntityManagerFactory(LocalContainerEntityManagerFactoryBean.java:365) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.buildNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:409) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.afterPropertiesSet(AbstractEntityManagerFactoryBean.java:396) ~[spring-orm-5.3.9.jar!/:5.3.9]         at ]         at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:145) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:434) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:338) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1343) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1332) ~[spring-boot-2.5.3.jar!/:2.5.3]         at flightdata.FlightdataApplication.main(FlightdataApplication.java:17) ~[classes!/:0.0.1-SNAPSHOT]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) ~[na:na]         at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]         at java.base/java.lang.reflect.Method.invoke(Method.java:568) ~[na:na]         at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:49) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT]         at org.springframework.boot.loader.Launcher.launch(Launcher.java:108) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT]         at org.springframework.boot.loader.Launcher.launch(Launcher.java:58) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT]         at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:88) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT] Caused by: java.net.ConnectException: Connection refused         at java.base/sun.nio.ch.Net.pollConnect(Native Method) ~[na:na]         at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672) ~[na:na]         at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:542) ~[na:na]         at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:597) ~[na:na]         at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327) ~[na:na]         at java.base/java.net.Socket.connect(Socket.java:633) ~[na:na]         at org.postgresql.core.PGStream.createSocket(PGStream.java:231) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.PGStream.&lt;init&gt;(PGStream.java:95) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.v3.ConnectionFactoryImpl.tryConnect(ConnectionFactoryImpl.java:98) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:213) ~[postgresql-42.2.23.jar!/:42.2.23]         ... 58 common frames omitted  2022-05-06 07:44:24.707  INFO 1 --- [           main] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.PostgreSQLDialect 2022-05-06 07:44:25.046  INFO 1 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting... 2022-05-06 07:44:26.055 ERROR 1 --- [           main] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Exception during pool initialization.  org.postgresql.util.PSQLException: Connection to localhost:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:303) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.ConnectionFactory.openConnection(ConnectionFactory.java:51) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.jdbc.PgConnection.&lt;init&gt;(PgConnection.java:223) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.Driver.makeConnection(Driver.java:465) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.Driver.connect(Driver.java:264) ~[postgresql-42.2.23.jar!/:42.2.23]         at com.zaxxer.hikari.util.DriverDataSource.getConnection(DriverDataSource.java:138) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.PoolBase.newConnection(PoolBase.java:364) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.PoolBase.newPoolEntry(PoolBase.java:206) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.createPoolEntry(HikariPool.java:476) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.checkFailFast(HikariPool.java:561) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.&lt;init&gt;(HikariPool.java:115) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:112) ~[HikariCP-4.0.3.jar!/:na]         at org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection(DatasourceConnectionProviderImpl.java:122) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess.obtainConnection(JdbcEnvironmentInitiator.java:180) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl.getIsolatedConnection(DdlTransactionIsolatorNonJtaImpl.java:43) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.internal.exec.ImprovedExtractionContextImpl.getJdbcConnection(ImprovedExtractionContextImpl.java:60) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.extract.internal.SequenceInformationExtractorLegacyImpl.extractMetadata(SequenceInformationExtractorLegacyImpl.java:40) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.extract.internal.DatabaseInformationImpl.initializeSequences(DatabaseInformationImpl.java:65) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.extract.internal.DatabaseInformationImpl.&lt;init&gt;(DatabaseInformationImpl.java:59) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.internal.Helper.buildDatabaseInformation(Helper.java:155) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.internal.AbstractSchemaMigrator.doMigration(AbstractSchemaMigrator.java:96) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.performDatabaseAction(SchemaManagementToolCoordinator.java:184) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.process(SchemaManagementToolCoordinator.java:73) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.internal.SessionFactoryImpl.&lt;init&gt;(SessionFactoryImpl.java:318) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.boot.internal.SessionFactoryBuilderImpl.build(SessionFactoryBuilderImpl.java:468) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build(EntityManagerFactoryBuilderImpl.java:1259) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.springframework.orm.jpa.vendor.SpringHibernateJpaPersistenceProvider.createContainerEntityManagerFactory(SpringHibernateJpaPersistenceProvider.java:58) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.createNativeEntityManagerFactory(LocalContainerEntityManagerFactoryBean.java:365) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.buildNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:421) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.afterPropertiesSet(AbstractEntityManagerFactoryBean.java:396) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.afterPropertiesSet(LocalContainerEntityManagerFactoryBean.java:341) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1845) ~[spring-beans-5.3.9.jar!/:5.3.9]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1782) ~[spring-beans-5.3.9.jar!/:5.3.9]         ... 24 common frames omitted Caused by: org.hibernate.exception.JDBCConnectionException: Unable to open JDBC Connection for DDL execution         at org.hibernate.exception.internal.SQLStateConversionDelegate.convert(SQLStateConversionDelegate.java:112) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.exception.internal.StandardSQLExceptionConverter.convert(StandardSQLExceptionConverter.java:42) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.spi.SqlExceptionHelper.convert(SqlExceptionHelper.java:113) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.spi.SqlExceptionHelper.convert(SqlExceptionHelper.java:99) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl.getIsolatedConnection(DdlTransactionIsolatorNonJtaImpl.java:69) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.internal.exec.ImprovedExtractionContextImpl.getJdbcConnection(ImprovedExtractionContextImpl.java:60) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.extract.internal.SequenceInformationExtractorLegacyImpl.extractMetadata(SequenceInformationExtractorLegacyImpl.java:40) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.extract.internal.DatabaseInformationImpl.initializeSequences(DatabaseInformationImpl.java:65) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.extract.internal.DatabaseInformationImpl.&lt;init&gt;(DatabaseInformationImpl.java:59) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.internal.Helper.buildDatabaseInformation(Helper.java:155) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.internal.AbstractSchemaMigrator.doMigration(AbstractSchemaMigrator.java:96) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.performDatabaseAction(SchemaManagementToolCoordinator.java:184) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.process(SchemaManagementToolCoordinator.java:73) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.internal.SessionFactoryImpl.&lt;init&gt;(SessionFactoryImpl.java:318) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.boot.internal.SessionFactoryBuilderImpl.build(SessionFactoryBuilderImpl.java:468) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build(EntityManagerFactoryBuilderImpl.java:1259) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.springframework.orm.jpa.vendor.SpringHibernateJpaPersistenceProvider.createContainerEntityManagerFactory(SpringHibernateJpaPersistenceProvider.java:58) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.createNativeEntityManagerFactory(LocalContainerEntityManagerFactoryBean.java:365) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.buildNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:409) ~[spring-orm-5.3.9.jar!/:5.3.9]         ... 28 common frames omitted Caused by: org.postgresql.util.PSQLException: Connection to localhost:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:303) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.ConnectionFactory.openConnection(ConnectionFactory.java:51) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.jdbc.PgConnection.&lt;init&gt;(PgConnection.java:223) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.Driver.makeConnection(Driver.java:465) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.Driver.connect(Driver.java:264) ~[postgresql-42.2.23.jar!/:42.2.23]         at com.zaxxer.hikari.util.DriverDataSource.getConnection(DriverDataSource.java:138) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.PoolBase.newConnection(PoolBase.java:364) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.PoolBase.newPoolEntry(PoolBase.java:206) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.createPoolEntry(HikariPool.java:476) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.checkFailFast(HikariPool.java:561) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.&lt;init&gt;(HikariPool.java:115) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:112) ~[HikariCP-4.0.3.jar!/:na]         at org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection(DatasourceConnectionProviderImpl.java:122) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess.obtainConnection(JdbcEnvironmentInitiator.java:180) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl.getIsolatedConnection(DdlTransactionIsolatorNonJtaImpl.java:43) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         ... 42 common frames omitted Caused by: java.net.ConnectException: Connection refused         at java.base/sun.nio.ch.Net.pollConnect(Native Method) ~[na:na]         at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672) ~[na:na]         at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:542) ~[na:na]         at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:597) ~[na:na]         at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327) ~[na:na]         at java.base/java.net.Socket.connect(Socket.java:633) ~[na:na]         at org.postgresql.core.PGStream.createSocket(PGStream.java:231) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.PGStream.&lt;init&gt;(PGStream.java:95) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.v3.ConnectionFactoryImpl.tryConnect(ConnectionFactoryImpl.java:98) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:213) ~[postgresql-42.2.23.jar!/:42.2.23]         ... 56 common frames omitted  </code></pre> ",
    "OwnerUserId": "5949561",
    "LastEditorUserId": "2576372",
    "LastEditDate": "2022-05-08T05:18:08.807",
    "LastActivityDate": "2022-05-08T05:18:08.807",
    "Title": "I have a Java Spring boot with Postgresql within docker-compose, org.postgresql.util.PSQLException: Connection to localhost:5432",
    "Tags": "<postgresql><spring-boot><docker><docker-compose><devops>",
    "AnswerCount": "1",
    "CommentCount": "5",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "72138430",
    "PostTypeId": "1",
    "AcceptedAnswerId": "72138773",
    "CreationDate": "2022-05-06T08:27:47.650",
    "Score": "5",
    "ViewCount": "9264",
    "Body": "<p>Caused by: org.postgresql.util.PSQLException: Connection to localhost:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.</p> <p>I am facing the problem in creation of docker image.</p> <p>when i check postgres port</p> <pre><code>postgres   4318 iqbal    8u  IPv4 0xbccc4b164eb6b423      0t0  TCP 127.0.0.1:5432 (LISTEN) com.docke 11144 iqbal   45u  IPv6 0xbccc4b1b1bb15e0b      0t0  TCP *:5432 (LISTEN) </code></pre> <p>Application.properties file</p> <pre><code>spring.mvc.converters.preferred-json-mapper=gson spring.datasource.url= jdbc:postgresql://localhost:5432/flightbed spring.datasource.username= iqbal spring.datasource.password= postgres  spring.datasource.hikari.connectionTimeout=20000 spring.datasource.hikari.maximumPoolSize=5  spring.jpa.properties.hibernate.dialect= org.hibernate.dialect.PostgreSQLDialect spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true  spring.jpa.hibernate.ddl-auto= update spring.jpa.show-sql=true </code></pre> <p>Docker-compose file is here:</p> <pre><code>    version: '3.1' services:   app:     image: 'docker-spring-boot-postgres:latest'     build:         context: .       container_name: app       depends_on:         - localhost       environment:         - SPRING_DATASOURCE_URL=jdbc:postgresql://postgresqldb:5432/flightbed         - SPRING_DATASOURCE_USERNAME=iqbal         - SPRING_DATASOURCE_PASSWORD=postgres         - SPRING_JPA_HIBERNATE_DDL_AUTO=update    localhost:         image: 'postgres:13.1-alpine'         container_name: postgresqldb         environment:           - POSTGRES_USER=iqbal           - POSTGRES_PASSWORD=postgres  </code></pre> <p>Dockerfile is here :</p> <pre><code>FROM  openjdk:17.0.1-jdk-slim  ADD target/flightdata-0.0.1-SNAPSHOT.jar flightdata-0.0.1-SNAPSHOT.jar  ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;flightdata-0.0.1-SNAPSHOT.jar&quot;] </code></pre> <p>Error log</p> <pre><code>iqbal@MacBook-Pro-von-furqan flightbed % docker run -p 8085:8085 flight1    .   ____          _            __ _ _  /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\ ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\  \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )   '  |____| .__|_| |_|_| |_\\__, | / / / /  =========|_|==============|___/=/_/_/_/  :: Spring Boot ::                (v2.5.3)  2022-05-06 07:44:22.422  INFO 1 --- [           main] flightdata.FlightdataApplication         : Starting FlightdataApplication v0.0.1-SNAPSHOT using Java 17.0.1 on be5bdb7475e9 with PID 1 (/flightdata-0.0.1-SNAPSHOT.jar started by root in /) 2022-05-06 07:44:22.423  INFO 1 --- [           main] flightdata.FlightdataApplication         : No active profile set, falling back to default profiles: default 2022-05-06 07:44:22.919  INFO 1 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode. 2022-05-06 07:44:22.961  INFO 1 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 37 ms. Found 2 JPA repository interfaces. 2022-05-06 07:44:23.334  INFO 1 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 9090 (http) 2022-05-06 07:44:23.341  INFO 1 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat] 2022-05-06 07:44:23.341  INFO 1 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.50] 2022-05-06 07:44:23.379  INFO 1 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext 2022-05-06 07:44:23.380  INFO 1 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 898 ms 2022-05-06 07:44:23.499  INFO 1 --- [           main] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default] 2022-05-06 07:44:23.531  INFO 1 --- [           main] org.hibernate.Version                    : HHH000412: Hibernate ORM core version 5.4.32.Final 2022-05-06 07:44:23.597  INFO 1 --- [           main] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {5.1.2.Final} 2022-05-06 07:44:23.641  INFO 1 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting... 2022-05-06 07:44:24.692 ERROR 1 --- [           main] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Exception during pool initialization.  org.postgresql.util.PSQLException: Connection to localhost:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:303) ~[postgresql-42.2.23.jar!/:42.2.23]         at          at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.9.jar!/:5.3.9]         at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.9.jar!/:5.3.9]         at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.9.jar!/:5.3.9]         at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1154) ~[spring-context-5.3.9.jar!/:5.3.9]         at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:908) ~[spring-context-5.3.9.jar!/:5.3.9]         at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:583) ~[spring-context-5.3.9.jar!/:5.3.9]         at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:145) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:434) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:338) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1343) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1332) ~[spring-boot-2.5.3.jar!/:2.5.3]         at flightdata.FlightdataApplication.main(FlightdataApplication.java:17) ~[classes!/:0.0.1-SNAPSHOT]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) ~[na:na]         at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]         at java.base/java.lang.reflect.Method.invoke(Method.java:568) ~[na:na]         at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:49) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT]         at org.springframework.boot.loader.Launcher.launch(Launcher.java:108) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT]         at org.springframework.boot.loader.Launcher.launch(Launcher.java:58) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT]         at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:88) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT] Caused by: java.net.ConnectException: Connection refused         at java.base/sun.nio.ch.Net.pollConnect(Native Method) ~[na:na]         at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672) ~[na:na]         at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:542) ~[na:na]         at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:597) ~[na:na]         at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327) ~[na:na]         at java.base/java.net.Socket.connect(Socket.java:633) ~[na:na]         at org.postgresql.core.PGStream.createSocket(PGStream.java:231) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.PGStream.&lt;init&gt;(PGStream.java:95) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.v3.ConnectionFactoryImpl.tryConnect(ConnectionFactoryImpl.java:98) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:213) ~[postgresql-42.2.23.jar!/:42.2.23]         ... 58 common frames omitted  2022-05-06 07:44:24.694  WARN 1 --- [           main] o.h.e.j.e.i.JdbcEnvironmentInitiator     : HHH000342: Could not obtain connection to query metadata  org.postgresql.util.PSQLException: Connection to localhost:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:303) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.ConnectionFactory.openConnection(ConnectionFactory.java:51) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.jdbc.PgConnection.&lt;init&gt;(PgConnection.java:223) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.Driver.makeConnection(Driver.java:465) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.Driver.connect(Driver.java:264) ~[postgresql-42.2.23.jar!/:42.2.23]         at com.zaxxer.hikari.util.DriverDataSource.getConnection(DriverDataSource.java:138) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.PoolBase.newConnection(PoolBase.java:364) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.PoolBase.newPoolEntry(PoolBase.java:206) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.createPoolEntry(HikariPool.java:476) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.checkFailFast(HikariPool.java:561) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.&lt;init&gt;(HikariPool.java:115) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:112) ~[HikariCP-4.0.3.jar!/:na]         at org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection(DatasourceConnectionProviderImpl.java:122) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess.obtainConnection(JdbcEnvironmentInitiator.java:180) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.initiateService(JdbcEnvironmentInitiator.java:68) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.initiateService(JdbcEnvironmentInitiator.java:35) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.boot.registry.internal.StandardServiceRegistryImpl.initiateService(StandardServiceRegistryImpl.java:101) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.service.internal.AbstractServiceRegistryImpl.createService(AbstractServiceRegistryImpl.java:263) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.service.internal.AbstractServiceRegistryImpl.initializeService(AbstractServiceRegistryImpl.java:237) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.service.internal.AbstractServiceRegistryImpl.getService(AbstractServiceRegistryImpl.java:214) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.injectServices(DefaultIdentifierGeneratorFactory.java:152) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.service.internal.AbstractServiceRegistryImpl.injectDependencies(AbstractServiceRegistryImpl.java:286) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.service.internal.AbstractServiceRegistryImpl.initializeService(AbstractServiceRegistryImpl.java:243) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.service.internal.AbstractServiceRegistryImpl.getService(AbstractServiceRegistryImpl.java:214) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.boot.internal.InFlightMetadataCollectorImpl.&lt;init&gt;(InFlightMetadataCollectorImpl.java:176) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.boot.model.process.spi.MetadataBuildingProcess.complete(MetadataBuildingProcess.java:127) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.metadata(EntityManagerFactoryBuilderImpl.java:1224) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build(EntityManagerFactoryBuilderImpl.java:1255) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.springframework.orm.jpa.vendor.SpringHibernateJpaPersistenceProvider.createContainerEntityManagerFactory(SpringHibernateJpaPersistenceProvider.java:58) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.createNativeEntityManagerFactory(LocalContainerEntityManagerFactoryBean.java:365) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.buildNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:409) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.afterPropertiesSet(AbstractEntityManagerFactoryBean.java:396) ~[spring-orm-5.3.9.jar!/:5.3.9]         at ]         at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:145) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:434) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:338) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1343) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1332) ~[spring-boot-2.5.3.jar!/:2.5.3]         at flightdata.FlightdataApplication.main(FlightdataApplication.java:17) ~[classes!/:0.0.1-SNAPSHOT]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) ~[na:na]         at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]         at java.base/java.lang.reflect.Method.invoke(Method.java:568) ~[na:na]         at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:49) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT]         at org.springframework.boot.loader.Launcher.launch(Launcher.java:108) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT]         at org.springframework.boot.loader.Launcher.launch(Launcher.java:58) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT]         at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:88) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT] Caused by: java.net.ConnectException: Connection refused         at java.base/sun.nio.ch.Net.pollConnect(Native Method) ~[na:na]         at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672) ~[na:na]         at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:542) ~[na:na]         at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:597) ~[na:na]         at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327) ~[na:na]         at java.base/java.net.Socket.connect(Socket.java:633) ~[na:na]         at org.postgresql.core.PGStream.createSocket(PGStream.java:231) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.PGStream.&lt;init&gt;(PGStream.java:95) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.v3.ConnectionFactoryImpl.tryConnect(ConnectionFactoryImpl.java:98) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:213) ~[postgresql-42.2.23.jar!/:42.2.23]         ... 58 common frames omitted  2022-05-06 07:44:24.707  INFO 1 --- [           main] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.PostgreSQLDialect 2022-05-06 07:44:25.046  INFO 1 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting... 2022-05-06 07:44:26.055 ERROR 1 --- [           main] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Exception during pool initialization.  org.postgresql.util.PSQLException: Connection to localhost:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:303) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.ConnectionFactory.openConnection(ConnectionFactory.java:51) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.jdbc.PgConnection.&lt;init&gt;(PgConnection.java:223) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.Driver.makeConnection(Driver.java:465) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.Driver.connect(Driver.java:264) ~[postgresql-42.2.23.jar!/:42.2.23]         at com.zaxxer.hikari.util.DriverDataSource.getConnection(DriverDataSource.java:138) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.PoolBase.newConnection(PoolBase.java:364) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.PoolBase.newPoolEntry(PoolBase.java:206) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.createPoolEntry(HikariPool.java:476) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.checkFailFast(HikariPool.java:561) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.&lt;init&gt;(HikariPool.java:115) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:112) ~[HikariCP-4.0.3.jar!/:na]         at org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection(DatasourceConnectionProviderImpl.java:122) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess.obtainConnection(JdbcEnvironmentInitiator.java:180) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl.getIsolatedConnection(DdlTransactionIsolatorNonJtaImpl.java:43) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.internal.exec.ImprovedExtractionContextImpl.getJdbcConnection(ImprovedExtractionContextImpl.java:60) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.extract.internal.SequenceInformationExtractorLegacyImpl.extractMetadata(SequenceInformationExtractorLegacyImpl.java:40) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.extract.internal.DatabaseInformationImpl.initializeSequences(DatabaseInformationImpl.java:65) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.extract.internal.DatabaseInformationImpl.&lt;init&gt;(DatabaseInformationImpl.java:59) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.internal.Helper.buildDatabaseInformation(Helper.java:155) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.internal.AbstractSchemaMigrator.doMigration(AbstractSchemaMigrator.java:96) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.performDatabaseAction(SchemaManagementToolCoordinator.java:184) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.process(SchemaManagementToolCoordinator.java:73) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.internal.SessionFactoryImpl.&lt;init&gt;(SessionFactoryImpl.java:318) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.boot.internal.SessionFactoryBuilderImpl.build(SessionFactoryBuilderImpl.java:468) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build(EntityManagerFactoryBuilderImpl.java:1259) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.springframework.orm.jpa.vendor.SpringHibernateJpaPersistenceProvider.createContainerEntityManagerFactory(SpringHibernateJpaPersistenceProvider.java:58) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.createNativeEntityManagerFactory(LocalContainerEntityManagerFactoryBean.java:365) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.buildNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:421) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.afterPropertiesSet(AbstractEntityManagerFactoryBean.java:396) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.afterPropertiesSet(LocalContainerEntityManagerFactoryBean.java:341) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1845) ~[spring-beans-5.3.9.jar!/:5.3.9]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1782) ~[spring-beans-5.3.9.jar!/:5.3.9]         ... 24 common frames omitted Caused by: org.hibernate.exception.JDBCConnectionException: Unable to open JDBC Connection for DDL execution         at org.hibernate.exception.internal.SQLStateConversionDelegate.convert(SQLStateConversionDelegate.java:112) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.exception.internal.StandardSQLExceptionConverter.convert(StandardSQLExceptionConverter.java:42) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.spi.SqlExceptionHelper.convert(SqlExceptionHelper.java:113) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.spi.SqlExceptionHelper.convert(SqlExceptionHelper.java:99) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl.getIsolatedConnection(DdlTransactionIsolatorNonJtaImpl.java:69) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.internal.exec.ImprovedExtractionContextImpl.getJdbcConnection(ImprovedExtractionContextImpl.java:60) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.extract.internal.SequenceInformationExtractorLegacyImpl.extractMetadata(SequenceInformationExtractorLegacyImpl.java:40) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.extract.internal.DatabaseInformationImpl.initializeSequences(DatabaseInformationImpl.java:65) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.extract.internal.DatabaseInformationImpl.&lt;init&gt;(DatabaseInformationImpl.java:59) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.internal.Helper.buildDatabaseInformation(Helper.java:155) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.internal.AbstractSchemaMigrator.doMigration(AbstractSchemaMigrator.java:96) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.performDatabaseAction(SchemaManagementToolCoordinator.java:184) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.process(SchemaManagementToolCoordinator.java:73) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.internal.SessionFactoryImpl.&lt;init&gt;(SessionFactoryImpl.java:318) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.boot.internal.SessionFactoryBuilderImpl.build(SessionFactoryBuilderImpl.java:468) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build(EntityManagerFactoryBuilderImpl.java:1259) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.springframework.orm.jpa.vendor.SpringHibernateJpaPersistenceProvider.createContainerEntityManagerFactory(SpringHibernateJpaPersistenceProvider.java:58) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.createNativeEntityManagerFactory(LocalContainerEntityManagerFactoryBean.java:365) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.buildNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:409) ~[spring-orm-5.3.9.jar!/:5.3.9]         ... 28 common frames omitted Caused by: org.postgresql.util.PSQLException: Connection to localhost:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:303) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.ConnectionFactory.openConnection(ConnectionFactory.java:51) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.jdbc.PgConnection.&lt;init&gt;(PgConnection.java:223) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.Driver.makeConnection(Driver.java:465) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.Driver.connect(Driver.java:264) ~[postgresql-42.2.23.jar!/:42.2.23]         at com.zaxxer.hikari.util.DriverDataSource.getConnection(DriverDataSource.java:138) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.PoolBase.newConnection(PoolBase.java:364) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.PoolBase.newPoolEntry(PoolBase.java:206) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.createPoolEntry(HikariPool.java:476) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.checkFailFast(HikariPool.java:561) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.&lt;init&gt;(HikariPool.java:115) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:112) ~[HikariCP-4.0.3.jar!/:na]         at org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection(DatasourceConnectionProviderImpl.java:122) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess.obtainConnection(JdbcEnvironmentInitiator.java:180) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl.getIsolatedConnection(DdlTransactionIsolatorNonJtaImpl.java:43) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         ... 42 common frames omitted Caused by: java.net.ConnectException: Connection refused         at java.base/sun.nio.ch.Net.pollConnect(Native Method) ~[na:na]         at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672) ~[na:na]         at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:542) ~[na:na]         at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:597) ~[na:na]         at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327) ~[na:na]         at java.base/java.net.Socket.connect(Socket.java:633) ~[na:na]         at org.postgresql.core.PGStream.createSocket(PGStream.java:231) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.PGStream.&lt;init&gt;(PGStream.java:95) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.v3.ConnectionFactoryImpl.tryConnect(ConnectionFactoryImpl.java:98) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:213) ~[postgresql-42.2.23.jar!/:42.2.23]         ... 56 common frames omitted  </code></pre> ",
    "OwnerUserId": "5949561",
    "LastEditorUserId": "2576372",
    "LastEditDate": "2022-05-08T05:18:08.807",
    "LastActivityDate": "2022-05-08T05:18:08.807",
    "Title": "I have a Java Spring boot with Postgresql within docker-compose, org.postgresql.util.PSQLException: Connection to localhost:5432",
    "Tags": "<postgresql><spring-boot><docker><docker-compose><devops>",
    "AnswerCount": "1",
    "CommentCount": "5",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "72138430",
    "PostTypeId": "1",
    "AcceptedAnswerId": "72138773",
    "CreationDate": "2022-05-06T08:27:47.650",
    "Score": "5",
    "ViewCount": "9264",
    "Body": "<p>Caused by: org.postgresql.util.PSQLException: Connection to localhost:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.</p> <p>I am facing the problem in creation of docker image.</p> <p>when i check postgres port</p> <pre><code>postgres   4318 iqbal    8u  IPv4 0xbccc4b164eb6b423      0t0  TCP 127.0.0.1:5432 (LISTEN) com.docke 11144 iqbal   45u  IPv6 0xbccc4b1b1bb15e0b      0t0  TCP *:5432 (LISTEN) </code></pre> <p>Application.properties file</p> <pre><code>spring.mvc.converters.preferred-json-mapper=gson spring.datasource.url= jdbc:postgresql://localhost:5432/flightbed spring.datasource.username= iqbal spring.datasource.password= postgres  spring.datasource.hikari.connectionTimeout=20000 spring.datasource.hikari.maximumPoolSize=5  spring.jpa.properties.hibernate.dialect= org.hibernate.dialect.PostgreSQLDialect spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true  spring.jpa.hibernate.ddl-auto= update spring.jpa.show-sql=true </code></pre> <p>Docker-compose file is here:</p> <pre><code>    version: '3.1' services:   app:     image: 'docker-spring-boot-postgres:latest'     build:         context: .       container_name: app       depends_on:         - localhost       environment:         - SPRING_DATASOURCE_URL=jdbc:postgresql://postgresqldb:5432/flightbed         - SPRING_DATASOURCE_USERNAME=iqbal         - SPRING_DATASOURCE_PASSWORD=postgres         - SPRING_JPA_HIBERNATE_DDL_AUTO=update    localhost:         image: 'postgres:13.1-alpine'         container_name: postgresqldb         environment:           - POSTGRES_USER=iqbal           - POSTGRES_PASSWORD=postgres  </code></pre> <p>Dockerfile is here :</p> <pre><code>FROM  openjdk:17.0.1-jdk-slim  ADD target/flightdata-0.0.1-SNAPSHOT.jar flightdata-0.0.1-SNAPSHOT.jar  ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;flightdata-0.0.1-SNAPSHOT.jar&quot;] </code></pre> <p>Error log</p> <pre><code>iqbal@MacBook-Pro-von-furqan flightbed % docker run -p 8085:8085 flight1    .   ____          _            __ _ _  /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\ ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\  \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )   '  |____| .__|_| |_|_| |_\\__, | / / / /  =========|_|==============|___/=/_/_/_/  :: Spring Boot ::                (v2.5.3)  2022-05-06 07:44:22.422  INFO 1 --- [           main] flightdata.FlightdataApplication         : Starting FlightdataApplication v0.0.1-SNAPSHOT using Java 17.0.1 on be5bdb7475e9 with PID 1 (/flightdata-0.0.1-SNAPSHOT.jar started by root in /) 2022-05-06 07:44:22.423  INFO 1 --- [           main] flightdata.FlightdataApplication         : No active profile set, falling back to default profiles: default 2022-05-06 07:44:22.919  INFO 1 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode. 2022-05-06 07:44:22.961  INFO 1 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 37 ms. Found 2 JPA repository interfaces. 2022-05-06 07:44:23.334  INFO 1 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 9090 (http) 2022-05-06 07:44:23.341  INFO 1 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat] 2022-05-06 07:44:23.341  INFO 1 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.50] 2022-05-06 07:44:23.379  INFO 1 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext 2022-05-06 07:44:23.380  INFO 1 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 898 ms 2022-05-06 07:44:23.499  INFO 1 --- [           main] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default] 2022-05-06 07:44:23.531  INFO 1 --- [           main] org.hibernate.Version                    : HHH000412: Hibernate ORM core version 5.4.32.Final 2022-05-06 07:44:23.597  INFO 1 --- [           main] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {5.1.2.Final} 2022-05-06 07:44:23.641  INFO 1 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting... 2022-05-06 07:44:24.692 ERROR 1 --- [           main] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Exception during pool initialization.  org.postgresql.util.PSQLException: Connection to localhost:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:303) ~[postgresql-42.2.23.jar!/:42.2.23]         at          at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.9.jar!/:5.3.9]         at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.9.jar!/:5.3.9]         at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.9.jar!/:5.3.9]         at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1154) ~[spring-context-5.3.9.jar!/:5.3.9]         at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:908) ~[spring-context-5.3.9.jar!/:5.3.9]         at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:583) ~[spring-context-5.3.9.jar!/:5.3.9]         at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:145) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:434) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:338) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1343) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1332) ~[spring-boot-2.5.3.jar!/:2.5.3]         at flightdata.FlightdataApplication.main(FlightdataApplication.java:17) ~[classes!/:0.0.1-SNAPSHOT]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) ~[na:na]         at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]         at java.base/java.lang.reflect.Method.invoke(Method.java:568) ~[na:na]         at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:49) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT]         at org.springframework.boot.loader.Launcher.launch(Launcher.java:108) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT]         at org.springframework.boot.loader.Launcher.launch(Launcher.java:58) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT]         at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:88) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT] Caused by: java.net.ConnectException: Connection refused         at java.base/sun.nio.ch.Net.pollConnect(Native Method) ~[na:na]         at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672) ~[na:na]         at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:542) ~[na:na]         at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:597) ~[na:na]         at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327) ~[na:na]         at java.base/java.net.Socket.connect(Socket.java:633) ~[na:na]         at org.postgresql.core.PGStream.createSocket(PGStream.java:231) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.PGStream.&lt;init&gt;(PGStream.java:95) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.v3.ConnectionFactoryImpl.tryConnect(ConnectionFactoryImpl.java:98) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:213) ~[postgresql-42.2.23.jar!/:42.2.23]         ... 58 common frames omitted  2022-05-06 07:44:24.694  WARN 1 --- [           main] o.h.e.j.e.i.JdbcEnvironmentInitiator     : HHH000342: Could not obtain connection to query metadata  org.postgresql.util.PSQLException: Connection to localhost:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:303) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.ConnectionFactory.openConnection(ConnectionFactory.java:51) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.jdbc.PgConnection.&lt;init&gt;(PgConnection.java:223) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.Driver.makeConnection(Driver.java:465) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.Driver.connect(Driver.java:264) ~[postgresql-42.2.23.jar!/:42.2.23]         at com.zaxxer.hikari.util.DriverDataSource.getConnection(DriverDataSource.java:138) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.PoolBase.newConnection(PoolBase.java:364) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.PoolBase.newPoolEntry(PoolBase.java:206) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.createPoolEntry(HikariPool.java:476) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.checkFailFast(HikariPool.java:561) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.&lt;init&gt;(HikariPool.java:115) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:112) ~[HikariCP-4.0.3.jar!/:na]         at org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection(DatasourceConnectionProviderImpl.java:122) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess.obtainConnection(JdbcEnvironmentInitiator.java:180) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.initiateService(JdbcEnvironmentInitiator.java:68) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.initiateService(JdbcEnvironmentInitiator.java:35) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.boot.registry.internal.StandardServiceRegistryImpl.initiateService(StandardServiceRegistryImpl.java:101) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.service.internal.AbstractServiceRegistryImpl.createService(AbstractServiceRegistryImpl.java:263) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.service.internal.AbstractServiceRegistryImpl.initializeService(AbstractServiceRegistryImpl.java:237) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.service.internal.AbstractServiceRegistryImpl.getService(AbstractServiceRegistryImpl.java:214) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.injectServices(DefaultIdentifierGeneratorFactory.java:152) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.service.internal.AbstractServiceRegistryImpl.injectDependencies(AbstractServiceRegistryImpl.java:286) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.service.internal.AbstractServiceRegistryImpl.initializeService(AbstractServiceRegistryImpl.java:243) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.service.internal.AbstractServiceRegistryImpl.getService(AbstractServiceRegistryImpl.java:214) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.boot.internal.InFlightMetadataCollectorImpl.&lt;init&gt;(InFlightMetadataCollectorImpl.java:176) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.boot.model.process.spi.MetadataBuildingProcess.complete(MetadataBuildingProcess.java:127) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.metadata(EntityManagerFactoryBuilderImpl.java:1224) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build(EntityManagerFactoryBuilderImpl.java:1255) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.springframework.orm.jpa.vendor.SpringHibernateJpaPersistenceProvider.createContainerEntityManagerFactory(SpringHibernateJpaPersistenceProvider.java:58) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.createNativeEntityManagerFactory(LocalContainerEntityManagerFactoryBean.java:365) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.buildNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:409) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.afterPropertiesSet(AbstractEntityManagerFactoryBean.java:396) ~[spring-orm-5.3.9.jar!/:5.3.9]         at ]         at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:145) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:434) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:338) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1343) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1332) ~[spring-boot-2.5.3.jar!/:2.5.3]         at flightdata.FlightdataApplication.main(FlightdataApplication.java:17) ~[classes!/:0.0.1-SNAPSHOT]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) ~[na:na]         at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]         at java.base/java.lang.reflect.Method.invoke(Method.java:568) ~[na:na]         at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:49) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT]         at org.springframework.boot.loader.Launcher.launch(Launcher.java:108) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT]         at org.springframework.boot.loader.Launcher.launch(Launcher.java:58) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT]         at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:88) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT] Caused by: java.net.ConnectException: Connection refused         at java.base/sun.nio.ch.Net.pollConnect(Native Method) ~[na:na]         at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672) ~[na:na]         at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:542) ~[na:na]         at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:597) ~[na:na]         at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327) ~[na:na]         at java.base/java.net.Socket.connect(Socket.java:633) ~[na:na]         at org.postgresql.core.PGStream.createSocket(PGStream.java:231) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.PGStream.&lt;init&gt;(PGStream.java:95) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.v3.ConnectionFactoryImpl.tryConnect(ConnectionFactoryImpl.java:98) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:213) ~[postgresql-42.2.23.jar!/:42.2.23]         ... 58 common frames omitted  2022-05-06 07:44:24.707  INFO 1 --- [           main] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.PostgreSQLDialect 2022-05-06 07:44:25.046  INFO 1 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting... 2022-05-06 07:44:26.055 ERROR 1 --- [           main] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Exception during pool initialization.  org.postgresql.util.PSQLException: Connection to localhost:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:303) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.ConnectionFactory.openConnection(ConnectionFactory.java:51) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.jdbc.PgConnection.&lt;init&gt;(PgConnection.java:223) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.Driver.makeConnection(Driver.java:465) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.Driver.connect(Driver.java:264) ~[postgresql-42.2.23.jar!/:42.2.23]         at com.zaxxer.hikari.util.DriverDataSource.getConnection(DriverDataSource.java:138) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.PoolBase.newConnection(PoolBase.java:364) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.PoolBase.newPoolEntry(PoolBase.java:206) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.createPoolEntry(HikariPool.java:476) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.checkFailFast(HikariPool.java:561) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.&lt;init&gt;(HikariPool.java:115) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:112) ~[HikariCP-4.0.3.jar!/:na]         at org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection(DatasourceConnectionProviderImpl.java:122) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess.obtainConnection(JdbcEnvironmentInitiator.java:180) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl.getIsolatedConnection(DdlTransactionIsolatorNonJtaImpl.java:43) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.internal.exec.ImprovedExtractionContextImpl.getJdbcConnection(ImprovedExtractionContextImpl.java:60) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.extract.internal.SequenceInformationExtractorLegacyImpl.extractMetadata(SequenceInformationExtractorLegacyImpl.java:40) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.extract.internal.DatabaseInformationImpl.initializeSequences(DatabaseInformationImpl.java:65) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.extract.internal.DatabaseInformationImpl.&lt;init&gt;(DatabaseInformationImpl.java:59) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.internal.Helper.buildDatabaseInformation(Helper.java:155) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.internal.AbstractSchemaMigrator.doMigration(AbstractSchemaMigrator.java:96) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.performDatabaseAction(SchemaManagementToolCoordinator.java:184) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.process(SchemaManagementToolCoordinator.java:73) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.internal.SessionFactoryImpl.&lt;init&gt;(SessionFactoryImpl.java:318) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.boot.internal.SessionFactoryBuilderImpl.build(SessionFactoryBuilderImpl.java:468) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build(EntityManagerFactoryBuilderImpl.java:1259) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.springframework.orm.jpa.vendor.SpringHibernateJpaPersistenceProvider.createContainerEntityManagerFactory(SpringHibernateJpaPersistenceProvider.java:58) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.createNativeEntityManagerFactory(LocalContainerEntityManagerFactoryBean.java:365) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.buildNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:421) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.afterPropertiesSet(AbstractEntityManagerFactoryBean.java:396) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.afterPropertiesSet(LocalContainerEntityManagerFactoryBean.java:341) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1845) ~[spring-beans-5.3.9.jar!/:5.3.9]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1782) ~[spring-beans-5.3.9.jar!/:5.3.9]         ... 24 common frames omitted Caused by: org.hibernate.exception.JDBCConnectionException: Unable to open JDBC Connection for DDL execution         at org.hibernate.exception.internal.SQLStateConversionDelegate.convert(SQLStateConversionDelegate.java:112) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.exception.internal.StandardSQLExceptionConverter.convert(StandardSQLExceptionConverter.java:42) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.spi.SqlExceptionHelper.convert(SqlExceptionHelper.java:113) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.spi.SqlExceptionHelper.convert(SqlExceptionHelper.java:99) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl.getIsolatedConnection(DdlTransactionIsolatorNonJtaImpl.java:69) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.internal.exec.ImprovedExtractionContextImpl.getJdbcConnection(ImprovedExtractionContextImpl.java:60) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.extract.internal.SequenceInformationExtractorLegacyImpl.extractMetadata(SequenceInformationExtractorLegacyImpl.java:40) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.extract.internal.DatabaseInformationImpl.initializeSequences(DatabaseInformationImpl.java:65) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.extract.internal.DatabaseInformationImpl.&lt;init&gt;(DatabaseInformationImpl.java:59) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.internal.Helper.buildDatabaseInformation(Helper.java:155) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.internal.AbstractSchemaMigrator.doMigration(AbstractSchemaMigrator.java:96) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.performDatabaseAction(SchemaManagementToolCoordinator.java:184) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.process(SchemaManagementToolCoordinator.java:73) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.internal.SessionFactoryImpl.&lt;init&gt;(SessionFactoryImpl.java:318) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.boot.internal.SessionFactoryBuilderImpl.build(SessionFactoryBuilderImpl.java:468) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build(EntityManagerFactoryBuilderImpl.java:1259) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.springframework.orm.jpa.vendor.SpringHibernateJpaPersistenceProvider.createContainerEntityManagerFactory(SpringHibernateJpaPersistenceProvider.java:58) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.createNativeEntityManagerFactory(LocalContainerEntityManagerFactoryBean.java:365) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.buildNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:409) ~[spring-orm-5.3.9.jar!/:5.3.9]         ... 28 common frames omitted Caused by: org.postgresql.util.PSQLException: Connection to localhost:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:303) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.ConnectionFactory.openConnection(ConnectionFactory.java:51) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.jdbc.PgConnection.&lt;init&gt;(PgConnection.java:223) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.Driver.makeConnection(Driver.java:465) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.Driver.connect(Driver.java:264) ~[postgresql-42.2.23.jar!/:42.2.23]         at com.zaxxer.hikari.util.DriverDataSource.getConnection(DriverDataSource.java:138) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.PoolBase.newConnection(PoolBase.java:364) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.PoolBase.newPoolEntry(PoolBase.java:206) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.createPoolEntry(HikariPool.java:476) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.checkFailFast(HikariPool.java:561) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.&lt;init&gt;(HikariPool.java:115) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:112) ~[HikariCP-4.0.3.jar!/:na]         at org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection(DatasourceConnectionProviderImpl.java:122) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess.obtainConnection(JdbcEnvironmentInitiator.java:180) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl.getIsolatedConnection(DdlTransactionIsolatorNonJtaImpl.java:43) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         ... 42 common frames omitted Caused by: java.net.ConnectException: Connection refused         at java.base/sun.nio.ch.Net.pollConnect(Native Method) ~[na:na]         at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672) ~[na:na]         at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:542) ~[na:na]         at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:597) ~[na:na]         at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327) ~[na:na]         at java.base/java.net.Socket.connect(Socket.java:633) ~[na:na]         at org.postgresql.core.PGStream.createSocket(PGStream.java:231) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.PGStream.&lt;init&gt;(PGStream.java:95) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.v3.ConnectionFactoryImpl.tryConnect(ConnectionFactoryImpl.java:98) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:213) ~[postgresql-42.2.23.jar!/:42.2.23]         ... 56 common frames omitted  </code></pre> ",
    "OwnerUserId": "5949561",
    "LastEditorUserId": "2576372",
    "LastEditDate": "2022-05-08T05:18:08.807",
    "LastActivityDate": "2022-05-08T05:18:08.807",
    "Title": "I have a Java Spring boot with Postgresql within docker-compose, org.postgresql.util.PSQLException: Connection to localhost:5432",
    "Tags": "<postgresql><spring-boot><docker><docker-compose><devops>",
    "AnswerCount": "1",
    "CommentCount": "5",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "72659587",
    "PostTypeId": "1",
    "CreationDate": "2022-06-17T12:43:09.937",
    "Score": "5",
    "ViewCount": "1628",
    "Body": "<p>I am a newbie to SpringBoot. I am trying to create a spring boot application which i am running using docker. when i run this app, i get the following error</p> <pre><code>org.postgresql.util.PSQLException: FATAL: role &quot;amigoscode&quot; does not exist </code></pre> <p>I don't have any hint, as i am not able to trace this error. Role &quot;amigoscode&quot; already exists. I am attaching below the application.yml and docker-compose.yml</p> <p>application.yml</p> <pre><code>server:   port: 8080  spring:   application:     name: customer   datasource:     password: password     url: jdbc:postgresql://localhost:5432/customer     username: amigoscode   jpa:     hibernate:       ddl-auto: create-drop     properties:       hibernate:         dialect: org.hibernate.dialect.PostgreSQLDialect         format_sql: 'true'     show-sql: 'true' </code></pre> <p>docker-compose.yml</p> <pre><code>services:   postgres:     container_name: postgres     image: postgres     environment:       POSTGRES_USER: amigoscode       POSTGRES_PASSWORD: password       PGDATA: /data/postgres     volumes:       - postgres:/data/postgres     ports:       - &quot;5432:5432&quot;     networks:       - postgres     restart: unless-stopped    pgadmin:     container_name: pgadmin     image: dpage/pgadmin4     environment:       PGADMIN_DEFAULT_EMAIL: ${PGADMIN_DEFAULT_EMAIL:-pgadmin4@pgadmin.org}       PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_DEFAULT_PASSWORD:-admin}       PGADMIN_CONFIG_SERVER_MODE: 'False'     volumes:       - pgadmin:/var/lib/pgadmin     ports:       - &quot;5050:80&quot;     networks:       - postgres     restart: unless-stopped  networks:   postgres:     driver: bridge  volumes:   postgres:   pgadmin: </code></pre> <p>Can you please guide me, what i might be doing wrong here? I have referred other similar question here, but none of them solves my issue. Thank you.</p> ",
    "OwnerUserId": "1468328",
    "LastActivityDate": "2023-12-25T16:49:48.390",
    "Title": "org.postgresql.util.PSQLException: FATAL: role 'amigoscode' does not exist",
    "Tags": "<postgresql><spring-boot><docker><docker-compose>",
    "AnswerCount": "5",
    "CommentCount": "8",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "72659587",
    "PostTypeId": "1",
    "CreationDate": "2022-06-17T12:43:09.937",
    "Score": "5",
    "ViewCount": "1628",
    "Body": "<p>I am a newbie to SpringBoot. I am trying to create a spring boot application which i am running using docker. when i run this app, i get the following error</p> <pre><code>org.postgresql.util.PSQLException: FATAL: role &quot;amigoscode&quot; does not exist </code></pre> <p>I don't have any hint, as i am not able to trace this error. Role &quot;amigoscode&quot; already exists. I am attaching below the application.yml and docker-compose.yml</p> <p>application.yml</p> <pre><code>server:   port: 8080  spring:   application:     name: customer   datasource:     password: password     url: jdbc:postgresql://localhost:5432/customer     username: amigoscode   jpa:     hibernate:       ddl-auto: create-drop     properties:       hibernate:         dialect: org.hibernate.dialect.PostgreSQLDialect         format_sql: 'true'     show-sql: 'true' </code></pre> <p>docker-compose.yml</p> <pre><code>services:   postgres:     container_name: postgres     image: postgres     environment:       POSTGRES_USER: amigoscode       POSTGRES_PASSWORD: password       PGDATA: /data/postgres     volumes:       - postgres:/data/postgres     ports:       - &quot;5432:5432&quot;     networks:       - postgres     restart: unless-stopped    pgadmin:     container_name: pgadmin     image: dpage/pgadmin4     environment:       PGADMIN_DEFAULT_EMAIL: ${PGADMIN_DEFAULT_EMAIL:-pgadmin4@pgadmin.org}       PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_DEFAULT_PASSWORD:-admin}       PGADMIN_CONFIG_SERVER_MODE: 'False'     volumes:       - pgadmin:/var/lib/pgadmin     ports:       - &quot;5050:80&quot;     networks:       - postgres     restart: unless-stopped  networks:   postgres:     driver: bridge  volumes:   postgres:   pgadmin: </code></pre> <p>Can you please guide me, what i might be doing wrong here? I have referred other similar question here, but none of them solves my issue. Thank you.</p> ",
    "OwnerUserId": "1468328",
    "LastActivityDate": "2023-12-25T16:49:48.390",
    "Title": "org.postgresql.util.PSQLException: FATAL: role 'amigoscode' does not exist",
    "Tags": "<postgresql><spring-boot><docker><docker-compose>",
    "AnswerCount": "5",
    "CommentCount": "8",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "72659587",
    "PostTypeId": "1",
    "CreationDate": "2022-06-17T12:43:09.937",
    "Score": "5",
    "ViewCount": "1628",
    "Body": "<p>I am a newbie to SpringBoot. I am trying to create a spring boot application which i am running using docker. when i run this app, i get the following error</p> <pre><code>org.postgresql.util.PSQLException: FATAL: role &quot;amigoscode&quot; does not exist </code></pre> <p>I don't have any hint, as i am not able to trace this error. Role &quot;amigoscode&quot; already exists. I am attaching below the application.yml and docker-compose.yml</p> <p>application.yml</p> <pre><code>server:   port: 8080  spring:   application:     name: customer   datasource:     password: password     url: jdbc:postgresql://localhost:5432/customer     username: amigoscode   jpa:     hibernate:       ddl-auto: create-drop     properties:       hibernate:         dialect: org.hibernate.dialect.PostgreSQLDialect         format_sql: 'true'     show-sql: 'true' </code></pre> <p>docker-compose.yml</p> <pre><code>services:   postgres:     container_name: postgres     image: postgres     environment:       POSTGRES_USER: amigoscode       POSTGRES_PASSWORD: password       PGDATA: /data/postgres     volumes:       - postgres:/data/postgres     ports:       - &quot;5432:5432&quot;     networks:       - postgres     restart: unless-stopped    pgadmin:     container_name: pgadmin     image: dpage/pgadmin4     environment:       PGADMIN_DEFAULT_EMAIL: ${PGADMIN_DEFAULT_EMAIL:-pgadmin4@pgadmin.org}       PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_DEFAULT_PASSWORD:-admin}       PGADMIN_CONFIG_SERVER_MODE: 'False'     volumes:       - pgadmin:/var/lib/pgadmin     ports:       - &quot;5050:80&quot;     networks:       - postgres     restart: unless-stopped  networks:   postgres:     driver: bridge  volumes:   postgres:   pgadmin: </code></pre> <p>Can you please guide me, what i might be doing wrong here? I have referred other similar question here, but none of them solves my issue. Thank you.</p> ",
    "OwnerUserId": "1468328",
    "LastActivityDate": "2023-12-25T16:49:48.390",
    "Title": "org.postgresql.util.PSQLException: FATAL: role 'amigoscode' does not exist",
    "Tags": "<postgresql><spring-boot><docker><docker-compose>",
    "AnswerCount": "5",
    "CommentCount": "8",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "74220706",
    "PostTypeId": "1",
    "CreationDate": "2022-10-27T10:36:27.207",
    "Score": "5",
    "ViewCount": "956",
    "Body": "<p>I am confused about the use case where HashiCorp Vault is used to provide database secrets dynamically for Spring Boot. Lets say you have two microservices: one containing the application logic and one running a database engine. The first obviously needs to authenticate towards the database and this is where dynamic secrets come into play. Vault can provide such credentials to the first microservice so you don't have to use e.g. ENV variables in a docker-compose file managing both microservices. <a href='https://i.stack.imgur.com/jSFCP.png' rel='nofollow noreferrer'><img src='https://i.stack.imgur.com/jSFCP.png' alt='enter image description here' /></a></p> <p>The App could be a Spring Boot microservice relying on Spring Cloud Vault to handle communication with HashiCorp Vault for credentials management. The microservice asks Vault for temporary db credentials (in this case they last for one hour) when it is started. During this one hour interval, the app can connect to the database and do whatever needs to be done. After one hour, the credentials expire and no communications is allowed.</p> <p>The Spring Boot Cloud Vault documentation mentions</p> <blockquote> <p>Spring Cloud Vault does not support getting new credentials and configuring your DataSource with them when the maximum lease time has been reached. That is, if max_ttl of the Database role in Vault is set to 24h that means that 24 hours after your application has started it can no longer authenticate with the database.</p> </blockquote> <p>In other words, after one hour, the connection is lost and there seems to be no other way to get new db credentials other then by restarting the microservice. So if have the following questions:</p> <ol> <li>What is the added value of using Vault in this particular example if you are (seemingly) forced to restart your entire application each time the TTL expires?</li> <li>Does the same apply when you use static secrets instead?</li> <li>Can this issue be solved without changing microservice code? (K8S, Istio, etc.?)</li> </ol> <p>My guess is the intended use of Vault with Spring Boot is different compared to my understanding.</p> ",
    "OwnerUserId": "5585819",
    "LastEditorUserId": "5585819",
    "LastEditDate": "2023-01-10T16:18:12.580",
    "LastActivityDate": "2023-01-11T08:56:02.500",
    "Title": "HashiCorp Vault dynamic secrets and Spring Boot",
    "Tags": "<spring-boot><docker-compose><microservices><hashicorp-vault>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "74220706",
    "PostTypeId": "1",
    "CreationDate": "2022-10-27T10:36:27.207",
    "Score": "5",
    "ViewCount": "956",
    "Body": "<p>I am confused about the use case where HashiCorp Vault is used to provide database secrets dynamically for Spring Boot. Lets say you have two microservices: one containing the application logic and one running a database engine. The first obviously needs to authenticate towards the database and this is where dynamic secrets come into play. Vault can provide such credentials to the first microservice so you don't have to use e.g. ENV variables in a docker-compose file managing both microservices. <a href='https://i.stack.imgur.com/jSFCP.png' rel='nofollow noreferrer'><img src='https://i.stack.imgur.com/jSFCP.png' alt='enter image description here' /></a></p> <p>The App could be a Spring Boot microservice relying on Spring Cloud Vault to handle communication with HashiCorp Vault for credentials management. The microservice asks Vault for temporary db credentials (in this case they last for one hour) when it is started. During this one hour interval, the app can connect to the database and do whatever needs to be done. After one hour, the credentials expire and no communications is allowed.</p> <p>The Spring Boot Cloud Vault documentation mentions</p> <blockquote> <p>Spring Cloud Vault does not support getting new credentials and configuring your DataSource with them when the maximum lease time has been reached. That is, if max_ttl of the Database role in Vault is set to 24h that means that 24 hours after your application has started it can no longer authenticate with the database.</p> </blockquote> <p>In other words, after one hour, the connection is lost and there seems to be no other way to get new db credentials other then by restarting the microservice. So if have the following questions:</p> <ol> <li>What is the added value of using Vault in this particular example if you are (seemingly) forced to restart your entire application each time the TTL expires?</li> <li>Does the same apply when you use static secrets instead?</li> <li>Can this issue be solved without changing microservice code? (K8S, Istio, etc.?)</li> </ol> <p>My guess is the intended use of Vault with Spring Boot is different compared to my understanding.</p> ",
    "OwnerUserId": "5585819",
    "LastEditorUserId": "5585819",
    "LastEditDate": "2023-01-10T16:18:12.580",
    "LastActivityDate": "2023-01-11T08:56:02.500",
    "Title": "HashiCorp Vault dynamic secrets and Spring Boot",
    "Tags": "<spring-boot><docker-compose><microservices><hashicorp-vault>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "74220706",
    "PostTypeId": "1",
    "CreationDate": "2022-10-27T10:36:27.207",
    "Score": "5",
    "ViewCount": "956",
    "Body": "<p>I am confused about the use case where HashiCorp Vault is used to provide database secrets dynamically for Spring Boot. Lets say you have two microservices: one containing the application logic and one running a database engine. The first obviously needs to authenticate towards the database and this is where dynamic secrets come into play. Vault can provide such credentials to the first microservice so you don't have to use e.g. ENV variables in a docker-compose file managing both microservices. <a href='https://i.stack.imgur.com/jSFCP.png' rel='nofollow noreferrer'><img src='https://i.stack.imgur.com/jSFCP.png' alt='enter image description here' /></a></p> <p>The App could be a Spring Boot microservice relying on Spring Cloud Vault to handle communication with HashiCorp Vault for credentials management. The microservice asks Vault for temporary db credentials (in this case they last for one hour) when it is started. During this one hour interval, the app can connect to the database and do whatever needs to be done. After one hour, the credentials expire and no communications is allowed.</p> <p>The Spring Boot Cloud Vault documentation mentions</p> <blockquote> <p>Spring Cloud Vault does not support getting new credentials and configuring your DataSource with them when the maximum lease time has been reached. That is, if max_ttl of the Database role in Vault is set to 24h that means that 24 hours after your application has started it can no longer authenticate with the database.</p> </blockquote> <p>In other words, after one hour, the connection is lost and there seems to be no other way to get new db credentials other then by restarting the microservice. So if have the following questions:</p> <ol> <li>What is the added value of using Vault in this particular example if you are (seemingly) forced to restart your entire application each time the TTL expires?</li> <li>Does the same apply when you use static secrets instead?</li> <li>Can this issue be solved without changing microservice code? (K8S, Istio, etc.?)</li> </ol> <p>My guess is the intended use of Vault with Spring Boot is different compared to my understanding.</p> ",
    "OwnerUserId": "5585819",
    "LastEditorUserId": "5585819",
    "LastEditDate": "2023-01-10T16:18:12.580",
    "LastActivityDate": "2023-01-11T08:56:02.500",
    "Title": "HashiCorp Vault dynamic secrets and Spring Boot",
    "Tags": "<spring-boot><docker-compose><microservices><hashicorp-vault>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "ContentLicense": "CC BY-SA 4.0"
  },
  {
    "Id": "76876515",
    "PostTypeId": "1",
    "AcceptedAnswerId": "76936788",
    "CreationDate": "2023-08-10T14:08:28.497",
    "Score": "5",
    "ViewCount": "424",
    "Body": "<p>I have following docker-compose file for local development:</p> <pre><code>version: '3.4'  networks:   mynetwork:  services:   samba:     image: instantlinux/samba-dc:latest     container_name: samba-dc     cap_add:       - CAP_SYS_ADMIN     hostname: my.org     environment:       DOMAIN_ACTION: provision       REALM: my.org     volumes:       - etc:/etc/samba       - lib:/var/lib/samba     ports:       - &quot;53:53&quot;       - &quot;53:53/udp&quot;       - &quot;88:88&quot;       - &quot;88:88/udp&quot;       - &quot;389:389&quot;     secrets:       - samba-admin-password  volumes:   etc:   lib:  secrets:   samba-admin-password:     file: secrets.yaml </code></pre> <p>Now I try to implement integration tests using testContainers for that purpose:</p> <pre><code>@Testcontainers @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) @ActiveProfiles(&quot;test&quot;) ....          init {             try {                 val ldapContainer =                     GenericContainer(&quot;instantlinux/samba-dc:latest&quot;)                         .withEnv(&quot;DOMAIN_ACTION&quot;, &quot;provision&quot;)                         .withEnv(&quot;REALM&quot;, &quot;my.company&quot;)                         .withEnv(&quot;ADMIN_PASSWORD_SECRET&quot;, &quot;samba-admin-password&quot;)                         .withExposedPorts(53, 88, 389)                                     ldapContainer.start()                 print(&quot;Containers has started&quot;)             } catch (e: Exception) {                 e.printStackTrace()             }         } </code></pre> <p>But when I try to run it I receive an error:</p> <pre><code>Container startup failed for image instantlinux/samba-dc:latest .... rg.testcontainers.containers.GenericContainer expected the predicate to return &lt;true&gt; but it returned &lt;false&gt; for input of &lt;InspectContainerResponse(args=[], config=ContainerConfig(attachStderr=false, attachStdin=false, attachStdout=false, cmd=null, domainName=, entrypoint=[/usr/local/bin/entrypoint.sh], env=[DOMAIN_ACTION=provision, ADMIN_PASSWORD_SECRET=samba-admin-password, REALM=my.company, PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin, ALLOW_DNS_UPDATES=secure, BIND_INTERFACES_ONLY=yes, DOMAIN_LOGONS=yes, DOMAIN_MASTER=no, INTERFACES=lo eth0, LOG_LEVEL=1, MODEL=standard, NETBIOS_NAME=, SERVER_STRING=Samba Domain Controller, TZ=UTC, WINBIND_USE_DEFAULT_DOMAIN=yes, WORKGROUP=AD], exposedPorts=.... ... 17:01:51.548 [Test worker] ERROR tc.instantlinux/samba-dc:latest -- Log output from the failed container: Set timezone Cannot read secret $ADMIN_PASSWORD_SECRET in /run/secrets </code></pre> <p>Looks like I have to configure secrets somehow but I don' see a way how to acheve it.</p> <h2>Update 1</h2> <p>Secret file looks like this:</p> <pre><code>kind: Secret apiVersion: v1 metadata:   name: samba-admin-password data:   ADMIN_PASSWORD_SECRET: superpassword </code></pre> <h2>Update 2</h2> <p>Based on VonC answer I've created the example:</p> <pre><code>@Testcontainers @SpringBootTest(webEnvironment = RANDOM_PORT) @ActiveProfiles(&quot;test&quot;) class TestContainersBase {      @Test     fun test() {         val mapper = ObjectMapper(YAMLFactory())         val secretPathOnHost = &quot;C:\\\\work\\\\MyApp\\\\docker\\\\secrets.yaml&quot;         val secretsFile = File(secretPathOnHost)          val secretsData: Map&lt;String, Any&gt; = mapper.readValue(secretsFile, object: TypeReference&lt;Map&lt;String, Any&gt;&gt;(){})          // Extract the secret from the parsed data         val adminPassword = (secretsData[&quot;data&quot;] as Map&lt;*,*&gt;?)!![&quot;ADMIN_PASSWORD_SECRET&quot;] as String?          val secretPathInContainer = &quot;/run/secrets/samba-admin-password&quot;;         // Create and start the container         val ldapContainer = GenericContainer(&quot;instantlinux/samba-dc:latest&quot;)             .withEnv(&quot;DOMAIN_ACTION&quot;, &quot;provision&quot;)             .withEnv(&quot;REALM&quot;, &quot;my.company&quot;)             .withEnv(&quot;ADMIN_PASSWORD_SECRET&quot;, adminPassword) // Set the extracted secret as an environment variable             .withExposedPorts(53, 88, 389)             .withFileSystemBind(secretPathOnHost, secretPathInContainer, BindMode.READ_ONLY);          ldapContainer.start()          print(&quot;qwerty&quot;)                  Thread.sleep(100000000)      } } </code></pre> <p>In app logs I see:</p> <pre><code>2023-08-21T13:38:50.555+03:00  INFO 15136 --- [    Test worker] o.t.utility.ImageNameSubstitutor         : Image name substitution will be performed by: DefaultImageNameSubstitutor (composite of 'ConfigurationFileImageNameSubstitutor' and 'PrefixingImageNameSubstitutor') 2023-08-21T13:38:51.739+03:00  INFO 15136 --- [    Test worker] o.t.d.DockerClientProviderStrategy       : Loaded org.testcontainers.dockerclient.NpipeSocketClientProviderStrategy from ~/.testcontainers.properties, will try it first 2023-08-21T13:38:52.779+03:00  INFO 15136 --- [    Test worker] o.t.d.DockerClientProviderStrategy       : Found Docker environment with local Npipe socket (npipe:////./pipe/docker_engine) 2023-08-21T13:38:52.784+03:00  INFO 15136 --- [    Test worker] org.testcontainers.DockerClientFactory   : Docker host IP address is localhost 2023-08-21T13:38:52.814+03:00  INFO 15136 --- [    Test worker] org.testcontainers.DockerClientFactory   : Connected to docker:    Server Version: 20.10.21   API Version: 1.41   Operating System: Docker Desktop   Total Memory: 38292 MB 2023-08-21T13:38:52.889+03:00  INFO 15136 --- [    Test worker] tc.testcontainers/ryuk:0.4.0             : Creating container for image: testcontainers/ryuk:0.4.0 2023-08-21T13:38:53.928+03:00  INFO 15136 --- [    Test worker] o.t.utility.RegistryAuthLocator          : Credential helper/store (docker-credential-desktop) does not have credentials for https://index.docker.io/v1/ 2023-08-21T13:38:54.201+03:00  INFO 15136 --- [    Test worker] tc.testcontainers/ryuk:0.4.0             : Container testcontainers/ryuk:0.4.0 is starting: b4a10e2647f83d6fc404644fb09edabf930e987e2c5d138eb3d1b9414b1400ac 2023-08-21T13:38:55.320+03:00  INFO 15136 --- [    Test worker] tc.testcontainers/ryuk:0.4.0             : Container testcontainers/ryuk:0.4.0 started in PT2.488268S 2023-08-21T13:38:55.330+03:00  INFO 15136 --- [    Test worker] o.t.utility.RyukResourceReaper           : Ryuk started - will monitor and terminate Testcontainers containers on JVM exit 2023-08-21T13:38:55.330+03:00  INFO 15136 --- [    Test worker] org.testcontainers.DockerClientFactory   : Checking the system... 2023-08-21T13:38:55.332+03:00  INFO 15136 --- [    Test worker] org.testcontainers.DockerClientFactory   : ?? Docker server version should be at least 1.6.0 2023-08-21T13:38:55.334+03:00  INFO 15136 --- [    Test worker] tc.instantlinux/samba-dc:latest          : Creating container for image: instantlinux/samba-dc:latest 2023-08-21T13:38:56.834+03:00  INFO 15136 --- [    Test worker] tc.instantlinux/samba-dc:latest          : Container instantlinux/samba-dc:latest is starting: 496246f47398809c3a7327b0c73a9b7d7fbe6440865b1cad4c124849f6069acb 2023-08-21T13:39:07.361+03:00  WARN 15136 --- [ntainers-wait-0] .c.w.i.InternalCommandPortListeningCheck : An exception while executing the internal check: Container.ExecResult(exitCode=137, stdout=, stderr=/bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found ) 2023-08-21T13:39:07.367+03:00  INFO 15136 --- [    Test worker] tc.instantlinux/samba-dc:latest          : Container instantlinux/samba-dc:latest started in PT12.0305603S </code></pre> <p>In docker desktop:</p> <p><a href='https://i.stack.imgur.com/2WJiX.png' rel='nofollow noreferrer'><img src='https://i.stack.imgur.com/2WJiX.png' alt='enter image description here' /></a></p> <p>And the first container(based on ports I think that it is Samba) logs:</p> <pre><code>2023-08-21 13:38:58 Set timezone 2023-08-21 13:38:59 INFO 2023-08-21 10:38:59,067 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #2108: Looking up IPv4 addresses 2023-08-21 13:38:59 INFO 2023-08-21 10:38:59,068 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #2125: Looking up IPv6 addresses 2023-08-21 13:38:59 WARNING 2023-08-21 10:38:59,068 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #2132: No IPv6 address will be assigned 2023-08-21 13:38:59 INFO 2023-08-21 10:38:59,721 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #2274: Setting up share.ldb 2023-08-21 13:38:59 INFO 2023-08-21 10:38:59,874 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #2278: Setting up secrets.ldb 2023-08-21 13:38:59 INFO 2023-08-21 10:38:59,936 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #2283: Setting up the registry 2023-08-21 13:39:00 INFO 2023-08-21 10:39:00,304 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #2286: Setting up the privileges database 2023-08-21 13:39:00 INFO 2023-08-21 10:39:00,466 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #2289: Setting up idmap db 2023-08-21 13:39:00 INFO 2023-08-21 10:39:00,555 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #2296: Setting up SAM db 2023-08-21 13:39:00 INFO 2023-08-21 10:39:00,573 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #880: Setting up sam.ldb partitions and settings 2023-08-21 13:39:00 INFO 2023-08-21 10:39:00,574 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #892: Setting up sam.ldb rootDSE 2023-08-21 13:39:00 INFO 2023-08-21 10:39:00,591 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1305: Pre-loading the Samba 4 and AD schema 2023-08-21 13:39:00 Unable to determine the DomainSID, can not enforce uniqueness constraint on local domainSIDs 2023-08-21 13:39:00  2023-08-21 13:39:00 INFO 2023-08-21 10:39:00,638 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1383: Adding DomainDN: DC=my,DC=company 2023-08-21 13:39:00 INFO 2023-08-21 10:39:00,659 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1415: Adding configuration container 2023-08-21 13:39:00 INFO 2023-08-21 10:39:00,678 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1430: Setting up sam.ldb schema 2023-08-21 13:39:03 INFO 2023-08-21 10:39:03,229 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1448: Setting up sam.ldb configuration data 2023-08-21 13:39:03 INFO 2023-08-21 10:39:03,356 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1489: Setting up display specifiers 2023-08-21 13:39:05 INFO 2023-08-21 10:39:05,522 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1497: Modifying display specifiers and extended rights 2023-08-21 13:39:05 INFO 2023-08-21 10:39:05,569 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1504: Adding users container 2023-08-21 13:39:05 INFO 2023-08-21 10:39:05,570 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1510: Modifying users container 2023-08-21 13:39:05 INFO 2023-08-21 10:39:05,571 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1513: Adding computers container 2023-08-21 13:39:05 INFO 2023-08-21 10:39:05,572 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1519: Modifying computers container 2023-08-21 13:39:05 INFO 2023-08-21 10:39:05,574 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1523: Setting up sam.ldb data 2023-08-21 13:39:05 INFO 2023-08-21 10:39:05,728 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1553: Setting up well known security principals 2023-08-21 13:39:05 INFO 2023-08-21 10:39:05,770 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1567: Setting up sam.ldb users and groups 2023-08-21 13:39:05 INFO 2023-08-21 10:39:05,993 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1575: Setting up self join 2023-08-21 13:39:06 Repacking database from v1 to v2 format (first record CN=Structural-Object-Class,CN=Schema,CN=Configuration,DC=my,DC=company) 2023-08-21 13:39:06 Repack: re-packed 10000 records so far 2023-08-21 13:39:06 Repacking database from v1 to v2 format (first record CN=nTDSSiteSettings-Display,CN=406,CN=DisplaySpecifiers,CN=Configuration,DC=my,DC=company) 2023-08-21 13:39:06 Repacking database from v1 to v2 format (first record CN=ObjectMoveTable,CN=FileLinks,CN=System,DC=my,DC=company) 2023-08-21 13:39:07 set_nt_acl_no_snum: fset_nt_acl returned NT_STATUS_ACCESS_DENIED. 2023-08-21 13:39:07 ERROR(runtime): uncaught exception - (3221225506, '{Access Denied} A process has requested access to an object but has not been granted those access rights.') 2023-08-21 13:39:07   File &quot;/usr/lib/python3.10/site-packages/samba/netcmd/__init__.py&quot;, line 186, in _run 2023-08-21 13:39:07     return self.run(*args, **kwargs) 2023-08-21 13:39:07   File &quot;/usr/lib/python3.10/site-packages/samba/netcmd/domain.py&quot;, line 493, in run 2023-08-21 13:39:07     result = provision(self.logger, 2023-08-21 13:39:07   File &quot;/usr/lib/python3.10/site-packages/samba/provision/__init__.py&quot;, line 2325, in provision 2023-08-21 13:39:07     provision_fill(samdb, secrets_ldb, logger, names, paths, 2023-08-21 13:39:07   File &quot;/usr/lib/python3.10/site-packages/samba/provision/__init__.py&quot;, line 1965, in provision_fill 2023-08-21 13:39:07     setsysvolacl(samdb, paths.netlogon, paths.sysvol, paths.root_uid, 2023-08-21 13:39:07   File &quot;/usr/lib/python3.10/site-packages/samba/provision/__init__.py&quot;, line 1742, in setsysvolacl 2023-08-21 13:39:07     _setntacl(sysvol) 2023-08-21 13:39:07   File &quot;/usr/lib/python3.10/site-packages/samba/provision/__init__.py&quot;, line 1736, in _setntacl 2023-08-21 13:39:07     return setntacl( 2023-08-21 13:39:07   File &quot;/usr/lib/python3.10/site-packages/samba/ntacls.py&quot;, line 228, in setntacl 2023-08-21 13:39:07     smbd.set_nt_acl( </code></pre> <p><strong>docker ps</strong></p> <pre><code>PS C:\\work\\myApp\\docker&gt; docker ps CONTAINER ID   IMAGE                       COMMAND       CREATED          STATUS          PORTS                     NAMES 5541e9f96005   testcontainers/ryuk:0.4.0   &quot;/bin/ryuk&quot;   24 seconds ago   Up 23 seconds   0.0.0.0:64762-&gt;8080/tcp   testcontainers-ryuk-6d02415f-7042-4de8-bf0d-a1be71ea5172 PS C:\\work\\myApp\\docker&gt; </code></pre> ",
    "OwnerUserId": "2674303",
    "LastEditorUserId": "2674303",
    "LastEditDate": "2023-08-21T12:17:00.510",
    "LastActivityDate": "2023-08-21T12:17:13.157",
    "Title": "How to pass secrets to testContainers?",
    "Tags": "<spring-boot><docker><kotlin><docker-compose><testcontainers>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "ContentLicense": "CC BY-SA 4.0"
  }
]