[
  {
    "Id": "39331665",
    "PostTypeId": "1",
    "CreationDate": "2016-09-05T13:27:29.483",
    "Score": "9",
    "ViewCount": "6837",
    "Body": "<p>I am trying to build a project using maven on teamcity and getting this error during maven build step.</p>  <blockquote>   <p>[Step 2/4] [ERROR] protoc failed output:<br>   [Step 2/4] [ERROR] protoc failed error: /bin/sh: 1: protoc: Permission denied   [Step 2/4]  [13:03:14][Step 2/4] Failed to execute goal   com.google.protobuf.tools:maven-protoc-plugin:0.1.10:compile   (generate-sources) on project unit-protocol-lib: protoc did not exit   cleanly. Review output for more information.</p> </blockquote>  <p>Keep in mind I am using docker-compose for building the teamcity agent (agent running in container) and protoc is added to /usr/local/bin/protoc ($PATH has /usr/local/bin, /usr/local/bin/protoc has rwx permissions).</p>  <p>EDITED for ease</p>  <p>Forget everything above for a while.<br> I logged into the buildagent of teamcity server, access the shell using <code>/bin/sh</code> and execute the command <code>protoc</code> and it returns the error:<br> <code>protoc failed error: /bin/sh: 1: protoc: Permission denied</code>  </p>  <p>Any help??</p> ",
    "OwnerUserId": "1690527",
    "LastEditorUserId": "1690527",
    "LastEditDate": "2016-09-09T10:04:03.913",
    "LastActivityDate": "2022-10-07T11:25:37.037",
    "Title": "Permission denied for protoc on maven build in Teamcity",
    "Tags": "<maven><ubuntu><docker><teamcity><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "4",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>I had the same issue.</p>  <p>What I found was that the error message was misleading.</p>  <p>Here's what worked for me:</p>  <p>Try this:</p>  <pre><code>protoc ./proto/hello/hello.proto --go_out=plugins=grpc:./outputDirectory -I ./proto/hello/hello.proto </code></pre>  <p>Parts of the command obviously look redundant, but this was what I had to do to get it working.  I recommend trying this, and see if it runs.  If it does then you can see if you're able to tweak it, but I don't think so.  </p>  <p>if '.' is your output, then do this:</p>  <pre><code>protoc ./proto/hello/hello.proto --go_out=plugins=grpc:. -I ./proto/hello/hello.proto </code></pre>  <p>Notice that you don't need space.</p> "
  },
  {
    "Id": "45660774",
    "PostTypeId": "1",
    "AcceptedAnswerId": "45710066",
    "CreationDate": "2017-08-13T13:18:22.230",
    "Score": "9",
    "ViewCount": "25926",
    "Body": "<p>I am trying to build a Java application and make a package using docker. This builds needs a maven repository which I don't want to include in the image, since it's very large. I wanted to try using volumes and mount my local maven repository to the maven repository in the image. I used <code>apt-get install -y maven</code> in order to have maven available, but I can't find the directory <code>.m2</code> in the image <code>$HOME</code>. </p>  <p>I used <code>ls -la $HOME</code>, <code>ls -la</code> and <code>ls -la /root</code> to find the maven home, but there is no <code>.m2</code> directory there.</p>  <p><strong>EDIT 1:</strong></p>  <p>I have these lines in <code>Dockerfile</code>: </p>  <pre><code>FROM ubuntu MAINTAINER Zeinab Abbasimazar # Install and configure required packages RUN apt-get update; \\     apt-get install -y --no-install-recommends apt-utils; \\     apt-get install -y dialog; \\     apt-get install -y wget unzip curl maven; \\     mkdir $HOME/.m2/; \\     ls -la /usr/share/maven/conf/; \\     echo \\     '&lt;settings xmlns='http://maven.apache.org/SETTINGS/1.0.0\\' \\     xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' \\     xsi:schemaLocation='http://maven.apache.org/SETTINGS/1.0.0 https://maven.apache.org/xsd/settings-1.0.0.xsd'&gt; \\         &lt;localRepository&gt;/root/.m2/repository&lt;/localRepository&gt; \\         &lt;interactiveMode&gt;true&lt;/interactiveMode&gt; \\         &lt;usePluginRegistry&gt;false&lt;/usePluginRegistry&gt; \\         &lt;offline&gt;false&lt;/offline&gt; \\     &lt;/settings&gt;' \\     &gt; /usr/share/maven/conf/settings.xml VOLUME ['/home/zeinab/.m2/', '/root/.m2/'] # Build RUN mvn  -X clean install -pl components -P profile </code></pre>  <p>Which puts local repository configurations in image's maven configuration file, mounts my local maven repository to a directory in the image and finally performs the build. As I can see in the maven build log that it's using the local repository path I expected:</p>  <pre><code>[DEBUG] Reading global settings from /usr/share/maven/conf/settings.xml [DEBUG] Reading user settings from /root/.m2/settings.xml [DEBUG] Using local repository at /root/.m2/repository </code></pre>  <p>But still can't detect dependencies. </p> ",
    "OwnerUserId": "1626977",
    "LastEditorUserId": "1626977",
    "LastEditDate": "2017-08-15T13:18:17.380",
    "LastActivityDate": "2020-03-03T13:52:03.607",
    "Title": "Mounting Maven Repository to Docker",
    "Tags": "<java><maven><docker><dockerfile><docker-build>",
    "AnswerCount": "2",
    "CommentCount": "5",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>I finally found the solution for mounting my local maven repository in docker. I changed my solution; I am mounting it in the <code>run</code> phase instead of <code>build</code> phase. This is my <code>Dockerfile</code>:</p>  <pre><code>FROM ubuntu MAINTAINER Zeinab Abbasimazar ADD gwr $HOME RUN apt-get update; \\     apt-get install -y --no-install-recommends apt-utils; \\     apt-get install -y wget unzip curl maven git; \\     echo \\     '&lt;settings xmlns='http://maven.apache.org/SETTINGS/1.0.0\\' \\     xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' \\     xsi:schemaLocation='http://maven.apache.org/SETTINGS/1.0.0 https://maven.apache.org/xsd/settings-1.0.0.xsd'&gt; \\         &lt;localRepository&gt;/root/.m2/repository&lt;/localRepository&gt; \\         &lt;interactiveMode&gt;true&lt;/interactiveMode&gt; \\         &lt;usePluginRegistry&gt;false&lt;/usePluginRegistry&gt; \\         &lt;offline&gt;false&lt;/offline&gt; \\     &lt;/settings&gt;' \\     &gt; /usr/share/maven/conf/settings.xml; \\     mkdir /root/.m2/; \\     echo \\     '&lt;settings xmlns='http://maven.apache.org/SETTINGS/1.0.0\\' \\     xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' \\     xsi:schemaLocation='http://maven.apache.org/SETTINGS/1.0.0 https://maven.apache.org/xsd/settings-1.0.0.xsd'&gt; \\         &lt;localRepository&gt;/root/.m2/repository&lt;/localRepository&gt; \\         &lt;interactiveMode&gt;true&lt;/interactiveMode&gt; \\         &lt;usePluginRegistry&gt;false&lt;/usePluginRegistry&gt; \\         &lt;offline&gt;false&lt;/offline&gt; \\     &lt;/settings&gt;' \\     &gt; /root/.m2/settings.xml WORKDIR . CMD mvn  -X clean install -pl components -P profile </code></pre>  <p>At first, I build the image using above <code>Dockerfile</code>:</p>  <pre><code>sudo docker build -t imageName:imageTag . </code></pre>  <p>Then, I run a container as below:</p>  <pre><code>sudo docker run -d -v /home/zeinab/.m2/:/root/.m2/ --name containerName imageName:imageTag </code></pre> ",
    "highest_rated_answer": "<p>You don't find the <code>~/.m2</code> directory because it is created only when needed, i.e. when you store libraries in the local repository or when you add a config file.</p>  <p>You can create the <code>~/.m2</code> directory yourself and create your own <code>settings.xml</code> inside. There you can define the emplacement of the local repository:</p>  <pre><code>&lt;settings  xmlns='http://maven.apache.org/SETTINGS/1.0.0'            xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'            xsi:schemaLocation='http://maven.apache.org/SETTINGS/1.0.0                                https://maven.apache.org/xsd/settings-1.0.0.xsd'&gt;   ...   &lt;localRepository&gt;/path/to/local/repo/&lt;/localRepository&gt;   ... &lt;/settings&gt; </code></pre>  <p>Read the <a href='https://maven.apache.org/settings.html' rel='noreferrer'>documentation</a> for more details.</p> "
  },
  {
    "Id": "46940191",
    "PostTypeId": "1",
    "AcceptedAnswerId": "46945954",
    "CreationDate": "2017-10-25T19:02:54.737",
    "Score": "9",
    "ViewCount": "12898",
    "Body": "<p><strong>I don't understand what's the problem ?</strong></p> <p>I installed Docker on Win10. This is my first experience with it. I read the manuals, start hello-world, and more. Next, I need to use the command <code>mvn compile</code> in the folder of the repository. For this needed to install Mavin.</p> <h3>I see this: <a href='http://hub.docker.com/_/maven/' rel='noreferrer'>https://hub.docker.com/_/maven/</a> and used:</h3> <p><code>docker run -it --rm --name my-maven-project -v &quot;$PWD&quot;:/usr/src/mymaven -w /usr/src/mymaven maven:3.2-jdk-7 mvn clean install</code></p> <p>... and I get the output</p> <pre><code>C:\\Program Files\\Docker\\Docker\\Resources\\bin\\docker.exe: invalid reference format. See 'C:\\Program Files\\Docker\\Docker\\Resources\\bin\\docker.exe run --help'. </code></pre> <h2>Output <code>docker version</code></h2> <pre><code>Client:  Version:      17.09.0-ce  API version:  1.32  Go version:   go1.8.3  Git commit:   afdb6d4  Built:        Tue Sep 26 22:40:09 2017  OS/Arch:      windows/amd64  Server:  Version:      17.09.0-ce  API version:  1.32 (minimum version 1.12)  Go version:   go1.8.3  Git commit:   afdb6d4  Built:        Tue Sep 26 22:45:38 2017  OS/Arch:      linux/amd64  Experimental: true </code></pre> <h2>Output <code>docker info</code></h2> <pre><code>Containers: 4  Running: 0  Paused: 0  Stopped: 4 Images: 3 Server Version: 17.09.0-ce Storage Driver: overlay2  Backing Filesystem: extfs  Supports d_type: true  Native Overlay Diff: true Logging Driver: json-file Cgroup Driver: cgroupfs Plugins:  Volume: local  Network: bridge host ipvlan macvlan null overlay  Log: awslogs fluentd gcplogs gelf journald json-file logentries splunk syslog Swarm: inactive Runtimes: runc Default Runtime: runc Init Binary: docker-init containerd version: 06b9cb35161009dcb7123345749fef02f7cea8e0 runc version: 3f2f8b84a77f73d38244dd690525642a72156c64 init version: 949e6fa Security Options:  seccomp   Profile: default Kernel Version: 4.9.49-moby Operating System: Alpine Linux v3.5 OSType: linux Architecture: x86_64 CPUs: 2 Total Memory: 1.934GiB Name: moby ID: O3WT:CHTU:34YG:IYV3:OELC:RSAW:WSYD:E3HV:2ZUO:DWBU:JXOB:EN4Y Docker Root Dir: /var/lib/docker Debug Mode (client): false Debug Mode (server): true  File Descriptors: 16  Goroutines: 26  System Time: 2017-10-25T18:44:10.1162161Z  EventsListeners: 0 Registry: https://index.docker.io/v1/ Experimental: true Insecure Registries:  127.0.0.0/8 Live Restore Enabled: false </code></pre> <p>Sorry for the stupid question, first time working with Docker... Thanks!</p> ",
    "OwnerUserId": "8833429",
    "LastEditorUserId": "-1",
    "LastEditDate": "2020-06-20T09:12:55.060",
    "LastActivityDate": "2019-11-03T09:53:29.947",
    "Title": "docker.exe: invalid reference format",
    "Tags": "<windows><maven><docker>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>You need to use the right syntax for the current folder, in the right environment:</p>  <ul> <li><p>in a simple CMD shell session, you would use:</p>  <pre><code>-v '%cd%':/usr/src/mymaven </code></pre></li> <li><p>in a Powershell session</p>  <pre><code>-v ${PWD}:/usr/src/mymaven </code></pre></li> </ul> ",
    "highest_rated_answer": "<p>I had a situation: the dash was Unicode dash not ASCII minus (need to retype the dashes)</p>  <pre><code>\u2010   8208    2010        HYPHEN \u2011   8209    2011        NON-BREAKING HYPHEN \u2012   8210    2012        FIGURE DASH \u2013   8211    2013    &amp;ndash; EN DASH \u2014   8212    2014    &amp;mdash; EM DASH \u2015   8213    2015        HORIZONTAL BAR </code></pre> "
  },
  {
    "Id": "71300031",
    "PostTypeId": "1",
    "AcceptedAnswerId": "71301494",
    "CreationDate": "2022-02-28T19:20:42.543",
    "Score": "9",
    "ViewCount": "14709",
    "Body": "<p>I'm trying to build a simple docker image, inside a maven project, adding the image build as part of the maven build process:</p> <pre><code>&lt;build&gt;         &lt;finalName&gt;my-api&lt;/finalName&gt;         &lt;plugins&gt;             &lt;plugin&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;             &lt;/plugin&gt;             &lt;!-- Docker --&gt;             &lt;plugin&gt;                 &lt;groupId&gt;com.spotify&lt;/groupId&gt;                 &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;                 &lt;version&gt;1.4.6&lt;/version&gt;                 &lt;executions&gt;                     &lt;execution&gt;                         &lt;id&gt;default&lt;/id&gt;                         &lt;goals&gt;                             &lt;goal&gt;build&lt;/goal&gt;                             &lt;!-- &lt;goal&gt;push&lt;/goal&gt; --&gt;                         &lt;/goals&gt;                     &lt;/execution&gt;                 &lt;/executions&gt;                 &lt;configuration&gt;                     &lt;repository&gt;reponame/${project.name}&lt;/repository&gt;                     &lt;tag&gt;${project.version}&lt;/tag&gt;                     &lt;skipDockerInfo&gt;true&lt;/skipDockerInfo&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt;          &lt;/plugins&gt;      &lt;/build&gt; </code></pre> <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp EXPOSE 8080 ADD target/*.jar app.jar ENTRYPOINT [ &quot;sh&quot;, &quot;-c&quot;, &quot;java -jar /app.jar&quot; ] </code></pre> <p>But it fails, always get the same error trace, no matter which image I use, the error persists.</p> <p>Error:</p> <blockquote> <p>Caused by: com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: java.lang.UnsatisfiedLinkError: could not load FFI provider jnr.ffi.provider.jffi.Provider</p> <p>Caused by: java.lang.UnsatisfiedLinkError: java.lang.UnsatisfiedLinkError: /private/var/folders/hz/rgppp8250rsdp86kf_tfjvqw0000gp/T/jffi8502916075702391528.dylib: dlopen(/private/var/folders/hz/rgppp8250rsdp86kf_tfjvqw0000gp/T/jffi8502916075702391528.dylib, 0x0001): tried: '/private/var/folders/hz/rgppp8250rsdp86kf_tfjvqw0000gp/T/jffi8502916075702391528.dylib' (fat file, but missing compatible architecture (have 'i386,x86_64', need 'arm64e')), '/usr/lib/jffi8502916075702391528.dylib' (no such file)</p> </blockquote> <p>Other images I tried:</p> <ul> <li>openjdk:13-alpine3.9</li> <li>openjdk:8-jre-alpine3.9</li> <li>azul/zulu-openjdk-alpine:17.0.2-17.32.13-arm64</li> </ul> <p><strong>My java version</strong>: openjdk version &quot;11.0.13&quot; 2021-10-19 LTS</p> <p><strong>My Docker version</strong>: Docker version 20.10.11, build dea9396</p> <p>Thanks in advance.</p> ",
    "OwnerUserId": "1949114",
    "LastEditorUserId": "1949114",
    "LastEditDate": "2022-02-28T19:54:33.877",
    "LastActivityDate": "2022-11-28T15:30:56.883",
    "Title": "Docker image build failed on Mac M1 chip",
    "Tags": "<java><docker><maven>",
    "AnswerCount": "3",
    "CommentCount": "2",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>It looks like the <code>dockerfile-maven-plugin</code> uses a runtime based on x86 architecture and won't run on Apple M1 (Arm).<br /> The plugin is now inactive so you should try something else, for example the <a href='https://maven.fabric8.io/' rel='noreferrer'>fabric8-maven-plugin</a></p> <pre><code>          &lt;plugin&gt;             &lt;groupId&gt;io.fabric8&lt;/groupId&gt;             &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;             &lt;version&gt;0.38.1&lt;/version&gt;             &lt;executions&gt;                 &lt;execution&gt;                     &lt;id&gt;build&lt;/id&gt;                     &lt;phase&gt;pre-integration-test&lt;/phase&gt;                     &lt;goals&gt;                         &lt;goal&gt;build&lt;/goal&gt;                     &lt;/goals&gt;                 &lt;/execution&gt;             &lt;/executions&gt;         &lt;/plugin&gt;  </code></pre> ",
    "highest_rated_answer": "<p>Both of the spotify docker maven plugins are no longer maintained. They need to upgrade their dependency to a version that supports aarch64.</p> <p>In our case there was significant refactoring needed to move to fabric8's plugin or to use maven exec so we wanted to continue to use spotify plugin.</p> <p>Fortunately, you can force the plugin to use a particular dependency by adding a <code>&lt;dependencies&gt;</code> section to your plugin section.</p> <pre><code>                &lt;plugin&gt;                     &lt;groupId&gt;com.spotify&lt;/groupId&gt;                     &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;                     &lt;version&gt;1.4.6&lt;/version&gt;                     &lt;dependencies&gt;                         &lt;dependency&gt;                             &lt;groupId&gt;com.github.jnr&lt;/groupId&gt;                             &lt;artifactId&gt;jnr-unixsocket&lt;/artifactId&gt;                             &lt;version&gt;0.38.14&lt;/version&gt;                         &lt;/dependency&gt;                     &lt;/dependencies&gt;                 &lt;/plugin&gt;  </code></pre> "
  },
  {
    "Id": "34815411",
    "PostTypeId": "1",
    "AcceptedAnswerId": "38398569",
    "CreationDate": "2016-01-15T16:19:20.567",
    "Score": "8",
    "ViewCount": "4889",
    "Body": "<p>I am trying to build a docker image using the docker-maven-plugin (provided by spotify: <a href='https://github.com/spotify/docker-maven-plugin' rel='noreferrer'>https://github.com/spotify/docker-maven-plugin</a>) but things aren't really working out. At first I got this exception: </p>  <pre><code>org.apache.http.conn.HttpHostConnectException: Connect to localhost:2375 </code></pre>  <p>I found out that I had to create an env. variable to fix this (<a href='https://github.com/spotify/docker-maven-plugin/issues/135' rel='noreferrer'>https://github.com/spotify/docker-maven-plugin/issues/135</a>): </p>  <pre><code>set DOCKER_HOST=set DOCKER_HOST=tcp://192.168.99.100:2376 </code></pre>  <p><a href='https://i.stack.imgur.com/Wp6IQ.png' rel='noreferrer'><img src='https://i.stack.imgur.com/Wp6IQ.png' alt='docker_host'></a></p>  <p>So after setting that env. variable I keep getting this ClientProtocolException:</p>  <pre><code>[ERROR] Failed to execute goal com.spotify:docker-maven-plugin:0.3.258:build (default-cli) on project docker_micro_maven: Exception caught: java.util.concurrent.ExecutionException: com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: org.apache.http.client.ClientProtocolException: The server failed to respond with a valid HTTP response </code></pre>  <p>I have no idea how I could fix this, any input would be greatly appreciated. </p> ",
    "OwnerUserId": "1725624",
    "LastActivityDate": "2017-07-20T16:42:21.237",
    "Title": "Docker maven plugin ClientProtocolException (Windows 10 using Docker Toolbox)",
    "Tags": "<java><maven><docker><spotify><docker-toolbox>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>You have to configure virtualbox port forwarding with host listen on 2375 port :</p>  <p><code>&gt; VBoxManage modifyvm 'default' --natpf1 'guestssh,tcp,,2375,,2376'</code></p>  <p>guestssh is the name of port forwarding, you can choose the name.</p>  <p>if <code>VBoxManage</code> isn't recognise, you can replace it by full path : </p>  <p>'pathVirtualBox\\VBoxManage.exe' </p>  <p>And after if you have an issue like  'The server failed to respond with a valid HTTP response'  copy the certs files from  <br>'%USER%.docker\\machines\\certs' <br>to  <br>'%USER%.docker'  <br>cause docker-maven-plugin read this files in '%USER%.docker' (don't copy directory certs, just files).</p>  <p>I think we can override maven properties to replace port 2375 and certs path, but i don't still find it.</p> ",
    "highest_rated_answer": "<p>fixed this by:</p>  <pre><code>        &lt;plugin&gt;             &lt;groupId&gt;com.spotify&lt;/groupId&gt;             &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;             &lt;version&gt;0.4.13&lt;/version&gt;             &lt;configuration&gt;                 &lt;imageName&gt;yourImageName&lt;/imageName&gt;                 &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt;                 &lt;dockerHost&gt;https://192.168.99.100:2376&lt;/dockerHost&gt;                 &lt;dockerCertPath&gt;/Users/your_user/.docker/machine/machines/default&lt;/dockerCertPath&gt;                 &lt;resources&gt;                     &lt;resource&gt;                         &lt;targetPath&gt;/&lt;/targetPath&gt;                         &lt;directory&gt;${project.build.directory}&lt;/directory&gt;                         &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;                     &lt;/resource&gt;                 &lt;/resources&gt;             &lt;/configuration&gt;         &lt;/plugin&gt; </code></pre>  <p>Important are these two tags:</p>  <pre><code>&lt;dockerHost&gt;https://192.168.99.100:2376&lt;/dockerHost&gt; &lt;dockerCertPath&gt;/Users/your_user/.docker/machine/machines/default&lt;/dockerCertPath&gt; </code></pre>  <p>I am using a dockerfile, which path you have to define with this tag:</p>  <pre><code>&lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt;   </code></pre>  <p>Now you can build your jar and generate docker image via: </p>  <p>mvn package docker:build</p> "
  },
  {
    "Id": "41976681",
    "PostTypeId": "1",
    "CreationDate": "2017-02-01T09:55:09.547",
    "Score": "8",
    "ViewCount": "14056",
    "Body": "<p>I would like have spring integration test with the plugin of fabric8, but when I try to run the test I got the next error: </p>  <blockquote>   <p>Cannot create docker access object</p> </blockquote>  <p>I have ubuntu and I think that I have well configurated dockers, I haven't had any problems with dockerfiles or dockercompose, so may it will be either a permissions problems or I forgot something. </p>  <p>I past below my fabric8 configuration, this have an image of mysql and the maven-failsafe-plugin to integration test. </p>  <pre><code>&lt;!--maven plugin --&gt;         &lt;plugin&gt;             &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;             &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt;             &lt;executions&gt;                 &lt;execution&gt;                     &lt;goals&gt;                         &lt;goal&gt;integration-test&lt;/goal&gt;                         &lt;goal&gt;verify&lt;/goal&gt;                     &lt;/goals&gt;                 &lt;/execution&gt;             &lt;/executions&gt;             &lt;configuration&gt;                 &lt;environmentVariables&gt;                     &lt;it-database.port&gt;${it-database.port}&lt;/it-database.port&gt;                 &lt;/environmentVariables&gt;             &lt;/configuration&gt;         &lt;/plugin&gt;         &lt;!--fabric8 plugin --&gt;         &lt;plugin&gt;             &lt;groupId&gt;io.fabric8&lt;/groupId&gt;             &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;             &lt;version&gt;0.18.1&lt;/version&gt;             &lt;configuration&gt;                 &lt;!--&lt;dockerHost&gt;unix:///var/run/docker.sock&lt;/dockerHost&gt;--&gt;                 &lt;dockerHost&gt;tcp://0.0.0.0:2375&lt;/dockerHost&gt;             &lt;/configuration&gt;             &lt;executions&gt;                 &lt;execution&gt;                     &lt;id&gt;prepare-it-database&lt;/id&gt;                     &lt;phase&gt;pre-integration-test&lt;/phase&gt;                     &lt;goals&gt;                         &lt;goal&gt;start&lt;/goal&gt;                     &lt;/goals&gt;                     &lt;configuration&gt;                         &lt;images&gt;                             &lt;image&gt;                                 &lt;name&gt;mysql:5.7&lt;/name&gt;                                 &lt;alias&gt;it-database&lt;/alias&gt;                                 &lt;run&gt;                                     &lt;ports&gt;                                         &lt;port&gt;it-database.port:5432&lt;/port&gt;                                     &lt;/ports&gt;                                     &lt;wait&gt;                                         &lt;log&gt;database system is ready to accept connections&lt;/log&gt;                                         &lt;time&gt;20000&lt;/time&gt;                                     &lt;/wait&gt;                                 &lt;/run&gt;                             &lt;/image&gt;                         &lt;/images&gt;                     &lt;/configuration&gt;                 &lt;/execution&gt;                 &lt;execution&gt;                     &lt;id&gt;remove-it-database&lt;/id&gt;                     &lt;phase&gt;post-integration-test&lt;/phase&gt;                     &lt;goals&gt;                         &lt;goal&gt;stop&lt;/goal&gt;                     &lt;/goals&gt;                 &lt;/execution&gt;             &lt;/executions&gt;         &lt;/plugin&gt; </code></pre> ",
    "OwnerUserId": "3322664",
    "LastActivityDate": "2023-08-09T05:24:15.693",
    "Title": "Cannot create docker access object",
    "Tags": "<spring><maven><docker><fabric8>",
    "AnswerCount": "4",
    "CommentCount": "1",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>A bit late but try to restart Docker. I had the same issue and restarting docker resolved the Problem.</p> <p>Docker Desktop on Windows 10</p> "
  },
  {
    "Id": "42278216",
    "PostTypeId": "1",
    "AcceptedAnswerId": "42278812",
    "CreationDate": "2017-02-16T15:31:39.383",
    "Score": "8",
    "ViewCount": "6130",
    "Body": "<p>I'm trying to build a simple web app with Maven and run with Tomcat7, inside a Docker container.</p>  <p>This is my structure:</p>  <pre><code>- Dockerfile - pom.xml - src/main/webapp/index.hmtl </code></pre>  <p>This is my Dockerfile:</p>  <pre><code>FROM java:8  # Install maven RUN apt-get -y update &amp;&amp; apt-get install -y maven  WORKDIR /code  # Prepare by downloading dependencies ADD pom.xml /code/pom.xml  # Adding source, compile and package into a fat jar ADD src /code/src RUN ['mvn', 'package']  EXPOSE 8080 CMD ['mvn', 'tomcat7:run'] </code></pre>  <p>I'm building the Docker image with</p>  <pre><code>docker build -t webapp-example . </code></pre>  <p>and try to run it with </p>  <pre><code>docker run -d -p 8080:8080 webapp-example </code></pre>  <p>But apparently it doesn't work.</p>  <p>Any ideas?</p> ",
    "OwnerUserId": "2007716",
    "LastActivityDate": "2018-02-25T02:14:50.663",
    "Title": "Run a maven webapp in a docker container",
    "Tags": "<maven><docker><tomcat7>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>Since you shared running using tty and interactive flag like following solves your problem,</p>  <p><code>docker run -ti --rm -p 8080:8080 webapp-example</code></p>  <p>That is because your base image is <a href='https://hub.docker.com/_/java/' rel='nofollow noreferrer'>java:8</a> which is primarily created to run application in front mode (with -ti flag) or compile only in -d mode.  </p>  <p>Also, since maven is build tools and should not be used to run application, you should,</p>  <ol> <li>Create you webapp using maven:latest image.</li> <li>Deploy it separately as tomcat container using official <a href='https://hub.docker.com/_/tomcat/' rel='nofollow noreferrer'>tomcat image</a>.</li> </ol> ",
    "highest_rated_answer": null
  },
  {
    "Id": "44919972",
    "PostTypeId": "1",
    "AcceptedAnswerId": "44923115",
    "CreationDate": "2017-07-05T07:44:29.767",
    "Score": "8",
    "ViewCount": "9392",
    "Body": "<p>I have followed through Spring's <a href='https://spring.io/guides/gs/rest-service/' rel='noreferrer'>Building a RESTful Web Service</a> tutorial and created a dummy webapp (with 'Build with Maven' instructions). I build and package the WAR. Then I run it with this command:</p>  <pre><code>java -jar ./target/Dummy-1.0-SNAPSHOT.war </code></pre>  <p>I can see the dummy JSON endpoint at <a href='http://localhost:8080/greeting/' rel='noreferrer'>http://localhost:8080/greeting/</a>.</p>  <p>Now I want to containerize the app with Docker so I can further test it without the needs to install Tomcat to system space. This is the <code>Dockerfile</code> I created:</p>  <pre><code>FROM tomcat:7-jre8-alpine  # copy the WAR bundle to tomcat COPY /target/Dummy-1.0-SNAPSHOT.war /usr/local/tomcat/webapps/app.war  # command to run CMD ['catalina.sh', 'run'] </code></pre>  <p>I build and run the docker binding to <a href='http://localhost:8080' rel='noreferrer'>http://localhost:8080</a>. I can see the Tomcat welcome page on '<a href='http://localhost:8080' rel='noreferrer'>http://localhost:8080</a>'. But I couldn't see my app on neither:</p>  <ul> <li><a href='http://localhost:8080/app/' rel='noreferrer'>http://localhost:8080/app/</a></li> <li><a href='http://localhost:8080/app/greeting/' rel='noreferrer'>http://localhost:8080/app/greeting/</a></li> <li><a href='http://localhost:8080/greeting/' rel='noreferrer'>http://localhost:8080/greeting/</a></li> </ul>  <p>How should I track down the issue? What could be the problem?</p>  <h2>Update 1: The Tomcat admin interface screenshot</h2>  <p><a href='https://i.stack.imgur.com/Rn35u.png' rel='noreferrer'><img src='https://i.stack.imgur.com/Rn35u.png' alt='Tomcat Admin'></a></p> ",
    "OwnerUserId": "372172",
    "LastEditorUserId": "372172",
    "LastEditDate": "2017-07-05T07:57:42.310",
    "LastActivityDate": "2017-07-05T10:06:09.940",
    "Title": "Deploying Spring WAR to Tomcat-based docker",
    "Tags": "<java><spring><maven><tomcat><docker>",
    "AnswerCount": "1",
    "CommentCount": "8",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>The <code>Application.java</code> file in <a href='https://spring.io/guides/gs/rest-service/' rel='nofollow noreferrer'>the example</a> looks like this:</p>  <pre><code>package hello;  import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication;  @SpringBootApplication public class Application {      public static void main(String[] args) {         SpringApplication.run(Application.class, args);     } } </code></pre>  <p>This is a valid SpringBoot application, but NOT a deployable application to Tomcat. To make it deployable, you can can:</p>  <ol> <li>redefine<code>Application</code> to extend <code>SpringBootServletInitializer</code> from Spring framework web support; then</li> <li><p>override the <code>configure</code> method:</p>  <pre><code>package hello;  import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.builder.SpringApplicationBuilder; import org.springframework.boot.web.support.SpringBootServletInitializer;      @SpringBootApplication public class Application extends SpringBootServletInitializer {      @Override     protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {         return application.sources(Application.class);     }      public static void main(String[] args) {         SpringApplication.run(Application.class, args);     }  } </code></pre></li> </ol>  <p>No need to change the <code>pom.xml</code> file (or any other configurations).</p>  <p>After rebuilding the dockerfile and run it with proper port binding, the greeting example endpoint will be available through: <a href='http://localhost:8080/app/greeting/' rel='nofollow noreferrer'>http://localhost:8080/app/greeting/</a></p>  <h2>References</h2>  <ol> <li><a href='https://stackoverflow.com/questions/27904594/spring-boot-war-deployed-to-tomcat'>Spring Boot War deployed to Tomcat</a></li> <li><a href='http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto-create-a-deployable-war-file' rel='nofollow noreferrer'>Spring Boot Reference Guide: Create a deployable war file</a></li> </ol> ",
    "highest_rated_answer": null
  },
  {
    "Id": "47321197",
    "PostTypeId": "1",
    "CreationDate": "2017-11-16T03:42:07.823",
    "Score": "8",
    "ViewCount": "6901",
    "Body": "<p>Deploy <code>Spring Cloud</code> project with <code>docker</code>, some code in the <code>pom.xml</code>:</p>  <pre><code>&lt;build&gt;         &lt;plugins&gt;             &lt;plugin&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;             &lt;/plugin&gt;             &lt;!-- tag::plugin[] --&gt;             &lt;plugin&gt;                 &lt;groupId&gt;com.spotify&lt;/groupId&gt;                 &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;                 &lt;version&gt;0.4.3&lt;/version&gt;                 &lt;configuration&gt;                     &lt;imageName&gt;${docker.image.prefix}/${project.artifactId}&lt;/imageName&gt;                     &lt;dockerDirectory&gt;${project.basedir}&lt;/dockerDirectory&gt;                     &lt;resources&gt;                         &lt;resource&gt;                             &lt;targetPath&gt;/&lt;/targetPath&gt;                             &lt;directory&gt;${project.build.directory}&lt;/directory&gt;                             &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;                         &lt;/resource&gt;                     &lt;/resources&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt;             &lt;!-- end::plugin[] --&gt;              &lt;plugin&gt;                 &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                 &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;                 &lt;configuration&gt;                     &lt;skipTests&gt;true&lt;/skipTests&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt;         &lt;/plugins&gt;     &lt;/build&gt; </code></pre>  <p>when i run the command: <code>mvn package docker:build</code>, it throws errors:</p>  <pre><code>[INFO] ------------------------------------------------------------------------ [ERROR] Failed to execute goal com.spotify:docker-maven-plugin:0.4.3:build (default) on project users-microservice: Exception caught: java.util.concurrent.ExecutionException: com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: org.apache.http.conn.HttpHostConnectException: Connect to localhost:2375 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused -&gt; [Help 1] [ERROR] [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch. [ERROR] Re-run Maven using the -X switch to enable full debug logging. [ERROR] [ERROR] For more information about the errors and possible solutions, please read the following articles: [ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException [ERROR] [ERROR] After correcting the problems, you can resume the build with the command </code></pre>  <p>why will it connect to localhost:2375? Any idea, i will appreciate!</p> ",
    "OwnerUserId": "5443977",
    "LastEditorUserId": "5443977",
    "LastEditDate": "2017-11-17T03:13:11.887",
    "LastActivityDate": "2017-11-25T09:33:56.050",
    "Title": "Failed to execute goal com.spotify:docker-maven-plugin:0.4.3:build Exception caught: HttpHostConnectException: Connect to localhost:2375",
    "Tags": "<docker><spring-boot><maven-3><spring-cloud>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Please update your <code>docker-maven-plugin</code>'s version from 0.4.3 to 1.0.0</p>  <pre><code>&lt;build&gt;         &lt;plugins&gt;             &lt;plugin&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;             &lt;/plugin&gt;             &lt;!-- tag::plugin[] --&gt;             &lt;plugin&gt;                 &lt;groupId&gt;com.spotify&lt;/groupId&gt;                 &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;                 &lt;version&gt;1.0.0&lt;/version&gt;                 &lt;configuration&gt;                     &lt;imageName&gt;${docker.image.prefix}/${project.artifactId}&lt;/imageName&gt;                     &lt;dockerDirectory&gt;${project.basedir}&lt;/dockerDirectory&gt;                     &lt;resources&gt;                         &lt;resource&gt;                             &lt;targetPath&gt;/&lt;/targetPath&gt;                             &lt;directory&gt;${project.build.directory}&lt;/directory&gt;                             &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;                         &lt;/resource&gt;                     &lt;/resources&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt;             &lt;!-- end::plugin[] --&gt;              &lt;plugin&gt;                 &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                 &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;                 &lt;configuration&gt;                     &lt;skipTests&gt;true&lt;/skipTests&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt;         &lt;/plugins&gt;     &lt;/build&gt; </code></pre> "
  },
  {
    "Id": "52933220",
    "PostTypeId": "1",
    "AcceptedAnswerId": "52934014",
    "CreationDate": "2018-10-22T15:49:48.663",
    "Score": "8",
    "ViewCount": "18844",
    "Body": "<p>We working in small team of 4 people. We using docker to deploy our services. One of the services is a java Spring Boot project which is deployed after building docker image with maven. To make docker image of Spring Boot service we use <code>mvn clean package dockerfile:build</code>.</p>  <p>The fun part is that my colleagues have no problem building docker image of Spring Boot service. And I get maven error message:</p>  <pre><code>[ERROR] Failed to execute goal com.spotify:dockerfile-maven-plugin:1.3.6:build (default-cli) on project 'foo': Could not build image: com.spotify.docker.client.shaded.com.fasterxml.jackson.databind.JsonMappingException: Can not construct instance of com.spotify.docker.client.messages.RegistryAuth: no String-argument constructor/factory method to deserialize from String value ('osxkeychain') </code></pre>  <p>I tried to remove all maven repositories from <code>.m2/repository</code>, restart docker, and remove all images.</p>  <p>Later I tried to run <code>mvn clean package dockerfile:build</code> in to two separate commands:</p>  <ul> <li><code>mvn package</code>, then</li> <li><code>mvn docker:build</code></li> </ul>  <p><code>mvn package</code> passed, and <code>mvn docker:build</code> failed with the same error as shown above.</p>  <p>Maven version <code>3.5.4</code>, Docker version <code>18.06.1-ce, build e68fc7a</code>, OS: macOS mojave</p>  <p>I even tried to restart my PC hoping that it will fix it...</p>  <p>Edited: Here is the maven pom plugin <code>dockerfile-maven-plugin</code></p>  <pre><code>... &lt;plugin&gt;     &lt;groupId&gt;com.spotify&lt;/groupId&gt;     &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;     &lt;version&gt;1.3.6&lt;/version&gt;     &lt;configuration&gt;         &lt;repository&gt;${project.artifactId}&lt;/repository&gt;     &lt;/configuration&gt; &lt;/plugin&gt; ... </code></pre>  <p>Edit 2:</p>  <p>Full error message:</p>  <pre><code>[ERROR] Failed to execute goal com.spotify:dockerfile-maven-plugin:1.3.6:build (default) on project spring-boot-service: Could not build image: com.spotify.docker.client.shaded.com.fasterxml.jackson.databind.JsonMappingException: Can not construct instance of com.spotify.docker.client.messages.RegistryAuth: no String-argument constructor/factory method to deserialize from String value ('swarm') [ERROR]  at [Source: N/A; line: -1, column: -1] (through reference chain: java.util.LinkedHashMap['stackOrchestrator']) [ERROR] -&gt; [Help 1] [ERROR]  [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch. [ERROR] Re-run Maven using the -X switch to enable full debug logging. [ERROR]  [ERROR] For more information about the errors and possible solutions, please read the following articles: [ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException </code></pre>  <p>Edit 3:</p>  <p>docker-compose.yml</p>  <pre><code>wrapper:   image: spring-boot-service:latest ports:   - '8080:8080' expose:   - '8080' links:   - db   - another-service </code></pre>  <p>Solved:</p>  <p>In my case it was wrong version of <code>dockerfile-maven-plugin</code>. I used <code>1.3.6</code>, and <code>1.4.7</code> fixed the problem. </p>  <p>Thanks to <a href='https://stackoverflow.com/users/3301492/boris'>Boris</a>!</p>  <p>Update: One more thing!</p>  <p>Make sure when <code>mvn</code> finish build naming is correct, for example:</p>  <pre><code>[INFO] Successfully built **spring-boot-service:0.0.1-SNAPSHOT** </code></pre>  <p>And <code>docker-compose.yml</code> should look like this:</p>  <pre><code>... wrapper:   image: **spring-boot-service:0.0.1-SNAPSHOT** ... </code></pre> ",
    "OwnerUserId": "5834613",
    "LastEditorUserId": "5834613",
    "LastEditDate": "2018-10-22T17:35:29.400",
    "LastActivityDate": "2022-08-11T11:28:21.330",
    "Title": "Failed to execute goal com.spotify:dockerfile-maven-plugin:1.3.6:build on project 'foo': Could not build image:",
    "Tags": "<java><maven><docker><spring-boot>",
    "AnswerCount": "2",
    "CommentCount": "4",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>Here is the <a href='https://github.com/spotify/dockerfile-maven/tree/master/plugin' rel='nofollow noreferrer'>dockerfile-maven-plugin</a> config:</p> <pre class='lang-xml prettyprint-override'><code>&lt;plugin&gt;   &lt;groupId&gt;com.spotify&lt;/groupId&gt;   &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;   &lt;version&gt;${dockerfile-maven-plugin.version}&lt;/version&gt;   &lt;executions&gt;     &lt;execution&gt;       &lt;id&gt;default&lt;/id&gt;       &lt;goals&gt;         &lt;goal&gt;build&lt;/goal&gt;         &lt;goal&gt;push&lt;/goal&gt;       &lt;/goals&gt;     &lt;/execution&gt;   &lt;/executions&gt;   &lt;configuration&gt;     &lt;repository&gt;${project.artifactId}&lt;/repository&gt;     &lt;tag&gt;${project.version}&lt;/tag&gt;     &lt;buildArgs&gt;       &lt;JAR_FILE&gt;target/${project.build.finalName}.jar&lt;/JAR_FILE&gt;     &lt;/buildArgs&gt;   &lt;/configuration&gt; &lt;/plugin&gt; </code></pre> <p><strong>NOTE:</strong> use the latest released version <a href='https://search.maven.org/artifact/com.spotify/dockerfile-maven-plugin' rel='nofollow noreferrer'>1.4.7</a></p> <p>This configures the plugin to build and push your image with a <a href='https://github.com/spotify/dockerfile-maven#consistent-build-lifecycle' rel='nofollow noreferrer'>single command</a>:</p> <pre class='lang-bash prettyprint-override'><code>$ mvn clean deploy </code></pre> <p>If you only want to build the Docker image, run:</p> <pre class='lang-bash prettyprint-override'><code>$ mvn clean package </code></pre> ",
    "highest_rated_answer": "<p>Solution:</p> <ol> <li>Go to docker desktop</li> <li>Open settings</li> <li>Go to general and put tick on Expose daemon on tcp://localhost:2375 without TLS <a href='https://i.stack.imgur.com/0FJ6S.png' rel='nofollow noreferrer'>enter image description here</a></li> </ol> "
  },
  {
    "Id": "54194249",
    "PostTypeId": "1",
    "AcceptedAnswerId": "54303663",
    "CreationDate": "2019-01-15T07:18:02.083",
    "Score": "8",
    "ViewCount": "6552",
    "Body": "<p>I have several maven projects (not multi-modules), that are residing in GitLab. I like to setup the GitLab CI for these projects, so I looked at <code>gitlab-ci.yml</code> files on how to do this.</p> <p>I found <a href='https://docs.gitlab.com/ee/ci/examples/artifactory_and_gitlab' rel='nofollow noreferrer'>https://docs.gitlab.com/ee/ci/examples/artifactory_and_gitlab</a>, which describes to put the <code>settings.xml</code> in the project itself and then refer it in the <code>gitlab-ci.yml</code> file.</p> <p>But I was wondering, how this is done when having multiple projects that would need this <code>settings.xml</code>, as putting it multiple times in the repository seems bad.</p> <p>Locally I have it in my <code>.m2</code> directory, but how and where to put it on the GitLab server for the pipeline ?</p> ",
    "OwnerUserId": "1504208",
    "LastEditorUserId": "183704",
    "LastEditDate": "2023-07-01T12:34:41.827",
    "LastActivityDate": "2023-07-01T12:34:41.827",
    "Title": "Where to store settings.xml for maven in docker based GitLab CI setup",
    "Tags": "<maven><docker><gitlab><gitlab-ci>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>I mount the host volume via the <code>config.toml</code> as the following example: -</p>  <pre class='lang-toml prettyprint-override'><code>concurrent = 1 check_interval = 30  [[runners]]   name = 'some-name'   url = 'url/to/gitlab/'   token = 'some-token'   executor = 'docker'   [runners.docker]     tls_verify = false     image = 'some-maven-image'     privileged = false     disable_cache = false     volumes = ['...', 'path/to/host/dir:/some/name:rw']     pull_policy = 'if-not-present'     shm_size = 0   [runners.cache] </code></pre>  <p>While the <code>path/to/host/dir</code> is a path on host machine which contains many files including with <code>settings.xml</code>, <code>settings-security.xml</code> and so on, based on project requirement. On the other hand the <code>/some/name</code> is a directory inside the docker.</p>  <p>At the <code>.gitlab-ci.yml</code>, I provide the <code>before_script</code> as the following example: -</p>    <pre><code>before_script:   - cp -f /some/name/settings.xml  $HOME/.m2/settings.xml   - cp -f /some/name/settings-security.xml $HOME/.m2/settings-security.xml   - ... after_script:   - rm -f $HOME/.m2/settings.xml   - rm -f $HOME/.m2/settings-security.xml   - ... </code></pre>  <p>Please visit <a href='https://docs.gitlab.com/runner/configuration/advanced-configuration.html' rel='nofollow noreferrer'>Advanced configuration</a> for further information about the <code>config.toml</code>.</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "55104543",
    "PostTypeId": "1",
    "AcceptedAnswerId": "55111608",
    "CreationDate": "2019-03-11T14:50:51.943",
    "Score": "8",
    "ViewCount": "17842",
    "Body": "<p>I want to run my Maven builds in a Docker container. I don't want to upload all depenedencies with every build, so I tried to mount host's local Maven repository as documented at <a href='https://jenkins.io/doc/book/pipeline/docker/#caching-data-for-containers' rel='noreferrer'>Using Docker with Pipeline</a>:</p>  <blockquote>   <p><strong>Caching data for containers</strong></p>      <p>[...]</p>      <p>Pipeline supports adding custom arguments which are passed to Docker, allowing users to specify custom Docker Volumes to mount, which can be used for caching data on the agent between Pipeline runs. The following example will cache ~/.m2 between Pipeline runs utilizing the maven container, thereby avoiding the need to re-download dependencies for subsequent runs of the Pipeline.</p>  <pre><code>pipeline {     agent {         docker {             image 'maven:3-alpine'             args '-v $HOME/.m2:/root/.m2'         }     }     stages {         stage('Build') {             steps {                 sh 'mvn -B'             }         }     } } </code></pre> </blockquote>  <p><strong>Code</strong></p>  <pre><code>pipeline {     agent {         docker {              image 'maven:3-alpine'              args '-v /home/jenkins/.m2:/root/.m2'         }         }     stages {         stage('Build') {             steps {                 sh 'mvn -B clean verify'             }         }     }    } </code></pre>  <p><strong>Log</strong></p>  <pre><code>Running in Durability level: MAX_SURVIVABILITY [Pipeline] Start of Pipeline [Pipeline] node Running on jenkins-docker in /home/jenkins/workspace/Test/Docker Test@2 [Pipeline] { [Pipeline] sh + docker inspect -f . maven:3-alpine . [Pipeline] withDockerContainer jenkins-docker does not seem to be running inside a container $ docker run -t -d -u 1000:1000 -v /home/jenkins/.m2:/root/.m2 -w '/home/jenkins/workspace/Test/Docker Test@2' -v '/home/jenkins/workspace/Test/Docker Test@2:/home/jenkins/workspace/Test/Docker Test@2:rw,z' -v '/home/jenkins/workspace/Test/Docker Test@2@tmp:/home/jenkins/workspace/Test/Docker Test@2@tmp:rw,z' -e ******** -e ******** -e ******** -e ******** -e ******** -e ******** -e ******** -e ******** -e ******** -e ******** -e ******** -e ******** -e ******** -e ******** -e ******** -e ******** -e ******** -e ******** -e ******** -e ******** -e ******** -e ******** -e ******** maven:3-alpine cat  [...]  [DEBUG] Reading global settings from /usr/share/maven/conf/settings.xml [DEBUG] Reading user settings from ?/.m2/settings.xml [DEBUG] Reading global toolchains from /usr/share/maven/conf/toolchains.xml [DEBUG] Reading user toolchains from ?/.m2/toolchains.xml [DEBUG] Using local repository at /home/jenkins/workspace/Test/Docker Test@2/?/.m2/repository [DEBUG] Using manager EnhancedLocalRepositoryManager with priority 10.0 for /home/jenkins/workspace/Test/Docker Test@2/?/.m2/repository </code></pre>  <p><strong>Problem</strong></p>  <p>After building the <code>~/m2</code> directory is empty, no file/directory was added. All files were added under <code>/home/jenkins/workspace/Test/Docker Test@2/?/.m2</code> (<em>Test</em> is the name of the folder, <em>Docker Test</em> is the name of the pipline). </p>  <p>The problem is that this directory is only used for this particular pipeline not for other pipelines, so I could not share local Maven repository with different pipelines/jobs. </p>  <p>Also my <code>settings.xml</code> is not used, because it is saved under <code>~/m2</code>.</p>  <p>Is there any solution for sharing local Maven repository and Maven settings with different pipelines using Docker? </p> ",
    "OwnerUserId": "5277820",
    "LastEditorUserId": "5277820",
    "LastEditDate": "2019-03-11T15:45:51.050",
    "LastActivityDate": "2019-11-14T21:13:35.550",
    "Title": "How to cache local Maven repository using Docker with Pipelines?",
    "Tags": "<maven><docker><jenkins><jenkins-pipeline>",
    "AnswerCount": "4",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>You can see my <a href='https://stackoverflow.com/questions/54185342/unversioned-files-due-to-folder-automatically-generated-when-compiling-the-g/54241029#54241029'>answer</a> related but using Gradle configuration. </p>  <p>As you said, in my base image, Jenkins runs the Docker container with the user 1002 and there is no user defined. You have to configure the Maven variable <code>user.home</code> in order to put the dependencies there. You can do it by including <code>user.home</code> in the <code>JAVA_OPTIONS</code> as an environment variable in your pipeline. Also <code>MAVEN_CONFIG</code> should be included:</p>  <pre><code>environment {   JAVA_TOOL_OPTIONS = '-Duser.home=/var/maven'   SETTINGS = credentials('your-secret-file') } </code></pre>  <p>and create a volume to cache the dependencies:</p>  <pre><code>docker {     image 'maven:3.3.9-jdk-8-alpine'     args '-v $HOME:/var/maven'     reuseNode true } </code></pre>  <p><strong>UPDATE</strong>: forgot to tell you that you can put your <code>settings.xml</code> in a secret file in order to <a href='https://www.cyberark.com/threat-research-blog/configuring-and-securing-credentials-in-jenkins/' rel='nofollow noreferrer'>use a \u2018least exposure principle\u2019 to limit credentials exposure in the Jenkins pipeline</a>. Also we are configuring personal credentials and this is the way we are configuring for instance Nexus credentials per user. Check the <a href='https://support.cloudbees.com/hc/en-us/articles/203802500-Injecting-Secrets-into-Jenkins-Build-Jobs' rel='nofollow noreferrer'>Jenkins documentation</a> on how to upload your secret file in your credentials:</p>  <pre><code>sh 'mvn -s $SETTINGS -B clean verify' </code></pre>  <p><strong>UPDATE2</strong>: I'm not using declarative pipeline, so my pipeline looks like:</p>  <pre><code>            withCredentials([                  file(credentialsId: 'settings-xml', variable: 'SETTINGS')]) {                     stage('Deploy') {                         gitlabCommitStatus(name: 'Deploy') {                             // Upload the Snapshot artefact                             sh 'mvn -s $SETTINGS clean verify'                         }                     }                 } </code></pre>  <p>It seems it can also be used in <a href='https://issues.jenkins-ci.org/browse/JENKINS-43910' rel='nofollow noreferrer'>declarative pipelines</a> but I did not test it myself.</p> ",
    "highest_rated_answer": "<p>I found a work-around, see <a href='https://github.com/carlossg/docker-maven/issues/63' rel='noreferrer'>Local settings.xml not picked up by Jenkins agent</a>:</p>  <blockquote>   <p>The issue is related to the <code>-u uid:gid</code> that jenkins uses to run the container. As you may know the image you are running only has the user <code>root</code> created, so when jenkins pass its own uid and gid , there is no entry for the user and consequentially no <code>$HOME</code> declared for it.</p>      <p>If you only want to run the build independently of the user, you can use the follow as agent:</p>  <pre><code>agent {         docker {             image 'maven:3-alpine'             args '-v $HOME/.m2:/root/.m2:z -u root'             reuseNode true         } } </code></pre>      <p>A few notes:</p>      <ol>   <li>if you notice the volume I am using with the flag <code>z</code>, as I am going to build with root, I need to tell docker that this volume will be shared among another containers, and then preventing access denied from my jenkins container (running with the user jenkins not root)</li>   <li>I tell jenkins to reuseNode, so any other stage using the same image, will be executing on the same container (it is just to speed up the provisioning time)</li>   </ol> </blockquote>  <p><strong>Log</strong></p>  <pre><code>[DEBUG] Reading global settings from /usr/share/maven/conf/settings.xml [DEBUG] Reading user settings from /root/.m2/settings.xml [DEBUG] Reading global toolchains from /usr/share/maven/conf/toolchains.xml [DEBUG] Reading user toolchains from /root/.m2/toolchains.xml [DEBUG] Using local repository at /root/.m2/repository [DEBUG] Using manager EnhancedLocalRepositoryManager with priority 10.0 for /root/.m2/repository </code></pre>  <p>Unfortunately the files in local repository <code>/home/jenkins/.m2</code> are now owned by user <code>root</code> instead of user <code>jenkins</code>. That could cause other problems. </p> "
  },
  {
    "Id": "55346431",
    "PostTypeId": "1",
    "AcceptedAnswerId": "55499244",
    "CreationDate": "2019-03-25T21:08:13.040",
    "Score": "8",
    "ViewCount": "1279",
    "Body": "<p>The specific error I am facing when starting my app on Tomcat9.  Spring version: 5.1.5.RELEASE: </p>  <p><code>SEVERE: Error configuring application listener of class [org.springframework.web.context.request.RequestContextListener] java.lang.NoClassDefFoundError: javax/xml/ws/WebServiceRef</code></p>  <p>There are multiple answers on this error that all suggest adding maven dependencies.  I have added these dependencies: </p>  <p><a href='https://i.stack.imgur.com/sk4nX.png' rel='noreferrer'><img src='https://i.stack.imgur.com/sk4nX.png' alt='POM.xml'></a></p>  <p>My build path:</p>  <p><a href='https://i.stack.imgur.com/DIbBn.png' rel='noreferrer'><img src='https://i.stack.imgur.com/DIbBn.png' alt='enter image description here'></a></p>  <p>The <code>WebServiceRef</code> class is found in the package explorer:</p>  <p><a href='https://i.stack.imgur.com/yGNLv.png' rel='noreferrer'><img src='https://i.stack.imgur.com/yGNLv.png' alt='enter image description here'></a></p>  <p>This error shows in the console when starting the app on Tomcat9.  Here is more of the stack trace: <a href='https://i.stack.imgur.com/nzaBr.png' rel='noreferrer'><img src='https://i.stack.imgur.com/nzaBr.png' alt='enter image description here'></a></p>  <p><code>SEVERE: Error configuring application listener of class [org.springframework.web.context.request.RequestContextListener] java.lang.NoClassDefFoundError: javax/xml/ws/WebServiceRef     at org.apache.catalina.core.DefaultInstanceManager.populateAnnotationsCache(DefaultInstanceManager.java:303)     ...more stuf.... java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)     at java.base/java.lang.reflect.Method.invoke(Method.java:566)     at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:355)     at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:495)</code></p>  <p>Any help or suggestions would be much appreciated!</p>  <p><strong>Update 1:</strong> Here are some .jar files that get copied into the final .war build under WEB-INF/lib.  The 4 new maven dependencies and their versions are here, but there is also possible duplicate .jar files.</p>  <p><a href='https://i.stack.imgur.com/SueUg.png' rel='noreferrer'><img src='https://i.stack.imgur.com/SueUg.png' alt='enter image description here'></a></p>  <p><strong>Update 2:</strong> Copying the jaws-api jar directly into my Tomcat Classpath resolved the runtime error...  So the app is launching now, but how would I overcome this issue when actually deploying the .war file?</p>  <p><a href='https://i.stack.imgur.com/wsE2G.png' rel='noreferrer'><img src='https://i.stack.imgur.com/wsE2G.png' alt='enter image description here'></a></p> ",
    "OwnerUserId": "2543557",
    "LastEditorUserId": "2543557",
    "LastEditDate": "2019-04-03T15:50:55.320",
    "LastActivityDate": "2019-04-03T15:50:55.320",
    "Title": "How to fix JAVAX runtime error on JDK11 Tomcat9 Spring Application",
    "Tags": "<java><spring><maven><docker><tomcat>",
    "AnswerCount": "2",
    "CommentCount": "10",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>This issue came down to Docker Desktop (Windows) interfering with Tomcat and specifically Tomcat's admin port <em>8006</em>, which forced me to change the port number to allow Tomcat to launch (from <em>8006 to 8007</em> for example).  I had an old Tomcat container at one point in time, and this may have been fired up when my computer started via Docker Desktop without me realizing it.</p>  <p>Steps completed to fix the issue assuming your pom.xml has the necessary dependencies.</p>  <ol> <li>Stop Docker Desktop</li> <li>Use the latest <a href='https://github.com/AdoptOpenJDK/openjdk-jdk11u/releases' rel='nofollow noreferrer'>JDK11 build</a> and update JAVA_HOME as needed</li> <li>Restore default Tomcat admin server port to <em>8006</em></li> <li>Republish/Restart the Tomcat server </li> </ol>  <p>I think in most cases this issue will be resolved as explained <a href='https://stackoverflow.com/questions/48204141/replacements-for-deprecated-jpms-modules-with-java-ee-apis'>here</a> from updating the pom.xml with the needed dependencies.  In my case it was entirely environmental and for some reason Docker Desktop prevented Tomcat from accessing the <strong>jaws-api-2.3.1.jar</strong> file at runtime.  Tomcat's inability to access this .jar file was confirmed via my 'Update 2' in the question above.</p>  <p>My pom.xml ended up only needing the following items: <a href='https://i.stack.imgur.com/nJKKQ.png' rel='nofollow noreferrer'><img src='https://i.stack.imgur.com/nJKKQ.png' alt='enter image description here'></a></p> ",
    "highest_rated_answer": "<p>Try by using this dependency in your pom.xml:</p>  <pre><code>&lt;dependency&gt;     &lt;groupId&gt;javax.annotation&lt;/groupId&gt;     &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt;     &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;     &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;     &lt;version&gt;2.4.0-b180725.0427&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;org.glassfish.jaxb&lt;/groupId&gt;     &lt;artifactId&gt;jaxb-runtime&lt;/artifactId&gt;     &lt;version&gt;2.4.0-b180725.0644&lt;/version&gt; &lt;/dependency&gt; </code></pre>  <p>I just tried and it works with tomcat 9 and spring 5.1.5</p> "
  },
  {
    "Id": "55353804",
    "PostTypeId": "1",
    "AcceptedAnswerId": "55436478",
    "CreationDate": "2019-03-26T09:35:14.623",
    "Score": "8",
    "ViewCount": "1442",
    "Body": "<p>I'm building a Jenkins Docker image and I will like to automate the installation of Maven 3 and Java 8 last JDK. But unfortunately I use these two groovy files locate into the groovy folder:</p>  <p><strong>groovy/java.groovy</strong>:</p>  <pre><code>import jenkins.model.* import hudson.model.* import hudson.tools.*  def inst = Jenkins.getInstance()  def desc = inst.getDescriptor('hudson.model.JDK')  def versions = [ 'jdk8': 'jdk-8u202'] def installations = [];  for (v in versions) {   def installer = new JDKInstaller(v.value, true)   def installerProps = new InstallSourceProperty([installer])   def installation = new JDK(v.key, '', [installerProps])   installations.push(installation) }  desc.setInstallations(installations.toArray(new JDK[0]))  desc.save() </code></pre>  <p><strong>groovy/maven.groovy</strong>:</p>  <pre><code>import jenkins.*; import jenkins.model.*; import hudson.*; import hudson.model.*;  mavenName = 'maven3' mavenVersion = '3.6.0' println('Checking Maven installations...')  // Grab the Maven 'task' (which is the plugin handle). mavenPlugin = Jenkins.instance.getExtensionList(hudson.tasks.Maven.DescriptorImpl.class)[0]  // Check for a matching installation. maven3Install = mavenPlugin.installations.find {    install -&gt; install.name.equals(mavenName) }  // If no match was found, add an installation. if(maven3Install == null) {    println('No Maven install found. Adding...')     newMavenInstall = new hudson.tasks.Maven.MavenInstallation('maven3', null,     [new hudson.tools.InstallSourceProperty([new hudson.tasks.Maven.MavenInstaller(mavenVersion)])] )     mavenPlugin.installations += newMavenInstall    mavenPlugin.save()     println('Maven install added.') } else {    println('Maven install found. Done.') } </code></pre>  <p>and then I run the command:</p>  <pre><code>docker run -p 8080:8080 -v `pwd`/groovy:/var/jenkins_home/jobs --rm --name jenkinsdocker jenkinsdocker:latest </code></pre>  <p>Unfortunately this returns an error:</p>  <pre><code>java.io.IOException: jenkins.model.InvalidBuildsDir: ${ITEM_ROOTDIR}/builds does not exist and probably cannot be created </code></pre>  <p>I'm just wondering if the groovy files are wrong or if there is something else I missed?</p>  <p>How can I automate the maven/java installation for Jenkins while running a <strong>docker run</strong>? Or is there another way to do it?</p> ",
    "OwnerUserId": "649605",
    "LastEditorUserId": "3021395",
    "LastEditDate": "2019-04-04T12:06:50.223",
    "LastActivityDate": "2019-04-04T12:06:50.223",
    "Title": "How to automate Maven and Java JDK8 installation with groovy for Jenkins?",
    "Tags": "<java><maven><docker><jenkins><groovy>",
    "AnswerCount": "1",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>I did not find jenkinsdocker image, so I guess is some docker image you generated from jenkins. In any case following <a href='https://cinqict.github.io/post/eric/jenkinsdocker/' rel='nofollow noreferrer'>this jenkinsdocker documentation</a> you should put your groovy scripts in the <code>init.groovy.d</code> folder to be executed on init. So you need to run docker modifying <code>jobs</code> by <code>init.groovy.d</code> and use the <code>jenkins:latest</code> image: </p>  <pre><code>     docker run -p 8080:8080 -v `pwd`/groovy:/var/jenkins_home/init.groovy.d/ --rm --name jenkins jenkins:latest </code></pre>  <p>You can also create your own Dockerfile (you can use version 2.60.3 for instance) as in the example above:</p>  <pre><code># Extended from https://github.com/jenkinsci/docker/blob/master/README.md FROM jenkins/jenkins:2.60.3  # Skip setup wizard ENV JAVA_OPTS='-Djenkins.install.runSetupWizard=false'  # Add groovy script to Jenkins hook COPY --chown=jenkins:jenkins groovy/ /var/jenkins_home/init.groovy.d/ </code></pre>  <p>Build and run the container:</p>  <pre><code>docker build jenkinsdocker -t . docker run -p 8080:8080 --name jenkinsdocker jenkinsdocker:latest </code></pre> ",
    "highest_rated_answer": null
  },
  {
    "Id": "57960603",
    "PostTypeId": "1",
    "CreationDate": "2019-09-16T16:01:59.883",
    "Score": "8",
    "ViewCount": "22416",
    "Body": "<p>I try to create docker image:</p> <p>It is my Dockerfile:</p> <pre><code>FROM maven:3-jdk-11  # Common files and utils for build RUN apt-get update &amp;&amp; apt-get install -y make fakeroot rpm dpkg-dev apt-utils wget unzip RUN apt-get install -y -q software-properties-common desktop-file-utils  # Then Wine with all deps RUN dpkg --add-architecture i386 &amp;&amp; apt-get update RUN apt-get install -y --install-recommends wine RUN apt-cache search openjdk RUN apt-get install -y openjdk-11-jdk RUN apt install -y openjfx11 libopenjfx-java libopenjfx-jni RUN apt-get install -y --install-recommends wine32  ENV JAVA_HOME /usr/lib/jvm/java-11-openjdk-amd64 ENV JAVAFX_HOME /usr/share/java/openjfx11  # And we ready to play with our code ARG SRCDIR=. ARG DSTDIR=/usr/src/CryptoStock ARG CACHEDIR=./cache  # Subject to be used here but should be command line, sic! # ADD ${CACHEDIR} /root/.m2 # ADD ${SRCDIR} /mnt/src  RUN mkdir -p /root/.m2/repository COPY settings.xml /root/.m2/settings.xml COPY settings-security.xml /root/.m2/settings-security.xml COPY jdk11-build-in-docker.sh ${DSTDIR}/jdk11-build-in-docker.sh  COPY ./static/. ${DSTDIR}/static COPY ./3rdparty/. ${DSTDIR}/3rdparty COPY ./winjdk11/. ${DSTDIR}/winjdk  ENV SOURCES /usr/src/CryptoStock ENV OUTSIDE /mnt/src  RUN dpkg -l '*openjfx*' RUN dpkg -l '*jdk*'  WORKDIR ${DSTDIR}  CMD [ &quot;sh&quot;, &quot;/usr/src/CryptoStock/jdk11-build-in-docker.sh&quot; ] </code></pre> <p>When I try to build I don't to watch java 11:</p> <pre><code>Step 6/27 : RUN apt-cache search openjdk  ---&gt; Running in e03b4c69fa69 jtreg - Regression Test Harness for the OpenJDK platform openjdk-8-dbg - Java runtime based on OpenJDK (debugging symbols) openjdk-8-demo - Java runtime based on OpenJDK (demos and examples) openjdk-8-doc - OpenJDK Development Kit (JDK) documentation openjdk-8-jdk - OpenJDK Development Kit (JDK) openjdk-8-jdk-headless - OpenJDK Development Kit (JDK) (headless) openjdk-8-jre - OpenJDK Java runtime, using Hotspot JIT openjdk-8-jre-headless - OpenJDK Java runtime, using Hotspot JIT (headless) openjdk-8-jre-zero - Alternative JVM for OpenJDK, using Zero/Shark openjdk-8-source - OpenJDK Development Kit (JDK) source files openjdk-8-jre-dcevm - Alternative VM for OpenJDK 8 with enhanced class redefinition uwsgi-plugin-jvm-openjdk-8 - Java plugin for uWSGI (OpenJDK 8) uwsgi-plugin-jwsgi-openjdk-8 - JWSGI plugin for uWSGI (OpenJDK 8) uwsgi-plugin-ring-openjdk-8 - Closure/Ring plugin for uWSGI (OpenJDK 8) uwsgi-plugin-servlet-openjdk-8 - JWSGI plugin for uWSGI (OpenJDK 8) Removing intermediate container e03b4c69fa69  ---&gt; 1fae3b35c58b Step 7/27 : RUN apt-get install -y openjdk-11-jdk  ---&gt; Running in 288fb5247ce6 Reading package lists... Building dependency tree... Reading state information... E: Unable to locate package openjdk-11-jdk The command '/bin/sh -c apt-get install -y openjdk-11-jdk' returned a non-zero code: 100 </code></pre> <p>There is only java 8, there is no java 11.</p> ",
    "OwnerUserId": "12073621",
    "LastEditorUserId": "1839439",
    "LastEditDate": "2022-01-20T19:06:58.010",
    "LastActivityDate": "2024-02-05T06:08:05.943",
    "Title": "E: Unable to locate package openjdk-11-jdk",
    "Tags": "<maven><docker><debian><java-11>",
    "AnswerCount": "2",
    "CommentCount": "3",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>OpenJDK 11 is installed by default in the maven:3-jdk-11 image:</p> <pre><code>$ docker run maven:3-jdk-11 java --version  openjdk 11.0.16 2022-07-19 OpenJDK Runtime Environment 18.9 (build 11.0.16+8) OpenJDK 64-Bit Server VM 18.9 (build 11.0.16+8, mixed mode, sharing) </code></pre> <p>It is also available via the Debian package system:</p> <pre><code>$ docker run maven:3-jdk-11 sh -c 'apt update &amp;&amp; apt-cache search openjdk-11'  [...] openjdk-11-dbg - Java runtime based on OpenJDK (debugging symbols) openjdk-11-demo - Java runtime based on OpenJDK (demos and examples) openjdk-11-doc - OpenJDK Development Kit (JDK) documentation openjdk-11-jdk - OpenJDK Development Kit (JDK) openjdk-11-jdk-headless - OpenJDK Development Kit (JDK) (headless) openjdk-11-jre - OpenJDK Java runtime, using Hotspot JIT openjdk-11-jre-headless - OpenJDK Java runtime, using Hotspot JIT (headless) openjdk-11-jre-zero - Alternative JVM for OpenJDK, using Zero openjdk-11-source - OpenJDK Development Kit (JDK) source files [...] </code></pre> <p>Today the maven:3-jdk-11 image is using Debian 11 (Bullseye), but when you wrote your question the maven:3-jdk-11 image was probably using a Debian 9 (Stretch) image with OpenJDK 11 installed but not available through the Debian package system. This explains your error.</p> "
  },
  {
    "Id": "58025908",
    "PostTypeId": "1",
    "CreationDate": "2019-09-20T09:47:31.863",
    "Score": "8",
    "ViewCount": "30385",
    "Body": "<p>[ERROR] Failed to execute goal com.spotify:docker-maven-plugin:1.0.0:build (default) on project Bookstore: Exception caught: java.util.concurrent.ExecutionException: com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: org.apache.http.conn.HttpHostConnectException: Connect to localhost:2375 [localhost/127.0.0.1] failed: Connection refused </p>  <p><strong><em>Why is this Exception Keep Occurring and how can i resolve it , i am building docker image from war file.</em></strong></p>  <p><strong><em>pom.xml</em></strong></p>  <pre><code>&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;net.codejava.javaee.bookstore&lt;/groupId&gt; &lt;artifactId&gt;Bookstore&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt;   &lt;properties&gt;  &lt;docker.image.prefix&gt;alesblaze&lt;/docker.image.prefix&gt;  &lt;/properties&gt;   &lt;dependencies&gt;      &lt;dependency&gt;          &lt;groupId&gt;javax.servlet&lt;/groupId&gt;          &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;          &lt;version&gt;3.1.0&lt;/version&gt;          &lt;scope&gt;provided&lt;/scope&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;          &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;          &lt;version&gt;2.3.1&lt;/version&gt;          &lt;scope&gt;provided&lt;/scope&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;jstl&lt;/groupId&gt;          &lt;artifactId&gt;jstl&lt;/artifactId&gt;          &lt;version&gt;1.2&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;mysql&lt;/groupId&gt;          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;          &lt;version&gt;5.1.30&lt;/version&gt;      &lt;/dependency&gt;  &lt;/dependencies&gt;    &lt;build&gt;  &lt;sourceDirectory&gt;src&lt;/sourceDirectory&gt;  &lt;plugins&gt;    &lt;plugin&gt;      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;      &lt;version&gt;3.5.1&lt;/version&gt;      &lt;configuration&gt;        &lt;source&gt;1.8&lt;/source&gt;        &lt;target&gt;1.8&lt;/target&gt;      &lt;/configuration&gt;    &lt;/plugin&gt;    &lt;plugin&gt;      &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;      &lt;version&gt;2.6&lt;/version&gt;      &lt;configuration&gt;      &lt;finalName&gt;BookStore&lt;/finalName&gt;        &lt;warSourceDirectory&gt;WebContent&lt;/warSourceDirectory&gt;        &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;      &lt;/configuration&gt;    &lt;/plugin&gt;     &lt;plugin&gt;  &lt;groupId&gt;com.spotify&lt;/groupId&gt;  &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;  &lt;version&gt;1.0.0&lt;/version&gt;  &lt;configuration&gt;  &lt;imageName&gt;${docker.image.prefix}/${project.artifactId}&lt;/imageName&gt;  &lt;dockerDirectory&gt;Docker&lt;/dockerDirectory&gt;  &lt;dockerHost&gt;https://localhost:3000&lt;/dockerHost&gt;  &lt;forceTags&gt;true&lt;/forceTags&gt;  &lt;imageTags&gt;  &lt;imageTag&gt;${project.version}&lt;/imageTag&gt;  &lt;imageTag&gt;latest&lt;/imageTag&gt;  &lt;/imageTags&gt;  &lt;serverId&gt;docker-hub&lt;/serverId&gt;  &lt;registryUrl&gt;https://hub.docker.com/&lt;/registryUrl&gt;  &lt;resources&gt;  &lt;resource&gt;  &lt;targetPath&gt;/&lt;/targetPath&gt;  &lt;directory&gt;${project.build.directory}&lt;/directory&gt;  &lt;include&gt;${project.build.finalName}.war&lt;/include&gt;  &lt;/resource&gt;  &lt;/resources&gt;  &lt;/configuration&gt;  &lt;executions&gt;  &lt;execution&gt;  &lt;phase&gt;package&lt;/phase&gt;  &lt;goals&gt;  &lt;goal&gt;build&lt;/goal&gt;  &lt;/goals&gt;  &lt;/execution&gt;  &lt;/executions&gt; &lt;/plugin&gt;   &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; </code></pre>  <p><strong><em>DockerFile</em></strong></p>  <pre><code> DockerFile ``` FROM tomcat:8.5-alpine VOLUEME /volume/mysql/ COPY /target/BookStore.war /usr/local/tomcat/webapps/app.war RUN sh -c 'touch /usr/local/tomcat/webapps/app.war' d ENTRYPOINT ['sh', '-c' , 'java -Djava.security.edg=file:/dev/./urandom -jar /usr/local/tomcat/webapps/app.war] ``` </code></pre>  <p><strong><em>UPDATE</em></strong></p>  <pre><code>[ERROR] Failed to execute goal com.spotify:docker-maven-plugin:1.0.0:build (default) on project Bookstore: Exception caught: Timeout: GET https://localhost:2375/version: com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: org.apache.http.conn.ConnectTimeoutException: Connect to localhost:2375 [localhost/127.0.0.1] failed: connect timed out  </code></pre>  <p>now i am  getting this error after turning off the firewall , what to do?</p> ",
    "OwnerUserId": "9790334",
    "LastEditorUserId": "9790334",
    "LastEditDate": "2019-09-21T07:43:53.630",
    "LastActivityDate": "2023-11-12T08:12:05.580",
    "Title": "HttpHostConnectException: Connect to localhost:2375 [localhost/127.0.0.1] failed: Connection refused",
    "Tags": "<java><maven><docker><docker-maven-plugin><spotify-docker-client>",
    "AnswerCount": "4",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<ol> <li><p>set DOCKER_HOST into env variables as tcp://localhost:2375</p> </li> <li><p>change docker desktop settings , as per the image attached.</p> </li> <li><p>restart the docker desktop</p> </li> </ol> <p><a href='https://i.stack.imgur.com/QetGj.jpg' rel='noreferrer'><img src='https://i.stack.imgur.com/QetGj.jpg' alt='enter image description here' /></a></p> "
  },
  {
    "Id": "58402441",
    "PostTypeId": "1",
    "CreationDate": "2019-10-15T20:47:59.197",
    "Score": "8",
    "ViewCount": "961",
    "Body": "<p>I am trying to Dockerize the maven build for my multi-module project. I have a nested file structure in which all modules for my project are contained in a modules/ directory. As part of the build, I would like to cache the dependencies so the container does not need to pull the dependencies unless the POM files are updated (i.e. Java changes should not necessitate pulling the dependencies every time). I have this working currently by copying each POM into the appropriate directory in the build container using individual Docker commands for each file; however, I have roughly 10 modules, currently, and may add more in the future. I would like to avoid having to individually COPY each POM as modules are added. I see that COPY supports the wildcard syntax for the source file parameter, but simply cannot get this working. The command I currently have is:</p>  <pre><code>COPY modules/*/pom.xml ./ </code></pre>  <p>but this does not seem to properly copy. I'm sure there is a way to COPY these files without having to specify a command for each one. What is the proper command for doing this? Thank you very much in advance for any help!</p> ",
    "OwnerUserId": "11924792",
    "LastActivityDate": "2021-05-03T19:19:01.593",
    "Title": "Docker Multimodule Maven Build - Copy All POM Files to Appropriate Directories",
    "Tags": "<java><maven><docker>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Do you need to build all the sibling modules when building a specific one? If not, my solution was to copy only the required POMs, then alter the parent <code>pom.xml</code> after copying it in the container:</p> <pre><code>RUN mv pom.xml pom.xml.org RUN cat pom.xml.org | grep -vP '&lt;module&gt;(?!my-commons|my-module)' &gt;&gt; pom.xml RUN mvn -pl my-commons,my-module dependency:go-offline </code></pre> <p>By removing the other module references from the parent you can build your project as if it would have only the desired modules.</p> "
  },
  {
    "Id": "42208442",
    "PostTypeId": "1",
    "CreationDate": "2017-02-13T16:06:04.087",
    "Score": "73",
    "ViewCount": "69999",
    "Body": "<p>I'm trying to use docker to automate maven builds. The project I want to build takes nearly 20 minutes to download all the dependencies, so I tried to build a docker image that would cache these dependencies, but it doesn't seem to save it. My Dockerfile is</p>  <pre><code>FROM maven:alpine RUN mkdir -p /usr/src/app WORKDIR /usr/src/app ADD pom.xml /usr/src/app RUN mvn dependency:go-offline </code></pre>  <p>The image builds, and it does download everything. However, the resulting image is the same size as the base <code>maven:alpine</code> image, so it doesn't seem to have cached the dependencies in the image. When I try to use the image to <code>mvn compile</code> it goes through the full 20 minutes of redownloading everything.</p>  <p>Is it possible to build a maven image that caches my dependencies so they don't have to download everytime I use the image to perform a build?</p>  <p>I'm running the following commands:</p>  <pre><code>docker build -t my-maven .  docker run -it --rm --name my-maven-project -v '$PWD':/usr/src/mymaven -w /usr/src/mymaven my-maven mvn compile </code></pre>  <p>My understanding is that whatever <code>RUN</code> does during the docker build process becomes part of the resulting image.</p> ",
    "OwnerUserId": "1563654",
    "LastEditorUserId": "400544",
    "LastEditDate": "2021-08-17T16:19:51.013",
    "LastActivityDate": "2023-02-10T08:18:54.300",
    "Title": "Maven docker cache dependencies",
    "Tags": "<java><docker><maven><caching><dockerfile>",
    "AnswerCount": "16",
    "CommentCount": "8",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Usually, there's no change in <code>pom.xml</code> file but just some other source code changes when you're attempting to start docker image build. In such circumstance you can do this:</p>  <p><b>FYI:</b></p>  <pre><code>FROM maven:3-jdk-8  ENV HOME=/home/usr/app  RUN mkdir -p $HOME  WORKDIR $HOME  # 1. add pom.xml only here  ADD pom.xml $HOME  # 2. start downloading dependencies  RUN ['/usr/local/bin/mvn-entrypoint.sh', 'mvn', 'verify', 'clean', '--fail-never']  # 3. add all source code and start compiling  ADD . $HOME  RUN ['mvn', 'package']  EXPOSE 8005  CMD ['java', '-jar', './target/dist.jar'] </code></pre>  <p>So the key is: </p>  <ol> <li><p>add <code>pom.xml</code> file.</p></li> <li><p>then <code>mvn verify --fail-never</code> it, it will download maven dependencies.</p></li> <li><p>add all your source file then, and start your compilation(<code>mvn package</code>).</p></li> </ol>  <p><strong>When there are changes in your <code>pom.xml</code> file or you are running this script for the first time, docker will do 1 -> 2 -> 3. When there are no changes in <code>pom.xml</code> file, docker will skip step 1\u30012 and do 3 directly.</strong></p>  <p>This simple trick can be used in many other package management circumstances(gradle\u3001yarn\u3001npm\u3001pip).</p>  <p><strong>Edit:</strong></p>  <p>You should also consider using <code>mvn dependency:resolve</code> or <code>mvn dependency:go-offline</code> accordingly as other comments &amp; answers suggest.</p> "
  },
  {
    "Id": "32614762",
    "PostTypeId": "1",
    "AcceptedAnswerId": "32659439",
    "CreationDate": "2015-09-16T17:12:48.583",
    "Score": "7",
    "ViewCount": "12300",
    "Body": "<p>It appears that maven overrides Java 8 with Java 7.  Consider the following Dockerfile:</p>  <pre><code>FROM java:8 RUN java -version &amp;&amp; ls -l /usr/bin/java     RUN apt-get update -y &amp;&amp; apt-get install maven -y RUN java -version &amp;&amp; ls -l /usr/bin/java     </code></pre>  <p>Line two will report the java version is 1.8 <strong>but line 4 will report java version is 1.7.</strong>  In both cases the <code>/usr/bin/java</code> symlink points to <code>/etc/alternatives/java</code> </p>  <p>Besides re-installing Java 8 (which is why I started with Java:8 in the first place), how can I undo these side-effects of installing maven when building a docker image?</p> ",
    "OwnerUserId": "517003",
    "LastActivityDate": "2015-09-18T19:12:29.157",
    "Title": "Installing maven in a docker build overrides JAVA 8 with JAVA 7(!)",
    "Tags": "<maven><docker><dockerfile>",
    "AnswerCount": "2",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>I found a minimal-delta solution although the point about not using apt-get for maven installs is noted.   Here is the solution as the code</p>  <pre><code>FROM java:8  # preserve Java 8  from the maven install. RUN mv /etc/alternatives/java /etc/alternatives/java8 RUN apt-get update -y &amp;&amp; apt-get install maven -y  # Restore Java 8 RUN mv -f /etc/alternatives/java8 /etc/alternatives/java RUN ls -l /usr/bin/java &amp;&amp; java -version </code></pre>  <p>Obviously, the last line is unnecessary but does confirm that the result is java 8.</p> ",
    "highest_rated_answer": "<p>Your problem isn't Maven, it's some dumb decision made by the person who packaged Maven into a .deb for APT. Do not use Maven from a .deb. The Apache Maven project doesn't make these, doesn't know what's in them, and does not support them very much. Download the genuine tar.gz from maven.apache.org, it will happily work with whatever version of Java you've got.</p> "
  },
  {
    "Id": "33381235",
    "PostTypeId": "1",
    "CreationDate": "2015-10-28T01:08:34.657",
    "Score": "7",
    "ViewCount": "876",
    "Body": "<p>I'm baking a Docker image which runs a Maven task at runtime. It looks kind of like this:</p>  <pre><code>ADD pom.xml /srv ADD src /srv/src  WORKDIR /srv RUN mvn dependencies:go-offline scala:testCompile </code></pre>  <p>At runtime, I'm running <code>mvn gatling:execute</code> to run a load testing utility.</p>  <p>My POM looks like this:</p>  <pre><code>&lt;project&gt;   &lt;dependencies&gt;         &lt;dependency&gt;             &lt;groupId&gt;io.gatling&lt;/groupId&gt;             &lt;artifactId&gt;gatling-core&lt;/artifactId&gt;             &lt;version&gt;${gatling.version}&lt;/version&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;io.gatling&lt;/groupId&gt;             &lt;artifactId&gt;gatling-http&lt;/artifactId&gt;             &lt;version&gt;${gatling.version}&lt;/version&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;io.gatling&lt;/groupId&gt;             &lt;artifactId&gt;gatling-app&lt;/artifactId&gt;             &lt;version&gt;${gatling.version}&lt;/version&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;io.gatling.highcharts&lt;/groupId&gt;             &lt;artifactId&gt;gatling-charts-highcharts&lt;/artifactId&gt;             &lt;version&gt;${gatling.version}&lt;/version&gt;             &lt;scope&gt;test&lt;/scope&gt;         &lt;/dependency&gt;     &lt;/dependencies&gt;      &lt;build&gt;         &lt;plugins&gt;             &lt;plugin&gt;                 &lt;groupId&gt;net.alchim31.maven&lt;/groupId&gt;                 &lt;artifactId&gt;scala-maven-plugin&lt;/artifactId&gt;                 &lt;version&gt;${scala-maven-plugin.version}&lt;/version&gt;             &lt;/plugin&gt;             &lt;plugin&gt;                 &lt;groupId&gt;io.gatling&lt;/groupId&gt;                 &lt;artifactId&gt;gatling-maven-plugin&lt;/artifactId&gt;                 &lt;version&gt;${gatling-plugin.version}&lt;/version&gt;                 &lt;executions&gt;                     &lt;execution&gt;                         &lt;goals&gt;                             &lt;goal&gt;execute&lt;/goal&gt;                         &lt;/goals&gt;                     &lt;/execution&gt;                 &lt;/executions&gt;             &lt;/plugin&gt;         &lt;/plugins&gt;     &lt;/build&gt; &lt;/project&gt; </code></pre>  <p>What I want to have happen is that when I ultimately run <code>mvn gatling:execute</code>, I don't want to have to download any dependencies, I'd like them all baked into the image at build time.</p>  <p>However, even executing <code>mvn dependencies:go-offline scala:testCompile</code> doesn't get me all of the way there. Running <code>gatling:execute</code> still requires downloading more dependencies.</p>  <p>How can I download <em>absolutely everything</em> that Maven requires into my Docker image, so that no downloads at runtime are required? </p> ",
    "OwnerUserId": "128967",
    "LastActivityDate": "2018-01-16T21:58:32.420",
    "Title": "Download all dependencies, plugin dependencies, compilers, etc. with Maven?",
    "Tags": "<maven><docker><gatling>",
    "AnswerCount": "2",
    "CommentCount": "10",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>You don't necessarily have to run the simulation with the maven plugin, do you? You can use maven to package a jar with all dependencies and execute the gatling runner from it. </p> "
  },
  {
    "Id": "36389982",
    "PostTypeId": "1",
    "CreationDate": "2016-04-03T19:18:02.020",
    "Score": "7",
    "ViewCount": "2365",
    "Body": "<p>I'm using the <a href='http://mvnrepository.com/artifact/com.spotify/docker-maven-plugin' rel='noreferrer'>Spotify Maven plugin</a> to automate the building and deploying of docker images when executing certain maven goals. </p>  <p>However, I'm running a private unsecured registry that is accessible through the following host: server.mydomain.com:5000. However, I can't seem to stop the plugin from forcing a secure push to the repository? It uses <a href='https://server.mydomain.com:5000' rel='noreferrer'>https://server.mydomain.com:5000</a>.</p>  <p>Is there any way to force the plugin to not use https?</p>  <p>Thanks.</p>  <p>Edit:</p>  <p>Current plugin POM configuration:</p>  <pre><code>&lt;plugin&gt;     &lt;groupId&gt;com.spotify&lt;/groupId&gt;     &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;     &lt;version&gt;0.4.3&lt;/version&gt;     &lt;configuration&gt;         &lt;imageName&gt;server.mydomain.com:5000/${project.artifactId}&lt;/imageName&gt;         &lt;baseImage&gt;java&lt;/baseImage&gt;         &lt;entryPoint&gt;['java', '-jar', '/${project.build.finalName}-packaged.jar']&lt;/entryPoint&gt;         &lt;resources&gt;             &lt;resource&gt;                 &lt;targetPath&gt;/&lt;/targetPath&gt;                 &lt;directory&gt;${project.build.directory}&lt;/directory&gt;                 &lt;include&gt;${project.build.finalName}-packaged.jar&lt;/include&gt;             &lt;/resource&gt;         &lt;/resources&gt;         &lt;imageTags&gt;             &lt;imageTag&gt;${project.version}&lt;/imageTag&gt;             &lt;imageTag&gt;latest&lt;/imageTag&gt;         &lt;/imageTags&gt;         &lt;retryPushCount&gt;0&lt;/retryPushCount&gt;     &lt;/configuration&gt;     &lt;executions&gt;         &lt;execution&gt;             &lt;id&gt;build-image&lt;/id&gt;             &lt;phase&gt;package&lt;/phase&gt;             &lt;goals&gt;                 &lt;goal&gt;build&lt;/goal&gt;             &lt;/goals&gt;         &lt;/execution&gt;         &lt;execution&gt;             &lt;id&gt;push-image&lt;/id&gt;             &lt;phase&gt;deploy&lt;/phase&gt;             &lt;goals&gt;                 &lt;goal&gt;push&lt;/goal&gt;             &lt;/goals&gt;         &lt;/execution&gt;     &lt;/executions&gt; &lt;/plugin&gt; </code></pre> ",
    "OwnerUserId": "5363974",
    "LastEditorUserId": "1743880",
    "LastEditDate": "2016-04-04T08:23:57.383",
    "LastActivityDate": "2016-04-04T11:43:39.500",
    "Title": "Docker Maven Spotify plugin - Possible to switch to non-secure registry",
    "Tags": "<maven><docker><maven-plugin><spotify><docker-registry>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>This seems to be Docker behavior and not related to the maven plugin you are using, see <a href='https://github.com/docker/docker-registry/issues/936' rel='nofollow'>this Docker issue</a> that mentions needing to set <code>--insecure-registry http://server.mydomain.com:5000</code> when starting the Docker daemon.</p> "
  },
  {
    "Id": "38179626",
    "PostTypeId": "1",
    "CreationDate": "2016-07-04T08:04:41.147",
    "Score": "7",
    "ViewCount": "12753",
    "Body": "<p>I installed ubuntu  14.04 virtual machine and run docker(1.11.2). I try to build sample image (<a href='https://github.com/giantswarm/sparkexample' rel='noreferrer'>here</a>).</p>  <p>docker file :</p>  <pre><code>FROM java:8   # Install maven RUN apt-get update   RUN apt-get install -y maven .... </code></pre>  <p>I get following error:</p>  <pre><code>Step 3: RUN apt-get update  --&gt; Using cache  ---&gt;64345sdd332 Step 4: RUN apt-get install -y maven  ---&gt; Running in a6c1d5d54b7a Reading package lists... Reading dependency tree... Reading state information... E: Unable to locate package maven INFO[0029] The command [/bin/sh -c apt-get install -y maven] returned a non-zero code:100 </code></pre>  <p><a href='https://i.stack.imgur.com/x4AXD.png' rel='noreferrer'><img src='https://i.stack.imgur.com/x4AXD.png' alt='enter image description here'></a></p>  <p>following solutions I have tried, but no success.</p>  <blockquote>   <ol>   <li><p>restarted docker <a href='https://stackoverflow.com/questions/30856801/apt-get-not-working-in-dockerfile'>here</a></p></li>   <li><p>run as <code>apt-get -qq -y install curl</code> <a href='https://stackoverflow.com/questions/27273412/cannot-install-packages-inside-docker-ubuntu-image'>here</a> :same error :(</p></li>   </ol> </blockquote>  <p>how can i view detailed error message ? a any way to fix the issue?</p> ",
    "OwnerUserId": "4947520",
    "LastEditorUserId": "-1",
    "LastEditDate": "2017-05-23T11:44:13.897",
    "LastActivityDate": "2020-05-23T07:13:35.173",
    "Title": "Cannot (apt-get) install packages inside docker",
    "Tags": "<maven><docker><apt-get>",
    "AnswerCount": "5",
    "CommentCount": "7",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>you may need to update os inside docker before</p>  <p>try to run <code>apt-get update</code> first, then <code>apt-get install xxx</code></p> "
  },
  {
    "Id": "39527236",
    "PostTypeId": "1",
    "CreationDate": "2016-09-16T08:46:41.540",
    "Score": "7",
    "ViewCount": "1673",
    "Body": "<p>I try to build my project inside of a docker container, the image looks like this:</p>  <pre><code>FROM maven:3.3.9-jdk-8 WORKDIR mvnBuildDir ENTRYPOINT ['mvn'] </code></pre>  <p>if I run my container like below everything works fine.</p>  <pre><code>docker run -v /home/user/Worspace/myMavenProject:/mvnBuildDir myMaven3 clean package </code></pre>  <p>But if I try this in my <em>Jenkinsfile</em> I got an error which is telling me nothing. Jenkinsfile:</p>  <pre class='lang-groovy prettyprint-override'><code>//... def maven = docker.image('myMaven3'); maven.inside('-v ${workdir}:/mvnBuildDir'){     stage 'build and test'     sh 'mvn clean install' } //.. </code></pre>  <p>Error:</p>  <pre><code>[Pipeline] { [Pipeline] stage (build and test) Entering stage build and test Proceeding [Pipeline] sh [master] Running shell script + mvn clean install -s mvnSettings.xml [Pipeline] } $ docker stop 1fc920c00b46a1038b0f39e2adc6e67f702d48ccf10d3e0bb3514d1cee3a795b $ docker rm -f 1fc920c00b46a1038b0f39e2adc6e67f702d48ccf10d3e0bb3514d1cee3a795b [Pipeline] // withDockerContainer [Pipeline] } [Pipeline] // withDockerRegistry [Pipeline] } [Pipeline] // withEnv [Pipeline] } [Pipeline] // node [Pipeline] End of Pipeline ERROR: script returned exit code -1 Finished: FAILURE </code></pre>  <p>Has anybody have an idea what the problem is here or has anybody another solution how to build my project inside the docker container? My whole workspace is mapped inside the container, so the problem isn't that pom or something else is not found I think. If I run 'mvn --version' I got the right output. Thanks so far.</p> ",
    "OwnerUserId": "4457053",
    "LastEditorUserId": "545127",
    "LastEditDate": "2019-04-10T09:33:40.827",
    "LastActivityDate": "2019-04-10T09:33:40.827",
    "Title": "Jenkins pipeline script exit status -1 for docker maven image",
    "Tags": "<maven><docker><jenkins><jenkins-pipeline>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>When using docker images I had the behavior that the command ended but the docker was still running, so I had no output.</p>  <p>You could try ton invoke the docker via shell.</p>  <p><code>sh 'docker pull myMaven3'</code></p>  <p><code>sh 'docker run --rm -v ${workdir}:/mvnBuildDir myMaven3 clean install'</code></p> "
  },
  {
    "Id": "39924530",
    "PostTypeId": "1",
    "AcceptedAnswerId": "39924695",
    "CreationDate": "2016-10-07T19:27:56.853",
    "Score": "7",
    "ViewCount": "10498",
    "Body": "<p>I am having trouble pushing my docker image to the hub using the following command:</p>  <pre><code>mvn clean package docker:build -DpushImage </code></pre>  <p>Each time I get the following response:</p>  <pre><code>[WARNING] Failed to push jdruwe/k8s-product-owner, retrying in 10 seconds (5/5).  ...  [ERROR] Failed to execute goal com.spotify:docker-maven-plugin:0.4.13:build (default-cli) on project k8s-product-owner: Exception caught: unauthorized: authentication required -&gt; [Help 1] </code></pre>  <p>When I try to login using one of the following commands, I keep getting the errors even tough the login succeeded</p>  <pre><code>docker login -u jdruwe https://index.docker.io/v1/  OR  docker login </code></pre>  <p>I did create an empty repo on hub just to try fixing it:</p>  <p><a href='https://i.stack.imgur.com/gPp35.png' rel='noreferrer'><img src='https://i.stack.imgur.com/gPp35.png' alt='enter image description here'></a></p>  <p>Any ideas?</p> ",
    "OwnerUserId": "1725624",
    "LastEditorUserId": "2439220",
    "LastEditDate": "2016-10-22T20:39:25.370",
    "LastActivityDate": "2021-10-24T18:23:05.253",
    "Title": "Spotify docker-maven-plugin unauthorized: authentication required public repo",
    "Tags": "<maven><docker><maven-plugin><spotify><docker-registry>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>Did you correctly configure the authentication settings? </p>  <p>User and password can be set in <strong>settings.xml</strong>:</p>  <pre><code>&lt;servers&gt;   &lt;server&gt;     &lt;id&gt;docker-hub&lt;/id&gt;     &lt;username&gt;jdruwe&lt;/username&gt;     &lt;password&gt;secret-password&lt;/password&gt;     &lt;configuration&gt;       &lt;email&gt;foo@foo.bar&lt;/email&gt;     &lt;/configuration&gt;   &lt;/server&gt; &lt;/servers&gt; </code></pre>  <p>Then, the <strong>pom</strong> references these settings:</p>  <pre><code> &lt;plugin&gt;   &lt;groupId&gt;com.spotify&lt;/groupId&gt;   &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;   &lt;version&gt;VERSION GOES HERE&lt;/version&gt;   &lt;configuration&gt;     [...]     &lt;serverId&gt;docker-hub&lt;/serverId&gt;     &lt;registryUrl&gt;https://index.docker.io/v1/&lt;/registryUrl&gt;   &lt;/configuration&gt; &lt;/plugin&gt; </code></pre>  <p>More detailed information can be found here: <a href='https://github.com/spotify/docker-maven-plugin#authenticating-with-private-registries' rel='noreferrer'>https://github.com/spotify/docker-maven-plugin#authenticating-with-private-registries</a></p> ",
    "highest_rated_answer": "<p>The above mentioned work-around worked like magic. However, settings.xml file was missing on my machine. Created setttings.xml under /Users/username/.m2 directory on my machine as follows and it worked</p> <pre><code>&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;     &lt;servers&gt;         &lt;server&gt;             &lt;id&gt;docker.io&lt;/id&gt;             &lt;username&gt;your_username&lt;/username&gt;             &lt;password&gt;your_password&lt;/password&gt;         &lt;/server&gt;     &lt;/servers&gt; &lt;/settings&gt; </code></pre> "
  },
  {
    "Id": "47776984",
    "PostTypeId": "1",
    "CreationDate": "2017-12-12T16:13:15.997",
    "Score": "7",
    "ViewCount": "4556",
    "Body": "<p>I have a maven project that is built as a docker image. I'm using <a href='https://github.com/spotify/dockerfile-maven' rel='noreferrer'>spotify/dockerfile-maven</a> to build this image and push it to docker.hub automatically on on <code>mvn clean install</code>. The <code>build</code> phase passes without any problems. But on <code>push</code> I have this error:</p>  <pre><code>[ERROR] denied: requested access to the resource is denied [WARNING] An attempt failed, will retry 1 more times org.apache.maven.plugin.MojoExecutionException: Could not push image     at com.spotify.plugin.dockerfile.PushMojo.execute(PushMojo.java:90) ........ Caused by: com.spotify.docker.client.exceptions.DockerException: denied: requested access to the resource is denied     at com.spotify.plugin.dockerfile.LoggingProgressHandler.handleError(LoggingProgressHandler.java:105)     at com.spotify.plugin.dockerfile.LoggingProgressHandler.progress(LoggingProgressHandler.java:63) ...... </code></pre>  <p>Here is my plugin config:</p>  <pre><code>     &lt;build&gt;         &lt;pluginManagement&gt;             &lt;plugins&gt;                 &lt;plugin&gt;                     &lt;groupId&gt;com.spotify&lt;/groupId&gt;                     &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;                     &lt;version&gt;1.3.6&lt;/version&gt;                     &lt;configuration&gt;                         &lt;repository&gt;${docker.image.prefix}/${project.artifactId}-istio&lt;/repository&gt;                         &lt;tag&gt;latest&lt;/tag&gt;                     &lt;/configuration&gt;                     &lt;executions&gt;                         &lt;execution&gt;                             &lt;phase&gt;package&lt;/phase&gt;                             &lt;goals&gt;                                 &lt;goal&gt;build&lt;/goal&gt;                                 &lt;goal&gt;push&lt;/goal&gt;                             &lt;/goals&gt;                         &lt;/execution&gt;                     &lt;/executions&gt;                 &lt;/plugin&gt;             &lt;/plugins&gt;         &lt;/pluginManagement&gt;     &lt;/build&gt; </code></pre>  <p>When pushing with <code>docker push image-name:tag</code> everything works.</p>  <p><a href='https://github.com/spotify/dockerfile-maven/issues/79#issuecomment-338563667' rel='noreferrer'>Here</a> I have found the similar issue, but adding the dependency for <code>docker-client v8.8.4</code> does not change anything.</p>  <p>Also, <a href='https://github.com/spotify/dockerfile-maven/issues/51#issuecomment-321549038' rel='noreferrer'>this</a> comment suggest switching to <code>1.3.3</code> version, but this doesn't work for me.</p>  <p>For both cases, I can see in the logs that it pushes to the same repository:</p>  <pre><code>The push refers to a repository [docker.io/my-login/my-image-name] </code></pre> ",
    "OwnerUserId": "5604676",
    "LastEditorUserId": "5604676",
    "LastEditDate": "2018-03-01T15:12:50.243",
    "LastActivityDate": "2021-01-09T05:00:30.077",
    "Title": "Error pushing docker hub using spotify/dockerfile-maven-plugin",
    "Tags": "<java><maven><docker><dockerhub><maven-docker-plugin>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Add <code>&lt;useMavenSettingsForAuth&gt;true&lt;/useMavenSettingsForAuth&gt;</code> to the configuration tag and specify your server credentials in maven settings.xml as - </p>  <pre><code>&lt;server&gt;       &lt;id&gt;docker.io&lt;/id&gt;       &lt;username&gt;xxxxx&lt;/username&gt;       &lt;password&gt;xxxxxx&lt;/password&gt;     &lt;/server&gt; </code></pre> "
  },
  {
    "Id": "51714101",
    "PostTypeId": "1",
    "AcceptedAnswerId": "51817774",
    "CreationDate": "2018-08-06T19:04:00.627",
    "Score": "7",
    "ViewCount": "7756",
    "Body": "<p>I have both deploy plugin and dockerize plugin in my Maven project.</p>  <p>Deploy plugin,</p>  <pre><code>&lt;plugin&gt;                 &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                 &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;                 &lt;executions&gt;                     &lt;execution&gt;                         &lt;id&gt;default-deploy&lt;/id&gt;                         &lt;phase&gt;deploy&lt;/phase&gt;                     &lt;/execution&gt;                 &lt;/executions&gt;             &lt;/plugin&gt; </code></pre>  <p>Dockerize plugin,</p>  <pre><code>&lt;profiles&gt;         &lt;profile&gt;             &lt;id&gt;docker&lt;/id&gt;             &lt;properties&gt;                 &lt;assembly.skipAssembly&gt;true&lt;/assembly.skipAssembly&gt;             &lt;/properties&gt;             &lt;build&gt;                 &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;                 &lt;plugins&gt;                     &lt;plugin&gt;                         &lt;groupId&gt;com.spotify&lt;/groupId&gt;                         &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;                         &lt;version&gt;${version.docker.plugin}&lt;/version&gt;                         &lt;executions&gt;                             &lt;execution&gt;                                 &lt;id&gt;dockerize-app&lt;/id&gt;                                 &lt;goals&gt;                                     &lt;goal&gt;build&lt;/goal&gt;                                     &lt;goal&gt;push&lt;/goal&gt;                                 &lt;/goals&gt;                             &lt;/execution&gt;                         &lt;/executions&gt;                         &lt;configuration&gt;                             &lt;repository&gt;${docker.image-prefix}${project.artifactId}&lt;/repository&gt;                             &lt;tag&gt;${project.version}&lt;/tag&gt;                             &lt;useMavenSettingsForAuth&gt;true&lt;/useMavenSettingsForAuth&gt;                             &lt;buildArgs&gt;                                 &lt;JAR_FILE&gt;${project.build.finalName}.jar&lt;/JAR_FILE&gt;                             &lt;/buildArgs&gt;                             &lt;resources&gt;                                 &lt;resource&gt;                                     &lt;targetPath&gt;/&lt;/targetPath&gt;                                     &lt;directory&gt;${project.build.directory}&lt;/directory&gt;                                     &lt;include&gt;${project.artifactId}.war&lt;/include&gt;                                 &lt;/resource&gt;                             &lt;/resources&gt;                         &lt;/configuration&gt;                     &lt;/plugin&gt;                 &lt;/plugins&gt;             &lt;/build&gt;         &lt;/profile&gt;     &lt;/profiles&gt; </code></pre>  <p>I have following use cases.</p>  <ol> <li>Deploy artifacts alone</li> <li>Deploy Docker image alone</li> <li>Deploy artifact &amp; Docker image</li> </ol>  <p>To achieve this, I added Docker plugin under profile. So that, Docker image will be deployed on passing the profile name.</p>  <blockquote>   <p><strong>mvn deploy</strong></p> </blockquote>  <p>The above command will deploy just the artifacts.</p>  <blockquote>   <p><strong>mvn deploy -P docker</strong></p> </blockquote>  <p>The above command will deploy artifacts &amp; Docker image.</p>  <p>But, I am unable to just deploy the Docker image.</p>  <p>To just deploy the Docker image, I am adding the below config in the deploy plugin,</p>  <pre><code>&lt;configuration&gt;                     &lt;skip&gt;true&lt;/skip&gt;                 &lt;/configuration&gt; </code></pre>  <p>Or, setting default-deploy to none.</p>  <pre><code>&lt;execution&gt;                         &lt;id&gt;default-deploy&lt;/id&gt;                         &lt;phase&gt;none&lt;/phase&gt;                     &lt;/execution&gt; </code></pre>  <p>The above 2 approaches needs pom change.</p>  <ol> <li>The other approach would be to create a profile for deploy also so that we can pass the profile we want.</li> </ol>  <p>Is there any other better approach? Or, is it possible with the Maven arguments to skip deploy?</p> ",
    "OwnerUserId": "1578872",
    "LastEditorUserId": "472495",
    "LastEditDate": "2019-10-23T08:03:16.463",
    "LastActivityDate": "2019-10-23T08:03:16.463",
    "Title": "Maven skip deploy & push only Docker images",
    "Tags": "<maven><docker>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>I think you can do what you want by using properties instead of profiles.  Just remove the <code>docker</code> profile and put the configuration directly inside your POM, and the following commands should work :</p>  <ul> <li><code>mvn -Dmaven.deploy.skip deploy</code> to deploy only Docker images (default <code>deploy</code> phase is skipped)</li> <li><code>mvn -Ddockerfile.skip deploy</code> to deploy only artifacts to your repository manager. Options to skip goals (like <code>dockerfile.skip</code>) are described on the <a href='https://github.com/spotify/dockerfile-maven/tree/v1.4.4#skip-docker-goals-bound-to-maven-phases' rel='noreferrer'><code>dockerfile-maven-plugin</code> documentation</a></li> <li><code>mvn deploy</code> to deploy both (artifacts and Docker images)</li> </ul> ",
    "highest_rated_answer": null
  },
  {
    "Id": "53093020",
    "PostTypeId": "1",
    "AcceptedAnswerId": "53227196",
    "CreationDate": "2018-10-31T22:52:44.750",
    "Score": "7",
    "ViewCount": "5006",
    "Body": "<p>We have around of 10 different applications that are Spring Boot projects with Groovy.</p>  <p>All of our projects build correctly in all developer work stations and they were running correctly until yesterday, however suddenly all of them stopped working today only in our GitLab CI pipelines with below error:</p>  <pre><code>[INFO] Tests run: 0, Failures: 0, Errors: 0, Skipped: 0 [INFO]  [INFO] ------------------------------------------------------------------------ [INFO] BUILD FAILURE [INFO] ------------------------------------------------------------------------ [INFO] Total time: 01:37 min [INFO] Finished at: 2018-10-31T17:49:11Z [INFO] ------------------------------------------------------------------------ [ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.21.0:test (default-test) on project ctg-oms-component: There are test failures. [ERROR]  [ERROR] Please refer to /builds/ctg-integrations/ctg-oms-component/target/surefire-reports for the individual test results. [ERROR] Please refer to dump files (if any exist) [date]-jvmRun[N].dump, [date].dumpstream and [date]-jvmRun[N].dumpstream. [ERROR] ExecutionException The forked VM terminated without properly saying goodbye. VM crash or System.exit called? </code></pre>  <p>I've pulled the same docker image that is using our GitLab CI pipeline, tested building the project and everything works correctly. However, the error occurs only in GitLab CI.</p>  <p>After an investigation looks like surefire is creating a fork that makes GitLab CI docker crash. In order to fix this, I've added below explicit configuration to avoid forked VM and this got rid of above error.</p>  <pre><code>&lt;!-- Needed only for GitLab CI --&gt; &lt;plugin&gt;     &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;     &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;     &lt;configuration&gt;         &lt;forkCount&gt;0&lt;/forkCount&gt;     &lt;/configuration&gt; &lt;/plugin&gt; </code></pre>  <p>Do you know why this is occurring? Is there another way to fix GitLab CI to avoid this issue? I don't really like this workaround, since it is just a way to avoid GitLab CI to explode but don't know how Docker is handled behind the scenes in Gitlab.</p> ",
    "OwnerUserId": "710099",
    "LastActivityDate": "2019-12-05T08:17:01.517",
    "Title": "GitLab CI is failing due to maven-surefire-plugin with VM crash",
    "Tags": "<docker><spring-boot><gitlab><gitlab-ci><maven-surefire-plugin>",
    "AnswerCount": "5",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>The issues are related to the latest maven docker images. </p>  <p>There is an open github issue where people reported the same problem: <a href='https://github.com/carlossg/docker-maven/issues/90' rel='noreferrer'>https://github.com/carlossg/docker-maven/issues/90</a></p>  <p>After an investigation I could sort out the problem using <code>alpine</code> version that saved me of adding the <code>maven-surefire-plugin</code> workaround. It's important to mention that using the surefire workaround brings another problem such as plugins like jacoco don't run since they need the VM fork.</p>  <p>So, these images work seamlessly (no surefire workaround was needed): </p>  <ul> <li>maven:3.3.9-jdk-8</li> <li>maven:3.5.3-jdk-8</li> <li>maven:3.5.4-jdk-8-alpine </li> <li>maven:3.6.0-jdk-8-alpine</li> </ul>  <p>However if we use the non alpine version the issue persists.</p> ",
    "highest_rated_answer": "<p>I had the same issue</p>  <p>You can find here the issue I created on gitlab for this, with detailed explanations : <a href='https://gitlab.com/gitlab-org/gitlab-ce/issues/53734' rel='nofollow noreferrer'>https://gitlab.com/gitlab-org/gitlab-ce/issues/53734</a></p>  <p>Also, I found a 'workaround'. <code>maven:3.5.3-jdk-8</code> as the docker image on which the build is executing. Or, the <code>forkCount=0</code> property on maven-surefire-plugin.</p>  <p>But this is disturbing. How, out of a sudden, builds start to fail? Don't know, and I don't think I have the experience necessary to solve this.</p>  <p>Till then, maybe this helps you</p> "
  },
  {
    "Id": "56284845",
    "PostTypeId": "1",
    "AcceptedAnswerId": "56285260",
    "CreationDate": "2019-05-24T01:42:29.300",
    "Score": "7",
    "ViewCount": "16500",
    "Body": "<p>I have a multi-module maven project. Parent pom looks like this:</p>  <pre><code>&lt;project&gt;     ...     &lt;packaging&gt;pom&lt;/packaging&gt;        &lt;modules&gt;         &lt;module&gt;common&lt;/module&gt;         &lt;module&gt;a&lt;/module&gt;         &lt;module&gt;b&lt;/module&gt;     &lt;/modules&gt; &lt;/project&gt; </code></pre>  <p><code>common</code> builds a jar, which is added as dependency in the other modules, like this:</p>  <pre><code>&lt;dependency&gt;     &lt;groupId&gt;my.project&lt;/groupId&gt;     &lt;artifactId&gt;common&lt;/artifactId&gt;     &lt;version&gt;${module.common.version}&lt;/version&gt; &lt;/dependency&gt; </code></pre>  <p>Modules <code>a</code> and <code>b</code> are Spring Boot projects having the <a href='https://github.com/spotify/dockerfile-maven' rel='noreferrer'>spotify docker plugin</a>.</p>  <p>I need to be able to run <code>mvn deploy</code> in order to get the spotify plugin push the docker image.</p>  <p><code>mvn install</code> works fine, which builds the docker images. But in order to push them, when I run <code>mvn deploy</code>, it throws error for the <code>common</code> module:</p>  <blockquote>   <p>[ERROR] Failed to execute goal   org.apache.maven.plugins:maven-deploy-plugin:2.7:deploy   (default-deploy) on project common: Deployment failed: repository   element was not specified in the POM inside distributionManagement   element or in -DaltDeploymentRepository=id::layout::url parameter</p> </blockquote>  <p>Searching for this error, <a href='https://stackoverflow.com/questions/27153024/repository-element-was-not-specified-in-the-pom-inside-distributionmanagement-el?rq=1'>this answer</a> suggests adding the repository url in the <code>distributionManagement</code> section. But I don't want to deploy <code>common</code>. I just want to build it, so it gets injected as dependency in the other modules and deploy those other modules. How can I do that?</p>  <p>I tried to deploy only <code>a</code> and <code>b</code> using this command, but it gives the same error for <code>common</code>:</p>  <pre><code>mvn clean \\    -DdockerRegistryHost=123.dkr.ecr.us-west-1.amazonaws.com/test1 \\    --projects a,b \\    --also-make \\    deploy </code></pre> ",
    "OwnerUserId": "1039555",
    "LastActivityDate": "2019-05-24T02:54:57.943",
    "Title": "Skip maven deploy for one module",
    "Tags": "<java><maven><spring-boot><docker><spotify-docker-client>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>You can accomplish what you want by configuring the <code>maven-deploy-plugin</code>.</p>  <p>Try adding the following to your parent pom:</p>  <pre><code>&lt;build&gt;     ...     &lt;pluginManagement&gt;         &lt;plugins&gt;             &lt;plugin&gt;                 &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;                 &lt;version&gt;3.0.0-M1&lt;/version&gt;                 &lt;configuration&gt;                     &lt;skip&gt;true&lt;/skip&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt;         &lt;/plugins&gt;     &lt;/pluginManagement&gt;     ...  &lt;/build&gt; </code></pre>  <p>or add <code>-Dmaven.deploy.skip=true</code> to your command line.</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "63789255",
    "PostTypeId": "1",
    "CreationDate": "2020-09-08T07:40:03.367",
    "Score": "7",
    "ViewCount": "2997",
    "Body": "<p>My Spring Boot project contains the Spring Boot Maven Plugin which I use for building a Docker image by running <code>mvn spring-boot:build-image</code>.</p> <pre class='lang-xml prettyprint-override'><code>&lt;plugin&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;     &lt;executions&gt;         &lt;execution&gt;             &lt;phase&gt;package&lt;/phase&gt;             &lt;goals&gt;                 &lt;goal&gt;build-image&lt;/goal&gt;             &lt;/goals&gt;         &lt;/execution&gt;     &lt;/executions&gt; &lt;/plugin&gt; </code></pre> <p>When deploying this image to a Docker stack I need to run a healthcheck using the <code>curl</code> command but unfortunately <code>curl</code> is not installed by the default buildpack.</p> <p>Is it possible to further tweak the image building process so that <code>curl</code> gets installed into the iamge? I couldn't find the necessary information</p> ",
    "OwnerUserId": "478406",
    "LastEditorUserId": "478406",
    "LastEditDate": "2020-09-08T07:47:11.900",
    "LastActivityDate": "2023-02-25T12:59:25.103",
    "Title": "Install package in Docker image created by Spring Boot Maven plugin",
    "Tags": "<spring-boot><docker><spring-boot-maven-plugin>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p><strong>TLDR;</strong></p> <p>Install <code>curl</code> into the build image with:</p> <pre><code>docker run --user=&quot;root&quot; --entrypoint launcher my-app:0.0.1-SNAPSHOT &quot;apt-get update &amp;&amp; apt-get install curl -y&quot; </code></pre> <p>Grab container id of the stopped container with <code>docker ps -a</code>:</p> <pre><code>$ docker ps -a CONTAINER ID   IMAGE                                  COMMAND                  CREATED          STATUS                       PORTS     NAMES 2ff7db32825f   my-app:0.0.1-SNAPSHOT   &quot;launcher 'apt-get u\u2026&quot;   44 minutes ago   Exited (0) 44 minutes ago              reverent_swanson </code></pre> <p>Create a new container image based on the one we installed <code>curl</code> into with:</p> <pre><code>docker commit 2ff7db32825f my-app-with-curl </code></pre> <p>Fire up a new container defining the correct <code>ENTRYPOINT</code> to start Spring Boot app:</p> <pre><code>docker run --rm -p 8080:8080 --user=&quot;cnb&quot; --entrypoint /cnb/process/web my-app-with-curl </code></pre> <p>Now <code>curl</code> should be ready inside your container.</p> <hr /> <p><strong>Details of the solution:</strong></p> <p>The reasoning behind Cloud Native Buildpacks (CNBs) &amp; Paketo.io, which are basically abstracted away by the <code>spring-boot-maven-plugin</code>s <code>build-image</code> goal, is to free us from the need to write/maintain our own <code>Dockerfiles</code>. So the inversion of this is: It's easy to configure the build process, but it is not easy to change things like installed packages.</p> <p>The reason is, that those packages are maintained in a so called <a href='https://buildpacks.io/docs/concepts/components/stack/' rel='nofollow noreferrer'>stack</a>, that manages the used <code>build</code>-time and <code>run</code>-time images. And if the stack doesn't define a <a href='https://buildpacks.io/docs/concepts/components/stack/#mixins' rel='nofollow noreferrer'>Mixin for your OS-level dependency</a>, then you can't simply add another package. It would also <strong>not suffice</strong> to <a href='https://buildpacks.io/docs/buildpack-author-guide/create-buildpack/' rel='nofollow noreferrer'>create your own simple buildpack</a> (I tried this approach). And creating your own stacks, buildpacks and/or builders would also negate the huge benefits that Cloud Native Buildpacks provide! Amongst other things we would be also forced to keep the images updated ourselves...</p> <p><strong>But there's another solution.</strong> As we don't want to create our own stacks/buildpacks, we can tweak the container image which has been created by CNBs/<code>spring-boot-maven-plugin</code>. Because the official docs show us <a href='https://buildpacks.io/docs/app-developer-guide/run-an-app/#user-provided-shell-process' rel='nofollow noreferrer'>how to hook into the startup process of the produced containers</a> and run shell scripts for example. Let's assume our <code>mvn spring-boot:build-image</code> command produced a container image called <code>my-app:0.0.1-SNAPSHOT</code>.</p> <p>Then first we install <code>curl</code> into the image with:</p> <pre><code>docker run --user=&quot;root&quot; --entrypoint launcher my-app:0.0.1-SNAPSHOT &quot;apt-get update &amp;&amp; apt-get install curl -y&quot; </code></pre> <p>We need to use <code>--user=&quot;root&quot;</code> here in order that the command <code>apt-get update &amp;&amp; apt-get install curl -y</code> will run successfully (otherwise we would run into errors like <code>List directory /var/lib/apt/lists/partial is missing. - Acquire (13: Permission denied)</code>). This will install curl, but we shouldn't use the resulting container in production. Because our Spring Boot app would run using the root user, which would introduce a variety of security problems. Also we've overwritten the <code>ENTRYPOINT</code> of our container, so it wouldn't be able to start our app.</p> <p>Therefore we simply <a href='https://stackoverflow.com/a/39329138/4964553'>start this stopped container with a new command</a>, entrypoint &amp; user! Simply grab the container ID of the stopped container with <code>docker ps -a</code>:</p> <pre><code>$ docker ps -a CONTAINER ID   IMAGE                                  COMMAND                  CREATED          STATUS                       PORTS     NAMES 2ff7db32825f   my-app:0.0.1-SNAPSHOT   &quot;launcher 'apt-get u\u2026&quot;   44 minutes ago   Exited (0) 44 minutes ago              reverent_swanson </code></pre> <p>And <strong>create a new container image</strong> based on the one we installed <code>curl</code> into with:</p> <pre><code>docker commit 2ff7db32825f my-app-with-curl </code></pre> <p>Finally <strong>fire up a new container</strong> based on this new image, defining the correct <code>ENTRYPOINT</code> to start our Spring Boot app and also using the <code>cnb</code> user again (as defined in the Cloud Native Buildpacks):</p> <pre><code>docker run --rm -p 8080:8080 --user=&quot;cnb&quot; --entrypoint /cnb/process/web my-app-with-curl </code></pre> <hr /> <p><strong>Off topic but relevant</strong>:</p> <p>There are ongoing discussions if it is desired to install curl in a production container. <a href='https://blog.sixeyed.com/docker-healthchecks-why-not-to-use-curl-or-iwr/' rel='nofollow noreferrer'>See this post for example</a>.</p> "
  },
  {
    "Id": "64849028",
    "PostTypeId": "1",
    "AcceptedAnswerId": "64958942",
    "CreationDate": "2020-11-15T19:43:42.410",
    "Score": "7",
    "ViewCount": "4410",
    "Body": "<p>Using Spring Boot 2.4.0, I'm trying to configure the <code>spring-boot:build-image</code> task to push an image to my private GitHub container registry.</p> <p>I used <a href='https://docs.spring.io/spring-boot/docs/2.4.0/maven-plugin/reference/htmlsingle/#build-image-example-publish' rel='noreferrer'>these instructions</a> to configure my POM as follows:</p> <pre class='lang-xml prettyprint-override'><code>            &lt;plugin&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                 &lt;configuration&gt;                     &lt;image&gt;                         &lt;name&gt;ghcr.io/abc/${project.artifactId}:${project.version}&lt;/name&gt;                         &lt;publish&gt;true&lt;/publish&gt;                     &lt;/image&gt;                     &lt;docker&gt;                         &lt;publishRegistry&gt;                             &lt;username&gt;abc&lt;/username&gt;                             &lt;token&gt;mytoken&lt;/token&gt;                             &lt;url&gt;https://ghcr.io&lt;/url&gt;                         &lt;/publishRegistry&gt;                     &lt;/docker&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt; </code></pre> <p>When I execute the <code>spring-boot:build-image</code> task, it builds the image but I get the following error when it tries to push:</p> <pre><code>[INFO] Successfully built image 'ghcr.io/abc/def:1.5.0' [INFO] [INFO]  &gt; Pushing image 'ghcr.io/abc/def:1.5.0' 100% Execution default-cli of goal org.springframework.boot:spring-boot-maven-plugin:2.4.0:build-image failed: Error response received when pushing image: error parsing HTTP 405 response body: unexpected end of JSON input: &quot;&quot; -&gt; [Help 1] </code></pre> <p>I can manually push the image using <code>docker push</code>, and I have tried doing a <code>docker login</code> which doesn't help either. I am also not behind any firewall or proxy.</p> ",
    "OwnerUserId": "657224",
    "LastEditorUserId": "657224",
    "LastEditDate": "2020-11-16T00:50:21.490",
    "LastActivityDate": "2020-11-22T20:04:35.763",
    "Title": "Maven Spring Boot Cannot Push Docker Image",
    "Tags": "<spring-boot><docker><spring-boot-maven-plugin>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>In case anyone else finds this, the problem ended up being a typo in the maven plugin configuration. I was using <code>&lt;token&gt;</code> instead of <code>&lt;password&gt;</code>. Below is the correct XML that works:</p> <pre><code>                &lt;docker&gt;                     &lt;publishRegistry&gt;                         &lt;username&gt;abc&lt;/username&gt;                         &lt;password&gt;mytoken&lt;/password&gt;                         &lt;url&gt;https://ghcr.io&lt;/url&gt;                     &lt;/publishRegistry&gt;                 &lt;/docker&gt; </code></pre> ",
    "highest_rated_answer": null
  },
  {
    "Id": "65437831",
    "PostTypeId": "1",
    "AcceptedAnswerId": "65506155",
    "CreationDate": "2020-12-24T11:42:26.827",
    "Score": "7",
    "ViewCount": "3559",
    "Body": "<p>I have the following multi-stage <code>dockerfile</code> that attempts to copy each module of my multi-module <code>java maven</code> project and build my <code>ear</code> file using <code>mvn clean install</code>.</p> <p><strong>dockerfile:</strong></p> <pre><code># Copy files from local to maven image and build ear FROM maven:3.5-jdk-8 AS build   COPY module1 /usr/src/app/src   COPY module2 /usr/src/app/src   COPY module3 /usr/src/app/src   COPY pom.xml /usr/src/app   RUN mvn -f /usr/src/app/pom.xml clean install  # Create server image + rest of docker file (working ok) </code></pre> <p>The error that I am getting is as follows:</p> <pre><code>Step 8/20 : RUN mvn -f /usr/src/app/pom.xml clean install  ---&gt; Running in cf9d8c1ef9ed [INFO] Scanning for projects... [ERROR] [ERROR] Some problems were encountered while processing the POMs: [FATAL] Non-resolvable parent POM for com.company.web:api:21.01-SNAPSHOT:   Could not find artifact com.company.parent:jee6:pom:1.0.1-SNAPSHOT and   'parent.relativePath' points at wrong local POM @ line 8, column 10  @ [ERROR] The build could not read 1 project -&gt; [Help 1] </code></pre> <p>The section in the <code>pom.xml</code> that corresponds to this error:</p> <pre><code>&lt;parent&gt; &lt;groupId&gt;com.company.parent&lt;/groupId&gt; &lt;artifactId&gt;jee6&lt;/artifactId&gt; &lt;version&gt;1.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; </code></pre> <p>I assume this issue because when trying to run the command in the maven docker image it cannot see my local <code>.m2</code> folder? And the dependency that it is looking for is a private dependency on my local machine.</p> <p>Would also copying my maven <code>settings.xml</code> help?</p> <p>How can I resolve this? I do not want someone to have to have Maven installed on their machine in order to run this dockerfile.</p> ",
    "OwnerUserId": "12268910",
    "LastEditorUserId": "1744774",
    "LastEditDate": "2021-01-01T13:08:57.680",
    "LastActivityDate": "2021-01-01T13:08:57.680",
    "Title": "Multi Module Maven Project and Docker: Cannot find artifact?",
    "Tags": "<java><docker><maven><dependencies><pom.xml>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>Dependency <code>com.company.parent:jee6:pom:1.0.1-SNAPSHOT</code> seems to be private, your Maven command inside Docker build needs to be able to either download it from private repository or have it readily accessible.</p> <blockquote> <p>I assume this issue because when trying to run the command in the maven docker image it cannot see my local .m2 folder?</p> </blockquote> <p>Yes, it then cannot see your <code>settings.xml</code> with private repository config, or local dependency if it's already available locally.</p> <blockquote> <p>Would also copying my maven settings.xml help?</p> </blockquote> <p>It's better not to: your <code>settings.xml</code> (and eventual secrets within) may be available to anyone using your image later. Using a secret mount with BuildKit would be a better solution (see below)</p> <hr /> <p>You have multiple solutions:</p> <h1>Mount <code>settings.xml</code> as secret during build</h1> <p>This solution assumes you have a <code>settings.xml</code> <a href='https://maven.apache.org/settings.html#servers' rel='noreferrer'>configured with proper credentials to access private registry</a>.</p> <p>Use <a href='https://docs.docker.com/develop/develop-images/build_enhancements/' rel='noreferrer'>Docker BuildKit</a> with <a href='https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/syntax.md#run---mounttypesecret' rel='noreferrer'><code>--mount=secret</code></a> to load <code>settings.xml</code> as secret with a <code>Dockerfile</code> such as:</p> <pre><code># syntax=docker/dockerfile:1.2 # Required comment at top of Dockerfile for using BuildKit  FROM maven:3.5-jdk-8 AS build    COPY module1 /usr/src/app/src   COPY module2 /usr/src/app/src   COPY module3 /usr/src/app/src   COPY pom.xml /usr/src/app    # Use your secret settings.xml RUN --mount=type=secret,id=mvnsettings,target=/root/.m2/settings.xml \\   mvn -f /usr/src/app/pom.xml clean install </code></pre> <p>And build command such as:</p> <pre><code>DOCKER_BUILDKIT=1 docker build --secret id=mvnsettings,src=$HOME/.m2/settings.xml .  </code></pre> <p>Maven should then be able to download parent dependency during build.</p> <p><em>Note: this is NOT <code>COPY</code>ing the <code>settings.xml</code> in image, as the secret <code>settings.xml</code> will only be made available for the specified build step and won't be persisted in final image.</em></p> <h1>Copy <code>com.company.parent:jee6</code> <code>pom.xml</code> during build</h1> <p>This solution is less practical and may not solve problem entirely:</p> <ul> <li>It would require to have <code>com.company.parent:jee6:pom:1.0.1-SNAPSHOT</code> <code>pom.xml</code> file available in build context</li> <li>Your parent <code>pom.xml</code> may refer to other private dependencies. You would have to include them the same way.</li> </ul> <p>... But it still may be worth a try.</p> <p>You can do something like:</p> <pre><code>FROM maven:3.5-jdk-8 AS build    # Copy and install parent pom COPY parent-pom.xml /tmp/parent/pom.xml RUN mvn -f /tmp/parent/pom.xml clean install  COPY module1 /usr/src/app/src   COPY module2 /usr/src/app/src   COPY module3 /usr/src/app/src   COPY pom.xml /usr/src/app   RUN mvn -f /usr/src/app/pom.xml clean install </code></pre> ",
    "highest_rated_answer": "<p>There are 2 different parts to the error: Cannot find the parent, and the parent.relativePath element is wrong.  I think the 2nd part might be causing the 1st.</p> <p>Since your parent element doesn't specify a relativePath element, the default is the module parent path (aka ..). Your modules are not in a child of the parent folder (/usr/src/app) but rather in the (/usr/src/app/src subfolder).</p> <p>Try changing your copy commands to :</p> <pre><code>COPY module1 /usr/src/app COPY module2 /usr/src/app   COPY module3 /usr/src/app   COPY pom.xml /usr/src/app </code></pre> <p>You should then see:</p> <pre><code>/usr/src/app /usr/src/app/module1 /usr/src/app/module2 /usr/src/app/module3 </code></pre> "
  },
  {
    "Id": "28078524",
    "PostTypeId": "1",
    "AcceptedAnswerId": "28127197",
    "CreationDate": "2015-01-21T23:03:47.697",
    "Score": "6",
    "ViewCount": "18530",
    "Body": "<p>I've an image which needs to connect to a repository in runtime, but it seams that Docker container is not able to read ~/.m2/settings.xml file located in host machine.</p>  <p>Is there any way to let docker now where maven configuration file is located? Or actually import the maven configuration file to the container?</p> ",
    "OwnerUserId": "3476247",
    "LastEditorUserId": "3476247",
    "LastEditDate": "2015-01-24T15:48:02.517",
    "LastActivityDate": "2015-01-25T00:10:43.127",
    "Title": "Docker - maven connect to specific repository in runtime",
    "Tags": "<java><xml><maven><docker>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>Regarding the feedback, we've came up with the following solution.</p>  <p>The settings.xml was added to the project build folder and the DockerFile looks like this:</p>  <pre><code>... RUN apt-get update RUN apt-get install -y maven  ADD /path/to/settings.xml /root/.m2/settings.xml ... </code></pre>  <p>and in the run script file we added the repository (this will write on /etc/hosts):</p>  <pre><code>... docker run --add-host=myrepo.mycompany.com:&lt;ip&gt; ... ... </code></pre>  <p>and now the application can resolve runtime dependencies!</p> ",
    "highest_rated_answer": "<p>You can do this by creating a volume mapping</p>  <pre><code>docker run ... -v /path/on/host/settings.xml:/home/me/.m2/settings.xml .... </code></pre>  <p>see also the following example where the repository is run within a container and accessed via a link: </p>  <ul> <li><a href='https://stackoverflow.com/questions/27767264/how-to-dockerize-maven-project-and-how-many-ways-to-accomplish-it/27768965#27768965'>How to dockerize maven project? and how many ways to accomplish it?</a></li> </ul> "
  },
  {
    "Id": "32015945",
    "PostTypeId": "1",
    "CreationDate": "2015-08-14T17:49:56.303",
    "Score": "6",
    "ViewCount": "1966",
    "Body": "<p>I am using a Jenkins server as CI. I am using a maven docker to run the maven tasks. So here is my problem and my doubts. </p>  <p>With jenkins I use the maven plugin to configure and compile the maven tasks. If I want to build I run the <strong>Build with Parameters</strong>, if I want to create an snapshot or release I run the <strong><em>Perform Maven Release</em></strong> and here I can specify the version. </p>  <p>But with docker is more complicated because I have to use arguments for the mvn command. So:</p>  <p>How do I set options to create a release or snapshot version?</p>  <p>I have the settings.xml file with my nexus url and also with the user/password, but the problems is using it with docker. </p>  <p>I am using docker.io/maven image.</p> ",
    "OwnerUserId": "988174",
    "LastActivityDate": "2015-08-14T20:52:09.197",
    "Title": "How to set maven options to run for release or snapshot",
    "Tags": "<java><maven><jenkins><docker><maven-release-plugin>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Maven handles releases and snapshots based on the version number, not based on the command line arguments.</p>  <p>There is a <a href='http://maven.apache.org/maven-release/maven-release-plugin/' rel='nofollow'>maven-release-plugin</a> that will automate the work required to release a build; however, you likely need some background information before you use it.</p>  <p>To 'build a release', you check in a pom.xml which lacks a '-SNAPSHOT' identifier (so you have a history of the source code of the release) and then you build the plugin using the 'mvn deploy' command (assuming your pom.xml is fully configured, which it likely isn't).  Then you would check in the 'next' -SNAPSHOT version, and everyone would continue developing on the next snapshot version.</p>  <p>If this sounds like a lot of work, keep in mind that all of this is automated through the maven-release-plugin.  That means the work is done once, and every release after that is automated.  This reduces the likelihood of human error in the release, and accelerates the speed of the release process.  It is worth the initial effort to setup.</p>  <p>Rebuilding a non-SNAPSHOT number with the 'mvn deploy' command is highly discouraged, as it makes the binaries dependent on both the version number and when they were built, where that last bit of information is not tracked.  </p> "
  },
  {
    "Id": "35450248",
    "PostTypeId": "1",
    "AcceptedAnswerId": "36735247",
    "CreationDate": "2016-02-17T07:19:06.233",
    "Score": "6",
    "ViewCount": "8148",
    "Body": "<p>I use <a href='https://github.com/rhuss/docker-maven-plugin' rel='noreferrer'>Docker Maven Plugin</a></p>  <p>When test-integration starts i can connect to mysql on container in terminal with this command:</p>  <pre><code>mysql -h 127.0.0.1 -P 32795 -uroot -p </code></pre>  <p>and everythings works good but when i want to connect mysql in java app with JDBC with this code:</p>  <pre><code>Class.forName('com.mysql.jdbc.Driver').newInstance(); Connection connection = DriverManager.getConnection(     'jdbc:mysql://127.0.0.1:' + System.getProperty('mysqlPort') + '/dashboardmanager',     'root',     'root' ); </code></pre>  <p>i get this error:</p>  <pre><code>org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is java.sql.SQLException: Cannot create PoolableConnectionFactory (Communications link failure  The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server.)     at org.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:80) ~[spring-jdbc-4.2.4.RELEASE.jar:4.2.4.RELEASE]     at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:615) ~[spring-jdbc-4.2.4.RELEASE.jar:4.2.4.RELEASE]     at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:866) ~[spring-jdbc-4.2.4.RELEASE.jar:4.2.4.RELEASE]     at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:927) ~[spring-jdbc-4.2.4.RELEASE.jar:4.2.4.RELEASE]     at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:937) ~[spring-jdbc-4.2.4.RELEASE.jar:4.2.4.RELEASE] </code></pre>  <p>I tried:</p>  <pre><code>export _JAVA_OPTIONS='-Djava.net.preferIPv4Stack=true' </code></pre>  <p>and</p>  <pre><code>System.setProperty('java.net.preferIPv4Stack' , 'true'); </code></pre>  <p>but nothing changed.</p>  <p><a href='https://github.com/rhuss/docker-maven-plugin' rel='noreferrer'>Docker Maven Plugin</a> Conf:</p>  <pre><code>&lt;plugin&gt;             &lt;groupId&gt;org.jolokia&lt;/groupId&gt;             &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;             &lt;version&gt;${docker-maven-plugin.version}&lt;/version&gt;             &lt;configuration&gt;                 &lt;images&gt;                     &lt;image&gt;                         &lt;name&gt;mysql:5.7.11&lt;/name&gt;                         &lt;run&gt;                             &lt;env&gt;                                 &lt;MYSQL_ROOT_PASSWORD&gt;root&lt;/MYSQL_ROOT_PASSWORD&gt;                                 &lt;MYSQL_DATABASE&gt;dashboardmanager&lt;/MYSQL_DATABASE&gt;                             &lt;/env&gt;                             &lt;ports&gt;                                 &lt;port&gt;mysqlPort:3306&lt;/port&gt;                             &lt;/ports&gt;                         &lt;/run&gt;                     &lt;/image&gt;                 &lt;/images&gt;             &lt;/configuration&gt;             &lt;executions&gt;                 &lt;execution&gt;                     &lt;id&gt;start&lt;/id&gt;                     &lt;phase&gt;pre-integration-test&lt;/phase&gt;                     &lt;goals&gt;                         &lt;goal&gt;start&lt;/goal&gt;                     &lt;/goals&gt;                 &lt;/execution&gt;                 &lt;execution&gt;                     &lt;id&gt;stop&lt;/id&gt;                     &lt;phase&gt;post-integration-test&lt;/phase&gt;                     &lt;goals&gt;                         &lt;goal&gt;stop&lt;/goal&gt;                     &lt;/goals&gt;                 &lt;/execution&gt;             &lt;/executions&gt;         &lt;/plugin&gt; </code></pre> ",
    "OwnerUserId": "1528519",
    "LastActivityDate": "2017-04-07T15:06:25.713",
    "Title": "Can't connect to mySql docker container with JDBC",
    "Tags": "<java><mysql><maven><jdbc><docker>",
    "AnswerCount": "2",
    "CommentCount": "9",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>The problem was this:</p>  <p>MySql starting process takes about 40 seconds, so i should stay about 40 seconds and after that try to connecting to mySql,  so simple :)</p>  <p>Or i can use these settings in pom.xml:</p>  <pre><code>&lt;image&gt;     &lt;name&gt;mysql:5.7.11&lt;/name&gt;     &lt;alias&gt;mysqlContainer&lt;/alias&gt;     &lt;run&gt;         &lt;env&gt;             &lt;MYSQL_ROOT_PASSWORD&gt;root&lt;/MYSQL_ROOT_PASSWORD&gt;             &lt;MYSQL_DATABASE&gt;dashboard&lt;/MYSQL_DATABASE&gt;         &lt;/env&gt;         &lt;ports&gt;             &lt;port&gt;mysqlPort:3306&lt;/port&gt;         &lt;/ports&gt;         &lt;wait&gt;             &lt;log&gt;.*port: 3306  MySQL Community Server.*&lt;/log&gt;             &lt;time&gt;120000&lt;/time&gt;         &lt;/wait&gt;     &lt;/run&gt; &lt;/image&gt; </code></pre> ",
    "highest_rated_answer": "<p>Make sure your your MySQL config file (<code>my.cnf</code>) set in your mysql container uses:</p>  <pre><code>bind-address = 0.0.0.0 </code></pre>  <p>As explained in <a href='https://stackoverflow.com/a/24326540/6309'>this answer</a> (for a reverse case: connecting to mysql running on host from a docker container, but the idea is the same here), in bridge mode, setting <code>bind-address</code> to broadcast mode would help validate that mysql is reacheable.</p>  <blockquote>   <p>Note: if you use <code>bind-address = 0.0.0.0</code> your MySQL server will listen for connections on all network interfaces. That means your MySQL server could be reached from the Internet ; make sure to setup firewall rules accordingly.</p> </blockquote>  <p>After this test, check '<a href='https://stackoverflow.com/a/34906355/6309'>How to connect to mysql running in container from host machine</a>'</p>  <blockquote>   <p>By default, root only has access from the localhost, 127.0.0.1 &amp; ::1, you need to specifically allow access from 192.168.99.1 or from anywhere using '%' in the user setup.<br>   See '<a href='http://dev.mysql.com/doc/refman/5.5/en/default-privileges.html' rel='nofollow noreferrer'>Securing the Initial MySQL Accounts</a>'.</p> </blockquote> "
  },
  {
    "Id": "37191662",
    "PostTypeId": "1",
    "CreationDate": "2016-05-12T15:42:21.597",
    "Score": "6",
    "ViewCount": "2178",
    "Body": "<p>I've got a Spring Boot project which I want to built an image from and push to a Docker private registry. I've followed <a href='https://spring.io/guides/gs/spring-boot-docker/' rel='nofollow'>Spring Boot official docs</a> for that, using the <a href='https://github.com/spotify/docker-maven-plugin' rel='nofollow'>Spotify Docker Maven plugin</a>. That worked well when publishing my image to a docker local instance using Boot2Docker.</p>  <p>Now I'm trying to do the same with a remote private repo (an unsecured one) and I'm struggling with it. I've followed the plugin documentation for that and that's how my configuration looks like:</p>  <pre><code>&lt;build&gt;     &lt;plugins&gt;         &lt;plugin&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;         &lt;/plugin&gt;         &lt;plugin&gt;             &lt;groupId&gt;com.spotify&lt;/groupId&gt;             &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;             &lt;version&gt;0.4.9&lt;/version&gt;             &lt;configuration&gt;                 &lt;imageName&gt;service-discovery&lt;/imageName&gt;                 &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt;                 &lt;resources&gt;                     &lt;resource&gt;                         &lt;targetPath&gt;/&lt;/targetPath&gt;                         &lt;directory&gt;${project.build.directory}&lt;/directory&gt;                         &lt;include&gt;${project.build.finalName}.war&lt;/include&gt;                     &lt;/resource&gt;                 &lt;/resources&gt;             &lt;/configuration&gt;               &lt;executions&gt;                 &lt;execution&gt;                   &lt;id&gt;build-image&lt;/id&gt;                   &lt;phase&gt;package&lt;/phase&gt;                   &lt;goals&gt;                     &lt;goal&gt;build&lt;/goal&gt;                   &lt;/goals&gt;                 &lt;/execution&gt;                 &lt;execution&gt;                   &lt;id&gt;tag-image&lt;/id&gt;                   &lt;phase&gt;package&lt;/phase&gt;                   &lt;goals&gt;                     &lt;goal&gt;tag&lt;/goal&gt;                   &lt;/goals&gt;                   &lt;configuration&gt;                     &lt;image&gt;service-discovery&lt;/image&gt;                     &lt;newName&gt;develop01.mycompany.com:5000/service-discovery&lt;/newName&gt;                   &lt;/configuration&gt;                 &lt;/execution&gt;               &lt;/executions&gt;         &lt;/plugin&gt;     &lt;/plugins&gt; &lt;/build&gt; </code></pre>  <p>My registry is accessible through <code>http://develop01.mycompany.com:5000</code>, but the docker plugin seems not to be able to find it.</p>  <p>Executing <em>mvn clean install</em> throws:</p>  <blockquote>   <p>[ERROR] Failed to execute goal com.spotify:docker-maven-plugin:0.4.9:build (buil   d-image) on project service-discovery: Exception caught: java.util.concurrent.Ex   ecutionException: com.spotify.docker.client.shaded.javax.ws.rs.ProcessingExcepti   on: org.apache.http.conn.HttpHostConnectException: Connect to localhost:2375 [lo   calhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: connec   t -> [Help 1]</p> </blockquote>  <p>Executing <em>mvn docker:tag -DpushImage</em> throws:</p>  <blockquote>   <p>[ERROR] Failed to execute goal com.spotify:docker-maven-plugin:0.4.9:tag (defaul   t-cli) on project service-discovery: The parameters 'image', 'newName' for goal   com.spotify:docker-maven-plugin:0.4.9:tag are missing or invalid -> [Help 1]</p> </blockquote>  <p>So the plugin seems not to recognize the parameters into the image goal (in fact, it looks like it's trying to connect to a local Docker instance when executing <em>mvn clean install</em>).</p>  <p><strong>Software:</strong></p>  <ul> <li>docker version: Server: 1.11.0</li> <li>docker-maven-plugin version: 0.4.9</li> <li>maven version: 3.2.3</li> </ul>  <p>A link to the <a href='https://github.com/spotify/docker-maven-plugin/issues/227' rel='nofollow'>GitHub issue</a> I created</p>  <hr>  <p><strong>Update</strong></p>  <p>I have set my DOCKER_HOST environment variable to <code>tcp://develop01.mycompany.com:5000</code> and now the plugin seems to pick it. Still don't understand why I have to do it through an environment variable, when I'm declaring the server name in the execution configuration. All in all, that's the error I'm getting right now:</p>  <blockquote>   <p>[ERROR] Failed to execute goal   com.spotify:docker-maven-plugin:0.4.9:build (buil d-image) on project   service-discovery: Exception caught: Request error: GET http   ://develop01.mycompany.com:5000/version: 404: HTTP 404 Not Found ->   [Help 1]</p> </blockquote>  <p>In fact, the /version endpoint of my registry returns 404. The /v2 endpoint however, returns an empty JSON. Is the plugin trying to deal with a previous docker version API?</p> ",
    "OwnerUserId": "1199132",
    "LastEditorUserId": "482717",
    "LastEditDate": "2016-09-21T16:14:33.497",
    "LastActivityDate": "2016-09-21T16:14:33.497",
    "Title": "Cannot push to remote repo using the (spotify) Docker maven plugin",
    "Tags": "<maven><docker><spring-boot>",
    "AnswerCount": "0",
    "CommentCount": "1",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": null
  },
  {
    "Id": "38293073",
    "PostTypeId": "1",
    "AcceptedAnswerId": "38294215",
    "CreationDate": "2016-07-10T14:42:19.643",
    "Score": "6",
    "ViewCount": "7523",
    "Body": "<p>I'm trying to create a Dockerfile to then build a Maven project.</p>  <p>I wonder how to fix the Dockerfile and what command to then execute.</p>  <p>I would like to know how to run the build so that it does NOT download all the Maven dependencies every time it builds when the source code, sitting in the src/ directory, has NOT changed.</p>  <p>Here is my Dockerfile file:</p>  <pre><code>FROM maven:3.3.9-jdk-8  RUN mkdir -p /usr/src/app  WORKDIR /usr/src/app  RUN cd /usr/src/app  ADD pom.xml /usr/src/app  RUN mvn dependency:resolve  ADD src /usr/src/app  RUN mvn package  ENTRYPOINT ['mvn'] CMD ['package'] </code></pre>  <p>Should I run the <code>docker run --rm -it toolbox</code> command or the <code>docker build -t toolbox .</code> command ?</p>  <p>Both of these above commands run fine, except that they both download all the Maven dependencies even if the source code has not been touched.</p> ",
    "OwnerUserId": "958373",
    "LastActivityDate": "2016-07-10T16:46:07.940",
    "Title": "Do not download all Maven dependencies on a Docker build",
    "Tags": "<maven><docker>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>That's how Docker works. Every time you do <code>docker run</code>, it creates a new container which does not have any access to the files in the old container. So, it download all dependencies it requires. You can circumvent this by declaring an external volume. Looking at the <code>Dockerfile</code> of Maven, it declares a volume <code>/root/.m2</code>. So, you can use a directory in your host machine and attach it to this volume by <code>-v</code> option. Your Docker command would be,</p>  <pre><code>`docker run -v &lt;directory-in-your-host&gt;:/root/.m2 &lt;other-options-and-commands&gt; </code></pre>  <p>Every time you run a new <code>docker run</code>, Maven will look into your local directory before downloading the dependency.</p>  <p>However, my question is why don't you build your app first and use the resulting jar to create the docker images unless you have any specific reasons. You can create your own Dockerfile using java base image or simply use one of the <code>docker-maven-plugin</code> like <a href='https://github.com/spotify/docker-maven-plugin' rel='noreferrer'>spotify</a> available out there. That makes your life a lot easier.</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "40898608",
    "PostTypeId": "1",
    "AcceptedAnswerId": "40997695",
    "CreationDate": "2016-11-30T21:32:01.990",
    "Score": "6",
    "ViewCount": "3059",
    "Body": "<p><strong>TL/DR: How can I cache the <code>pom.xml</code> file's <code>&lt;parent&gt;</code> so my build can be run in offline mode?</strong></p>  <p>I'm using Docker to build a maven project. My goal is to add two steps to the build: one to download all of the dependencies, and another to build the project. Here's what my Dockerfile looks like so far:</p>  <pre><code>FROM maven:3.3-jdk-8  # Download the project dependencies (so they can be cached by Docker) ADD pom.xml /runtime/ WORKDIR /runtime RUN mvn dependency:go-offline RUN mvn dependency:resolve-plugins  # Mount the local repository ADD . /runtime  # Build the service RUN mvn clean package -o -DskipTests </code></pre>  <p><strike>This seems to work fine for the plugins. I checked the <code>/root/.m2/repository</code> and everything seems to be in order.</strike></p>  <p><strike>Edit: When double checking for the <code>/root/.m2/repository</code> directory, it's no longer there. For some reason, Maven isn't saving any of the dependencies to this location.</strike></p>  <p><strong>Edit 2: After building the Docker image, there's no <code>/root/.m2/repository</code> directory. However, if I run <code>mvn dependency:go-offline</code> from within a shell inside the Docker container, the directory is created without a problem.</strong></p>  <p>When I attempt build my application, I get the following error:</p>  <pre><code>[ERROR] [ERROR] Some problems were encountered while processing the POMs: [FATAL] Non-resolvable parent POM for com.example:service:1.2: Cannot access central (http://jcenter.bintray.com) in offline mode and the artifact org.springframework.boot:spring-boot-starter-parent:pom:1.4.0.M3 has not been downloaded from it before. and 'parent.relativePath' points at wrong local POM @ line 14, column 13  @ [ERROR] The build could not read 1 project -&gt; [Help 1] [ERROR] [ERROR]   The project com.sample:service:1.2 (/runtime/pom.xml) has 1 error [ERROR]     Non-resolvable parent POM for com.oe:graph-service:1.2: Cannot access central (http://jcenter.bintray.com) in offline mode and the artifact org.springframework.boot:spring-boot-starter-parent:pom:1.4.0.M3 has not been downloaded from it before. and 'parent.relativePath' points at wrong local POM @ line 14, column 13 -&gt; [Help 2] [ERROR] [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch. [ERROR] Re-run Maven using the -X switch to enable full debug logging. [ERROR] [ERROR] For more information about the errors and possible solutions, please read the following articles: [ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/ProjectBuildingException [ERROR] [Help 2] http://cwiki.apache.org/confluence/display/MAVEN/UnresolvableModelException </code></pre>  <p>The problem seems to be that <code>mvn dependency:go-offline</code> isn't resolving the parent. When I run the build in offline mode, it breaks.</p>  <p>Here are the relevant portions of my <code>pom.xml</code> file:</p>  <pre><code>&lt;?xml version='1.0' encoding='UTF-8'?&gt;  &lt;project xmlns='http://maven.apache.org/POM/4.0.0' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'          xsi:schemaLocation='http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd'&gt;     &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;      ...      &lt;parent&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;         &lt;version&gt;1.4.0.M3&lt;/version&gt;     &lt;/parent&gt;      ...      &lt;repositories&gt;         &lt;repository&gt;             &lt;snapshots&gt;                 &lt;enabled&gt;false&lt;/enabled&gt;             &lt;/snapshots&gt;             &lt;id&gt;central&lt;/id&gt;             &lt;name&gt;bintray&lt;/name&gt;             &lt;url&gt;http://jcenter.bintray.com&lt;/url&gt;         &lt;/repository&gt;          &lt;repository&gt;             &lt;id&gt;repository.springsource.snapshot&lt;/id&gt;             &lt;name&gt;SpringSource Snapshot Repository&lt;/name&gt;             &lt;url&gt;http://repo.springsource.org/snapshot&lt;/url&gt;         &lt;/repository&gt;          &lt;repository&gt;             &lt;id&gt;spring-milestones&lt;/id&gt;             &lt;url&gt;http://repo.spring.io/milestone&lt;/url&gt;         &lt;/repository&gt;     &lt;/repositories&gt;      &lt;dependencies&gt;        ...          &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;             &lt;exclusions&gt;                 &lt;exclusion&gt;                     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                     &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;                 &lt;/exclusion&gt;             &lt;/exclusions&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;             &lt;scope&gt;test&lt;/scope&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.scala&lt;/groupId&gt;             &lt;artifactId&gt;spring-scala_2.11&lt;/artifactId&gt;             &lt;version&gt;1.0.0.BUILD-SNAPSHOT&lt;/version&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;!-- disabling Spring cloud AWS until proper testing harnesses can be set up --&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;             &lt;artifactId&gt;httpcore&lt;/artifactId&gt;             &lt;version&gt;LATEST&lt;/version&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;             &lt;artifactId&gt;spring-cloud-aws-autoconfigure&lt;/artifactId&gt;             &lt;version&gt;1.1.0.RELEASE&lt;/version&gt;         &lt;/dependency&gt;          ...     &lt;/dependencies&gt;      ... &lt;/project&gt; </code></pre> ",
    "OwnerUserId": "262125",
    "LastEditorUserId": "262125",
    "LastEditDate": "2016-12-02T20:50:24.150",
    "LastActivityDate": "2016-12-06T14:27:46.830",
    "Title": "Caching Maven parent in offline build",
    "Tags": "<java><maven><docker>",
    "AnswerCount": "2",
    "CommentCount": "8",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>If you customize maven's <code>settings.xml</code> file you can save your repository files on image.</p>  <p>Create a custom version of <code>settings.xml</code>, with the <code>localRepository</code> setting modified, like this:</p>  <pre><code>&lt;settings xmlns='http://maven.apache.org/SETTINGS/1.0.0'           xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'           xsi:schemaLocation='http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd'&gt;   &lt;!-- localRepository    | The path to the local repository maven will use to store artifacts.    |    | Default: ${user.home}/.m2/repository --&gt;   &lt;localRepository&gt;/usr/share/maven/repo&lt;/localRepository&gt; ... </code></pre>  <p>Then override the default configuration when building your image:</p>  <pre><code>FROM maven:3-jdk-8  COPY settings.xml /usr/share/maven/conf/settings.xml  RUN mkdir -p /usr/src/app WORKDIR /usr/src/app  ADD . /usr/src/app  RUN mvn dependency:go-offline  RUN mvn clean package </code></pre>  <p>Now your repository is stored in <code>/usr/share/maven/repo</code>.</p>  <h2>Using onbuild</h2>  <p>You can also create a base image using <a href='https://docs.docker.com/engine/reference/builder/#/onbuild' rel='nofollow noreferrer'>ONBUILD</a>, this will allow to have custom configured images for every maven project.</p>  <p>Like this:</p>  <pre><code>FROM maven:3-jdk-8  COPY settings.xml /usr/share/maven/conf/settings.xml  RUN mkdir -p /usr/src/app WORKDIR /usr/src/app  ONBUILD ADD . /usr/src/app  ONBUILD RUN mvn dependency:go-offline  ONBUILD RUN mvn clean package </code></pre>  <p>Then build the image:</p>  <pre><code>docker build -t mvn_bldr . </code></pre>  <p>This will create a <em>template</em> for other maven images. Then you can create your custom <em>downstream</em> image with:</p>  <pre><code>FROM mvn_bldr </code></pre>  <p>If you want to customize your image further you can add more instructions, every instruction of the template will be triggered after the <code>FROM mvn_bldr</code> command, as in the docs:</p>  <blockquote>   <p>The trigger will be executed in the context of the downstream build,   as if it had been inserted immediately after the FROM instruction in   the downstream Dockerfile.</p> </blockquote> ",
    "highest_rated_answer": "<p>It may seem like using <code>RUN</code> with Docker is like executing commands in a shell script, but it's not. Every instance of <code>RUN</code> gets applied to a new container that results from the changes created by the previous command. So each command is executing inside of a new container context.</p>  <p>Dockerifles can contain a <code>VOLUME</code> reference, which mounts an external directory inside the Docker container. If there were any files inside the volume, those files are wiped out. If you don't explicitly specify a volume, Docker is happy to instead create an empty folder.</p>  <p>While my Dockerfile doesn't contain an explicit reference to a <code>VOLUME</code>, its parent does. So, even though my <code>mvn dependency:go-offline</code> command was running, those files were being wiped out in the next step by the <code>VOLUME</code> specified in the <a href='https://github.com/carlossg/docker-maven/blob/master/jdk-8/Dockerfile' rel='nofollow noreferrer'><code>docker-maven</code> <code>Dockerfile</code></a>.</p>  <p>In the end, I couldn't find a good way to make the <code>maven</code> Docker image work, so I switched to the <code>openjdk</code> image and installed <code>maven</code> via <code>apt-get</code> instead.</p> "
  },
  {
    "Id": "44537781",
    "PostTypeId": "1",
    "CreationDate": "2017-06-14T07:06:10.760",
    "Score": "6",
    "ViewCount": "1250",
    "Body": "<p>My application uses some additional files which I have inside the resource folder. When I do the regular build with Maven and package my app into JAR, I can see all my resources in case I unzip this archive. </p>  <p>But when I create a docker image I use spring-boot-maven-plugin to make my JAR archive executable. For some reason <strong>my resources aren't being added to the new repacked JAR</strong>. Moreover I <strong>can not even unzip it</strong> because it is corrupted.</p>  <p>Here is the way I set the repackage goal in my pom.xml:</p>  <pre><code>&lt;id&gt;prod&lt;/id&gt;         &lt;build&gt;             &lt;plugins&gt;                 &lt;plugin&gt;                     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                     &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                     &lt;version&gt;1.5.3.RELEASE&lt;/version&gt;                     &lt;configuration&gt;                         &lt;mainClass&gt;ApplicationName&lt;/mainClass&gt;                         &lt;executable&gt;true&lt;/executable&gt;                         &lt;arguments&gt;                             &lt;argument&gt;--spring.profiles.active=prod&lt;/argument&gt;                         &lt;/arguments&gt;                         &lt;!--&lt;addResources&gt;true&lt;/addResources&gt;--&gt;                     &lt;/configuration&gt;                     &lt;executions&gt;                         &lt;execution&gt;                             &lt;goals&gt;                                 &lt;goal&gt;repackage&lt;/goal&gt;                             &lt;/goals&gt;                             &lt;configuration&gt;                                 &lt;!--&lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt;--&gt;                                 &lt;!--&lt;layout&gt;JAR&lt;/layout&gt;--&gt;                             &lt;/configuration&gt;                         &lt;/execution&gt;                     &lt;/executions&gt;                 &lt;/plugin&gt;             &lt;/plugins&gt;         &lt;/build&gt; </code></pre>  <p>I want to add that when I run my image in docker it works fine <strong>but all the needed resources are missing</strong>.</p>  <p>Has anyone run into the same problem? Or maybe you can suggest how to fix it.</p> ",
    "OwnerUserId": "4624052",
    "LastActivityDate": "2017-06-14T07:06:10.760",
    "Title": "Resources are missing from JAR file after repackage with spring boot maven plugin",
    "Tags": "<maven><docker><spring-boot><spring-boot-maven-plugin><docker-maven-plugin>",
    "AnswerCount": "0",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": null
  },
  {
    "Id": "44667063",
    "PostTypeId": "1",
    "AcceptedAnswerId": "44694167",
    "CreationDate": "2017-06-21T04:49:23.627",
    "Score": "6",
    "ViewCount": "14268",
    "Body": "<p>I have a very simple demo of using Spring Boot + Docker Compose + Eureka. </p>  <p>My server runs on port 8671 with the following application properties:</p>  <pre><code>server:   port: 8761 eureka:   instance:     prefer-ip-address: true   client:     registerWithEureka: false     fetchRegistry: false   server:     waitTimeInMsWhenSyncEmpty: 0 </code></pre>  <p>My Eureka client runs on port 9000 with the following application properties:</p>  <pre><code>server:   port: 9000 spring:   application:     name: user-registration eureka:   client:     registerWithEureka: true     fetchRegistry: true     serviceUrl:       defaultZone: http://localhost:8761/eureka/   instance:     prefer-ip-address: true </code></pre>  <p>When I start up my docker.compose file in the parent maven project, this is the contents of my docker-compose file:</p>  <pre><code>eureka-server:   image: rosenthal/eureka-server ports:    - '8761:8761' user-registration:   image: rosenthal/user-registration   ports:    - '9000:9000'   links:    - eureka-server </code></pre>  <p>When I run my application by first starting the eureka server, following by the client via </p>  <pre><code>mvn spring-boot:run  </code></pre>  <p>The server successfully registers my client (I call it user-registration).</p>  <p>When I run my application through docker-compose, the client fails to register with the following output:</p>  <pre><code> DiscoveryClient_USER-REGISTRATION/0fd640cbc3ba:user-registration:9000:   registering service...  user-registration_1  | 2017-06-21 04:36:05.120 ERROR 1 --- [nfoReplicator-0]          c.n.d.s.t.d.RedirectingEurekaHttpClient  : Request execution error  user-registration_1  |   user-registration_1  | com.sun.jersey.api.client.ClientHandlerException:   java.net.ConnectException: Connection refused (Connection refused) </code></pre>  <p>My first assumption was that running docker-compose ran into a race condition on waiting for the server to start, but my eureka client seems to have a heartbeat trying to call home to the server it's configured with. This means it's just not able to find the Eureka server I have registered (and is running, I can navigate to it on localhost:8671).</p>  <p>What am I missing here? Everything runs fine running locally with spring-boot starting up with it's own embedded tomcat containers. As soon as I start to do it with docker-compose, it doesn't want to work.</p>  <h2>EDIT</h2>  <p>I realized my problem, I believe. So docker doesn't run on localhost, it runs on the public IP it is assigned when I start up docker. Navigating to this ip + port shows my service running for Eureka Server. The client still doesn't register.</p>  <p>SO, I made changes to the application.yml file for my eureka client to:</p>  <pre><code>serviceUrl:   defaultZone: http://192.168.59.103:8761/eureka/ </code></pre>  <p>That IP is the one my docker daemon is running under. Now, it misses the first registration when I do docker-compose, but the second heartbeat picks up my client. </p>  <p>How can I ensure the client waits until the server is FULLY up? I used the proper docker 'links' field in my docket compose file, but it didn't work as I hoped. Additionally, how can I see the defaultZone file to be my DOCKER_HOST IP?</p>  <h2>Final result</h2>  <p>The resulting docker-compose file that got everything working for me was:</p>  <pre><code>eureka-server:   image: thorrism/eureka-server   ports:    - '8761:8761' user-registration:   image: thorrism/user-registration   ports:    - '9000:9000'   links:    - eureka-server   environment:     EUREKA_CLIENT_SERVICEURL_DEFAULTZONE: http://eureka-server:8761/eureka </code></pre> ",
    "OwnerUserId": "5203863",
    "LastEditorUserId": "5203863",
    "LastEditDate": "2017-06-21T16:52:46.653",
    "LastActivityDate": "2021-12-23T15:35:28.220",
    "Title": "Docker and Eureka with Spring Boot failing to register clients",
    "Tags": "<java><spring><maven><docker><spring-boot>",
    "AnswerCount": "5",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>If useful for you, that's in some way how I configure it for my production environment (docker-compose file version 2):</p>  <pre><code>version: '2' services:   eureka-server:     image: rosenthal/eureka-server     expose:     - '8761'   user-registration:     image: rosenthal/user-registration     container_name: user-registration     ports:     - '9000:8080'     environment:       server.port: 8080       eureka.client.enabled: 'true'       eureka.host: eureka-server       eureka.instance.preferIpAddress: 'true' </code></pre>  <p>From the <a href='https://docs.docker.com/compose/compose-file/#service-configuration-reference' rel='nofollow noreferrer'>docs</a> that's what <code>expose</code> does:</p>  <blockquote>   <p>Expose ports without publishing them to the host machine - they\u2019ll only be accessible to linked services. Only the internal port can be specified.</p> </blockquote>  <p>As you've got everything in the same network, containers can see each other with no links between them.</p>  <p><strong>SIDE NOTE</strong></p>  <p>Keep in mind that with this configuration port 9000 will be publicly accessible at the host machine, and mapped to the 8080 port of the user-registration container.</p> ",
    "highest_rated_answer": "<p>Set an environment property to override the <code>eureka.client.serviceUrl.defaultZone</code> to match the service name in your docker compose file.</p>  <pre><code>eureka-server:   image: rosenthal/eureka-server   ports:    - '8761:8761' user-registration:   image: rosenthal/user-registration   ports:    - '9000:9000'   environment:    - EUREKA_CLIENT_SERVICEURL_DEFAULTZONE: http://eureka-server:8761/eureka </code></pre>  <p>This will override the property from the packaged <code>application.properties</code>. </p>  <p><strong>NOTE:</strong> As mentioned in the comments you don't need the <code>links</code> section in the compose file. I removed is as such. See <a href='https://docs.docker.com/compose/networking/' rel='noreferrer'>https://docs.docker.com/compose/networking/</a> for info on that.</p> "
  },
  {
    "Id": "45063118",
    "PostTypeId": "1",
    "CreationDate": "2017-07-12T16:27:18.947",
    "Score": "6",
    "ViewCount": "1336",
    "Body": "<p>I am using <a href='https://hub.docker.com/r/heroku/java/' rel='nofollow noreferrer'>Heroku Java Docker Image</a> and <a href='https://github.com/docker/compose' rel='nofollow noreferrer'>docker-compose</a> to run dropwizard java based web service locally.</p>  <p>When I run <code>docker-compose build web</code> command to build code, It goes to download few dependencies each time. So build process turnaround time increased.</p>  <p>My project docker file is only single line : <code>FROM heroku/java</code></p>  <p>Here are build log:</p>  <pre><code>[INFO] ------------------------------------------------------------------------ [INFO] Building generator-app-server 0.0.2-SNAPSHOT [INFO] ------------------------------------------------------------------------ Downloading: https://repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-clean-plugin/2.5/maven-clean-plugin-2.5.pom Downloaded: https://repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-clean-plugin/2.5/maven-clean-plugin-2.5.pom (4 KB at 0.7 KB/sec) Downloading: https://repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-plugins/22/maven-plugins-22.pom Downloaded: https://repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-plugins/22/maven-plugins-22.pom (13 KB at 9.0 KB/sec) Downloading: https://repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-clean-plugin/2.5/maven-clean-plugin-2.5.jar Downloaded: https://repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-clean-plugin/2.5/maven-clean-plugin-2.5.jar (25 KB at 14.7 KB/sec) [INFO]  [INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ generator-app-server --- Downloading: https://repo.maven.apache.org/maven2/org/codehaus/plexus/plexus-utils/3.0/plexus-utils-3.0.pom Downloaded: https://repo.maven.apache.org/maven2/org/codehaus/plexus/plexus-utils/3.0/plexus-utils-3.0.pom (4 KB at 5.4 KB/sec) Downloading: https://repo.maven.apache.org/maven2/org/sonatype/spice/spice-parent/16/spice-parent-16.pom Downloaded: https://repo.maven.apache.org/maven2/org/sonatype/spice/spice-parent/16/spice-parent-16.pom (9 KB at 4.9 KB/sec) Downloading: https://repo.maven.apache.org/maven2/org/sonatype/forge/forge-parent/5/forge-parent-5.pom Downloaded: https://repo.maven.apache.org/maven2/org/sonatype/forge/forge-parent/5/forge-parent-5.pom (9 KB at 5.0 KB/sec) Downloading: https://repo.maven.apache.org/maven2/org/codehaus/plexus/plexus-utils/3.0/plexus-utils-3.0.jar Downloaded: https://repo.maven.apache.org/maven2/org/codehaus/plexus/plexus-utils/3.0/plexus-utils-3.0.jar (221 KB at 20.0 KB/sec) [INFO] Deleting /app/user/target [INFO]  [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ generator-app-server --- [INFO] Using 'UTF-8' encoding to copy filtered resources. [INFO] Copying 7 resources [INFO]  [INFO] --- maven-compiler-plugin:3.6.1:compile (default-compile) @ generator-app-server --- Downloading: https://repo.maven.apache.org/maven2/org/mapstruct/mapstruct-processor/1.1.0.Final/mapstruct-processor-1.1.0.Final.jar Downloaded: https://repo.maven.apache.org/maven2/org/mapstruct/mapstruct-processor/1.1.0.Final/mapstruct-processor-1.1.0.Final.jar (1502 KB at 24.5 KB/sec) Downloading: https://repo.maven.apache.org/maven2/org/mapstruct/mapstruct-processor/1.1.0.Final/mapstruct-processor-1.1.0.Final.pom Downloaded: https://repo.maven.apache.org/maven2/org/mapstruct/mapstruct-processor/1.1.0.Final/mapstruct-processor-1.1.0.Final.pom (12 KB at 4.9 KB/sec) </code></pre>  <p><code>docker-compose build</code> not using cached dependencies for above libs. How to forcefully use cached dependencies?</p>  <p>Googled a lot but no luck. Share if anyone had faced and fixed.</p>  <p><b>Update:</b></p>  <pre><code>Dockerfile FROM heroku/java  docker-compose.yml web:   build: .   command: 'bash -c ''java $JAVA_OPTS -jar target/generator-app-server-0.0.2-SNAPSHOT.jar db migrate config.yml &amp;&amp; java $JAVA_OPTS -Ddw.server.connector.port=$PORT -jar target/generator-app-server-0.0.2-SNAPSHOT.jar server config.yml'''   working_dir: /app/user   environment:     PORT: 8080     DATABASE_URL: 'postgres://postgres:@herokuPostgresql:5432/postgres'   ports:     - '8080:8080'   links:     - herokuPostgresql shell:   build: .   command: bash   working_dir: /app/user   environment:     PORT: 8080     DATABASE_URL: 'postgres://postgres:@herokuPostgresql:5432/postgres'   ports:     - '8080:8080'   links:     - herokuPostgresql   volumes:     - '.:/app/user' herokuPostgresql:   image: postgres </code></pre> ",
    "OwnerUserId": "722683",
    "LastEditorUserId": "722683",
    "LastEditDate": "2017-07-12T17:11:09.837",
    "LastActivityDate": "2017-07-13T17:44:00.783",
    "Title": "docker-compose build download few pom dependencies each time",
    "Tags": "<maven><heroku><docker-compose><dockerfile><dropwizard>",
    "AnswerCount": "1",
    "CommentCount": "6",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>My previous answer didn't make sense (I mistakenly thought that Maven dependencies were handled at run time and they are handled at <code>ONBUILD</code> instructions instead). But I'll try to give a second explanation of why these specific dependencies are not cached.</p>  <p>The downloaded dependencies listed in the question are from the builtin plugins for Maven <code>clean</code>. In the parent <code>Dockerfile</code> we download the project dependencies at <a href='https://github.com/heroku/docker-java/blob/master/Dockerfile#L14' rel='nofollow noreferrer'>https://github.com/heroku/docker-java/blob/master/Dockerfile#L14</a> (everything in your POM). Then, later on in the <code>Dockerfile</code> it runs the <code>clean</code> at <a href='https://github.com/heroku/docker-java/blob/master/Dockerfile#L18' rel='nofollow noreferrer'>https://github.com/heroku/docker-java/blob/master/Dockerfile#L18</a>. Since the <code>maven-clean-plugin</code> isn't part of your POM, it gets downloaded automatically at the clean step (it isn't cached from the previous <code>Dockerfile</code> instructions).</p>  <p>So, if you wanted to cache the <code>maven-clean-plugin</code> as well, you may need to add it as a dependency in your POM (you might be able to get away with just <code>&lt;scope&gt;import&lt;/scope&gt;</code>).</p> "
  },
  {
    "Id": "45685232",
    "PostTypeId": "1",
    "AcceptedAnswerId": "45685743",
    "CreationDate": "2017-08-15T01:20:44.837",
    "Score": "6",
    "ViewCount": "3892",
    "Body": "<p>I am new to Docker. I am using spring boot and when we build the project using maven, it will create jar file like app-.jar and then I am coping this jar file using ADD command in DockerFile. Now If I change the version number in pom.xml, then I need to manually update the JAR file name in DockerFile. Is there anyway by which I can dynamically get the version number which is in the pom.xml and update the JAR file name automatically in the DockerFile?</p> ",
    "OwnerUserId": "8441512",
    "LastActivityDate": "2017-08-15T02:37:53.053",
    "Title": "Dynamically get JAR filename in DockerFile",
    "Tags": "<maven><docker><jar><dockerfile>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>Instead of copying the jar file inside the dockerfile, you can mount the folder in which jar is created. And you will not be needed to be worried with the filename.</p>  <p>What you want can be done using environment variables. You can create an <a href='https://docs.docker.com/compose/env-file/' rel='nofollow noreferrer'>--env-file</a> and keep your version number there. And inside dockerfile, refer to value of variable declared in env file with <code>{VERSIION}</code>. By following this process, you may want to use this same version in your pom file. For that, take a look at <a href='https://stackoverflow.com/questions/10463077/how-to-refer-environment-variable-in-pom-xml'>this</a> question.</p>  <p>The answer links environment variables by setting env.path and detailed guide is <a href='http://books.sonatype.com/mvnref-book/reference/resource-filtering-sect-properties.html' rel='nofollow noreferrer'>here</a>.</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "48523558",
    "PostTypeId": "1",
    "AcceptedAnswerId": "48525718",
    "CreationDate": "2018-01-30T14:16:04.850",
    "Score": "6",
    "ViewCount": "13748",
    "Body": "<p>I am having a problem starting a .jar file within a Docker Container. The error message I am getting is: </p>  <blockquote>   <p>Exception in thread 'main' java.lang.ClassNotFoundException:   ccinfw.MainApplication</p> </blockquote>  <p>I have added information below. Why am I getting this error and how can I fix it?</p>  <p>TIA</p>  <p><strong>Manifest File</strong></p>  <pre><code>Manifest-Version: 1.0 Implementation-Title: SpringBootErrorHandlingDemoy Implementation-Version: 0.0.1-SNAPSHOT Archiver-Version: Plexus Archiver Built-By: root Implementation-Vendor-Id: ccinfw Spring-Boot-Version: 1.5.4.RELEASE Implementation-Vendor: Pivotal Software, Inc. Main-Class: org.springframework.boot.loader.JarLauncher Start-Class: ccinfw.MainApplication Spring-Boot-Classes: BOOT-INF/classes/ Spring-Boot-Lib: BOOT-INF/lib/ Created-By: Apache Maven 3.3.9 Build-Jdk: 1.8.0_131 Implementation-URL: http://maven.apache.org </code></pre>  <p><strong>ran jar -xvf BackEndRestFunctionality-0.0.1-SNAPSHOT.jar > expanded. Below is a portion of the output. MainApplication.class does exist in the jar file</strong></p>  <pre><code> [... snip ...]   inflated: BOOT-INF/classes/ccinfw/security/user/ApplicationUser.class  inflated: BOOT-INF/classes/ccinfw/security/security/SecurityConstants.class  inflated: BOOT-INF/classes/ccinfw/security/security/AccountCredentials.class  inflated: BOOT-INF/classes/ccinfw/security/security/WebSecurity.class  inflated: BOOT-INF/classes/ccinfw/security/security/JWTAuthenticationFilter.class  inflated: BOOT-INF/classes/ccinfw/security/security/JWTAuthorizationFilter.class  **inflated: BOOT-INF/classes/ccinfw/MainApplication.class**  inflated: BOOT-INF/classes/ccinfw/dao/MstrgenroletypeDAO.class  inflated: BOOT-INF/classes/application.properties   created: META-INF/maven/   created: META-INF/maven/ccinfw/   created: META-INF/maven/ccinfw/BackEndRestFunctionality/  inflated: META-INF/maven/ccinfw/BackEndRestFunctionality/pom.xml  inflated: META-INF/maven/ccinfw/BackEndRestFunctionality/pom.properties   created: BOOT-INF/lib/ extracted: BOOT-INF/lib/slf4j-api-1.7.25.jar  [... snip ...] </code></pre>  <p><strong>I am using the following software</strong></p>  <pre><code>jenkins-slave-one:/var/jenkins/workspace/build-cc-restapi-dev/target/docker# java -version openjdk version '1.8.0_131' OpenJDK Runtime Environment (build 1.8.0_131-8u131-b11-2ubuntu1.16.04.3-b11) OpenJDK 64-Bit Server VM (build 25.131-b11, mixed mode)  jenkins-slave-one:/var/jenkins/workspace/build-cc-restapi-dev/target/docker# javac -version javac 1.8.0_131  jenkins-slave-one:/var/jenkins/workspace/build-cc-restapi-dev/target/docker# mvn -version Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-10T16:41:47+00:00) Maven home: /opt/maven Java version: 1.8.0_131, vendor: Oracle Corporation Java home: /usr/lib/jvm/java-8-openjdk-amd64/jre Default locale: en_US, platform encoding: UTF-8 OS name: 'linux', version: '4.4.0-87-generic', arch: 'amd64', family: 'unix' </code></pre>  <p><strong>Maven Dependencies</strong></p>  <p><a href='https://i.stack.imgur.com/MziS8.png' rel='noreferrer'><img src='https://i.stack.imgur.com/MziS8.png' alt='enter image description here'></a></p>  <p><strong>I am getting the following error message when starting it:</strong></p>  <pre><code>Exception in thread 'main' java.lang.ClassNotFoundException: ccinfw.MainApplication at java.net.URLClassLoader.findClass(URLClassLoader.java:381) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at org.springframework.boot.loader.LaunchedURLClassLoader.loadClass(LaunchedURLClassLoader.java:94) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:46) at org.springframework.boot.loader.Launcher.launch(Launcher.java:87) at org.springframework.boot.loader.Launcher.launch(Launcher.java:50) at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:51) </code></pre>  <p><strong>the maven command executed within Jenkins</strong></p>  <pre><code>$ /opt/maven/bin/mvn -f /var/jenkins/workspace/build-cc-restapi-dev/pom.xml -Pdevelopment clean package docker:build -B </code></pre>  <p><strong>portion of pom.xml file responsible for building</strong></p>  <p></p>  <pre><code>&lt;profile&gt;     &lt;id&gt;development&lt;/id&gt;     &lt;build&gt;         &lt;plugins&gt;             &lt;plugin&gt;                 &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;                 &lt;executions&gt;                     &lt;execution&gt;                         &lt;phase&gt;test&lt;/phase&gt;                         &lt;goals&gt;                             &lt;goal&gt;run&lt;/goal&gt;                         &lt;/goals&gt;                         &lt;configuration&gt;                             &lt;tasks&gt;                                  &lt;copy                                     file='${project.build.outputDirectory}/application.development.properties'                                     tofile='${project.build.outputDirectory}/application.properties' /&gt;                             &lt;/tasks&gt;                         &lt;/configuration&gt;                     &lt;/execution&gt;                 &lt;/executions&gt;             &lt;/plugin&gt;              &lt;plugin&gt;                 &lt;groupId&gt;com.spotify&lt;/groupId&gt;                 &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;                  &lt;configuration&gt;                     &lt;imageName&gt;apostx-cc-restapi-dev&lt;/imageName&gt;                      &lt;baseImage&gt;java:8&lt;/baseImage&gt;                     &lt;entryPoint&gt;['java', '-jar', '/${project.build.finalName}.jar']&lt;/entryPoint&gt;                     &lt;!-- copy the service's jar file from target into the root directory                          of the image --&gt;                     &lt;resources&gt;                         &lt;resource&gt;                             &lt;targetPath&gt;/&lt;/targetPath&gt;                             &lt;directory&gt;${project.build.directory}&lt;/directory&gt;                             &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;                         &lt;/resource&gt;                     &lt;/resources&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt;              &lt;plugin&gt;                 &lt;!-- Build an executable JAR --&gt;                 &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                 &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;                 &lt;!-- &lt;version&gt;2.6&lt;/version&gt; --&gt;                 &lt;executions&gt;                     &lt;execution&gt;                         &lt;id&gt;analyze&lt;/id&gt;                         &lt;phase&gt;package&lt;/phase&gt;                         &lt;configuration&gt;                             &lt;failBuild&gt;true&lt;/failBuild&gt;                             &lt;ignoreDirect&gt;false&lt;/ignoreDirect&gt;                         &lt;/configuration&gt;                     &lt;/execution&gt;                 &lt;/executions&gt;                 &lt;configuration&gt;                     &lt;archive&gt;                         &lt;manifest&gt;                             &lt;mainClass&gt;ccinfw.MainApplication&lt;/mainClass&gt;                         &lt;/manifest&gt;                     &lt;/archive&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt;              &lt;plugin&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;             &lt;/plugin&gt;         &lt;/plugins&gt;     &lt;/build&gt; &lt;/profile&gt; </code></pre>  <p><strong>the Dockerfile being accessed</strong></p>  <pre><code>FROM java:8 ADD /BackEndRestFunctionality-0.0.1-SNAPSHOT.jar // ENTRYPOINT ['java', '-jar', '/BackEndRestFunctionality-0.0.1-SNAPSHOT.jar'] ~ </code></pre>  <p><strong>Here is a part of the Jenkins log file where the Docker Image file is being built using the generated .jar file - again - the .jar file works fine when ran on its own</strong></p>  <pre><code>[INFO] Copying /var/jenkins/workspace/build-cc-restapi-dev/target/BackEndRestFunctionality-0.0.1-SNAPSHOT.jar -&gt; /var/jenkins/workspace/build-cc-restapi-dev/target/docker/BackEndRestFunctionality-0.0.1-SNAPSHOT.jar [INFO] Building image apostx-cc-restapi-dev Step 1/3 : FROM java:8  ---&gt; d23bdf5b1b1b Step 2/3 : ADD /BackEndRestFunctionality-0.0.1-SNAPSHOT.jar //  ---&gt; abfcb05b4173 Removing intermediate container f573f737009a Step 3/3 : ENTRYPOINT java -jar /BackEndRestFunctionality-0.0.1-SNAPSHOT.jar  ---&gt; Running in 28bb20467e70  ---&gt; 2ffb803f96dc Removing intermediate container 28bb20467e70 ProgressMessage{id=null, status=null, stream=null, error=null, progress=null, progressDetail=null} Successfully built 2ffb803f96dc Successfully tagged apostx-cc-restapi-dev:latest [INFO] Built apostx-cc-restapi-dev [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 30.181 s [INFO] Finished at: 2018-01-30T06:18:18+00:00 [INFO] Final Memory: 36M/95M [INFO] ------------------------------------------------------------------------ </code></pre>  <p><strong>Docker Image Layers</strong></p>  <pre><code>351.5 MB     RUN set -x &amp;&amp; apt-get update &amp;&amp; apt-get install -y openjdk-8-jdk='$JAVA_DEBIAN_VERSION' ca-certificates-java='$CA_CERTIFICATES_JAVA_VERSION' &amp;&amp; rm -rf /var/lib/apt/lists/* &amp;&amp; [ '$JAVA_HOME' = '$(docker-java-home)' ] 123 MB   ADD file:89ecb642d662ee7edbb868340551106d51336c7e589fdaca4111725ec64da957 in / 122.6 MB     RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends bzr git mercurial openssh-client subversion procps &amp;&amp; rm -rf /var/lib/apt/lists/* 44.3 MB      RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends ca-certificates curl wget &amp;&amp; rm -rf /var/lib/apt/lists/* 32.9 MB      ADD file:565dae161b3b516b50d596648650278591d96fe820e36a3eeef0ee7c33d7915d in // 1.3 MB   RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends bzip2 unzip xz-utils &amp;&amp; rm -rf /var/lib/apt/lists/* 418.5 kB     RUN /var/lib/dpkg/info/ca-certificates-java.postinst configure 87 B     RUN { echo '#!/bin/sh'; echo 'set -e'; echo; echo 'dirname '$(dirname '$(readlink -f '$(which javac || which java)')')''; } &gt; /usr/local/bin/docker-java-home &amp;&amp; chmod +x /usr/local/bin/docker-java-home 55 B     RUN echo 'deb http://deb.debian.org/debian jessie-backports main' &gt; /etc/apt/sources.list.d/jessie-backports.list 0 B      CMD ['/bin/bash'] 0 B      ENV LANG=C.UTF-8 0 B      ENV JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64 0 B      ENV JAVA_VERSION=8u111 0 B      ENV JAVA_DEBIAN_VERSION=8u111-b14-2~bpo8+1 0 B      ENV CA_CERTIFICATES_JAVA_VERSION=20140324 0 B      ENTRYPOINT ['java' '-jar' '/BackEndRestFunctionality-0.0.1-SNAPSHOT.jar']  </code></pre> ",
    "OwnerUserId": "2707727",
    "LastEditorUserId": "2707727",
    "LastEditDate": "2018-01-30T14:40:28.553",
    "LastActivityDate": "2023-02-02T20:55:25.743",
    "Title": "getting a java.lang.ClassNotFoundException when starting a Docker container",
    "Tags": "<java><maven><docker>",
    "AnswerCount": "4",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>I found out what the problem was - thank goodness for having a version in Gitlab to refer to (as well as a 'previous' version on another machine)</p>  <p>Basically, I used Maven to put the project together. I executed the following command from Jenkins to build the .jar file</p>  <pre><code>$ /opt/maven/bin/mvn -f /var/jenkins/workspace/build-cc-restapi-dev/pom.xml -Pdevelopment clean package docker:build -B </code></pre>  <p>In the pom.xml file, I did not specify : </p>  <pre><code>&lt;artifactId&gt;&lt;/artifactId&gt; </code></pre>  <p>When I went ahead and set it </p>  <pre><code>ex: &lt;artifactId&gt;stuff&lt;/artifactId&gt;  </code></pre>  <p>Docker started the jar file correctly and everything worked fine.</p> ",
    "highest_rated_answer": "<p>I found out what the problem was - thank goodness for having a version in Gitlab to refer to (as well as a 'previous' version on another machine)</p>  <p>Basically, I used Maven to put the project together.</p>  <p>To build the project, I set up the command below and ran it under Jenkins:</p>  <pre><code>$ /opt/maven/bin/mvn -f /var/jenkins/workspace/build-cc-restapi-dev/pom.xml -Pdevelopment clean package docker:build -B </code></pre>  <p>In the pom.xml file, I did not specify : </p>  <pre><code>&lt;artifactId&gt;&lt;/artifactId&gt; </code></pre>  <p>When I went ahead and set it </p>  <pre><code>ex: &lt;artifactId&gt;stuff&lt;/artifactId&gt;  </code></pre>  <p>Docker started the jar file correctly and everything worked fine.</p>  <p><strong>UPDATE</strong> Need to report items more accurately.</p>  <pre><code>&lt;artifactId&gt;&lt;/artifactId&gt; </code></pre>  <p>was defined. But</p>  <pre><code>&lt;artifactId&gt;stuff&lt;/artifactId&gt; =&gt; worked &lt;artifactId&gt;ccinfieldworkserver&lt;/artifactId&gt; =&gt; worked &lt;artifactId&gt;BackEndRestFunctionality&lt;/artifactId&gt; =&gt; did not work. </code></pre>  <p>TIA</p> "
  },
  {
    "Id": "51540952",
    "PostTypeId": "1",
    "CreationDate": "2018-07-26T14:12:25.923",
    "Score": "6",
    "ViewCount": "1492",
    "Body": "<p>I have a problem accessing <strong>parent.parent.version</strong> from grandchild pom.</p>  <p>Here is the exact description of the problem:</p>  <p>Parent pom:</p>  <pre><code>&lt;groupId&gt;com.parent&lt;/groupId&gt; &lt;artifactId&gt;parent&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.6-SNAPSHOT&lt;/version&gt; . . . &lt;properties&gt;     &lt;child.version&gt;1.3-SNAPSHOT&lt;/child.version&gt; &lt;/properties&gt; </code></pre>  <p>Child pom:</p>  <pre><code>&lt;parent&gt;     &lt;groupId&gt;com.parent&lt;/groupId&gt;     &lt;artifactId&gt;parent&lt;/artifactId&gt;     &lt;version&gt;1.6-SNAPSHOT&lt;/version&gt; &lt;/parent&gt;  &lt;groupId&gt;com.child&lt;/groupId&gt; &lt;artifactId&gt;child&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;${child.version}&lt;/version&gt; </code></pre>  <p>GrandChild pom:</p>  <pre><code>&lt;parent&gt;     &lt;groupId&gt;com.child&lt;/groupId&gt;     &lt;artifactId&gt;child&lt;/artifactId&gt;     &lt;version&gt;${child.version}&lt;/version&gt; &lt;/parent&gt;  &lt;groupId&gt;com.grandchild&lt;/groupId&gt; &lt;artifactId&gt;grandchild&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;${project.parent.version}&lt;/version&gt; . . . &lt;profiles&gt; &lt;plugin&gt;    &lt;groupId&gt;com.spotify&lt;/groupId&gt;    &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;    &lt;version&gt;1.0.0&lt;/version&gt;    &lt;configuration&gt;       &lt;imageName&gt;artifactory:6001/${project.name}:${parent.parent.version}&lt;/imageName&gt;       &lt;serverId&gt;docker&lt;/serverId&gt;       &lt;dockerDirectory&gt;${project.basedir}&lt;/dockerDirectory&gt;       &lt;resources&gt;          &lt;resource&gt;             &lt;targetPath&gt;/&lt;/targetPath&gt;             &lt;directory&gt;${project.build.directory}&lt;/directory&gt;             &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;          &lt;/resource&gt;       &lt;/resources&gt;    &lt;/configuration&gt;    &lt;executions&gt;       &lt;execution&gt;          &lt;phase&gt;package&lt;/phase&gt;          &lt;goals&gt;             &lt;goal&gt;build&lt;/goal&gt;          &lt;/goals&gt;       &lt;/execution&gt;    &lt;/executions&gt; &lt;/plugin&gt; &lt;/profile&gt; </code></pre>  <p>Whenever I build this project, I get below exception:</p>  <blockquote>   <p>Failed to execute goal com.spotify:docker-maven-plugin:1.0.0:build (default) on project grandchild: Exception caught: The template variable 'parent.parent.version' has no value -> [Help 1]</p> </blockquote>  <p>How do I get parent.parent.version(main project version) from grandchild pom. <br/><strong>Docker version should be same as main project version. Thats the goal for me!!!</strong></p> ",
    "OwnerUserId": "5270186",
    "LastActivityDate": "2018-07-26T14:12:25.923",
    "Title": "Maven 3: Accessing parent.parent.version from grandchild pom",
    "Tags": "<java><maven><pom.xml><parent-pom><docker-maven-plugin>",
    "AnswerCount": "0",
    "CommentCount": "2",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": null
  },
  {
    "Id": "51801388",
    "PostTypeId": "1",
    "CreationDate": "2018-08-11T15:54:50.953",
    "Score": "6",
    "ViewCount": "1760",
    "Body": "<p>I have a <code>maven</code> <code>spring-boot</code> project deployed on appengine that I am building and deploying using Google Cloud Build using the following builder image: <a href='https://github.com/strudeau/mvn-gcloud-builder' rel='nofollow noreferrer'>https://github.com/strudeau/mvn-gcloud-builder</a></p>  <p>When performing a build, most of the time is spent downloading the plugins and dependencies from maven. I would like to be able to mount a persistent volume to this Docker image so as to be able to keep a persistent <code>.M2</code> directory where my plugins and dependencies would be stored to avoid having them downloaded each time I do a build.</p>  <p><code>Google Cloud Filestore</code> would probably be ideal if it weren't for the fact that you have to provision 1TB of data or more which becomes ridiculously expensive for a small non-production profit project.</p>  <ul> <li>Is there a way to mount a bucket as a filesystem on the docker image?</li> <li>Can I mount a <code>Google Persistent Disk</code>?</li> </ul> ",
    "OwnerUserId": "7182586",
    "LastEditorUserId": "8304665",
    "LastEditDate": "2019-08-01T16:11:33.133",
    "LastActivityDate": "2019-08-01T16:11:33.133",
    "Title": "How to connect persistent storage to Google Cloud Build?",
    "Tags": "<maven><docker><google-cloud-storage><google-cloud-build>",
    "AnswerCount": "1",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>You can't mount a bucket into the build, but you can copy your <code>.M2</code> directory out to a bucket at the end of a build, then restore it at the beginning of a subsequent build.</p>  <p>I've lifted the example directly from the <a href='https://cloud.google.com/cloud-build/docs/speeding-up-builds#caching_directories_with_google_cloud_storage' rel='noreferrer'>documentation</a>, in case it disappears.</p>  <pre><code>steps: - name: gcr.io/cloud-builders/gsutil   args: ['cp', 'gs://mybucket/results.zip', 'previous_results.zip'] # operations that use previous_results.zip and produce new_results.zip - name: gcr.io/cloud-builders/gsutil   args: ['cp', 'new_results.zip', 'gs://mybucket/results.zip'] </code></pre>  <p>Watch out when mixing this strategy with concurrent builds.</p> "
  },
  {
    "Id": "52892488",
    "PostTypeId": "1",
    "AcceptedAnswerId": "52942964",
    "CreationDate": "2018-10-19T12:37:00.097",
    "Score": "6",
    "ViewCount": "2290",
    "Body": "<p>I'm trying to build/deploy a spring boot in a docker container.</p>  <pre><code>FROM maven:3.5.3-jdk-8-slim AS build COPY ./pom.xml /app/pom.xml RUN cd /app RUN mvn -f /app/pom.xml -s /usr/share/maven/ref/settings-docker.xml dependency:go-offline dependency:resolve-plugins -B COPY . /app RUN mvn -f /app/pom.xml -s /usr/share/maven/ref/settings-docker.xml --batch-mode package -DskipTests </code></pre>  <p>As you can see, I'm caching all dependencies with the first mvn command so that every change in my code app will not trigger a new bulk of dependencies downloads. It works for most of the dependencies but some are still downloaded (even if cached). This is the log of the second mvn command (package):</p>  <pre><code>[INFO] Scanning for projects... [INFO]  [INFO] ----------------------&lt; xxx:xxx &gt;---------------------- [INFO] Building xxxx 0.0.0 [INFO] --------------------------------[ jar ]--------------------------------- [INFO]  [INFO] --- apt-maven-plugin:1.1.3:process (default) @ vsol-java --- [INFO] Downloading from spring-releases: https://repo.spring.io/libs-release/org/apache/commons/commons-io/1.3.2/commons-io-1.3.2.pom [INFO] Downloaded from spring-releases: https://repo.spring.io/libs-release/org/apache/commons/commons-io/1.3.2/commons-io-1.3.2.pom (0 B at 0 B/s) [INFO] Downloading from spring-releases: https://repo.spring.io/libs-release/commons-io/commons-io/1.3.2/commons-io-1.3.2.pom [INFO] Downloaded from spring-releases: https://repo.spring.io/libs-release/commons-io/commons-io/1.3.2/commons-io-1.3.2.pom (0 B at 0 B/s) [INFO] Downloading from spring-releases: https://repo.spring.io/libs-release/org/apache/commons/commons-parent/3/commons-parent-3.pom [INFO] Downloaded from spring-releases: https://repo.spring.io/libs-release/org/apache/commons/commons-parent/3/commons-parent-3.pom (0 B at 0 B/s) [INFO] Downloading from spring-releases: https://repo.spring.io/libs-release/org/sonatype/plexus/plexus-build-api/0.0.7/plexus-build-api-0.0.7.jar ... </code></pre>  <p>(BTW, the (0 B at 0 B/s) is a little bit strange...just a check?)</p>  <p>If I launch a container based on the step after the first maven command (mvn dependency:...) (the one that should cached all dependencies) </p>  <pre><code>root@3281a837a236:/usr/share/maven/ref/repository# ls -lh org/codehaus/plexus/plexus-utils/1.5.15 total 244K -rw-r--r-- 1 root root  202 Oct 19 12:07 _remote.repositories -rw-r--r-- 1 root root 223K Oct 19 12:07 plexus-utils-1.5.15.jar -rw-r--r-- 1 root root   40 Oct 19 12:07 plexus-utils-1.5.15.jar.sha1 -rw-r--r-- 1 root root 6.7K Oct 19 12:07 plexus-utils-1.5.15.pom -rw-r--r-- 1 root root   40 Oct 19 12:07 plexus-utils-1.5.15.pom.sha1 </code></pre>  <p>The lib seems to be there but, I can see this in the log from mvn package:</p>  <p>[INFO] Downloading from spring-releases: <a href='https://repo.spring.io/libs-release/org/codehaus/plexus/plexus-utils/1.5.15/plexus-utils-1.5.15.jar' rel='noreferrer'>https://repo.spring.io/libs-release/org/codehaus/plexus/plexus-utils/1.5.15/plexus-utils-1.5.15.jar</a></p>  <p>If I run mvn package in offline mode, it fails because it can't reach <a href='https://repo.spring.io/libs-release' rel='noreferrer'>https://repo.spring.io/libs-release</a>.</p>  <p>So it looks like it is cached but maven still try to download this file. I've tried this in my pom.xml</p>  <pre><code>        &lt;pluginRepository&gt;             &lt;id&gt;spring-releases&lt;/id&gt;             &lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt;             &lt;snapshots&gt;                 &lt;enabled&gt;true&lt;/enabled&gt;                 &lt;updatePolicy&gt;never&lt;/updatePolicy&gt;             &lt;/snapshots&gt;             &lt;releases&gt;                 &lt;enabled&gt;true&lt;/enabled&gt;                 &lt;updatePolicy&gt;never&lt;/updatePolicy&gt;             &lt;/releases&gt;         &lt;/pluginRepository&gt; </code></pre>  <p>But no effect.</p>  <p>Any idea? Thanks!</p> ",
    "OwnerUserId": "2813807",
    "LastEditorUserId": "2813807",
    "LastEditDate": "2018-10-19T12:43:47.393",
    "LastActivityDate": "2018-10-23T06:59:56.110",
    "Title": "Maven/Docker: cache all dependencies",
    "Tags": "<maven><docker><spring-boot>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>I finally find the solution by using go-offline-maven-plugin.</p>  <pre><code>         &lt;plugin&gt;             &lt;groupId&gt;de.qaware.maven&lt;/groupId&gt;             &lt;artifactId&gt;go-offline-maven-plugin&lt;/artifactId&gt;             &lt;version&gt;1.0.0&lt;/version&gt;             &lt;configuration&gt;                 &lt;dynamicDependencies&gt;                     &lt;DynamicDependency&gt;                         &lt;groupId&gt;org.apache.maven.surefire&lt;/groupId&gt;                         &lt;artifactId&gt;surefire-junit4&lt;/artifactId&gt;                         &lt;version&gt;2.20.1&lt;/version&gt;                         &lt;repositoryType&gt;PLUGIN&lt;/repositoryType&gt;                     &lt;/DynamicDependency&gt;                 &lt;/dynamicDependencies&gt;             &lt;/configuration&gt;         &lt;/plugin&gt; </code></pre>  <p>And trying to get all dependencies using:</p>  <pre><code>mvn de.qaware.maven:go-offline-maven-plugin:resolve-dependencies </code></pre> ",
    "highest_rated_answer": null
  },
  {
    "Id": "55956323",
    "PostTypeId": "1",
    "CreationDate": "2019-05-02T16:06:09.590",
    "Score": "6",
    "ViewCount": "6646",
    "Body": "<p>How does the config file provider plugin work?</p>  <p>I have a Jenkinsfile for a declarative pipeline (multi-branch build) that contains:</p>  <pre><code>configFileProvider([configFile(fileId: 'maven-settings', variable: 'MAVEN_SETTINGS')]) {     sh 'mvn -B -s $MAVEN_SETTINGS -DWHERE='$WHERE' deploy' } </code></pre>  <p>I have tried running this on two different Jenkins installations one which is installed directly and runs as daemon and another running as a container (jenkinsci/blueocean).</p>  <p>When run on the direct the Jenkins Config File Provider plugin is able to provide the required settings.</p>  <pre><code>provisioning config files... copy managed file [Maven settings] to file:/var/lib/jenkins/workspace/redacted@tmp/config8989354118161621860tmp </code></pre>  <p>When run under the jenkinsci/blueocean container it fails with:</p>  <pre><code>provisioning config files... not able to provide the file [ManagedFile: id=maven-settings, targetLocation=null, variable=MAVEN_SETTINGS], can't be resolved by any provider - maybe it got deleted by an administrator </code></pre>  <p>I have created a managed maven-settings.xml file with id maven-settings for blue/ocean but it is not being picked up. I've also tried copying it to ~/.m2/settings.xml</p>  <p>By contrast the working installation does not have any managed files (settings.xml or otherwise) and I am unable to locate any maven settings file in the workspace. I'm not sure what the @tmp directory is. It is deleted by the time a build finishes.</p>  <p>So my question is:</p>  <p><strong>Where should I put the settings to make the configFileProvider pass them on for the jenkinsci/blueocean build job?</strong> </p>  <p>How does the config file provider plugin work?</p>  <p>I have no idea what its doing so its hard to debug. The source is <a href='https://github.com/jenkinsci/config-file-provider-plugin' rel='nofollow noreferrer'>here</a> but Java, Maven &amp; Jenkins are not my main area.</p>  <p>What differences are there when Jenkins itself run as a container?</p>  <p><a href='https://stackoverflow.com/a/43796714/1569204'>This answer</a> suggests the the config file provider is unnecessary.</p>  <p>There is a <a href='https://stackoverflow.com/questions/41110028/how-do-you-provide-a-managed-file-to-a-jenkins-build-using-docker-image'>similar question</a> which is unanswered but it relates to a maven plugin.</p> ",
    "OwnerUserId": "1569204",
    "LastEditorUserId": "1569204",
    "LastEditDate": "2019-05-14T15:12:47.327",
    "LastActivityDate": "2022-06-29T13:51:44.290",
    "Title": "How does the Jenkins config file provider plugin work?",
    "Tags": "<maven><docker><jenkins>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>I have part of the answer. My maven-settings file wasn't being picked up because I was using the file name rather than the file <strong>Id</strong> which is different.</p>  <p>The remaining part of the question is how is the original Jenkins instance able to generate this file without it being listed as a managed file.</p> "
  },
  {
    "Id": "57198251",
    "PostTypeId": "1",
    "AcceptedAnswerId": "57199247",
    "CreationDate": "2019-07-25T09:09:08.607",
    "Score": "6",
    "ViewCount": "8780",
    "Body": "<p>i am trying to create a docket container with Java,Maven and Tomcat. </p>  <p>So far, i'm able to create a container with Maven and compile my java code and create the final WAR file.</p>  <p>But i want to <strong>copy this WAR file to a particular folder</strong>(webapp folder of tomcat) of another container which is of Tomcat.</p>  <p>Approach one, Dockerfile</p>  <pre><code>FROM maven:3.6.1-jdk-8 as maven_builder  ENV HOME=/app  WORKDIR $HOME  ADD pom.xml $HOME  RUN ['/usr/local/bin/mvn-entrypoint.sh', 'mvn', 'verify', 'clean', '--fail-never']  ADD . $HOME  RUN ['mvn','clean','install','-T','2C','-DskipTests=true']  FROM tomcat:8.5.43-jdk8  COPY --from=maven_builder $HOME/wc_admin/target/wc-admin.war /usr/local/tomcat/webapps </code></pre>  <p>i tried to simply copy it, but the intermediate container is deleted before copying.</p>  <p>Approach 2,  i am trying to write a YAML for docker-compose and use shared volume concept.</p>  <pre><code>version: '3' services:     maven-build:         build: .         volumes:             - 'myshare:/shared'      tomcat-build:         image: 'tomcat:8.5.43-jdk8'         ports:             - '8080:8080'         volumes:             - 'myshare:/shared'  volumes:   myshare:     driver: local ' </code></pre>  <p>i'm not able to figure out, how do i copy a particular file from one container(i.e maven_build) to another container (i.e tomcat's webapp folder).</p> ",
    "OwnerUserId": "8287269",
    "LastActivityDate": "2019-07-25T09:59:53.253",
    "Title": "Docker with Maven and Tomcat",
    "Tags": "<java><maven><docker><tomcat>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>Your first (multi-stage build) approach is better practice.</p>  <p>In the multi-stage build, every time you have a new <code>FROM</code> command to start a new image, the execution environment resets.  In particular, when the first stage sets a <code>HOME</code> environment variable, that gets reset in the second stage, so the final <code>COPY</code> command is copying out of <code>/wc_admin/...</code> and not the directory where the application got built.</p>  <p>It's typical to treat Docker filesystem layouts as fixed, and to not set variables like <code>HOME</code> that are meaningful in other contexts but not really in Docker.  I'd just hard-code <code>/app</code> throughout:</p>  <pre><code>FROM maven:3.6.1-jdk-8 as maven_builder WORKDIR /app ADD pom.xml . ... FROM tomcat:8.5.43-jdk8 COPY --from=maven_builder /app/wc_admin/target/wc-admin.war /usr/local/tomcat/webapps </code></pre>  <p>The volumes approach has two big problems.  People try to take advantage of Docker populating a named volume with content from the image, but this only works the first time you run it.  If you rebuild the image, Docker refuses to touch the volume (it has important user data that must be preserved, that's what volumes are for) and so your volume will keep your old <code>.war</code> file.  If you'll ever run your application in Kubernetes, it will not auto-populate volumes from images and you'll need to do more work to make a volumes-for-sharing setup work.</p> ",
    "highest_rated_answer": "<p>Your first attempt is almost correct, minus one issue. Environmental variables are local for the context of the container. <strong>They are not inherited among build stages.</strong></p>  <p>In this snippet</p>  <pre><code>FROM tomcat:8.5.43-jdk8  COPY --from=maven_builder $HOME/wc_admin/target/wc-admin.war /usr/local/tomcat/webapps </code></pre>  <p><code>tomcat</code> image knows nothing about <code>$HOME</code> environmental variable of maven image</p>  <pre><code>FROM maven:3.6.1-jdk-8 as maven_builder  ENV HOME=/app </code></pre>  <p>thus it uses its own <code>$HOME</code> envar.</p>  <p>Try this:</p>  <p><code>COPY --from=maven_builder /app/wc_admin/target/wc-admin.war /usr/local/tomcat/webapps</code></p> "
  },
  {
    "Id": "57366246",
    "PostTypeId": "1",
    "AcceptedAnswerId": "57366462",
    "CreationDate": "2019-08-05T21:22:24.043",
    "Score": "6",
    "ViewCount": "5998",
    "Body": "<p>I\u2019m trying to build a Docker image from my DockerFile but  keep getting an error like it can't find the parent <code>pom.xml</code> to perform a maven command in the docker file and build the project. Ive been looking around and you see what people do is the add to the child <code>pom.xml</code> a reference to the parent pom.xml y tried adding a <code>relativePath&gt;.. /pom.xml/relativePath&gt;</code> to the child but still won't work.</p>  <h2>Maven-multimodule project</h2>  <p>[<img src='https://i.stack.imgur.com/koK4I.png' alt='project structure[1]'></p>  <h2>DockerFile</h2>  <pre><code>FROM alpine/git as clone WORKDIR /app RUN git clone https://github.com/RicardoVargasLeslie/manager.git  FROM openjdk:8-jdk-alpine as build WORKDIR /workspace/app  COPY mvnw . COPY .mvn .mvn COPY pom.xml . COPY src src  RUN ./mvnw install -DskipTests  ENTRYPOINT ['java','-jar','/Web-0.0.1-SNAPSHOT.jar'] </code></pre>  <h2>Child-pom.xml(Web)</h2>  <pre><code>&lt;project xmlns='http://maven.apache.org/POM/4.0.0'     xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'     xsi:schemaLocation='http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd'&gt;     &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;     &lt;parent&gt;         &lt;groupId&gt;com.imricki.manager&lt;/groupId&gt;         &lt;artifactId&gt;core&lt;/artifactId&gt;         &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;         &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt;     &lt;/parent&gt;     &lt;artifactId&gt;Web&lt;/artifactId&gt;     &lt;name&gt;Web&lt;/name&gt;     &lt;description&gt;Web Module&lt;/description&gt; </code></pre>  <h2>Parent-pom.xml(Core)</h2>  <pre><code>&lt;?xml version='1.0' encoding='UTF-8'?&gt; &lt;project xmlns='http://maven.apache.org/POM/4.0.0'     xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'     xsi:schemaLocation='http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd'&gt;     &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;     &lt;parent&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;         &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;         &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt;     &lt;/parent&gt;     &lt;groupId&gt;com.imricki.manager&lt;/groupId&gt;     &lt;artifactId&gt;core&lt;/artifactId&gt;     &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;     &lt;name&gt;Core&lt;/name&gt;     &lt;description&gt;Core Module&lt;/description&gt;     &lt;packaging&gt;pom&lt;/packaging&gt; </code></pre>  <h3>Docker comand to build image</h3>  <pre><code>docker build -t rest-api . </code></pre>  <h2>Comand-line Trace</h2>  <pre><code>$ docker build -t rest-api . Sending build context to Docker daemon  42.92MB Step 1/11 : FROM alpine/git as clone  ---&gt; a1d22e4b51ad Step 2/11 : WORKDIR /app  ---&gt; Using cache  ---&gt; e53f5b4941b5 Step 3/11 : RUN git clone https://github.com/RicardoVargasLeslie/manager.git  ---&gt; Using cache  ---&gt; 490b2afea22c Step 4/11 : FROM openjdk:8-jdk-alpine as build  ---&gt; a3562aa0b991 Step 5/11 : WORKDIR /workspace/app  ---&gt; Using cache  ---&gt; 0b7c106319e9 Step 6/11 : COPY mvnw .  ---&gt; Using cache  ---&gt; 2c7ab0b79d25 Step 7/11 : COPY .mvn .mvn  ---&gt; Using cache  ---&gt; eb9ec36b737a Step 8/11 : COPY pom.xml .  ---&gt; Using cache  ---&gt; 2296a5fbd6ae Step 9/11 : COPY src src  ---&gt; Using cache  ---&gt; 022a609f4376 Step 10/11 : RUN ./mvnw install -DskipTests  ---&gt; Running in 897cff2e3c3b [INFO] Scanning for projects... [ERROR] [ERROR] Some problems were encountered while processing the POMs: [FATAL] Non-resolvable parent POM for com.imricki.manager:Web:[unknown-version]: Could not find artifact com.imricki.manager:core:pom:0.0.1-SNAPSHOT and 'parent.relativePath' points at wrong local POM @ line 5, column 10  @ [ERROR] The build could not read 1 project -&gt; [Help 1] [ERROR] [ERROR]   The project com.imricki.manager:Web:[unknown-version] (/workspace/app/pom.xml) has 1 error [ERROR]     Non-resolvable parent POM for com.imricki.manager:Web:[unknown-version]: Could not find artifact com.imricki.manager:core:pom:0.0.1-SNAPSHOT and 'parent.relativePath' points at wrong local POM @ line 5, column 10 -&gt; [Help 2] [ERROR] [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch. [ERROR] Re-run Maven using the -X switch to enable full debug logging. [ERROR] [ERROR] For more information about the errors and possible solutions, please read the following articles: [ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/ProjectBuildingException [ERROR] [Help 2] http://cwiki.apache.org/confluence/display/MAVEN/UnresolvableModelException The command '/bin/sh -c ./mvnw install -DskipTests' returned a non-zero code: 1 </code></pre>  <p>I\u2019m  not sure what wron or how to make the build work,thanks for any help.</p> ",
    "OwnerUserId": "4814583",
    "LastActivityDate": "2023-07-04T07:32:10.747",
    "Title": "Non-resolvable parent POM on Docker Build",
    "Tags": "<java><maven><spring-boot><docker><pom.xml>",
    "AnswerCount": "2",
    "CommentCount": "4",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>Maven is a tool that enables a declarative way of managing your project's dependencies. It does that by standardising the way jar and pom files (artifacts) are shared by projects and uses maven coordinates to declare a project dependency (groupId, artifactId and version) which are then looked up in a large public maven repository of jar and pom files called Maven Central.</p>  <p>In order to have your jar/pom files (like your core for example) managed as a maven artifact, you need to deploy your artifact to either the Maven Central (public repository accessible by anyone) or a private repository some where in your private network (or even on the internet, and maybe with authentication). In the case of a private repository, you need to include the you private repository so that your maven execution not only looks for artifacts in Maven Central, but also in your private repository. You can achieve this by adding the following to your <code>settings.xml</code> file:</p>  <pre class='lang-xml prettyprint-override'><code>&lt;!-- Authentication here --&gt; &lt;servers&gt;   &lt;server&gt;       &lt;id&gt;nexus&lt;/id&gt;       &lt;username&gt;some_username&lt;/username&gt;       &lt;password&gt;some_passowrd&lt;/password&gt;     &lt;/server&gt; &lt;/servers&gt; ...  &lt;profiles&gt;     &lt;profile&gt;       &lt;id&gt;nexus&lt;/id&gt;       &lt;!--Override the repository (and pluginRepository) 'central' from the    Maven Super POM --&gt;       &lt;repositories&gt;         &lt;repository&gt;           &lt;id&gt;nexus-release&lt;/id&gt;           &lt;name&gt;nexus-release&lt;/name&gt;           &lt;url&gt;http://hostname_or_ip_address/content/repositories/releases&lt;/url&gt;         &lt;/repository&gt;         &lt;repository&gt;           &lt;id&gt;nexus-thirdparty&lt;/id&gt;           &lt;name&gt;nexus-thirdparty&lt;/name&gt;           &lt;url&gt;http://hostname_or_ip_address/content/repositories/thirdparty&lt;/url&gt;         &lt;/repository&gt;       &lt;/repositories&gt;       &lt;pluginRepositories&gt;         &lt;pluginRepository&gt;           &lt;id&gt;nexus-plugin-release&lt;/id&gt;           &lt;name&gt;nexus-plugin-release&lt;/name&gt;           &lt;url&gt;http://hostname_or_ip_address/content/repositories/releases/&lt;/url&gt;         &lt;/pluginRepository&gt;         &lt;pluginRepository&gt;           &lt;id&gt;nexus-plugin-third-party&lt;/id&gt;           &lt;name&gt;nexus-plugin-third-party&lt;/name&gt;           &lt;url&gt;http://hostname_or_ip_address/content/repositories/thirdparty/&lt;/url&gt;         &lt;/pluginRepository&gt;       &lt;/pluginRepositories&gt;     &lt;/profile&gt;   &lt;/profiles&gt; ... </code></pre>  <p>I noticed your child <code>pom.xml</code> file references a custom parent module. You need to make sure that your parent module is in a maven repository (Nexus/Artifactory) and that you supply a <code>settings.xml</code> file with the repository settings for the Docker container to be able to pull the parent pom.</p> ",
    "highest_rated_answer": "<p>In my case i was getting this due to the fact that apparently the Dockerfile instructions as copy can not see the parent folders !</p> <p>meaning if you have a structure :</p> <pre><code>ParentProject |  --&gt; Child Module A  --&gt; pom.xml --&gt; DockerFile |  --&gt; Child Module B   --&gt; pom.xml --&gt; DockerFile | -&gt; pom.xml </code></pre> <p>the Dockerfiles inside the modules can't perform actions like :</p> <pre><code>COPY ../pom.xml / </code></pre> <p>because it can't access localSystem &quot;..&quot; !! the solution was to move the Dockerfiles to the parent folder like this :</p> <pre><code>ParentProject |  --&gt; Child Module A  --&gt; pom.xml |  --&gt; Child Module B   --&gt; pom.xml | --&gt; DockerFileA --&gt; DockerFileB -&gt; pom.xml </code></pre> <p>and then i was just doing something like this :</p> <pre><code>WORKDIR /app  COPY ./pom.xml /app  COPY ./ChildA/pom.xml /app/child-project/ </code></pre> <p>It took me tons of times to figure this out, i needed to create a container just with COPY instructions without running maven , and then i drilled into the container files and found that the pom parent was not copied and actually somehow the docker copied the child pom as the parent pom for this instruction :</p> <pre><code>COPY ../pom.xml / </code></pre> <p>so you should know that when building docker , you can't copy files from parent folders in your localMachine since it does not have access to it. and it will execute the same command on the current folder, which makes it really hard to detect since no error is thrown upon it scenario.</p> "
  },
  {
    "Id": "63433361",
    "PostTypeId": "1",
    "CreationDate": "2020-08-16T05:06:51.137",
    "Score": "6",
    "ViewCount": "3549",
    "Body": "<p>I made a Java project which uses an own library, which is installed in my local m2 repository. Now, I'm trying to create a Docker image that generates the jar in a build stage. It fails because it can't resolve dependencies for project of my own library. Is there any way to tell maven (from container) to use my local m2 repository (outside container) so it could resolve my library dependency when I run <code>mvn package</code>?</p> ",
    "OwnerUserId": "6716090",
    "LastActivityDate": "2023-02-13T12:04:27.693",
    "Title": "Use local m2 repository in docker build stage",
    "Tags": "<java><docker><maven><dependencies>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Simple answer - you can't, because there is no way to mount a volume for <code>docker build</code> command.</p> <p>I'm assuming your end goal is a Docker image that runs contains your project's built jar or war.</p> <p>To accomplish that you need two Dockerfiles - one that can be used to create a container that will build your project and exit and a second one that will describe the image that you actually want - one that can be used to create a container that runs your project.</p> <p>There is a nice article describing how to create and use the first one <a href='https://dzone.com/articles/maven-build-local-project-with-docker-why' rel='nofollow noreferrer'>here</a>. As for the second one, that depends on whether your project builds as jar or a war and how it needs to be started/deployed.</p> "
  },
  {
    "Id": "63492180",
    "PostTypeId": "1",
    "CreationDate": "2020-08-19T17:33:30.387",
    "Score": "6",
    "ViewCount": "1459",
    "Body": "<p>I am trying to build a docker image for my basic Spring Boot application using the spring-boot-maven-plugin:build-image goal.</p> <p>It fails with the below error:</p> <pre><code>[ERROR] Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:2.4.0-M2:build-image (default-cli) on project spring-docker: Execution default-cli of goal org.springframework.boot:spring-boot-maven-plugin:2.4.0-M2:build-image failed: **Docker API call to 'localhost/v1.24/containers/eaaba1e2a727547ae53df3c1f7c4420ba821914b4392ea12ff47326ee03eeaa5/start' failed with status code 400 &quot;Bad Request&quot;** -&gt; [Help 1] </code></pre> <p>I have tried with both <strong>Spring Boot 2.3.3.RELEASE</strong> as well as <strong>2.4.0-M2</strong> and I get the same error.</p> <p>I have Docker Desktop running on a Windows 10 machine.</p> <p><code>$ docker version</code></p> <pre><code>**Client: Docker Engine - Community  Version:           19.03.12  API version:       1.40**  Go version:        go1.13.10  Git commit:        48a66213fe  Built:             Mon Jun 22 15:43:18 2020  OS/Arch:           windows/amd64  Experimental:      false  **Server: Docker Engine - Community  Engine:   Version:          19.03.12   API version:      1.40 (minimum version 1.12)**   Go version:       go1.13.10   Git commit:       48a66213fe   Built:            Mon Jun 22 15:49:27 2020   OS/Arch:          linux/amd64   Experimental:     false  containerd:   Version:          v1.2.13   GitCommit:        7ad184331fa3e55e52b890ea95e65ba581ae3429  runc:   Version:          1.0.0-rc10   GitCommit:        dc9208a3303feef5b3839f4323d9beb36df0a9dd  docker-init:   Version:          0.18.0   GitCommit:        fec3683 </code></pre> <p>Full stack trace:</p> <pre><code>[ERROR] Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:2.4.0-M2:build-image (default-cli) on project spring-docker: Execution default-cli of goal org.springframework.boot:spring-boot-maven-plugin:2.4.0-M2:build-image failed: Docker API call to 'localhost/v1.24/containers/cbdb316cb8cb0fbdf641bc7347f56701429d7a887fb240768e8710d36ca5f836/start' failed with status code 400 &quot;Bad Request&quot; -&gt; [Help 1] org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:2.4.0-M2:build-image (default-cli) on project spring-docker: Execution default-cli of goal org.springframework.boot:spring-boot-maven-plugin:2.4.0-M2:build-image failed: Docker API call to 'localhost/v1.24/containers/cbdb316cb8cb0fbdf641bc7347f56701429d7a887fb240768e8710d36ca5f836/start' failed with status code 400 &quot;Bad Request&quot;     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:215)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)     at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)     at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)     at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)     at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)     at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)     at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)     at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)     at jdk.internal.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)     at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke (Method.java:566)     at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:289)     at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:229)     at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:415)     at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:356) Caused by: org.apache.maven.plugin.PluginExecutionException: Execution default-cli of goal org.springframework.boot:spring-boot-maven-plugin:2.4.0-M2:build-image failed: Docker API call to 'localhost/v1.24/containers/cbdb316cb8cb0fbdf641bc7347f56701429d7a887fb240768e8710d36ca5f836/start' failed with status code 400 &quot;Bad Request&quot;     at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:148)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)     at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)     at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)     at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)     at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)     at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)     at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)     at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)     at jdk.internal.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)     at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke (Method.java:566)     at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:289)     at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:229)     at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:415)     at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:356) Caused by: org.springframework.boot.buildpack.platform.docker.transport.DockerEngineException: Docker API call to 'localhost/v1.24/containers/cbdb316cb8cb0fbdf641bc7347f56701429d7a887fb240768e8710d36ca5f836/start' failed with status code 400 &quot;Bad Request&quot;     at org.springframework.boot.buildpack.platform.docker.transport.HttpClientTransport.execute (HttpClientTransport.java:136)     at org.springframework.boot.buildpack.platform.docker.transport.HttpClientTransport.post (HttpClientTransport.java:82)     at org.springframework.boot.buildpack.platform.docker.DockerApi$ContainerApi.start (DockerApi.java:264)     at org.springframework.boot.buildpack.platform.build.Lifecycle.run (Lifecycle.java:148)     at org.springframework.boot.buildpack.platform.build.Lifecycle.execute (Lifecycle.java:113)     at org.springframework.boot.buildpack.platform.build.Builder.executeLifecycle (Builder.java:133)     at org.springframework.boot.buildpack.platform.build.Builder.build (Builder.java:72)     at org.springframework.boot.maven.BuildImageMojo.buildImage (BuildImageMojo.java:152)     at org.springframework.boot.maven.BuildImageMojo.execute (BuildImageMojo.java:144)     at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)     at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)     at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)     at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)     at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)     at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)     at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)     at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)     at jdk.internal.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)     at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke (Method.java:566)     at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:289)     at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:229)     at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:415)     at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:356) </code></pre> ",
    "OwnerUserId": "11447153",
    "LastEditorUserId": "3630528",
    "LastEditDate": "2020-08-19T20:34:08.647",
    "LastActivityDate": "2020-08-19T22:25:05.167",
    "Title": "spring-boot-maven-plugin:build-image fails with 400 Bad Request",
    "Tags": "<spring-boot><docker><maven>",
    "AnswerCount": "1",
    "CommentCount": "6",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Doing</p> <p>docker volume prune</p> <p>was resolved my issue.</p> "
  },
  {
    "Id": "64104769",
    "PostTypeId": "1",
    "AcceptedAnswerId": "64108998",
    "CreationDate": "2020-09-28T15:04:21.723",
    "Score": "6",
    "ViewCount": "3074",
    "Body": "<p>For the past few months I have been experimenting with docker and have enjoyed the benefits of building and running java applications inside containers.</p> <p>A few weeks ago I stumbled upon the <a href='https://github.com/GoogleContainerTools/jib' rel='noreferrer'>jib maven plugin</a> and noticed that jib can build images to docker registries <strong>without using a docker daemon</strong>.</p> <p>After adding jib to one of my projects and running <code>mvn clean install jib:build</code>(on a VM which doesn't have docker installed), I was surprised that jib actually built and pushed an image containing my project to a remote registry.</p> <p>Out of curiosity, I went online to read more about how jib builds and pushes docker images without having docker installed but found little to no information on the subject. I managed to find an <a href='https://www.projectatomic.io/blog/2018/03/the-many-ways-to-build-oci-images/' rel='noreferrer'>article</a> which explains a few ways of creating images without using docker and also tried to understand how the maven goal <code>jib:build</code> works by reading it's <a href='https://github.com/GoogleContainerTools/jib/blob/master/jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/BuildImageMojo.java' rel='noreferrer' title='https://github.com/GoogleContainerTools/jib/blob/master/jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/BuildImageMojo.java'>source code</a> but neither of the two gave me any insights on what's happening behind the sceneces when you run <code>jib:build</code>.</p> <p>I would greatly appreciate if someone shares more about the jib maven plugin and how it actually builds and pushes an image behind the scenes without using a docker daemon.</p> ",
    "OwnerUserId": "6749813",
    "LastActivityDate": "2023-03-03T13:18:22.590",
    "Title": "How does the Jib maven plugin build images without using a docker daemon?",
    "Tags": "<java><docker><maven><jib><maven-jib>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>(Jib dev here. I will very lightly touch on the subject at a very high level and only conceptually. Keep in mind that the following covers only one aspect of image building.)</p> <p>Conceptually the anatomy of a container image is remarkably simple; it's just a collection of tarballs, plus some metadata about the image (about two JSON files). You'll get that if you untar some tarballs in an orderly fashion (<a href='https://en.wikipedia.org/wiki/Union_mount' rel='nofollow noreferrer'>union mounting</a>, to be specific), you are left with some files and directories; these are basically the filesystem contents of an image you'll get and see at runtime. Throw in a couple small JSON files in the scene for some metadata about the image (for example, environment variables at runtime, image entrypoint, which tarballs this image is composed of, etc.), and you already have a container image in your hands. Then, you communicate with a container registry via the <a href='https://docs.docker.com/registry/spec/api/' rel='nofollow noreferrer'>Docker Registry API</a> (i.e., sending and receiving HTTP requests and responses) to upload those tarballs (after compression) and JSON files, and voila! You built and pushed an image to a registry.</p> <p>So, yes, you can create those tarballs using the good old <code>tar</code> on the command-line (these tarballs are called &quot;image layers&quot;), create some JSON files with a text editor, and upload them to a registry using <code>curl</code>. I've done that before. Of course, in order for any container runtime to be able to actually run such an image, your tarballs may need to include some minimally required skeleton files and directories to correctly function, for example, as a Linux system (not a lot actually). But still, there's no restriction in the contents of tarballs; they don't even have to be a valid tar archive. (Yes, you can abuse a container registry to upload any garbage data. For example, <a href='https://github.com/chanseokoh/docker-hub-upload-speed-test#uploading-using-curl-with-bash' rel='nofollow noreferrer'>this shell script</a> uploads 40MB of random bytes to Docker Hub.) And you can still claim with the JSON metadata files that your (completely broken) &quot;image&quot; is composed of these garbage BLObs. (Of course, such an image will fail to run at runtime.)</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "72277087",
    "PostTypeId": "1",
    "CreationDate": "2022-05-17T15:49:14.753",
    "Score": "6",
    "ViewCount": "12528",
    "Body": "<p>I am on windows and this is the plugin configuration:</p> <pre><code>&lt;plugin&gt;     &lt;groupId&gt;com.google.cloud.tools&lt;/groupId&gt;     &lt;artifactId&gt;jib-maven-plugin&lt;/artifactId&gt;     &lt;version&gt;3.2.1&lt;/version&gt;     &lt;configuration&gt;         &lt;container&gt;             &lt;ports&gt;                 &lt;port&gt;8080&lt;/port&gt;             &lt;/ports&gt;             &lt;format&gt;OCI&lt;/format&gt;         &lt;/container&gt;     &lt;/configuration&gt; &lt;/plugin&gt; </code></pre> <p>This is the command I run:</p> <pre><code>.\\mvnw clean install jib:dockerBuild -Dimage=fullstack:v1 </code></pre> <p>This is the error I keep getting no matter what I do:</p> <pre><code>[ERROR] Failed to execute goal com.google.cloud.tools:jib-maven-plugin:3.2.1:dockerBuild (default-cli) on project SpringBootFullStack: Build  to Docker daemon failed, perhaps you should make sure your credentials for 'registry-1.docker.io/library/eclipse-temurin' are set up correc tly. See https://github.com/GoogleContainerTools/jib/blob/master/docs/faq.md#what-should-i-do-when-the-registry-responds-with-unauthorized f or help: Unauthorized for registry-1.docker.io/library/eclipse-temurin: 401 Unauthorized [ERROR] {&quot;details&quot;:&quot;incorrect username or password&quot;} [ERROR] -&gt; [Help 1] [ERROR] [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch. [ERROR] Re-run Maven using the -X switch to enable full debug logging. [ERROR] [ERROR] For more information about the errors and possible solutions, please read the following articles: [ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException </code></pre> <p>How should I go about it? I've read the documentation on jib github repo on authenticating but I don't really understand how to procede and feel overwhelmed</p> <p>UPDATE</p> <p>I ran <code>docker login</code> and I get:</p> <pre><code>Authenticating with existing credentials... Login Succeeded </code></pre> <p>but the error persists (and I figured I didn't include some part of the logging maybe:</p> <pre><code>[INFO] Using credentials from Docker config (C:\\Users\\david\\.docker\\config.json) for openjdk:17 [INFO] Executing tasks:                                [INFO] [============                  ] 40.0% complete [INFO] &gt; building image to Docker daemon               [INFO]                                                 [INFO] ------------------------------------------------------------------------ [INFO] BUILD FAILURE [INFO] ------------------------------------------------------------------------ [INFO] Total time:  2.964 s [INFO] Finished at: 2022-05-17T19:39:12+02:00 [INFO] ------------------------------------------------------------------------ [ERROR] Failed to execute goal com.google.cloud.tools:jib-maven-plugin:3.2.1:dockerBuild (default-cli) on project SpringBootFullStack: Build  to Docker daemon failed, perhaps you should make sure your credentials for 'registry-1.docker.io/library/openjdk' are set up correctly. See  Unauthorized for registry-1.docker.io/library/openjdk: 401 Unauthorized [ERROR] {&quot;details&quot;:&quot;incorrect username or password&quot;} [ERROR] -&gt; [Help 1] [ERROR] [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch. [ERROR] Re-run Maven using the -X switch to enable full debug logging. [ERROR] [ERROR] For more information about the errors and possible solutions, please read the following articles: [ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException </code></pre> <p>UPDATE 2</p> <p>this is also the content of the file logs refer to in order to get username and password:</p> <pre><code>{     &quot;auths&quot;: {         &quot;https://index.docker.io/v1/&quot;: {}     },     &quot;credsStore&quot;: &quot;desktop&quot; } </code></pre> <p>UPDATE 3</p> <p>After two days of trying I decided to look for something else that would do the same job: <a href='https://spring.io/guides/gs/spring-boot-docker/' rel='noreferrer'>https://spring.io/guides/gs/spring-boot-docker/</a> And with this the job was done in ~10 minutes. Life really is crazy</p> ",
    "OwnerUserId": "15046825",
    "LastEditorUserId": "15046825",
    "LastEditDate": "2022-05-19T21:14:22.717",
    "LastActivityDate": "2024-01-10T10:42:00.293",
    "Title": "401 Unauthorized when using jib to create docker image",
    "Tags": "<java><docker><maven><jib><maven-jib>",
    "AnswerCount": "11",
    "CommentCount": "6",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Just delete the credsStore property from the docker-config file. You will find the config.json at your user-home dir.</p> <p>the path is: <strong>$USER/.docker/config.json</strong> and suppose the file contains the followings,</p> <pre><code>{   &quot;auths&quot;: {     &quot;https://index.docker.io/v1/&quot;: {}   },   &quot;credsStore&quot;: &quot;desktop&quot; } </code></pre> <p>and now delete the line : &quot;credsStore&quot;: &quot;desktop&quot;</p> <p>So, the file will now contain the following</p> <pre><code>{   &quot;auths&quot;: {     &quot;https://index.docker.io/v1/&quot;: {}   } } </code></pre> "
  },
  {
    "Id": "31696439",
    "PostTypeId": "1",
    "AcceptedAnswerId": "31710204",
    "CreationDate": "2015-07-29T09:28:27.153",
    "Score": "55",
    "ViewCount": "64612",
    "Body": "<p><em>What I want to do is build a docker image for my Java application but the following considerations should be true for most compiled languages.</em></p> <h1>problem</h1> <p>On my build server I want to produce a docker image for my application as the deliverable. For this I have to compile the application using some build tool (typically Gradle, Maven or Ant) and then add the created JAR file to the docker image. As I want the docker image to just execute the JAR file I will of course start from a base image with Java already installed.</p> <h1>There are three ways of doing this:</h1> <h2>let the build tool control the process</h2> <p>In this case my build tool controls the whole process. So it prepares the JAR file and after the JAR is created it calls Docker to create the image. This works as the JAR is created beforehand and Docker can be  oblivious of the build process needed to create the JAR.</p> <p>But my Dockerfile is no longer standalone. It depends on steps to happen outside of Docker for it work. In my Dockerfile I will have a <code>COPY</code> or <code>ADD</code> statement that is supposed to copy the JAR file to the image. This statement will fail when the jar is not created beforehand. So just executing the Dockerfile might not work. This becomes a problem if you want to integrate with services that just build using the present Dockerfile like the auto-build feature on DockerHub.</p> <h2>let Docker control the build</h2> <p>In this case all necessary steps to create the image are added to the Dockerfile so the image can be created by just executing the Docker build.</p> <p>The main problem with this approach is that there is no way to add to a Dockerfile commands that should be executed outside the docker image being created. This means I have to add my source code and my build tools to the docker image and build my JAR file inside the image. This will result in my image being bigger than it has to be due to all the files added that will be unnecessary at runtime. This will also add extra layers to my image.</p> <h3>Edit:</h3> <p>As @adrian-mouat pointed out if I would add the sources, build the application and deleted the sources in one RUN statement I could avoid adding unnecessary files and layers to the Docker image. This would mean creating some insane chained command.</p> <h2>two separate builds</h2> <p>In this case we split our build in two: first we create the JAR file using our build tool and upload it to a repository (Maven or Ivy repository). We then trigger a separate Docker build that just adds the JAR file from the repository.</p> <h1>conclusion</h1> <p>In my opinion the better way would be <em>letting the build tool control the process</em>. This is will result in a clean docker image and as the image is what we want to deliver this is of importance. To avoid having a potentially not working Dockerfile lying around this should be created as part of the build. So no one would accidentally use it to start a broken build.</p> <p>But this will not allow me to integrate with DockerHub.</p> <h1>question</h1> <p>Is there another way I am missing?</p> <h1>update June 2020</h1> <p>In the years since I first created this question a lot of stuff has changed. At this point I would advocate using <a href='https://github.com/GoogleContainerTools/jib' rel='noreferrer'>Googel's JIB Tool</a>. It integrates with the most common Java Build Tools (Maven and Gradle) and allows you to create container directly from your build. This is much more concise than any of the old approaches I considered all these years ago.</p> <h1>update February 2021</h1> <p>I found this blog post and video from James Ward that reflects better what is currently state of the art. <a href='https://cloud.google.com/blog/topics/developers-practitioners/comparing-containerization-methods-buildpacks-jib-and-dockerfile' rel='noreferrer'>https://cloud.google.com/blog/topics/developers-practitioners/comparing-containerization-methods-buildpacks-jib-and-dockerfile</a></p> ",
    "OwnerUserId": "2481404",
    "LastEditorUserId": "2481404",
    "LastEditDate": "2021-02-26T14:01:27.760",
    "LastActivityDate": "2021-02-26T14:01:27.760",
    "Title": "How to build a docker container for a Java application",
    "Tags": "<java><maven><gradle><docker><dockerfile>",
    "AnswerCount": "6",
    "CommentCount": "6",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>The docker registry hub has a <a href='https://registry.hub.docker.com/_/maven/' rel='noreferrer'>Maven image</a> that can be used to create java containers.</p>  <p>Using this approach the build machine does not need to have either Java or Maven pre-installed, Docker controls the entire build process.</p>  <h1>Example</h1>  <pre><code>\u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 pom.xml \u2514\u2500\u2500 src     \u251c\u2500\u2500 main     \u2502\u00a0\u00a0 \u251c\u2500\u2500 java     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 org     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 demo     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u2514\u2500\u2500 App.java     \u2502\u00a0\u00a0 \u2514\u2500\u2500 resources     \u2502\u00a0\u00a0     \u2514\u2500\u2500 log4j.properties     \u2514\u2500\u2500 test         \u2514\u2500\u2500 java             \u2514\u2500\u2500 org                 \u2514\u2500\u2500 demo                     \u2514\u2500\u2500 AppTest.java </code></pre>  <p>Image is built as follows:</p>  <pre><code>docker build -t my-maven . </code></pre>  <p>And run as follows:</p>  <pre><code>$ docker run -it --rm my-maven 0    [main] INFO  org.demo.App  - hello world </code></pre>  <h2>Dockerfile</h2>  <pre><code>FROM maven:3.3-jdk-8-onbuild CMD ['java','-jar','/usr/src/app/target/demo-1.0-SNAPSHOT-jar-with-dependencies.jar'] </code></pre>  <hr>  <h1>Update</h1>  <p>If you wanted to optimize your image to exclude the source you could create a Dockerfile that only includes the built jar:</p>  <pre><code>FROM java:8 ADD target/demo-1.0-SNAPSHOT-jar-with-dependencies.jar /opt/demo/demo-1.0-SNAPSHOT-jar-with-dependencies.jar CMD ['java','-jar','/opt/demo/demo-1.0-SNAPSHOT-jar-with-dependencies.jar'] </code></pre>  <p>And build the image in two steps:</p>  <pre><code>docker run -it --rm -w /opt/maven \\    -v $PWD:/opt/maven \\    -v $HOME/.m2:/root/.m2 \\    maven:3.3-jdk-8 \\    mvn clean install  docker build -t my-app . </code></pre>  <p>__</p>  <h2>Update (2017-07-27)</h2>  <p>Docker now has a <a href='https://docs.docker.com/engine/userguide/eng-image/multistage-build/' rel='noreferrer'>multi-stage build</a> capability. This enables Docker to build an image containing the build tools but only the runtime dependencies. </p>  <p>The following example demonstrates this concept, note how the jar is copied from target directory of the first build phase</p>  <pre><code>FROM maven:3.3-jdk-8-onbuild   FROM java:8 COPY --from=0 /usr/src/app/target/demo-1.0-SNAPSHOT.jar /opt/demo.jar CMD ['java','-jar','/opt/demo.jar'] </code></pre> ",
    "highest_rated_answer": "<blockquote>   <p><strong>Structure of java aplication</strong></p> </blockquote>  <pre><code>Demo \u2514\u2500\u2500 src |    \u251c\u2500\u2500 main |    \u2502   \u251c\u2500\u2500 java |    \u2502   \u2502   \u2514\u2500\u2500 org |    \u2502   \u2502       \u2514\u2500\u2500 demo |    \u2502   \u2502           \u2514\u2500\u2500 App.java |    \u2502   \u2514\u2500\u2500 resources |    \u2502       \u2514\u2500\u2500 application.properties |    \u2514\u2500\u2500 test |         \u2514\u2500\u2500 java |               \u2514\u2500\u2500 org |                   \u2514\u2500\u2500 demo |                         \u2514\u2500\u2500 App.java   \u251c\u2500\u2500\u2500\u2500 Dockerfile \u251c\u2500\u2500\u2500\u2500 pom.xml </code></pre>  <blockquote>   <p><strong>Content of Dockerfile</strong></p> </blockquote>  <pre><code>FROM java:8 EXPOSE 8080 ADD /target/demo.jar demo.jar ENTRYPOINT ['java','-jar','demo.jar'] </code></pre>  <blockquote>   <p><strong>Commands to build and run image</strong></p>      <ul>   <li>Go to the directory of project.Lets say D:/Demo</li>   </ul> </blockquote>  <pre><code>$ cd D/demo $ mvn clean install $ docker build demo . $ docker run -p 8080:8080 -t demo </code></pre>  <blockquote>   <p>Check that container is running or not</p> </blockquote>  <pre><code>$ docker ps </code></pre>  <blockquote>   <p>The output will be</p> </blockquote>  <pre><code>CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS                    NAMES 55c11a464f5a        demo1               'java -jar demo.jar'   21 seconds ago      Up About a minute   0.0.0.0:8080-&gt;8080/tcp   cranky_mayer </code></pre> "
  },
  {
    "Id": "34713722",
    "PostTypeId": "1",
    "AcceptedAnswerId": "34715019",
    "CreationDate": "2016-01-11T03:21:31.987",
    "Score": "5",
    "ViewCount": "4649",
    "Body": "<p>I am trying to build a docker image using docker-maven plugin, and plan to execute the mvn command using jenkins. I have jenkins.war deployed on a tomcat instance instead of a standalone app, which runs as a non-root user. The problem is that docker needs to be run as root user, so maven commands need to be run as root user, and hence jenkins/tomcat needs to run as root user which is not a good practice (although my non-root-user is also sudoer so I guess won't matter much). </p>  <p>So bottom line, I see two solutions : Either run docker as non-root user (and need help on how to do that)  OR  Need to run jenkins as root (And not sure how to achieve that as I changed environment variable /config and still its not switching to root). </p>  <p>Any advice on which solution to choose and how to implement it ? </p> ",
    "OwnerUserId": "3175401",
    "LastActivityDate": "2019-11-14T11:48:25.180",
    "Title": "Running docker as non-root user OR running jenkins on tomcat as root user",
    "Tags": "<maven><tomcat><jenkins><docker><devops>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<blockquote>   <p>The problem is that docker needs to be run as root user, so maven commands need to be run as root user, </p> </blockquote>  <p>No, a docker run can be done with a <a href='https://docs.docker.com/engine/reference/run/#user' rel='nofollow noreferrer'><code>-u</code> (<code>--user</code>) parameter</a> in order to use a non-root user inside the container.</p>  <blockquote>   <p>Either run docker as non-root user</p> </blockquote>  <p><a href='https://askubuntu.com/a/477554/5470'>Your user (on the host) needs to be part of the <code>docker</code> group</a>. Then you can run the docker service with that user.</p>  <p>As commented, this is not very secure.<br> See:</p>  <ul> <li>'<a href='https://github.com/chrisfosterelli/dockerrootplease' rel='nofollow noreferrer'><code>chrisfosterelli/dockerrootplease</code></a>'</li> <li>'<a href='https://medium.com/@mccode/understanding-how-uid-and-gid-work-in-docker-containers-c37a01d01cf#ce09' rel='nofollow noreferrer'>Understanding how uid and gid work in Docker containers</a>'</li> </ul>  <p>That last links ends with the following findings:</p>  <blockquote>   <ul>   <li>If there\u2019s a known uid that the process inside the container is executing as, it could be as simple as restricting access to the host system so that the uid from the container has limited access.</li>   <li><strong>The better solution is to start containers with a known uid using the<code>--user</code></strong> (you can use a username also, but remember that it\u2019s just a friendlier way of providing a uid from the host\u2019s username system), and <strong>then limiting access to the uid on the host that you\u2019ve decided the container will run as</strong>.</li>   <li>Because of how uids and usernames (and gids and group names) map from a container to the host, specifying the user that a containerized process runs as can make the process appear to be owned by different users inside vs outside the container.</li>   </ul> </blockquote>  <p>Regarding that last point, you now have <strong><a href='https://stackoverflow.com/a/35854547/6309'>user namespace (userns) remapping</a></strong> (since docker 1.10, but I would advice 17.06, because of <a href='https://github.com/moby/moby/issues/33844' rel='nofollow noreferrer'>issue 33844</a>).</p> ",
    "highest_rated_answer": "<p>I am also stuck on how to setup a docker build server.</p>  <p>Here's where I see ground truth right now...</p>  <ul> <li><p>Docker commands require root privileges</p>  <ul> <li>This is because if can run arbitrary docker commands, you have the same powers as root on the host. (You can build a container runnings as root internally, with a filesystem mount to anywhere on the host, thus allowing any root action.)</li> </ul></li> <li><p>The 'docker' group is a big lie IMHO. It's effectively the same as making the members root.</p></li> <li><p>The <strong>only</strong> way I can see to wrap docker with any kind of security for non-root use is to build custom bash scripts to launch very specific docker commands, then to <strong>carefully audit</strong> the security implications of those commands, then add those scripts to the sudoers file (granting passwordless sudo to non-root users).</p></li> </ul>  <p>In the world where we integrate docker into development pipelines (e.g. putting docker commands in Maven builds or allow developers to make arbitrary changes to build definitions for a docker build server), I have idea how you maintain any security.</p> "
  },
  {
    "Id": "36842719",
    "PostTypeId": "1",
    "AcceptedAnswerId": "36843137",
    "CreationDate": "2016-04-25T13:57:12.227",
    "Score": "5",
    "ViewCount": "15830",
    "Body": "<p>I am building a development pipeline. The Docker images will be created automatically after a successful and tested version of my java application be deployed on a <strong>private</strong> Maven repository (Sonatype Nexus).</p>  <p>Once my application is built successfully, I need to publish it in somewhere, and  Docker needs to have access to download it and create a container.</p>  <p>I thought on Docker accessing the Nexus Maven repository, but I did not find how can <code>wget</code> download a jar from a <strong>private repository</strong>. I did not found on Nexus documentation how I can pass authentication parameters to access a private URL. Does anyone know that?</p>  <p>PS: I also accept advice of easier solutions to accomplish this.</p> ",
    "OwnerUserId": "399113",
    "LastEditorUserId": "399113",
    "LastEditDate": "2016-04-26T13:54:45.120",
    "LastActivityDate": "2016-04-26T13:56:43.120",
    "Title": "Docker Automated build downloading private jars from a Maven Sonatype Nexus repository",
    "Tags": "<java><maven><docker><nexus><continuous-deployment>",
    "AnswerCount": "2",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>I just discovered I can do it using cURL. Example:</p>  <pre><code>curl -u username:password -o myapp.war 'http://nexus.mycompany.com/service/local/artifact/maven/redirect?r=snapshots&amp;g=com.company&amp;a=MyApp&amp;v=1.0-SNAPSHOT&amp;p=war' -L </code></pre>  <p>Where de <code>-L</code> flag is to cURL accepts redirect (301 response).</p>  <p>So, in <code>docker-compose.yml</code> I have a line like this:</p>  <pre><code>RUN curl -u username:password -o myapp.war 'http://nexus.mycompany.com/service/local/artifact/maven/redirect?r=snapshots&amp;g=com.company&amp;a=MyApp&amp;v=1.0-SNAPSHOT&amp;p=war' -L </code></pre> ",
    "highest_rated_answer": "<p>If you are using maven </p>  <pre><code>mvn dependency:copy -Dartifact=groupId:artifactId:version[:packaging][:classifier] -DoutputDirectory=[target] -Dusername=[username] -Dpassword=[password] </code></pre> "
  },
  {
    "Id": "37963689",
    "PostTypeId": "1",
    "AcceptedAnswerId": "37964149",
    "CreationDate": "2016-06-22T09:19:26.750",
    "Score": "5",
    "ViewCount": "1599",
    "Body": "<p>I was wondering if it would be possible to make the <code>maven-release-plugin</code> run a specific script before the commit of the new tag.   </p>  <p>The reason is, I have a Dockerfile that I want to update with the new version of my project.</p> ",
    "OwnerUserId": "4552808",
    "LastEditorUserId": "1033581",
    "LastEditDate": "2017-03-19T17:07:36.853",
    "LastActivityDate": "2017-03-19T17:07:36.853",
    "Title": "maven-release-plugin automatically run a script before commit",
    "Tags": "<maven><docker><maven-release-plugin>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>You could use the <a href='https://maven.apache.org/maven-release/maven-release-plugin/prepare-mojo.html#completionGoals' rel='nofollow'><code>completionGoals</code></a> option of the <code>release:perform</code> goal:</p>  <blockquote>   <p>Goals to run on completion of the preparation step, after transformation back to the next development version but before committing. Space delimited.</p> </blockquote>  <p>And have the <a href='http://www.mojohaus.org/exec-maven-plugin/' rel='nofollow'><code>maven-exec-plugin</code></a> execute your script via its <a href='http://www.mojohaus.org/exec-maven-plugin/exec-mojo.html' rel='nofollow'><code>exec</code></a> goal.</p>  <p>A simple example would be as following:</p>  <pre><code>&lt;build&gt;     &lt;plugins&gt;         ....         &lt;plugin&gt;             &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;             &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;             &lt;version&gt;1.5.0&lt;/version&gt;             &lt;configuration&gt;                 &lt;!-- example: executing an hello message on Windows console --&gt;                 &lt;executable&gt;cmd&lt;/executable&gt;                 &lt;arguments&gt;                     &lt;argument&gt;/C&lt;/argument&gt;                     &lt;argument&gt;echo&lt;/argument&gt;                     &lt;argument&gt;hello&lt;/argument&gt;                 &lt;/arguments&gt;             &lt;/configuration&gt;         &lt;/plugin&gt;         &lt;plugin&gt;             &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;             &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt;             &lt;version&gt;2.5.3&lt;/version&gt;             &lt;configuration&gt;                 ...                 &lt;completionGoals&gt;exec:exec&lt;/completionGoals&gt;             &lt;/configuration&gt;         &lt;/plugin&gt;     &lt;/plugins&gt; &lt;/build&gt; </code></pre>  <p>Note the value of the <code>completionGoals</code> above, we actually telling Maven to also execute the <code>exec</code> plugin and its <code>exec</code> goal, which will then pick up our global configuration as above.</p>  <p>In your case the exec configuration above would be something like:</p>  <pre><code>&lt;configuration&gt;     &lt;executable&gt;your-script&lt;/executable&gt;     &lt;!-- optional --&gt;     &lt;workingDirectory&gt;/tmp&lt;/workingDirectory&gt;     &lt;arguments&gt;         &lt;argument&gt;-X&lt;/argument&gt;         &lt;argument&gt;myproject:dist&lt;/argument&gt;     &lt;/arguments&gt; &lt;/configuration&gt; </code></pre>  <hr>  <p>Depending on the exact point of release preparation, you could also consider to use the additional <a href='https://maven.apache.org/maven-release/maven-release-plugin/prepare-mojo.html#preparationGoals' rel='nofollow'><code>preparationGoals</code></a> configuration option instead:</p>  <blockquote>   <p>Goals to run as part of the preparation step, after transformation but before committing. Space delimited.</p> </blockquote>  <p>Which has a default value of <code>clean verify</code>, in this case would then be <code>clean verify exec:exec</code>.</p> ",
    "highest_rated_answer": "<p>You could do like @dimatteo said, but I encourage you to NOT do this, as docker and maven are two tools for two differents purposes.</p>  <p>If you want to automate these 2 actions, use something (shell, jenkins, ...) which will launch maven then docker.</p> "
  },
  {
    "Id": "38692481",
    "PostTypeId": "1",
    "AcceptedAnswerId": "39218734",
    "CreationDate": "2016-08-01T06:43:42.563",
    "Score": "5",
    "ViewCount": "3415",
    "Body": "<h3>Background</h3>  <p>I am trying to create a compiler web service, so a user could post code written in some language I made a compiler for, then it would compile, run, and return the printed results. My second iteration involves using Docker images to isolate the running of the code POST'ed into my running web server. </p>  <h3>Problem</h3>  <p>I am trying to write the posted code to a text file to run my compiler on it, but my compiler is failing on trying to create a file. My file paths should be correct, and my other test route is working. Here is some demo code that I'm trying to run, but fails:</p>  <pre><code>try (Writer writer = new BufferedWriter(new OutputStreamWriter(                 new FileOutputStream('/raw/compile-source.slacc'), 'utf-8'))) {             writer.write(req.body());         } </code></pre>  <p>In my Dockerfile that I'm using to start this, I have created the /raw directory, if it matters. I'm imagining that Docker doesn't want Java processes to create arbitrary files. Any thoughts? Below is my Dockerfile.</p>  <h3>My Dockerfile</h3>  <pre><code>FROM java:8  # Install maven RUN apt-get update RUN apt-get install -y maven  WORKDIR /code  # Prepare by downloading dependencies ADD pom.xml /code/pom.xml RUN ['mvn', 'dependency:resolve'] RUN ['mvn', 'verify']  # Adding source, compile and package into a fat jar ADD src /code/src RUN ['mvn', 'package']  CMD ['java', '-version']  CMD ['mkdir', '/raw'] CMD ['mkdir', '/classfiles']; CMD ['mkdir', '/out']; EXPOSE 4567 CMD ['mvn', 'exec:java'] </code></pre> ",
    "OwnerUserId": "4467844",
    "LastActivityDate": "2016-08-30T04:22:35.203",
    "Title": "Write to file in Java App running on Docker",
    "Tags": "<java><maven><docker>",
    "AnswerCount": "1",
    "CommentCount": "4",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>I had CMD and RUN confused. I only need to have the final </p>  <pre><code>mvn exec:java </code></pre>  <p>in a CMD block, but the others needed to be runs. This is my final output. I also omitted getting scala. :)</p>  <pre><code>FROM java:8  # Install Scala ENV SCALA_HOME /usr/local/share/scala ENV PATH $PATH:$SCALA_HOME/bin  ENV SCALA_VERSION 2.11.8  RUN wget --quiet http://downloads.lightbend.com/scala/$SCALA_VERSION/scala-$SCALA_VERSION.tgz &amp;&amp; \\ tar -xf scala-$SCALA_VERSION.tgz &amp;&amp; \\ rm scala-$SCALA_VERSION.tgz &amp;&amp; \\ mv scala-$SCALA_VERSION $SCALA_HOME  # Install maven RUN apt-get update RUN apt-get install -y maven  WORKDIR /code  # Prepare by downloading dependencies ADD pom.xml /code/pom.xml RUN ['mvn', 'dependency:resolve'] RUN ['mvn', 'verify']  # Adding source, compile and package into a fat jar ADD src /code/src RUN ['mvn', 'package']  RUN ['java', '-version']  RUN ['mkdir', '/raw'] RUN ['chmod', 'a+w', '/raw'] RUN ['mkdir', '/classfiles']; RUN ['mkdir', '/out']; EXPOSE 4567 CMD ['mvn', 'exec:java'] </code></pre>  <p>Thank you everyone for responding and helping me out.</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "40131609",
    "PostTypeId": "1",
    "AcceptedAnswerId": "40167253",
    "CreationDate": "2016-10-19T12:36:38.543",
    "Score": "5",
    "ViewCount": "3005",
    "Body": "<p>I am using Bitbucket Pipelines for building a project from our university.</p>  <p>Here is my configuration from bitbucket-pipelines.yml:</p>  <pre><code>image: maven:3.3.9-jdk-8  pipelines:   default:     - step:         script: # Modify the commands below to build your repository.           - mvn -f EasyDiet_JavaFX_View/pom.xml clean install </code></pre>  <p>And here is some of the compilation error -> relates to JavaFX:</p>  <pre><code>ERROR] COMPILATION ERROR :  [INFO] ------------------------------------------------------------- [ERROR] /opt/atlassian/pipelines/agent/build/EasyDiet_JavaFX_View/src/at/fhv/easyDiet/teamC/presentation/patientFile/PatientFileController.java:[11,19] package javafx.fxml does not exist [ERROR] /opt/atlassian/pipelines/agent/build/EasyDiet_JavaFX_View/src/at/fhv/easyDiet/teamC/presentation/patientFile/PatientFileController.java:[12,28] package javafx.scene.control does not exist [ERROR] /opt/atlassian/pipelines/agent/build/EasyDiet_JavaFX_View/src/at/fhv/easyDiet/teamC/presentation/patientFile/PatientFileController.java:[13,27] package javafx.scene.layout does not exist [ERROR] /opt/atlassian/pipelines/agent/build/EasyDiet_JavaFX_View/src/at/fhv/easyDiet/teamC/presentation/patientFile/PatientFileController.java:[14,27] package javafx.scene.layout does not exist [ERROR] /opt/atlassian/pipelines/agent/build/EasyDiet_JavaFX_View/src/at/fhv/easyDiet/teamC/presentation/patientFile/PatientFileController.java:[15,20] package javafx.stage does not exist [ERROR] /opt/atlassian/pipelines/agent/build/EasyDiet_JavaFX_View/src/at/fhv/easyDiet/teamC/presentation/patientFile/PatientFileController.java:[27,13] cannot find symbol   symbol:   class VBox   location: class at.fhv.easyDiet.teamC.presentation.patientFile.PatientFileController [ERROR] /opt/atlassian/pipelines/agent/build/EasyDiet_JavaFX_View/src/at/fhv/easyDiet/teamC/presentation/patientFile/PatientFileController.java:[29,13] cannot find symbol   symbol:   class BorderPane   location: class at.fhv.easyDiet.teamC.presentation.patientFile.PatientFileController [ERROR] /opt/atlassian/pipelines/agent/build/EasyDiet_JavaFX_View/src/at/fhv/easyDiet/teamC/presentation/patientFile/PatientFileController.java:[336,12] cannot find symbol   symbol:   class Stage   location: class at.fhv.easyDiet.teamC.presentation.patientFile.PatientFileController </code></pre>  <p>And here some output of the build failure:</p>  <pre><code>    INFO] BUILD FAILURE [INFO] ------------------------------------------------------------------------ [INFO] Total time: 12.828 s [INFO] Finished at: 2016-10-19T10:18:57+00:00 [INFO] Final Memory: 19M/282M [INFO] ------------------------------------------------------------------------ [ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.3:compile (default-compile) on project easydiet-view: Compilation failure: Compilation failure: [ERROR] /opt/atlassian/pipelines/agent/build/EasyDiet_JavaFX_View/src/at/fhv/easyDiet/teamC/presentation/patientFile/PatientFileController.java:[11,19] package javafx.fxml does not exist [ERROR] /opt/atlassian/pipelines/agent/build/EasyDiet_JavaFX_View/src/at/fhv/easyDiet/teamC/presentation/patientFile/PatientFileController.java:[12,28] package javafx.scene.control does not exist [ERROR] /opt/atlassian/pipelines/agent/build/EasyDiet_JavaFX_View/src/at/fhv/easyDiet/teamC/presentation/patientFile/PatientFileController.java:[13,27] package javafx.scene.layout does not exist [ERROR] /opt/atlassian/pipelines/agent/build/EasyDiet_JavaFX_View/src/at/fhv/easyDiet/teamC/presentation/patientFile/PatientFileController.java:[14,27] package javafx.scene.layout does not exist [ERROR] /opt/atlassian/pipelines/agent/build/EasyDiet_JavaFX_View/src/at/fhv/easyDiet/teamC/presentation/patientFile/PatientFileController.java:[15,20] package javafx.stage does not exist [ERROR] /opt/atlassian/pipelines/agent/build/EasyDiet_JavaFX_View/src/at/fhv/easyDiet/teamC/presentation/patientFile/PatientFileController.java:[27,13] cannot find symbol [ERROR] symbol:   class VBox [ERROR] location: class at.fhv.easyDiet.teamC.presentation.patientFile.PatientFileController [ERROR] /opt/atlassian/pipelines/agent/build/EasyDiet_JavaFX_View/src/at/fhv/easyDiet/teamC/presentation/patientFile/PatientFileController.java:[29,13] cannot find symbol [ERROR] symbol:   class BorderPane [ERROR] location: class at.fhv.easyDiet.teamC.presentation.patientFile.PatientFileController </code></pre>  <p>If i build it locally on my Mac it works fine, but if i try with Bitbucket Pipelines i only get those errors. I have already tried with the default maven:3.3.3 image.</p>  <p>How is it possible to build JavaFX in Bitbucket Pipelines?</p> ",
    "OwnerUserId": "5661641",
    "LastActivityDate": "2019-09-04T08:15:19.517",
    "Title": "Bitbucket Pipelines - mvn clean install not working with JavaFX",
    "Tags": "<docker><continuous-integration><maven-3><bitbucket-pipelines>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>This worked for me:</p>  <pre><code>image: maven:3-jdk-8  pipelines:   default:     - step:         script: # Modify the commands below to build your repository.           - apt-get update           - apt-get install -y openjfx           - mvn clean install </code></pre> ",
    "highest_rated_answer": null
  },
  {
    "Id": "44589875",
    "PostTypeId": "1",
    "CreationDate": "2017-06-16T12:59:38.873",
    "Score": "5",
    "ViewCount": "21953",
    "Body": "<p>I am trying to perform &quot;mvn install&quot; to create war file from Dockerfile. Bellow is the Dockerfile</p> <pre><code>FROM scratch FROM ubuntu:16.04  RUN mkdir /opt/java8 RUN mkdir /opt/tomcat8 RUN mkdir /opt/maven3  ENV JAVA_HOME /opt/java8 ENV CATALINA_HOME /opt/tomcat8  ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/bin:$M2_HOME/bin  ADD jdk1.8.0_112 /opt/java8 ADD apache-tomcat-8.0.38 /opt/tomcat8  WORKDIR /home/veni/git/M_UserTP RUN mvn install  WORKDIR /home/veni/git/M_UserTP/target  RUN mv M_UserTP.war  /home/veni/Documents/dhaval_bhoot/docker_images/tomcat1  ADD M_UserTP.war /opt/tomcat8/webapps  EXPOSE 8080  CMD [&quot;catalina.sh&quot;, &quot;run&quot;] </code></pre> <p>I also added the path of bin directory of maven in PATH environment variable.</p> <p>PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/home/veni/Documents/apache-maven-3.3.9/bin/</p> <p>This path I set from root user in my machine, I also added same path in PATH variable as normal user already.</p> <p>So now I exit from root user and come back by sudo su to be root user and check PATH variable, it has not path of maven</p> <h1>So when I make docker build of image I get the bellow error</h1> <p>/bin/sh: 1: mvn: not found The command '/bin/sh -c mvn install' returned a non-zero code: 127</p> ",
    "OwnerUserId": "7480534",
    "LastEditorUserId": "-1",
    "LastEditDate": "2020-06-20T09:12:55.060",
    "LastActivityDate": "2020-11-12T01:01:53.493",
    "Title": "I am trying to perform mvn install from Dockerfile but it is not working says mvn not found",
    "Tags": "<maven><docker><build>",
    "AnswerCount": "4",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Given that you want to run your application in a Tomcat 8 Docker container:</p>  <p>Your maven project should be laid out like:</p>  <blockquote>   <p>M_UserTP<br>        + Dockerfile<br>        + pom.xml<br>        + src<br>        + target </p> </blockquote>  <p>This is a standard maven layout plus your Dockerfile.</p>  <p>Ensure that your pom.xml contains the following <code>finalName</code> defined in it:</p>  <pre><code>&lt;build&gt;     &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;     ... &lt;/build&gt; </code></pre>  <p>Your Dockerfile can be really simple:</p>  <pre><code>FROM tomcat:8.0     COPY target/M_UserTP.war $CATALINA_HOME/webapps/ </code></pre>  <p>(Note how the finalName is used by the Dockerfile)</p>  <p>To build it, execute:</p>  <pre><code>mvn clean install &amp;&amp; docker build . -t Bhoot/M_UserTP </code></pre>  <p>You can use what ever <code>-t</code> tag that you want.</p>  <p>It will take some time the first time that you do this while the standard Tomcat 8 image is downloaded.</p>  <p>Now you can run it:</p>  <pre><code>docker run --detach --publish 8080:8080 Bhoot/M_UserTP </code></pre>  <blockquote>   <p>You don't really want to build your WAR file in the docker image. This will suck all the maven repository components used by maven to build your application into the image. This space is not recoverable as images will only ever grow - they never shrink again.</p> </blockquote> "
  },
  {
    "Id": "45909245",
    "PostTypeId": "1",
    "AcceptedAnswerId": "45909457",
    "CreationDate": "2017-08-27T20:52:11.000",
    "Score": "5",
    "ViewCount": "1985",
    "Body": "<p>I'm developing Spring Data JPA project that targets a MySQL database, and I want to run end-to-end integration tests from Maven.</p>  <p>So far, I've configured <code>io.fabric8.docker-maven-plugin</code> to spin up a MySQL container during <code>pre-integration-test</code> phase. It will use a random available port, which I need to pass to my <code>application.properties</code> file.</p>  <p>I've tried <a href='https://docs.spring.io/spring-boot/docs/current/reference/html/howto-properties-and-configuration.html' rel='nofollow noreferrer'>Automatic property expansion using Maven</a> but I suspect that the <code>mysql.port</code> maven property is only getting resolved <em>after</em> the spring properties are getting updated.</p>  <p>pom.xml</p>  <pre><code>    &lt;?xml version='1.0' encoding='UTF-8'?&gt; &lt;project xmlns='http://maven.apache.org/POM/4.0.0' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'     xsi:schemaLocation='http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd'&gt;     &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;      &lt;groupId&gt;example&lt;/groupId&gt;     &lt;artifactId&gt;pass-port-number-from-docker-maven-plugin-to-spring-property&lt;/artifactId&gt;     &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;     &lt;packaging&gt;jar&lt;/packaging&gt;      &lt;parent&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;         &lt;version&gt;1.5.6.RELEASE&lt;/version&gt;         &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;     &lt;/parent&gt;      &lt;properties&gt;         &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;         &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;         &lt;java.version&gt;1.8&lt;/java.version&gt;     &lt;/properties&gt;      &lt;dependencies&gt;          &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;         &lt;/dependency&gt;          &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;             &lt;scope&gt;runtime&lt;/scope&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;             &lt;scope&gt;test&lt;/scope&gt;         &lt;/dependency&gt;          &lt;!-- other jpa dependencies ... --&gt;      &lt;/dependencies&gt;      &lt;build&gt;          &lt;resources&gt;             &lt;resource&gt;                 &lt;directory&gt;src/main/resources&lt;/directory&gt;                 &lt;filtering&gt;true&lt;/filtering&gt;             &lt;/resource&gt;         &lt;/resources&gt;          &lt;plugins&gt;              &lt;plugin&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;             &lt;/plugin&gt;              &lt;plugin&gt;                 &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                 &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt;                 &lt;executions&gt;                 &lt;execution&gt;                     &lt;goals&gt;                     &lt;goal&gt;integration-test&lt;/goal&gt;                     &lt;goal&gt;verify&lt;/goal&gt;                     &lt;/goals&gt;                 &lt;/execution&gt;                 &lt;/executions&gt;             &lt;/plugin&gt;          &lt;/plugins&gt;     &lt;/build&gt;      &lt;profiles&gt;         &lt;profile&gt;             &lt;id&gt;docker-test&lt;/id&gt;             &lt;properties&gt;                 &lt;docker-maven.version&gt;0.21.0&lt;/docker-maven.version&gt;             &lt;/properties&gt;             &lt;build&gt;                 &lt;resources&gt;                     &lt;resource&gt;                         &lt;directory&gt;src/main/resources&lt;/directory&gt;                         &lt;filtering&gt;true&lt;/filtering&gt;                     &lt;/resource&gt;                 &lt;/resources&gt;                 &lt;plugins&gt;                      &lt;plugin&gt;                         &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;                         &lt;artifactId&gt;build-helper-maven-plugin&lt;/artifactId&gt;                         &lt;version&gt;3.0.0&lt;/version&gt;                         &lt;executions&gt;                         &lt;execution&gt;                             &lt;id&gt;reserve-network-port&lt;/id&gt;                             &lt;goals&gt;                             &lt;goal&gt;reserve-network-port&lt;/goal&gt;                             &lt;/goals&gt;                             &lt;phase&gt;process-resources&lt;/phase&gt;                             &lt;configuration&gt;                             &lt;portNames&gt;                                 &lt;portName&gt;mysql.port&lt;/portName&gt;                             &lt;/portNames&gt;                             &lt;/configuration&gt;                         &lt;/execution&gt;                         &lt;/executions&gt;                     &lt;/plugin&gt;                      &lt;plugin&gt;                     &lt;groupId&gt;io.fabric8&lt;/groupId&gt;                     &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;                     &lt;version&gt;${docker-maven.version}&lt;/version&gt;                      &lt;configuration&gt;                         &lt;images&gt;                             &lt;image&gt;                             &lt;alias&gt;mysql&lt;/alias&gt;                             &lt;name&gt;mysql:5.7&lt;/name&gt;                             &lt;run&gt;                                 &lt;env&gt;                                     &lt;MYSQL_ROOT_PASSWORD&gt;my-secret-pw&lt;/MYSQL_ROOT_PASSWORD&gt;                                 &lt;/env&gt;                                 &lt;ports&gt;                                     &lt;port&gt;mysql.port:3306&lt;/port&gt;                                 &lt;/ports&gt;                                 &lt;wait&gt;                                     &lt;log&gt;ready for connections&lt;/log&gt;                                     &lt;!-- &lt;time&gt;20000&lt;/time&gt; --&gt;                                 &lt;/wait&gt;                                 &lt;log&gt;                                     &lt;prefix&gt;mysql&lt;/prefix&gt;                                     &lt;date&gt;ISO8601&lt;/date&gt;                                     &lt;color&gt;blue&lt;/color&gt;                                 &lt;/log&gt;                             &lt;/run&gt;                             &lt;/image&gt;                         &lt;/images&gt;                     &lt;/configuration&gt;                      &lt;!-- Connect start/stop to pre- and                         post-integration-test phase, respectively if you want to start                         your docker containers during integration tests --&gt;                     &lt;executions&gt;                         &lt;execution&gt;                         &lt;id&gt;start&lt;/id&gt;                         &lt;phase&gt;pre-integration-test&lt;/phase&gt;                         &lt;goals&gt;                             &lt;goal&gt;start&lt;/goal&gt;                         &lt;/goals&gt;                         &lt;/execution&gt;                         &lt;execution&gt;                         &lt;id&gt;stop&lt;/id&gt;                         &lt;phase&gt;post-integration-test&lt;/phase&gt;                         &lt;goals&gt;                             &lt;goal&gt;stop&lt;/goal&gt;                         &lt;/goals&gt;                         &lt;/execution&gt;                     &lt;/executions&gt;                     &lt;/plugin&gt;                 &lt;/plugins&gt;             &lt;/build&gt;         &lt;/profile&gt;     &lt;/profiles&gt;  &lt;/project&gt; </code></pre>  <p>application.properties</p>  <pre><code>mysql.port = @mysql.port@ </code></pre>  <p>When I run my test I get a connection error, and when I inspect <code>target/classes/application.properties</code> I see that <code>@mysql.port@</code> hasn't been updated.</p>  <p>Any suggestions would be much appreciated.</p> ",
    "OwnerUserId": "6606982",
    "LastEditorUserId": "6606982",
    "LastEditDate": "2017-08-28T05:31:18.280",
    "LastActivityDate": "2017-08-28T05:31:18.280",
    "Title": "Pass port number from docker-maven-plugin to spring property",
    "Tags": "<spring><maven><spring-data-jpa><maven-docker-plugin>",
    "AnswerCount": "1",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p><code>@</code> <strong>only</strong> works if you extend from <code>spring-boot-starter-parent</code>; you didn't show the relevant portions of your <code>pom.xml</code>. Assuming you did that, try attaching <code>reserve-network-port</code> to <code>process-sources</code> phase, <strong>before</strong> <code>process-resources</code>. It's very possible that when Maven copies the resources, the <code>reserve-network-port</code> hasn't ran yet.</p>  <p>What happens if you hardcode 3306 in <code>application.properties</code>?</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "47302658",
    "PostTypeId": "1",
    "AcceptedAnswerId": "47307991",
    "CreationDate": "2017-11-15T08:31:58.980",
    "Score": "5",
    "ViewCount": "4684",
    "Body": "<p>I'm trying to build CI/CD pipeline with Jenkins for Maven project. I can't seem to find any decent examples on how to use .jar file produced by mvn package in another Jenkins declarative pipeline stage. I need the jar file to make an docker-image before uploading it to docker-registry. Here's my relevant parts of jenkinsfile:</p>  <pre><code>pipeline {   agent none   stages{     stage('Build Jar'){         agent {           docker {             image 'maven:3-alpine'             args '-v /root/.m2:/root/.m2'           }         }         steps {             sh 'mvn package'             stash includes: 'target/*.jar', name: 'targetfiles'         }     }     stage('Deploy') {         agent {             node {                 label 'DockerDefault'             }          }        steps {             script{                 def image = docker.build('image-name:test', ' .')             }       }     }   } } </code></pre>  <p>Dockerfile:</p>  <pre><code>#install OS FROM centos #install java RUN yum install -y java #make directory structure to store temporary files RUN mkdir -p /store #put jar into container ADD target/AdWordsProducer-1.0-SNAPSHOT-shaded.jar adwordsproducer.jar #run jar ENTRYPOINT ['java', '-jar', '/adwordsproducer.jar'] </code></pre>  <p><strong>EDIT 1----------------------------------------------------------------------:</strong></p>  <p>Laszlos answer did the trick, as I noticed that my .jar file was under different name than dockerfile assumed.  Here is my working final jenkinsfile:</p>  <pre><code>pipeline {   agent none   stages{     stage('Build Jar'){         agent {           docker {             image 'maven:3-alpine'             args '-v /root/.m2:/root/.m2'           }         }         steps {             sh 'mvn package'             stash includes: 'target/*.jar', name: 'targetfiles'         }     }     stage('Deploy') {         agent {             node {                 label 'DockerDefault'             }          }        steps {             script{                 unstash 'targetfiles'                 sh 'ls -l -R'                 def image = docker.build('image-name:test', ' .')             }       }     }   } } </code></pre>  <p>And modified dockerfile:</p>  <pre><code>#install OS FROM centos #install java RUN yum install -y java #make directory structure to store temporary files RUN mkdir -p /store #put jar into container #ADD target/AdWordsProducer-1.0-SNAPSHOT-shaded.jar adwordsproducer.jar ADD target/AdWordsProducer-1.0-SNAPSHOT.jar adwordsproducer.jar #run jar ENTRYPOINT ['java', '-jar', '/adwordsproducer.jar'] </code></pre> ",
    "OwnerUserId": "1754089",
    "LastEditorUserId": "1754089",
    "LastEditDate": "2017-11-15T15:03:01.970",
    "LastActivityDate": "2017-11-15T15:03:01.970",
    "Title": "How can I use Jar produced by mvn package in another Jenkins declarative pipeline stage?",
    "Tags": "<java><maven><docker><jenkins><devops>",
    "AnswerCount": "2",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>You are stashing the jar files under the name 'targetfiles'. This is good.</p>  <p>What I think is missing is to pop from the stash, try adding the unstash line as shown bellow. The files will be in the exact same location as when you stashed them. Under 'target/' in your case.</p>  <pre><code>stage('Deploy') {   steps {         script{             unstash 'targetfiles'             sh 'docker build image-name:test'         }   } } </code></pre> ",
    "highest_rated_answer": "<p>You can use the same dockerfile for all stages and just install docker cmd on it and mount the docker.sock to it.</p>  <p>Add this to the Dockerfile:</p>  <pre><code>RUN apt-get update &amp;&amp; \\     apt-get install -y apt-transport-https ca-certificates curl software-properties-common &amp;&amp; \\     curl -fsSL https://download.docker.com/linux/centos/gpg | apt-key add - &amp;&amp; \\     add-apt-repository 'deb [arch=amd64] https://download.docker.com/linux/centos trusty stable' &amp;&amp; \\     apt-get update &amp;&amp; \\     apt-get install -y docker-ce </code></pre>  <p>And run set the Jenkinsfile like this:</p>  <pre><code>pipeline {     agent {        docker {          image 'maven:3-alpine'          args '-u root -v /root/.m2:/root/.m2 -v /var/run/docker.sock:/var/run/docker.sock'        }     }     stage('Build Jar'){         steps {             sh 'mvn package'             stash includes: 'target/*.jar', name: 'targetfiles'         }     }     stage('Deploy') {        steps {             script{                 sh 'docker build image-name:test'             }       }     } } </code></pre> "
  },
  {
    "Id": "50610998",
    "PostTypeId": "1",
    "CreationDate": "2018-05-30T18:07:59.927",
    "Score": "5",
    "ViewCount": "6450",
    "Body": "<p>In attempts to make a standalone JAR that I can launch cleanly and independently, I've ran into issues involving Jersey and my desirable, fat JAR. The final jar will be moved to a Docker image.</p>  <p>The error that I am getting is essentially this:</p>  <pre><code>Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.glassfish.jersey.server.ResourceConfig]: Factory method 'jerseyResourceConfig' threw exception; nested exception is org.glassfish.jersey.server.internal.scanning.ResourceFinderException: java.io.FileNotFoundException: /dir/myproject-1.0.0-SNAPSHOT.jar!/BOOT-INF/classes (No such file or directory)     at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:189)     at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:588)     ... 48 common frames omitted Caused by: org.glassfish.jersey.server.internal.scanning.ResourceFinderException: java.io.FileNotFoundException: /dir/myproject/target/myproject-1.0.0-SNAPSHOT.jar!/BOOT-INF/classes (No such file or directory)     at org.glassfish.jersey.server.internal.scanning.JarZipSchemeResourceFinderFactory.create(JarZipSchemeResourceFinderFactory.java:89)     at org.glassfish.jersey.server.internal.scanning.JarZipSchemeResourceFinderFactory.create(JarZipSchemeResourceFinderFactory.java:65)     at org.glassfish.jersey.server.internal.scanning.PackageNamesScanner.addResourceFinder(PackageNamesScanner.java:282)     at org.glassfish.jersey.server.internal.scanning.PackageNamesScanner.init(PackageNamesScanner.java:198)     at org.glassfish.jersey.server.internal.scanning.PackageNamesScanner.&lt;init&gt;(PackageNamesScanner.java:154)     at org.glassfish.jersey.server.internal.scanning.PackageNamesScanner.&lt;init&gt;(PackageNamesScanner.java:110)     at org.glassfish.jersey.server.ResourceConfig.packages(ResourceConfig.java:680)     at org.glassfish.jersey.server.ResourceConfig.packages(ResourceConfig.java:660)     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke(Method.java:498)     at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:162)     ... 49 common frames omitted Caused by: java.io.FileNotFoundException: /dir/myproject/target/myproject-1.0.0-SNAPSHOT.jar!/BOOT-INF/classes (No such file or directory) </code></pre>  <p>Here is my build profile in my POM file:</p>  <pre><code>&lt;profile&gt;     &lt;id&gt;d2&lt;/id&gt;     &lt;activation&gt;         &lt;activeByDefault&gt;false&lt;/activeByDefault&gt;     &lt;/activation&gt;     &lt;properties&gt;         &lt;packaging.type&gt;jar&lt;/packaging.type&gt;         &lt;log.dir&gt;logs&lt;/log.dir&gt;         &lt;!-- updates bootstrap.properties --&gt;         &lt;config.override.path&gt;./conf&lt;/config.override.path&gt;     &lt;/properties&gt;     &lt;build&gt;         &lt;plugins&gt;             &lt;plugin&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                 &lt;configuration&gt;                     &lt;requiresUnpack&gt;                         &lt;dependency&gt;                             &lt;groupId&gt;my.com&lt;/groupId&gt;                             &lt;artifactId&gt;myArtifact&lt;/artifactId&gt;                         &lt;/dependency&gt;                     &lt;/requiresUnpack&gt;                 &lt;/configuration&gt;                 &lt;executions&gt;                     &lt;execution&gt;                         &lt;goals&gt;                             &lt;goal&gt;repackage&lt;/goal&gt;                         &lt;/goals&gt;                     &lt;/execution&gt;                 &lt;/executions&gt;             &lt;/plugin&gt;         &lt;/plugins&gt;     &lt;/build&gt; &lt;/profile&gt; </code></pre>  <p>Finally, here are all of the jersey dependencies that I am using:</p>  <pre><code>org.springframework.boot:spring-boot-starter-jersey:jar:1.5.12.RELEASE:compile |  |  +- org.glassfish.jersey.core:jersey-server:jar:2.25.1:compile |  |  |  +- org.glassfish.jersey.core:jersey-client:jar:2.25.1:compile |  |  |  +- org.glassfish.jersey.media:jersey-media-jaxb:jar:2.25.1:compile |  |  +- org.glassfish.jersey.containers:jersey-container-servlet:jar:2.25.1:compile |  |  +- org.glassfish.jersey.ext:jersey-bean-validation:jar:2.25.1:compile |  |  +- org.glassfish.jersey.ext:jersey-spring3:jar:2.25.1:compile |  |  \\- org.glassfish.jersey.media:jersey-media-json-jackson:jar:2.25.1:compile |  |     +- org.glassfish.jersey.ext:jersey-entity-filtering:jar:2.25.1:compile ................................................................................ |     |  +- org.glassfish.jersey.connectors:jersey-apache-connector:jar:2.17:compile ................................................................................ |  \\- io.swagger:swagger-jersey2-jaxrs:jar:1.5.6:compile |     +- org.glassfish.jersey.containers:jersey-container-servlet-core:jar:2.25.1:compile |     |  +- org.glassfish.hk2.external:javax.inject:jar:2.5.0-b32:compile |     |  \\- org.glassfish.jersey.core:jersey-common:jar:2.25.1:compile |     |     +- org.glassfish.jersey.bundles.repackaged:jersey-guava:jar:2.25.1:compile |     \\- org.glassfish.jersey.media:jersey-media-multipart:jar:2.25.1:compile </code></pre>  <p>I've read through all of the sources that are referenced from this <a href='https://stackoverflow.com/questions/42194680/spring-boot-application-wont-run-when-trying-to-run-from-the-jar-file?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa'>SO question</a>. I was led through a few github issues that both Spring and Jersey have apparently fixed, yet I am still dealing with these complications.  The unique thing about my complication is that the boot-inf/classes that are not found is directly inside my jar and referencing the project itself. Its not complaining about a different, depended on jar, its complaining about the project's own /BOOT-INF/classes.</p>  <p>Any additional insight not mentioned in the aforementioned SO question would be extremely useful! I find that Java is incredibly more difficult to work with in Docker than any other stack that I've experienced (python-django and node-js). Let me know if more information is desired.</p> ",
    "OwnerUserId": "4930850",
    "LastEditorUserId": "4930850",
    "LastEditDate": "2018-06-04T16:58:24.103",
    "LastActivityDate": "2019-04-01T07:48:25.557",
    "Title": "/BOOT-INF/classes (No such file or directory) on spring boot java project",
    "Tags": "<java><maven><docker><spring-boot><jersey-2.0>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Try adding the following plugin</p>  <p><code>&lt;plugin&gt;    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;     &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;/plugin&gt;</code></p>  <p>Read more on this <a href='https://maven.apache.org/plugins/maven-shade-plugin/' rel='nofollow noreferrer'>https://maven.apache.org/plugins/maven-shade-plugin/</a></p> "
  },
  {
    "Id": "50896123",
    "PostTypeId": "1",
    "CreationDate": "2018-06-17T11:17:56.970",
    "Score": "5",
    "ViewCount": "5362",
    "Body": "<p>I am creating a docker file for my Spring Boot application.</p>  <p>Here is the file:</p>  <pre><code>FROM openjdk:8-jdk-alpine COPY eureka/target/eureka-1.0.jar app.jar ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre>  <p>The name of the jar file (it is eureka-1.0.jar in this case) is defined in the pom.xml</p>  <pre><code>&lt;artifactId&gt;eureka&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; </code></pre>  <p>My question is; when I change the file name in the pom, I am having to reflect the change to the docker file manually, which is ruining the automatic deployment process. </p>  <p>What is the best practice to get the file name that was defined in the pom.xml, from within the docker file? </p>  <p><em>(In case it matters for best practices: there are multiple docker files all similar to this one and they are used by a docker-compose.yml)</em></p> ",
    "OwnerUserId": "7948092",
    "LastActivityDate": "2021-01-17T09:10:31.127",
    "Title": "What is the best practice to get the file name that was defined in the pom.xml, from within the docker file?",
    "Tags": "<java><maven><docker><spring-boot><dockerfile>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Usually you define the <code>&lt;finalName&gt;</code> in your pom file to keep the name static..</p>  <p>The default for the final name is defined like this:</p>  <pre><code> &lt;build&gt;     &lt;finalName&gt;${project.artifactId}-${project.version}&lt;/finalName&gt;     ..  &lt;/build&gt; </code></pre>  <p>This means if you release your artifact etc. you have to change the <code>Dockerfile</code>...The simplest solution is to change the definition in your pom ilke this:</p>  <pre><code> &lt;build&gt;     &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;     ..  &lt;/build&gt; </code></pre>  <p>Than you need to change the <code>Dockerfile</code> only if you change your artifactId which usually does not happen very often...</p>  <h1>Update</h1>  <p>What you could do is to provide arguments to your <code>Dockerfile</code> like:</p>  <p></p>  <pre><code>#!/bin/bash POM_VERSION=$(mvn -q help:evaluate -Dexpression=project.version -DforceStdout=true) echo 'POM Version: $POM_VERSION' docker build --no-cache \\     --build-arg APPVERSION=$POM_VERSION \\     --rm=true -t user-registration . </code></pre>  <p>One word about the line: <code>POM_VERSION=..</code> Starting with <a href='http://maven.apache.org/plugins/maven-help-plugin/evaluate-mojo.html' rel='noreferrer'>maven-help-plugin version 3.1.0</a> it is possible to extract things from the pom file like this in particular without any grep/awk vodoo.</p>  <p>The Dockerfile can look like this:</p>  <pre><code># FROM alpine:3.6 (plus Open JDK?) FROM openjdk:8u131-jre-alpine ARG APPVERSION RUN echo 'Building ${APPVERSION}' RUN mkdir /usr/local/service/ COPY target/user-registration-${APPVERSION}.jar /usr/local/service/user-registration.jar # 8080 application port # 8081 admin port. EXPOSE 10080 10081 CMD ['java', '-XX:MaxRAM=128m', '-jar', '/usr/local/service/user-registration.jar'] </code></pre>  <p>The problem here is simply that <code>CMD</code> does not support ENV,ARGS expanding which means you need to do the copy by using a version as above. You could use the <code>ARG</code> at several points but not at all locations...</p> "
  },
  {
    "Id": "52768974",
    "PostTypeId": "1",
    "CreationDate": "2018-10-11T21:10:07.190",
    "Score": "5",
    "ViewCount": "5929",
    "Body": "<p>I have a .jar that contains multiple <code>public static void main</code>(<code>psvm</code>)'s that I want to be able to call when I do <code>docker run ... -e &lt;class.path.from.env&gt;</code> on the image and pass an environment variable to specify the class path. Something like this:</p>  <pre><code>  &lt;plugin&gt;     &lt;groupId&gt;io.fabric8&lt;/groupId&gt;     &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;     &lt;configuration&gt;       &lt;images&gt;         &lt;image&gt;           &lt;name&gt;${project.artifactId}&lt;/name&gt;           &lt;build&gt;             &lt;from&gt;java:8-jre&lt;/from&gt;             &lt;tags&gt;               &lt;tag&gt;${build.environment}-latest&lt;/tag&gt;               &lt;tag&gt;${build.environment}-${build.number}&lt;/tag&gt;             &lt;/tags&gt;             &lt;entryPoint&gt;               &lt;exec&gt;                 &lt;arg&gt;java&lt;/arg&gt;                 &lt;arg&gt;-Duser.timezone=UTC&lt;/arg&gt;                 &lt;arg&gt;-cp&lt;/arg&gt;                 &lt;arg&gt;/opt/${project.artifactId}-${project.version}.jar&lt;/arg&gt;                 &lt;arg&gt;${class.path.from.env}&lt;/arg&gt;               &lt;/exec&gt;             &lt;/entryPoint&gt;             &lt;assembly&gt;               &lt;basedir&gt;/opt&lt;/basedir&gt;               &lt;inline&gt;                 &lt;files&gt;                   &lt;file&gt;                     &lt;source&gt;target/${project.artifactId}-${project.version}.jar&lt;/source&gt;                   &lt;/file&gt;                 &lt;/files&gt;               &lt;/inline&gt;             &lt;/assembly&gt;           &lt;/build&gt;         &lt;/image&gt;       &lt;/images&gt;     &lt;/configuration&gt;   &lt;/plugin&gt; </code></pre>  <p>Although I read the whole documentation for <code>docker-maven-plugin</code>, I'm not sure how I can make this work. Basically where do I declare the environment variable <code>class.path.from.env</code> and how can I make sure it gets the one I pass through <code>-e</code> in <code>docker run ...</code>?</p> ",
    "OwnerUserId": "4438271",
    "LastEditorUserId": "145989",
    "LastEditDate": "2019-08-14T05:12:16.937",
    "LastActivityDate": "2019-08-14T05:33:19.217",
    "Title": "docker-maven-plugin: how do I pass environment variable from `docker run ... -e <value>` to build or run step?",
    "Tags": "<maven><docker><environment-variables><docker-maven-plugin>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>I think you need to declare a <code>&lt;run&gt;</code> section next to your <code>&lt;build&gt;</code> section, and add your env variable to <code>&lt;env&gt;</code>, as described here: <a href='https://dmp.fabric8.io/#misc-env' rel='nofollow noreferrer'>https://dmp.fabric8.io/#misc-env</a></p>  <pre><code>&lt;run&gt;   &lt;env&gt;     &lt;CATALINA_OPTS&gt;-Xmx32m&lt;/CATALINA_OPTS&gt;     &lt;JOLOKIA_OFF/&gt;   &lt;/env&gt; </code></pre> "
  },
  {
    "Id": "54202708",
    "PostTypeId": "1",
    "CreationDate": "2019-01-15T16:12:52.360",
    "Score": "5",
    "ViewCount": "1464",
    "Body": "<p>On my development machine, I can build my image in about 30 seconds. <a href='https://github.com/Azure-Samples/iot-edge-sample-java/blob/master/modules/SampleModule/Dockerfile.amd64' rel='noreferrer'>This</a> is the Dockerfile I'm building from.</p>  <p>However, now I need to deploy my application on a Raspberry Pi, and now I have to target ARM. The project linked above also contains an <a href='https://github.com/Azure-Samples/iot-edge-sample-java/blob/master/modules/SampleModule/Dockerfile.arm32v7' rel='noreferrer'>ARM Dockerfile</a> that I'm using. However, this is <em>extremely</em> slow, no matter how I build it. It takes at least 20 minutes, regardless of how I've approached the build. This is what I've tried:</p>  <ul> <li><a href='https://ownyourbits.com/2018/06/27/running-and-building-arm-docker-containers-in-x86/' rel='noreferrer'>Using qemu to build on my developer machine.</a> Docker version 18.09.1, build 4c52b90, qemu-arm version 2.11.1</li> <li>Building on a Rasbperry Pi 3 Model B, Docker version 18.09.0, build 4d60db4.</li> <li>Enabling remote access to the daemon on Raspberry and using dockers -H flag to target that daemon from my development machine.</li> </ul>  <p>Fetching dependencies using maven is excruciatingly slow and takes up the bulk of the time spent creating the image, even when the dependencies are in our mirrored internal repository.</p>  <p>Is there any way to speed the process up? Can the Dockerfiles be improved? Am I at fault, or is it like this building for ARM, if so, why?</p> ",
    "OwnerUserId": "1688639",
    "LastActivityDate": "2019-01-15T16:12:52.360",
    "Title": "Docker on ARM extremely slow",
    "Tags": "<maven><docker><arm>",
    "AnswerCount": "0",
    "CommentCount": "1",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": null
  },
  {
    "Id": "56269584",
    "PostTypeId": "1",
    "CreationDate": "2019-05-23T06:54:28.520",
    "Score": "5",
    "ViewCount": "1613",
    "Body": "<p>We have a docker image that runs a git clone command for a particular repository and then runs maven build . When running this image locally, it works fine. When running this image in an AWS VM, it works fine.</p>  <p>The problem we have is that when we run this image inside ACI (Azure Container Instances) or on an Azure VM - the download artefacts step inside the maven build has some connection issues - the jar downloads slow down very very much (sometimes) - and even timeout (sometimes).</p>  <p>We parameterize the repository that is built with this image - and the timeout issue only occurs on a few projects. As far as we can tell those projects do not have anything special.</p>  <p>For a particular configuration of the vm and the mvn commands we actually run - the connection issue occurs at the same set of artefacts.</p>  <p>If we change the mvn commands - the place where the connection issue occurs changes.</p>  <ol> <li><p>Initially we had a single <code>mvn clean package</code> command executed after the git clone - that was generating an issue on a particular set of jars. We then added <code>mvn dependency:resolve-plugins</code>, <code>mvn compile dependency:resolve</code> and finally <code>mvn clean package</code>. We did this because we thought that some tests that were running initially might have caused the connection issues - and so we moved the artefact download step first. This did not solve the issue - just changed the place where the jar downloads freeze.</p></li> <li><p>Changed the mvn thread count configuration and also the VM core and memory sizes - but this did not help.</p></li> <li><p>We set a TCP Keepalive flag on the VM - as to avoid a possible Azure NAT/Load Balancer timeout that was killing our connections.  This was a solution suggested by Azure support and we also found it here:  <a href='https://stackoverflow.com/questions/42024619/maven-build-gets-connection-reset-when-downloading-artifacts'>Maven build gets connection reset when downloading artifacts</a>  We configured it based on the azure guide: <a href='https://github.com/wbuchwalter/azure-content/blob/master/includes/guidance-tcp-session-timeout-include.md' rel='nofollow noreferrer'>https://github.com/wbuchwalter/azure-content/blob/master/includes/guidance-tcp-session-timeout-include.md</a></p></li> </ol>  <pre><code>&gt; sysctl net.ipv4.tcp_keepalive_time net.ipv4.tcp_keepalive_intvl net.ipv4.tcp_keepalive_probes net.ipv4.tcp_keepalive_time = 60 net.ipv4.tcp_keepalive_intvl = 10 net.ipv4.tcp_keepalive_probes = 20 </code></pre>  <p>This is a sample of the mvn log:</p>  <pre><code>14:10:48,505 [BasicRepositoryConnector-repo.maven.apache.org-27-0] [INFO] Downloading from central: https://repo.maven.apache.org/maven2/regexp/regexp/1.3/regexp-1.3.jar 14:10:48,506 [BasicRepositoryConnector-repo.maven.apache.org-27-2] [INFO] Downloading from central: https://repo.maven.apache.org/maven2/org/apache/maven/scm/maven-scm-provider-cvs-commons/1.7/maven-scm-provider-cvs-commons-1.7.jar 14:10:48,505 [BasicRepositoryConnector-repo.maven.apache.org-27-1] [INFO] Downloading from central: https://repo.maven.apache.org/maven2/org/apache/maven/scm/maven-scm-provider-git-commons/1.7/maven-scm-provider-git-commons-1.7.jar 14:10:48,521 [BasicRepositoryConnector-repo.maven.apache.org-27-3] [INFO] Downloading from central: https://repo.maven.apache.org/maven2/org/tmatesoft/sqljet/sqljet/1.0.4/sqljet-1.0.4.jar 14:10:48,523 [BasicRepositoryConnector-repo.maven.apache.org-27-4] [INFO] Downloading from central: https://repo.maven.apache.org/maven2/org/antlr/antlr-runtime/3.1.3/antlr-runtime-3.1.3.jar 14:10:48,540 [BasicRepositoryConnector-repo.maven.apache.org-27-0] [INFO] Downloaded from central: https://repo.maven.apache.org/maven2/regexp/regexp/1.3/regexp-1.3.jar (25 kB at 706 kB/s) 14:10:48,540 [BasicRepositoryConnector-repo.maven.apache.org-27-0] [INFO] Downloading from central: https://repo.maven.apache.org/maven2/org/antlr/stringtemplate/3.2/stringtemplate-3.2.jar 14:10:48,564 [BasicRepositoryConnector-repo.maven.apache.org-27-0] [INFO] Downloaded from central: https://repo.maven.apache.org/maven2/org/antlr/stringtemplate/3.2/stringtemplate-3.2.jar (172 kB at 4.0 MB/s) 14:26:32,150 [BasicRepositoryConnector-repo.maven.apache.org-27-2] [INFO] Downloaded from central: https://repo.maven.apache.org/maven2/org/apache/maven/scm/maven-scm-provider-cvs-commons/1.7/maven-scm-provider-cvs-commons-1.7.jar (80 kB at 84 B/s) 14:26:32,157 [BasicRepositoryConnector-repo.maven.apache.org-27-4] [INFO] Downloaded from central: https://repo.maven.apache.org/maven2/org/antlr/antlr-runtime/3.1.3/antlr-runtime-3.1.3.jar (151 kB at 159 B/s) 14:26:32,199 [BasicRepositoryConnector-repo.maven.apache.org-27-3] [INFO] Downloaded from central: https://repo.maven.apache.org/maven2/org/tmatesoft/sqljet/sqljet/1.0.4/sqljet-1.0.4.jar (744 kB at 788 B/s) </code></pre>  <p>Notice the suspicious: (151 kB at 159 B/s), (80 kB at 84 B/s), (744 kB at 788 B/s)</p>  <p>We have examples of executions that run just fine - and examples of executions that timeout (1 hour) - and examples of executions that take close to 1h.</p>  <p>Solutions:</p>  <ul> <li><p>We have options to pre-cache some of the jars in the initial docker image - and thus not need maven to handle them. But the docker image that handles this build needs to do run for any git repo (Java + Maven) and we cannot know what dependecies those projects have. </p></li> <li><p>Similar to the other point, have options to create an external volume that is shared between running containers and to cache the jars there.</p></li> <li><p>We have options to restart the maven build once it fails - because part of the dependencies would have already been downloaded and it will not get stuck at the same place.</p></li> </ul>  <p>We reached out to Azure support and they recommended the TCP Keep-alive configuration - but that did not solve our problem.</p>  <p>We want to understand the root cause of the issue - is it a docker config ? is it a maven bug ? is it an azure specific issue ? The connection issue occurs roughly 9/10 executions - i have no ideea why it works - and no ideea why it doesn't work :) The solutions I mentioned before are just work-arounds - they do not fix it - just ignore it.</p>  <p><strong>Found the problem</strong></p>  <p>The issue is that Maven reuses the same HTTP Connections for the download of the pom/jar files. <a href='https://maven.apache.org/guides/mini/guide-http-settings.html#Maven_3.0.4' rel='nofollow noreferrer'>https://maven.apache.org/guides/mini/guide-http-settings.html#Maven_3.0.4</a> Thus - our scenario is along the following lines:</p>  <p>Project</p>  <p>-- module 1 - download some pom/jars - keep connection active</p>  <p>-- module 2 - runs some plugins / tests - lasts more that 5 minutes</p>  <p>-- module 3 - tries to download some pom/jars</p>  <p>Azure - the NAT configuration: <a href='https://github.com/wbuchwalter/azure-content/blob/master/includes/guidance-tcp-session-timeout-include.md' rel='nofollow noreferrer'>https://github.com/wbuchwalter/azure-content/blob/master/includes/guidance-tcp-session-timeout-include.md</a> kills any idle connections after 4 minutes. </p>  <p>So during the execution of module 2 - all of the connections initially opened and used by module 1 get closed - and module 3 does not know it.</p>  <p>Our solution - given the NAT 4 minute timeout cannot be configured - is to use tcp keep-alive or to force Maven to use a different connection pool implementation or to use an eviction manager to would 'nicely' close out these idle connections before NAT can close them 'forcefully'.</p> ",
    "OwnerUserId": "876158",
    "LastEditorUserId": "876158",
    "LastEditDate": "2019-06-13T13:47:38.927",
    "LastActivityDate": "2019-06-13T13:47:38.927",
    "Title": "Maven build download artefacts connection slow/reset when running inside a Docker Container on Azure",
    "Tags": "<java><azure><maven><docker>",
    "AnswerCount": "0",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": null
  },
  {
    "Id": "57303048",
    "PostTypeId": "1",
    "CreationDate": "2019-08-01T06:35:08.437",
    "Score": "5",
    "ViewCount": "1806",
    "Body": "<p><a href='https://www.testcontainers.org/modules/docker_compose/' rel='nofollow noreferrer'>Test-containers</a> project alllows start docker contaniders from compose file. They have <a href='https://www.testcontainers.org/test_framework_integration/junit_4/' rel='nofollow noreferrer'>integration with JUnit</a>. But when test phase is finished, all I have is maven log - all started containers were removed by that time. It would be nice if6 for example I run <code>Application</code> and <code>Database</code> containers 4 times for 4 tests. So maven target folder should contains the following: <code>target/test-containers/&lt;start-id&gt;/Application.log</code> and <code>target/test-containers/&lt;start-id&gt;/Database.log</code>.</p> <p>Is there a way to configure test-containers or JUnit or both to redirect log from started containers into some folder?</p> ",
    "OwnerUserId": "1251549",
    "LastEditorUserId": "-1",
    "LastEditDate": "2020-06-20T09:12:55.060",
    "LastActivityDate": "2019-08-01T06:46:08.033",
    "Title": "How store container logs from test-containers?",
    "Tags": "<java><maven><docker><junit><testcontainers>",
    "AnswerCount": "0",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": null
  },
  {
    "Id": "57464720",
    "PostTypeId": "1",
    "CreationDate": "2019-08-12T16:15:38.490",
    "Score": "5",
    "ViewCount": "5798",
    "Body": "<p>I've been trying to create a multi-stage docker build for my spring-boot-application. The problem is on every change on the master branch, the pom.xml file changes (thanks to maven release plugin), so it's kind of hard to make use of docker build-cache during the build stage and all the dependencies will be downloaded every time I run the build. As far as I know, I can't mount volumes during the building of the image. The experimental version of the docker allows you to mount volumes during the build but it's still experimental so I'm trying to avoid it.</p>  <p>So I decided to try my luck with docker-compose, where the first service will run 'mvn package' inside the container and create a jar file inside a shared volume, which will be then used by the second service to build its own image (basically adding that jar inside its image), which will be published to docker hub. Whatever I was trying to do didn't seem right. Now I'm not really expert of docker-compose here, but is this the right approach to do it?<br> I'm using <code>Docker version 18.09.0, build 4d60db4</code></p>  <pre><code>version: '3' #Specify all the services you want to create services:   #service name   build-service:     context: .     dockerfile: Dockerfile-build     volumes:       - ./:/usr/app       - '$(HOME)'/.m2:/usr/mvn/.m2   spring-app:     conext: .     dockerfile: Dockerfile-jar     volumes:       - ./:/usr/app </code></pre>  <p>Is there any way to make use of local .m2 repository during the first stage. Or any other suggestions are welcome.</p> ",
    "OwnerUserId": "5700299",
    "LastActivityDate": "2019-08-13T05:43:19.073",
    "Title": "How to use maven local repository in Multi-stage docker build?",
    "Tags": "<java><maven><docker-compose><dockerfile><docker-multi-stage-build>",
    "AnswerCount": "1",
    "CommentCount": "1",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>The short answer is that you cannot. The only way you could use the maven repository during build would be to copy it inside the image in the first stage. But you cannot do that because normally the location of the maven repository is outside your build context. Of course you can change that for your project (place the .m2 folder in your current project) and then this approach might work. I am not recommending this approach, I am merely mentioning it as an option.</p>  <p>However, I think you can solve your issue by following the best practice of not using Docker during development. While Docker is an awesome tool, it does slow down development. The build and push of the image should be delegated to your CI/CD pipeline (Jenkins, Gitlab CI, etc.). During day to day activities it is better and faster to just run your maven builds locally.</p> "
  },
  {
    "Id": "57947511",
    "PostTypeId": "1",
    "AcceptedAnswerId": "59572034",
    "CreationDate": "2019-09-15T19:22:36.287",
    "Score": "5",
    "ViewCount": "3296",
    "Body": "<p>I am trying to use Google Cloud Build to build my Java app. It allows to use so called cloud builders - docker images of different builders. I am using Maven. So the problem is that I have to use a private repository (artifactory) to deploy artifacts. This rep is password protected and I do not know how to pass these credentials to GC maven docker container.</p>  <p>I see that the only possible way is: </p>  <ol> <li><p>To run the shell script which will update the maven container settings.xml with something like:</p>  <pre><code>&lt;servers&gt;     &lt;server&gt;         &lt;id&gt;myRepoName&lt;/id&gt;         &lt;username&gt;${server.username}&lt;/username&gt;         &lt;password&gt;${server.password}&lt;/password&gt;     &lt;/server&gt; &lt;/servers&gt; </code></pre></li> <li><p>set env variables in the cloudbuild.yml</p></li> </ol>  <p>Are there any other elegant ways to achieve what I'm trying to?</p> ",
    "OwnerUserId": "10369917",
    "LastEditorUserId": "916225",
    "LastEditDate": "2019-09-16T03:33:24.213",
    "LastActivityDate": "2020-01-03T01:09:43.813",
    "Title": "How to pass private repository credentials to maven docker image when using Google Cloud Build",
    "Tags": "<maven><docker><google-cloud-platform><google-cloud-build><docker-maven-plugin>",
    "AnswerCount": "1",
    "CommentCount": "6",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>I solved this by doing the following:</p>  <ol> <li><p>Create a Google Cloud Storage bucket and upload your desired <code>settings.xml</code>. I'm using GitHub Packages, following <a href='https://help.github.com/en/github/managing-packages-with-github-packages/configuring-apache-maven-for-use-with-github-packages#authenticating-to-github-packages' rel='noreferrer'>their documentation</a></p></li> <li><p>Setup your cloudbuild.yaml with the following:</p></li> </ol>  <pre><code>steps:   - name: gcr.io/cloud-builders/gsutil     args: ['cp', 'gs://ci-maven/settings.xml', 'settings.xml']   - name: maven:3.6.3-jdk-11-openj9     entrypoint: 'mvn'     args: ['--settings', '/workspace/settings.xml', 'install'] images: ['gcr.io/schemata-np/scheduler'] </code></pre>  <p>First, it copies the settings.xml to the current directory (<code>/workspace</code>). Then, using the Docker Maven image directly, we add <code>--settings /workspace/settings.xml</code> to our args to specify the settings.xml location. From there, Google Cloud Build was able to pull my private GitHub package to properly install my project.</p>  <p>It may be possible to copy to <code>/usr/share/maven/ref/</code> in the first step to allow the default Maven Docker behavior, but I was not able to get this to work. If anyone does, let me know!</p>  <p>Based on <a href='https://stackoverflow.com/a/55800624/2693009'>this answer to a slightly different question about caching artifacts</a> and <a href='https://cloud.google.com/cloud-build/docs/speeding-up-builds#caching_directories_with_google_cloud_storage' rel='noreferrer'>Google Cloud Build documentation</a></p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "58681074",
    "PostTypeId": "1",
    "AcceptedAnswerId": "62205339",
    "CreationDate": "2019-11-03T14:23:04.653",
    "Score": "5",
    "ViewCount": "3472",
    "Body": "<p>I would like to ask for some recommendations for development workflow for application with stack mentioned in the title. Before I switched to use Docker all I had to do was:</p>  <ol> <li>Go to start.spring.io and download project starter</li> <li>Import it into intelliJ</li> <li>Develop features, hit green arrow to start app or red square to stop and repeat it with every change in code</li> </ol>  <p>Now when I switched to docker, after step 2, I do this:</p>  <ol> <li>Create Dockerfile and docker-compose.yml (where I start my app and also mysql service). </li> <li>Right click on docker-compose and hit run. Then it builds my app image (i use --build flag in my run configuration so it builds images every time it I hit run on docker-compose) and starts two services: app and mysql, and everything works.</li> </ol>  <p>The problem is when I change sth in my code then I have to:</p>  <ol> <li>Execute mvn clean and install steps manually, to produce new jar under /target folder</li> <li>Then stop previous docker compose and run it again. Then it builds new images from what is in /target </li> </ol>  <p>I would rather like to have something like one-click solution, like it was before I started to use docker. So when I change code then I press only one button and new image is generated and run with all changes applied. Is it possible? Do I miss something? Could you tell me if your workflow is similar to mine? Maybe you could recommend some tools or different config?</p> ",
    "OwnerUserId": "4910038",
    "LastActivityDate": "2020-06-04T22:42:14.420",
    "Title": "Development workflow for Spring Boot + Maven + Docker + IntelliJ",
    "Tags": "<java><maven><docker><intellij-idea><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>You can set up Spring Boot dev tools to live reload inside a Docker container.</p>  <p>Ensure spring-boot-devtools dependency is in your pom.xml:</p>  <pre><code>&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;   &lt;scope&gt;runtime&lt;/scope&gt;   &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; </code></pre>  <p>Then create a docker-compose.yml file with</p>  <pre><code>version: '3.1' services:   backend:     image: maven:3.6.3-jdk-8     command: mvn spring-boot:run     ports:       - 8000:8000     volumes:       - .:/usr/src/mymaven:rw     working_dir: /usr/src/mymaven </code></pre>  <p>This uses the <a href='https://hub.docker.com/_/maven' rel='noreferrer'>Maven Docker image</a> so when you run <code>docker-compose up</code>, it will run the image and map your source code folder as a volume. Then maven will run the application using <code>mvn spring-boot:run</code></p>  <p>Whenever you make a change to the source code, it will reload with the same functionality as <code>mvn spring-boot:run</code>.</p> ",
    "highest_rated_answer": "<ol> <li>Create a separate release module - <em>project-name</em>-release - which brings down the old image, build the new image and run/publish it</li> <li>Use <a href='https://github.com/spotify/dockerfile-maven' rel='nofollow noreferrer'>docker maven plugin</a> in the config</li> </ol>  <p>Sample project - <a href='https://github.com/spring-guides/gs-spring-boot-docker' rel='nofollow noreferrer'>https://github.com/spring-guides/gs-spring-boot-docker</a></p> "
  },
  {
    "Id": "59228202",
    "PostTypeId": "1",
    "CreationDate": "2019-12-07T16:48:00.353",
    "Score": "5",
    "ViewCount": "1812",
    "Body": "<p>We have a requirement to include a maven artifact (a jar file) in a Dockerfile. This jar file is used an as argument in the run command of our application. What is the correct way of copying a maven artifact in the Dockerfile which does not exist in the build directory and only exists in the local maven repo? I have found that since maven artifacts wont be in the build context, the only way to copy it is from the .m2 directory of the container (.m2 directory contains all the maven artifacts). Is that correct or is there a better way? Thanks</p> ",
    "OwnerUserId": "164954",
    "LastActivityDate": "2019-12-07T22:52:27.090",
    "Title": "Including a maven artifact in Dockerfile",
    "Tags": "<maven><docker>",
    "AnswerCount": "1",
    "CommentCount": "1",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>You can do that by copying the jar to your image when creating it.</p>  <p>here's an example. Assuming you wanna using the Quava jar, and it is already listed as a dependency in your POM.</p>  <p>Create <code>Makefile</code> in your root project (where you have your POM.xml),</p>  <pre><code>create_image: Dockerfile build         docker build . -t myimage:mytag  build: POM.xml         mvn clean install </code></pre>  <p>Create Dockerfile in the same directory:</p>  <pre><code>FROM centos COPY ~/.m2/repository/com/google/guava/14.0.1/guava.jar / CMD ['sh run.sh', '/quava.jar'] </code></pre>  <p>and simply create your image using:</p>  <p><code>make create_image</code></p> "
  },
  {
    "Id": "60504536",
    "PostTypeId": "1",
    "AcceptedAnswerId": "60630158",
    "CreationDate": "2020-03-03T09:56:24.267",
    "Score": "5",
    "ViewCount": "1005",
    "Body": "<p>Using the following plugin </p>  <pre><code>&lt;groupId&gt;io.fabric8&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.33&lt;/version </code></pre>  <p>and using the following configuration (Just posting the relevant bits here)</p>  <pre><code>    &lt;configuration&gt;       &lt;verbose&gt;build&lt;/verbose&gt;       &lt;images&gt;         &lt;image&gt;           &lt;name&gt;${container.imageNameWithTag}&lt;/name&gt;           &lt;build&gt;             &lt;labels&gt;               &lt;dummy.label&gt;dummyLabelValue&lt;/dummy.label&gt;             &lt;/labels&gt;             &lt;contextDir&gt;${project.basedir}/src/main/docker&lt;/contextDir&gt;            &lt;assembly&gt;some required assembly &lt;/assembly&gt;           &lt;/build&gt;          &lt;/image&gt;         &lt;/images&gt;     &lt;/configuration&gt;      &lt;executions&gt;       &lt;execution&gt;         &lt;id&gt;docker-build&lt;/id&gt;         &lt;goals&gt;           &lt;goal&gt;build&lt;/goal&gt;         &lt;/goals&gt;         &lt;phase&gt;package&lt;/phase&gt;       &lt;/execution&gt;     &lt;/executions&gt; </code></pre>  <p>But the final image has only these labels</p>  <pre><code>        'Labels': {             'org.label-schema.build-date': '20181204',             'org.label-schema.license': 'GPLv2',             'org.label-schema.name': 'CentOS Base Image',             'org.label-schema.schema-version': '1.0',             'org.label-schema.vendor': 'CentOS'         } </code></pre>  <p>which I reckon are from <code>centos</code> base image, but no <strong>dummy.label</strong></p>  <p>Am I missing any configuration, or anything is wrongly configured?</p>  <p>The documentation to the plugin is at <a href='https://dmp.fabric8.io/' rel='nofollow noreferrer'>Maven Docker Plugin</a></p> ",
    "OwnerUserId": "4524618",
    "LastEditorUserId": "4524618",
    "LastEditDate": "2020-03-06T12:52:51.750",
    "LastActivityDate": "2020-03-11T06:09:31.340",
    "Title": "Fabric8 docker-maven-plugin unable set labels to an image",
    "Tags": "<docker><maven-plugin><fabric8><docker-maven-plugin>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>After looking into <a href='https://dmp.fabric8.io/#build-configuration' rel='nofollow noreferrer'>Build Configuration</a>, of maven-docker-plugin, there is a <code>buildOptions</code> property that also could be used.</p>  <p>The <code>buildOptions</code> also states</p>  <blockquote>   <p><em>These options map to the ones listed as query parameters in the Docker Remote API</em></p> </blockquote>  <p>The query parameters in <a href='https://docs.docker.com/engine/api/v1.40/#operation/ImageBuild' rel='nofollow noreferrer'>Docker Remote API</a> has <code>labels</code> as a parameter.</p>  <blockquote>   <p>labels:  Arbitrary key/value labels to set on the image, as a   JSON map of string pairs.</p> </blockquote>  <p>So we have to specify a JSON string into build options as shown below</p>  <pre><code>&lt;configuration&gt;           &lt;verbose&gt;build&lt;/verbose&gt;           &lt;images&gt;             &lt;image&gt;               &lt;name&gt;${container.nameWithTag}&lt;/name&gt;               &lt;build&gt;                 &lt;contextDir&gt;${project.basedir}/src/main/docker&lt;/contextDir&gt;                 &lt;buildOptions&gt;                    &lt;labels&gt;{                     'org.label-schema.name':'${container.name}',                     'org.label-schema.description':'My Image',                     'org.label-schema.vcs-url':'${project.scm.url}',                     'org.label-schema.vendor':'Test Vendor',                     'org.label-schema.version':'${container.tag}'                     }&lt;/labels&gt;                  &lt;/buildOptions&gt;               &lt;/build&gt;             &lt;/image&gt;           &lt;/images&gt;         &lt;/configuration&gt; </code></pre> ",
    "highest_rated_answer": null
  },
  {
    "Id": "60948766",
    "PostTypeId": "1",
    "CreationDate": "2020-03-31T10:46:22.080",
    "Score": "5",
    "ViewCount": "4754",
    "Body": "<p>So I am trying to run a spring boot app with maven wrapper inside the docker container. Here is my Docker file: </p>  <pre><code>### Stage 1: Build the application FROM openjdk:8-jdk-alpine as build  RUN mkdir -p /app #Set the current working directory inside the image WORKDIR /app  #copy maven executable to the image COPY mvnw . COPY .mvn .mvn  #Copy the pom.xml file COPY pom.xml .  #Build all the dependencies in preparation to go offline #This is a separate step so the dependencies will be cached unless #the pom.xml file has changed  RUN ./mvnw dependency:go-offline -B  #Copy the project source COPY src src  #Package the application RUN ./mvnw package -DskipTests RUN mkdir -p target/dependency &amp;&amp; (cd target/dependency; jar -xf ../*.jar)  </code></pre>  <p>I have this error:</p>  <pre><code>Step 7/16 : RUN ./mvnw dependency:go-offline -B  ---&gt; Running in 642a32f86392 /bin/sh: ./mvnw: not found ERROR: Service 'app-server' failed to build: The command '/bin/sh -c ./mvnw dependency:go-offline -B' returned a non-zero code: 127  </code></pre>  <p>I am working with windows 10 pro. Please I need your help</p> ",
    "OwnerUserId": "12579196",
    "LastActivityDate": "2022-12-14T06:37:52.357",
    "Title": "Unable to run 'RUN ./mvnw dependency:go-offline -B' when building docker image from 'openjdk:8-jdk-alpine' for Spring Boot app",
    "Tags": "<java><spring><spring-boot><docker><maven>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Maybe a duplicate of <a href='https://stackoverflow.com/questions/52748640/unable-to-run-mvnw-clean-install-when-building-docker-image-based-on-openjd'>Unable to run &#39;./mvnw clean install&#39; when building docker image based on &quot;openjdk:8-jdk-alpine&quot; for Spring Boot app</a></p>  <p>Can you check the line endings of the <code>mvnw</code> shell script?  You could fix it by adding this before executing the <code>mvnw</code> command:</p>  <pre><code>RUN dos2unix mvnw </code></pre>  <p>Alternatively, if the file is in git, you can also fix it by adding the following to a <code>.gitattributes</code> file and checking the file out again:</p>  <pre><code>*.bat           text eol=crlf mvnw            text eol=lf </code></pre> "
  },
  {
    "Id": "61189237",
    "PostTypeId": "1",
    "AcceptedAnswerId": "61190005",
    "CreationDate": "2020-04-13T13:44:14.080",
    "Score": "5",
    "ViewCount": "13366",
    "Body": "<p>I'm following Spring Boot Docker Tutorial from <a href='https://spring.io/guides/gs/spring-boot-docker/' rel='noreferrer'>here</a>.</p>  <p>I got the exact result while having an internet connection. Now I need to produce the same result in an environment without an internet connection. I copied maven repositories and docker image into the new environment. I'm quite sure maven and docker is up and running. </p>  <p>When I tried to run following command <code>com.google.cloud.tools:jib-maven-plugin:dockerBuild -Dimage=eureka</code> I'm getting error messages. I guess there are some files plugin cannot locate but not sure which ones. </p>  <p>I'm adding the error message</p>  <pre><code>[INFO] Scanning for projects... [INFO] [INFO] ---------------------------&lt; com.ays:eureka &gt;--------------------------- [INFO] Building eureka 0.0.1-SNAPSHOT [INFO] --------------------------------[ jar ]--------------------------------- [INFO] [INFO] --- jib-maven-plugin:2.1.0:dockerBuild (default-cli) @ eureka --- [INFO] [INFO] Containerizing application to Docker daemon as eureka... [WARNING] Base image 'gcr.io/distroless/java:8' does not use a specific image digest - build may not be reproducible [ERROR] I/O error for image [gcr.io/distroless/java]: [ERROR]     org.apache.http.conn.ConnectTimeoutException [ERROR]     Connect to gcr.io:443 [gcr.io/64.233.184.82] failed: connect timed out [INFO] Executing tasks: [INFO] [============                  ] 40,0% complete [INFO] &gt; building image to Docker daemon [INFO] [INFO] ------------------------------------------------------------------------ [INFO] BUILD FAILURE [INFO] ------------------------------------------------------------------------ [INFO] Total time:  22.409 s [INFO] Finished at: 2020-04-13T16:37:23+03:00 [INFO] ------------------------------------------------------------------------ [ERROR] Failed to execute goal com.google.cloud.tools:jib-maven-plugin:2.1.0:dockerBuild (default-cli) on project eureka: Connect to gcr.io:443 [gcr.io/64.233.184.82] failed: connect timed out -&gt; [Help 1] [ERROR] [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch. [ERROR] Re-run Maven using the -X switch to enable full debug logging. [ERROR] [ERROR] For more information about the errors and possible solutions, please read the following articles: [ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException  </code></pre>  <p>Can somebody point me where should I look or is there anything I'm missing at this point?</p>  <p>Here is my DockerFile</p>  <pre><code>FROM openjdk:8-jdk-alpine RUN addgroup -S spring &amp;&amp; adduser -S spring -G spring USER spring:spring ARG DEPENDENCY=target/dependency COPY ${DEPENDENCY}/BOOT-INF/lib /app/lib COPY ${DEPENDENCY}/META-INF /app/META-INF COPY ${DEPENDENCY}/BOOT-INF/classes /app ENTRYPOINT ['java','-cp','app:app/lib/*','hello.Application']` </code></pre>  <p>I didn't change anything in DockerFile.</p> ",
    "OwnerUserId": "1303334",
    "LastEditorUserId": "8405123",
    "LastEditDate": "2020-04-13T23:19:17.297",
    "LastActivityDate": "2023-12-16T01:02:41.690",
    "Title": "Problem with using jib maven plugin offline for building docker container",
    "Tags": "<java><spring-boot><docker><maven-plugin><jib>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>If you do not specify a base image, <a href='https://github.com/GoogleContainerTools/jib/blob/master/docs/default_base_image.md' rel='nofollow noreferrer'>Jib 3.0+ by default uses <code>adoptopenjdk:8-jre</code></a> as a base image for Java 8 apps. (Prior to 3.0, Jib used <code>gcr.io/distroless/java:8</code> as the default.)</p> <p>When you are not using a specific image digest (such as <code>gcr.io/distroless/java@sha256:...</code>) but instead use a tag (<code>:8</code> in your case with Jib &lt; 3.0) for a base image, the tag can point to different images over time. That is, if you build an image sometime later on a different machine, Jib may pick up a slightly different base image than you used before. Hence the following warning:</p> <pre><code>[WARNING] Base image 'gcr.io/distroless/java:8' does not use a specific image digest - build may not be reproducible </code></pre> <p>For this reason, when you are not using a digest, Jib reaches out to the registry (<code>gcr.io</code>) and checks if the locally cached image (not in the local Docker engine cache but Jib's own cache) is up to date. If not, Jib will download the updated image. This is why you are getting the error when you're offline.</p> <p>You have two options.</p> <ol> <li><p>Pass <code>--offline</code> to Maven on the command-line. Then, Jib will use the cached base image; there will be no online connection. Of course, for this to work, Jib should have cached the base image before; you need to run Jib at least once online beforehand.</p> </li> <li><p>Use a digest to pin down a specific base image. For example, in your <code>pom.xml</code>,</p> <pre class='lang-xml prettyprint-override'><code>&lt;configuration&gt;   &lt;from&gt;&lt;image&gt;adoptopenjdk@sha256:9cb8bc7356ec2d9de56f3be3d8204a846ca0a3220af059aa67c35d53c7138e17&lt;/image&gt;&lt;/from&gt; &lt;/configuration&gt; </code></pre> <p>If you prefer, you can specify both tag and digest. However, the tag will have no effect and only serve as a comment in this case.</p> <pre class='lang-xml prettyprint-override'><code>&lt;from&gt;&lt;image&gt;adoptopenjdk:8-jre@sha256:9cb8bc7356ec2d9de56f3be3d8204a846ca0a3220af059aa67c35d53c7138e17&lt;/image&gt;&lt;/from&gt; </code></pre> <p>To find out which digest to use, check the <a href='https://hub.docker.com/_/adoptopenjdk?tab=tags&amp;page=1&amp;ordering=last_updated' rel='nofollow noreferrer'><code>adoptopenjdk</code> Docker Hub repository</a>. Another way is to run Jib once online. After the warning, you will see a message reporting the current digest for the tag.</p> <pre><code>[WARNING] Base image 'adoptopenjdk:8-jre' does not use a specific image digest - build may not be reproducible [INFO] Using base image with digest: sha256:9cb8bc7356ec2d9de56f3be3d8204a846ca0a3220af059aa67c35d53c7138e17 </code></pre> </li> </ol> <p>Another option when you're running a local Docker daemon is to make Jib use an image from the daemon by prefixing <code>docker://</code> to the base image (for example, <code>&lt;image&gt;docker://openjdk:11-jre-slim&lt;/image&gt;</code>). However, depending on circumstances, this can be a little bit slower than using a remote base image (but probably not so much even in that case).</p> <hr /> <p>Lastly, <em><strong>you can delete your <code>Dockerfile</code>.</strong></em> Jib does not use <code>Dockerfile</code>, Docker CLI, or Docker daemon.</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "61548934",
    "PostTypeId": "1",
    "AcceptedAnswerId": "61556604",
    "CreationDate": "2020-05-01T18:55:42.237",
    "Score": "5",
    "ViewCount": "10491",
    "Body": "<p>I am trying to dockerize a simple Spring Boot Application, built with Maven.</p>  <p><strong>Dockerfile:</strong></p>  <pre><code>FROM openjdk:latest COPY target/backend-1.0-SNAPSHOT.jar app.jar ENTRYPOINT ['java','-jar','app.jar'] </code></pre>  <p>When I run the .jar without the container (<code>java -jar target/backend-1.0-SNAPSHOT.jar</code>), everything works fine and the app is running.</p>  <p>Now I create the container with <code>docker build -t company/backend .</code></p>  <p>But when I try to run the docker container with <code>docker run -p 8080:8080 company/backend</code> the following error occurs:</p>  <pre><code>Exception in thread 'main' java.lang.NoClassDefFoundError: org/springframework/boot/SpringApplication         at de.company.backend.Application.main(Application.java:10) Caused by: java.lang.ClassNotFoundException: org.springframework.boot.SpringApplication         at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:602)         at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178)         at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)         ... 1 more </code></pre>  <p>It seems like docker does not find the main class, even though it is defined in my pom.xml:</p>  <pre><code>&lt;properties&gt;     &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;     &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;     &lt;mainClass&gt;de.elbdev.backend.Application&lt;/mainClass&gt; &lt;/properties&gt;  &lt;build&gt;     &lt;plugins&gt;         &lt;plugin&gt;             &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;             &lt;executions&gt;                 &lt;execution&gt;                     &lt;phase&gt;install&lt;/phase&gt;                     &lt;goals&gt;                         &lt;goal&gt;copy-dependencies&lt;/goal&gt;                     &lt;/goals&gt;                     &lt;configuration&gt;                         &lt;outputDirectory&gt;${project.build.directory}/lib&lt;/outputDirectory&gt;                     &lt;/configuration&gt;                 &lt;/execution&gt;             &lt;/executions&gt;         &lt;/plugin&gt;         &lt;plugin&gt;             &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;             &lt;configuration&gt;                 &lt;archive&gt;                     &lt;manifest&gt;                         &lt;addClasspath&gt;true&lt;/addClasspath&gt;                         &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;                         &lt;mainClass&gt;${mainClass}&lt;/mainClass&gt;                     &lt;/manifest&gt;                 &lt;/archive&gt;             &lt;/configuration&gt;         &lt;/plugin&gt;     &lt;/plugins&gt; &lt;/build&gt; </code></pre>  <p><strong>Main Class:</strong></p>  <pre><code>package de.company.backend;  import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication;  @SpringBootApplication public class Application {    public static void main(String[] args) {     SpringApplication.run(Application.class, args);   } } </code></pre> ",
    "OwnerUserId": "10719574",
    "LastEditorUserId": "10719574",
    "LastEditDate": "2020-05-01T19:12:57.257",
    "LastActivityDate": "2021-03-12T10:06:12.867",
    "Title": "Error when running docker container 'NoClassDefFoundError'",
    "Tags": "<java><spring-boot><docker><maven>",
    "AnswerCount": "2",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>In your pom.xml, the <code>copy-dependencies</code> goal is specified at the <code>install</code> phase : too late the package of the jar was already done.  </p>  <blockquote>   <p>I am trying to dockerize a simple Spring Boot Application, built with   Maven.</p> </blockquote>  <p>You don't need to declare any plugin to create a fat jar with spring boot that could be run by a docker container.<br> Declaring these plugins is error prone (and should be used only in corner cases) while <a href='https://docs.spring.io/spring-boot/docs/current/maven-plugin/repackage-mojo.html' rel='nofollow noreferrer'>the <code>repackage</code> goal of the spring boot maven plugin</a> attached by default to the package phase of maven will create for you the fat jar : </p>  <blockquote>   <p>Repackages existing JAR and WAR archives so that they can be executed   from the command line using java -jar</p> </blockquote>  <p>Juste remove these plugins declarations and execute <code>mvn clean package</code> and it should be good.</p>  <p>Side note : </p>  <blockquote>   <p>FROM openjdk:latest</p> </blockquote>  <p>Don't use <code>latest</code> as image version but favor a specific version of the image othewhise you could have bad surprises.  As you use JDK 8, you could specify a JRE or a JDK 8 such as :  <code>FROM openjdk:8-jre-alpine</code>.   </p> ",
    "highest_rated_answer": "<p>I had the same problem as you.</p> <p>you need to add plugin in your pom.xml.</p> <pre><code>     &lt;build&gt;         &lt;plugins&gt;             &lt;plugin&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;             &lt;/plugin&gt;         &lt;/plugins&gt;     &lt;/build&gt;  </code></pre> <p>If you input as above, it works normally.</p> <p>and check MANIFEST.MF (in .jar file)</p> <pre><code>Main-Class: org.springframework.boot.loader.JarLauncher    Start-Class: {your main class} </code></pre> "
  },
  {
    "Id": "62994046",
    "PostTypeId": "1",
    "AcceptedAnswerId": "62994879",
    "CreationDate": "2020-07-20T11:07:48.717",
    "Score": "5",
    "ViewCount": "2521",
    "Body": "<p>Dockerfile:</p> <pre><code>FROM maven:3.6.3-openjdk-8 as builder # Set the working directory. WORKDIR /usr/src/mymaven COPY ./ /usr/src/mymaven CMD [ &quot;mvn&quot; , &quot;clean&quot; , &quot;install&quot; ]  FROM openjdk:8 COPY --from=builder /usr/src/mymaven/target /usr/src/myapp WORKDIR /usr/src/myapp CMD [&quot;java&quot;, &quot;-jar&quot; , &quot;Backend-0.0.1-SNAPSHOT.jar&quot;] </code></pre> <p>The above docker build fails with the error: target folder does not exist<br> The below dockerfile works perfectly:</p> <pre><code>FROM maven:3.6.3-openjdk-8 as builder # Set the working directory. WORKDIR /usr/src/mymaven COPY ./ /usr/src/mymaven RUN [ &quot;mvn&quot; , &quot;clean&quot; , &quot;install&quot; ]  FROM openjdk:8 COPY --from=builder /usr/src/mymaven/target /usr/src/myapp WORKDIR /usr/src/myapp CMD [&quot;java&quot;, &quot;-jar&quot; , &quot;Backend-0.0.1-SNAPSHOT.jar&quot;] </code></pre> <p>Just changing CMD to RUN fixed the issue. Why is this happening? I thought in the intermittent container, the cmd would execute which should make both the commands equivalent right?</p> ",
    "OwnerUserId": "12648193",
    "LastActivityDate": "2021-07-07T11:48:09.313",
    "Title": "Docker multi-stage build fails if we use CMD in dockerfile",
    "Tags": "<java><docker><maven><dockerfile><docker-multi-stage-build>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>In a multistage build, you may copy files from a previous step. Each step is considered as an individual, private <strong>image</strong>(in the scope of the multistage build).</p> <p><code>CMD</code> instruction however is not invoked at build time, it only applies at runtime as clearly stated in the <a href='https://docs.docker.com/engine/reference/builder/#cmd' rel='noreferrer'>official docs</a>:</p> <blockquote> <p>The main purpose of a CMD is to provide defaults for an <strong>executing container</strong>.</p> </blockquote> <p>Since you are currently building the result image, <code>CMD</code> is never executed thus you get the error you have reported.</p> <p>In the other hand, <code>RUN</code> instruction executes during build time making its result available for the next step. Quoting again from <a href='https://docs.docker.com/engine/reference/builder/#run' rel='noreferrer'>docs</a>:</p> <blockquote> <p><strong>The RUN instruction will execute any commands in a new layer on top of the current image and commit the results</strong>. The resulting committed image will be used for the next step in the Dockerfile.</p> </blockquote> <p>It should be clear by now why the multistage build completes successfully when <code>RUN</code> is used in contrast to <code>CMD</code> instruction.</p> <p>Your confusion started from wrongly assuming that the below is true:</p> <blockquote> <p>I thought in the intermittent container, the cmd would execute which should make both the commands equivalent right?</p> </blockquote> ",
    "highest_rated_answer": null
  },
  {
    "Id": "67579217",
    "PostTypeId": "1",
    "AcceptedAnswerId": "67586929",
    "CreationDate": "2021-05-18T02:34:38.193",
    "Score": "5",
    "ViewCount": "25242",
    "Body": "<p>Previously my build is running fine but all of a sudden it's failing with the below error.</p> <pre><code>Failed to collect dependencies at ar.com.fdvs:DynamicJasper:jar:5.3.0 -&gt; net.sf.jasperreports:jasperreports:jar:6.8.0 -&gt; com.lowagie:itext:jar:2.1.7.js6: Failed to read artifact descriptor for com.lowagie:itext:jar:2.1.7.js6: Could not transfer artifact com.lowagie:itext:pom:2.1.7.js6 from/to maven-default-http-blocker (http://0.0.0.0/): Blocked mirror for repositories: [jaspersoft-third-party (http://jaspersoft.jfrog.io/jaspersoft/third-party-ce-artifacts/, default, releases+snapshots), jr-ce-releases (http://jaspersoft.jfrog.io/jaspersoft/jr-ce-releases, default, releases+snapshots)] -&gt; [Help 1] [ERROR]  </code></pre> <p>These are the dependencies I am using in my code.</p> <pre><code>        &lt;dependency&gt;             &lt;groupId&gt;com.lowagie&lt;/groupId&gt;             &lt;artifactId&gt;itext&lt;/artifactId&gt;             &lt;version&gt;2.1.7.js6&lt;/version&gt;             &lt;scope&gt;compile&lt;/scope&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;ar.com.fdvs&lt;/groupId&gt;             &lt;artifactId&gt;DynamicJasper&lt;/artifactId&gt;             &lt;version&gt;5.3.1&lt;/version&gt;         &lt;/dependency&gt;         &lt;!-- https://mvnrepository.com/artifact/ar.com.fdvs/DynamicJasper-core-fonts --&gt;         &lt;dependency&gt;             &lt;groupId&gt;ar.com.fdvs&lt;/groupId&gt;             &lt;artifactId&gt;DynamicJasper-core-fonts&lt;/artifactId&gt;             &lt;version&gt;2.0&lt;/version&gt;         &lt;/dependency&gt; </code></pre> <p>I tried changing the DynamicJasper version also but no luck.</p> <p>In the docker file, I am using the below image as a base image.</p> <pre><code>FROM maven:3.6.0-jdk-11-slim AS build </code></pre> ",
    "OwnerUserId": "10195404",
    "LastEditorUserId": "10195404",
    "LastEditDate": "2021-05-18T05:11:58.580",
    "LastActivityDate": "2021-08-25T05:27:00.230",
    "Title": "maven build failing to download com.lowagie:itext:jar:2.1.7.js6 dependency",
    "Tags": "<java><docker><maven>",
    "AnswerCount": "5",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<pre><code>&lt;dependency&gt;   &lt;groupId&gt;com.lowagie&lt;/groupId&gt;   &lt;artifactId&gt;itext&lt;/artifactId&gt;   &lt;version&gt;4.2.0&lt;/version&gt; &lt;/dependency&gt;          </code></pre> <p>My issue resolved after adding this dependency.</p> ",
    "highest_rated_answer": "<p>if you run maven on linux .then use this</p> <pre><code>&lt;dependency&gt;     &lt;groupId&gt;net.sf.jasperreports&lt;/groupId&gt;     &lt;artifactId&gt;jasperreports&lt;/artifactId&gt;     &lt;version&gt;6.12.1&lt;/version&gt;     &lt;exclusions&gt;         &lt;exclusion&gt;             &lt;groupId&gt;com.lowagie&lt;/groupId&gt;             &lt;artifactId&gt;itext&lt;/artifactId&gt;         &lt;/exclusion&gt;     &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--        &quot;jasperreports&quot; can't resolve &quot;itext&quot; dependency on jenkins.so it added independently--&gt; &lt;dependency&gt;     &lt;groupId&gt;com.lowagie&lt;/groupId&gt;     &lt;artifactId&gt;itext&lt;/artifactId&gt;     &lt;version&gt;2.1.7&lt;/version&gt; &lt;/dependency&gt; </code></pre> "
  },
  {
    "Id": "69691678",
    "PostTypeId": "1",
    "CreationDate": "2021-10-23T20:08:25.050",
    "Score": "5",
    "ViewCount": "4333",
    "Body": "<p>I am developing small Spring Boot micro-service application. I am facing an issue when I am trying to create custom Spring image to deploy into Docker engine. To create new custom image I am using configuration element in Maven plugin section of my POM file.</p> <blockquote> <p>Error : Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:2.5.5:build-image (default-cli) on project BankModule: Execution default-cli of goal org.springframework.boot:spring-boot-maven-plugin:2.5.5:build-image failed: Unable to parse image reference &quot;kolludocker/ms1-BankModule:0.0.1-SNAPSHOT&quot;. Image reference must be in the form '[domainHost:port/][path/]name[:tag][@digest]', with 'path' and 'name' containing only [a-z0-9][.][_][-] -&gt; [Help 1] [ERROR]</p> </blockquote> <p>The <code>pom.xml</code> file :</p> <pre class='lang-xml prettyprint-override'><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;          xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;     &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;      &lt;parent&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;         &lt;version&gt;2.5.5&lt;/version&gt;         &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;     &lt;/parent&gt;      &lt;groupId&gt;com.kollu.BankModule&lt;/groupId&gt;     &lt;artifactId&gt;BankModule&lt;/artifactId&gt;     &lt;version&gt;0.0.1-SNAPSHOT     &lt;/version&gt;     &lt;name&gt;BankModule&lt;/name&gt;     &lt;description&gt;BankModule SpringBoot and MicroServices project     &lt;/description&gt;     &lt;properties&gt;         &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;         &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;         &lt;java.version&gt;1.8&lt;/java.version&gt;         &lt;spring-cloud.version&gt;2020.0.4&lt;/spring-cloud.version&gt; &lt;!-- Eureka server --&gt;     &lt;/properties&gt;     &lt;dependencies&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;!-- Eureka server --&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;             &lt;artifactId&gt;spring-cloud-starter&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;             &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;         &lt;/dependency&gt; &lt;!-- Inbuild LoadBalancer dependency--&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;             &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;!-- Fault tolerance- Circuit Breakers with resilience4j --&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;io.github.resilience4j&lt;/groupId&gt;             &lt;artifactId&gt;resilience4j-spring-boot2&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;!-- Distributed Tracing(To generate unique id per each logger) - sleuth,RabbitMQ,ZipKin --&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-sleuth-zipkin&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; --&gt;         &lt;!-- mvnrepository.com/artifact/org.springframework.boot/\u2026 --&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;             &lt;scope&gt;runtime&lt;/scope&gt;             &lt;optional&gt;true&lt;/optional&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;             &lt;scope&gt;test&lt;/scope&gt;         &lt;/dependency&gt;         &lt;!-- Oracle --&gt;         &lt;dependency&gt;             &lt;groupId&gt;com.oracle.database.jdbc&lt;/groupId&gt;             &lt;artifactId&gt;ojdbc8&lt;/artifactId&gt; &lt;!-- &lt;scope&gt;12.2.0.1&lt;/scope&gt; --&gt;             &lt;version&gt;12.2.0.1&lt;/version&gt;&lt;!--$NO-MVN-MAN-VER$--&gt;         &lt;/dependency&gt; &lt;!-- Swagger api --&gt;         &lt;dependency&gt;             &lt;groupId&gt;io.springfox&lt;/groupId&gt;             &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;             &lt;version&gt;2.7.0&lt;/version&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;io.springfox&lt;/groupId&gt;             &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;             &lt;version&gt;2.7.0&lt;/version&gt;         &lt;/dependency&gt;         &lt;!-- Field/ Input values validation --&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;         &lt;/dependency&gt;     &lt;/dependencies&gt; &lt;!-- Eureka server --&gt;     &lt;dependencyManagement&gt;         &lt;dependencies&gt;             &lt;dependency&gt;                 &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;                 &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;                 &lt;version&gt;${spring-cloud.version}&lt;/version&gt;                 &lt;type&gt;pom&lt;/type&gt;                 &lt;scope&gt;import&lt;/scope&gt;             &lt;/dependency&gt;         &lt;/dependencies&gt;     &lt;/dependencyManagement&gt;      &lt;build&gt;         &lt;plugins&gt;             &lt;plugin&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                 &lt;version&gt;2.5.5&lt;/version&gt;&lt;!--$NO-MVN-MAN-VER$--&gt;                 &lt;configuration&gt;                     &lt;image&gt;                         &lt;name&gt;kolludocker/ms1-${project.artifactId}:${project.version}&lt;/name&gt;                     &lt;/image&gt;                     &lt;pullPolicy&gt;IF_NOT_PRESENT&lt;/pullPolicy&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt;         &lt;/plugins&gt;     &lt;/build&gt; &lt;/project&gt; </code></pre> ",
    "OwnerUserId": "3185699",
    "LastEditorUserId": "466862",
    "LastEditDate": "2021-10-24T10:43:00.507",
    "LastActivityDate": "2022-08-09T06:40:47.473",
    "Title": "Unable to create custom image name in Spring Boot 2.5.5 with Docker",
    "Tags": "<java><spring-boot><docker><maven><microservices>",
    "AnswerCount": "2",
    "CommentCount": "4",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>The artifact id has capital letters in its name. The error given is telling:</p> <p>'path' and 'name' containing only <code>[a-z0-9][.][_][-]</code></p> <p>Once you make the artifact id &quot;BankModule&quot; to &quot;bank-module&quot;, this will work.</p> "
  },
  {
    "Id": "76387734",
    "PostTypeId": "1",
    "AcceptedAnswerId": "76389022",
    "CreationDate": "2023-06-02T06:43:32.930",
    "Score": "5",
    "ViewCount": "1152",
    "Body": "<p>I am trying to create an artifact using gcloud artifact registry and I ran the <code>gcloud init</code> command which was fine and then I ran the following command</p> <p><code>(venv) PS C:\\Users\\abc\\Python VS code projects\\project-name\\server&gt; gcloud artifacts repositories create repo-name --repository-format=docker --location=us-central1 --description=&quot;Docker repo description&quot;</code></p> <p>in doing so I came across the following error</p> <p><code>ERROR: (gcloud.artifacts.repositories.create) INVALID_ARGUMENT: Maven config is not supported for format &quot;DOCKER&quot;</code></p> <p>I have been using the same list of gcloud commands for creating artifact registries and using them and many other apis on google cloud console for some time but I have not come across this error. I have tried googling it but no avail. Any help would be appreciated. Thanks. Also my Docker file:</p> <pre><code> # run command to install all dependencies RUN pip install Flask gunicorn flask_wtf pyrebase4 firebase_admin httplib2==0.15.0 pycryptodome==3.10.1  # RUN pip install google-auth google-auth-oauthlib google-auth-httplib2 google-api-python-client  # now to copy our sourcre code to a folder in the container COPY src/ app/ # and set this container folder to working directory WORKDIR /app # here set environment variable for a port which we set in app.run command in app.py ENV PORT 8080 # run a command for gunicorn where we bind the ports,  # set workers to 1,  # set threads to 8, # bind the app  CMD exec gunicorn --bind :$PORT --workers 1 --threads 8 app:app``` </code></pre> ",
    "OwnerUserId": "9110576",
    "LastActivityDate": "2023-06-02T09:42:49.150",
    "Title": "Error on gcloud artifact registry: INVALID_ARGUMENT: Maven config is not supported for format 'DOCKER'",
    "Tags": "<docker><maven><gcloud>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>I found the solution to my problem <a href='https://github.com/google/app-reporting-pack' rel='noreferrer'>here on github</a>. It does not say what the reason for the problem was but the solution was to update gcloud components. I updated my Cloud SDK CLI by running following command in administrator mode.</p> <pre><code>gcloud components update </code></pre> ",
    "highest_rated_answer": null
  },
  {
    "Id": "27749193",
    "PostTypeId": "1",
    "AcceptedAnswerId": "31987595",
    "CreationDate": "2015-01-02T22:08:43.030",
    "Score": "46",
    "ViewCount": "100158",
    "Body": "<p>Building Docker images works in a desktop without a problem. Installing Node.js NPM dependencies work as usual. However, when using a continuous integration server such as Jenkins that is hosted behind a corporate proxy, the build Docker Images fail.</p>  <h2>Node.js NPM Dependencies</h2>  <p>While building Node.js pacakges, the command <strong>npm install</strong> fails when it cannot connect to GIT while cloning GIT dependencies.</p>  <pre><code>e1ce5e8407d1: Already exists Status: Image is up to date for node:0.10.33  ---&gt; e1ce5e8407d1 Step 1 : RUN mkdir -p /usr/src/app  ---&gt; Using cache  ---&gt; 965cad0c68b0 Step 2 : WORKDIR /usr/src/app  ---&gt; Using cache  ---&gt; 4c498f0c07e9 Step 3 : COPY package.json /usr/src/app/  ---&gt; b0662a8275fb Removing intermediate container 5aca20551452 Step 4 : RUN npm install  ---&gt; Running in 7ccf9e5362af npm WARN package.json newww@2.0.0 No README data npm WARN package.json Dependency 'async-cache' exists in both dependencies and devDependencies, using 'async-cache@^0.1.5' from dependencies npm ERR! git clone https://github.com/npm/npm2es.git Cloning into bare repository '/root/.npm/_git-remotes/https-github-com-npm-npm2es-git-60a75edb'... npm ERR! git clone https://github.com/npm/npm2es.git fatal: unable to access 'https://github.com/npm/npm2es.git/': Failed to connect to github.com port 443: Connection timed out </code></pre>  <h2>Java Maven, Ruby, Go Docker Images with Dependencies</h2>  <p>The same occurs when building Java, Ruby or Go containers, where dependencies are located in repository servers across your corporate Proxy server. </p>  <p>Knowing that you can configure Docker with HTTP_PROXY environment variable, how to properly configure Docker to properly build images in CI environments?</p> ",
    "OwnerUserId": "433814",
    "LastActivityDate": "2023-01-12T12:47:14.353",
    "Title": "How to build Docker Images with Dockerfile behind HTTP_PROXY by Jenkins?",
    "Tags": "<git><maven><npm><docker><dockerfile>",
    "AnswerCount": "8",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>Note: Docker 1.9 <em>might</em> help solve this:</p>  <ul> <li>'<a href='https://github.com/docker/docker/issues/14634'>Issue 14634</a>': <strong>Builder - Build-time argument passing</strong> (e.g., <code>HTTP_PROXY</code>)</li> <li>'<a href='https://github.com/docker/docker/pull/15182'>PR 15182</a>': <strong>Support for passing build-time variables in build context</strong></li> </ul>  <p>Usage (proposed):</p>  <pre><code>docker build --build-arg http_proxy=http://my.proxy.url  --build-arg foo=bar &lt;&lt;MARK FROM busybox RUN &lt;command that need http_proxy&gt; ARG --description='foo's description' foo USER $foo MARK </code></pre> ",
    "highest_rated_answer": "<p>Docker has multiple ways to set proxies that take effect at different times.</p> <hr> <p>If your <code>docker build</code> has to <strong>retrieve a base image through a proxy</strong>, you'll want to specify <code>build-arg</code>s:</p> <pre><code>docker build --build-arg HTTP_PROXY=$http_proxy \\ --build-arg HTTPS_PROXY=$http_proxy --build-arg NO_PROXY=&quot;$no_proxy&quot; \\ --build-arg http_proxy=$http_proxy --build-arg https_proxy=$http_proxy \\ --build-arg no_proxy=&quot;$no_proxy&quot; -t myContainer /path/to/Dockerfile/directory </code></pre> <p>where <code>$http_proxy</code> and <code>$no_proxy</code> were set in my bashrc. I used both <code>HTTP_PROXY</code> and <code>http_proxy</code> because different utilities will check different variables (<code>curl</code> checks both, <code>wget</code> only checks the lowercase ones, etc).</p> <hr> <p>If your <code>docker build</code> has a <strong><code>RUN curl/wget/etc</code> command that has to go through the proxy</strong>, you'll need to specify an environment variable inside your docker image:</p> <pre><code>ENV https_proxy=http://proxy-us02.company.com:8080 ENV http_proxy=http://proxy-us02.company.com:8080 ENV HTTP_PROXY=http://proxy-us02.company.com:8080 ENV HTTPS_PROXY=http://proxy-us02.company.com:8080 ENV no_proxy=&quot;localhost,localdomain,127.0.0.1,etc&quot; ENV NO_PROXY=&quot;localhost,localdomain,127.0.0.1,etc&quot; </code></pre> <p>If you don't want this environment variable inside your image at runtime, you can remove all these at the end:</p> <pre><code>RUN unset http_proxy https_proxy no_proxy HTTP_PROXY HTTPS_PROXY NO_PROXY </code></pre> "
  },
  {
    "Id": "34657902",
    "PostTypeId": "1",
    "CreationDate": "2016-01-07T14:41:27.080",
    "Score": "4",
    "ViewCount": "4462",
    "Body": "<p>I'm trying to have docker images for a maven Java project built and pushed in the install and deploy phases respectively; and I'd like those images to be tagged with the current git commit id.</p>  <p>The problem that I am facing is that the <a href='https://github.com/ktoso/maven-git-commit-id-plugin/' rel='nofollow'>maven-git-commit-plugin</a> does not seem to export the <code>${git.commit.id.abbrev}</code> variable correctly for consumption in <a href='https://github.com/spotify/docker-maven-plugin' rel='nofollow'>docker-maven-plugin</a>.</p>  <p>My parent <code>pom.xml</code> goes like this:</p>  <pre><code>&lt;?xml version='1.0' encoding='UTF-8'?&gt; &lt;project xmlns='http://maven.apache.org/POM/4.0.0'          xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'          xsi:schemaLocation='http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd'&gt;      &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;         &lt;name&gt;myproject&lt;/name&gt;      &lt;groupId&gt;mygroup&lt;/groupId&gt;     &lt;artifactId&gt;myartifact&lt;/artifactId&gt;     &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;     &lt;packaging&gt;pom&lt;/packaging&gt;      &lt;modules&gt;         &lt;module&gt;mymodule&lt;/module&gt;     &lt;/modules&gt;      &lt;properties&gt;          &lt;!-- dependency versions --&gt;                &lt;!-- some stuff here...--&gt;         &lt;!-- plugin versions --&gt;         &lt;maven.enforcer.plugin.version&gt;1.4.1&lt;/maven.enforcer.plugin.version&gt;         &lt;maven.shade.plugin.version&gt;2.4.2&lt;/maven.shade.plugin.version&gt;         &lt;scala.maven.plugin.version&gt;3.2.2&lt;/scala.maven.plugin.version&gt;         &lt;com.spotify.docker.plugin.version&gt;0.3.8&lt;/com.spotify.docker.plugin.version&gt;     &lt;/properties&gt;      &lt;dependencyManagement&gt;         &lt;dependencies&gt;            &lt;!-- some stuff here...--&gt;         &lt;/dependencies&gt;     &lt;/dependencyManagement&gt;      &lt;build&gt;          &lt;pluginManagement&gt;             &lt;plugins&gt;                 &lt;plugin&gt;                     &lt;groupId&gt;com.spotify&lt;/groupId&gt;                     &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;                     &lt;version&gt;${com.spotify.docker.plugin.version}&lt;/version&gt;                     &lt;executions&gt;                         &lt;execution&gt;                             &lt;id&gt;docker-build&lt;/id&gt;                             &lt;goals&gt;                                 &lt;goal&gt;build&lt;/goal&gt;                             &lt;/goals&gt;                             &lt;phase&gt;install&lt;/phase&gt;                         &lt;/execution&gt;                         &lt;execution&gt;                             &lt;id&gt;docker-push&lt;/id&gt;                             &lt;goals&gt;                                 &lt;goal&gt;push&lt;/goal&gt;                             &lt;/goals&gt;                             &lt;phase&gt;deploy&lt;/phase&gt;                         &lt;/execution&gt;                     &lt;/executions&gt;                     &lt;configuration&gt;                         &lt;forceTags&gt;true&lt;/forceTags&gt;                         &lt;baseImage&gt;java&lt;/baseImage&gt;                     &lt;/configuration&gt;                 &lt;/plugin&gt;                  &lt;plugin&gt;                     &lt;groupId&gt;pl.project13.maven&lt;/groupId&gt;                     &lt;artifactId&gt;git-commit-id-plugin&lt;/artifactId&gt;                     &lt;version&gt;2.2.0&lt;/version&gt;                     &lt;executions&gt;                         &lt;execution&gt;                             &lt;goals&gt;                                 &lt;goal&gt;revision&lt;/goal&gt;                             &lt;/goals&gt;                         &lt;/execution&gt;                     &lt;/executions&gt;                      &lt;configuration&gt;                         &lt;dateFormatTimeZone&gt;${user.timezone}&lt;/dateFormatTimeZone&gt;                         &lt;verbose&gt;true&lt;/verbose&gt;                     &lt;/configuration&gt;                 &lt;/plugin&gt;              &lt;/plugins&gt;         &lt;/pluginManagement&gt;          &lt;plugins&gt;         &lt;/plugins&gt;      &lt;/build&gt; &lt;/project&gt; </code></pre>  <p>And my plugins part of my module pom.xml:</p>  <pre><code>        &lt;plugin&gt;             &lt;groupId&gt;com.spotify&lt;/groupId&gt;             &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;             &lt;configuration&gt;                 &lt;imageName&gt;docker-registry.nexus.bazaarvoice.com/${project.parent.artifactId}-${project.artifactId}:${git.commit.id.abbrev}&lt;/imageName&gt;                 &lt;entryPoint&gt;['java', '-jar', '/${project.build.finalName}.jar']&lt;/entryPoint&gt;                 &lt;!-- copy the service's jar file from target into the root directory of the image --&gt;                 &lt;resources&gt;                     &lt;resource&gt;                         &lt;targetPath&gt;/&lt;/targetPath&gt;                         &lt;directory&gt;${project.build.directory}&lt;/directory&gt;                         &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;                     &lt;/resource&gt;                     &lt;resource&gt;                         &lt;targetPath&gt;config&lt;/targetPath&gt;                         &lt;directory&gt;${project.parent.basedir}/deploy/config/${project.artifactId}&lt;/directory&gt;                         &lt;include&gt;*&lt;/include&gt;                     &lt;/resource&gt;                 &lt;/resources&gt;             &lt;/configuration&gt;         &lt;/plugin&gt; </code></pre>  <p>I'm getting the following error:</p>  <pre><code>[ERROR] Failed to execute goal com.spotify:docker-maven-plugin:0.3.8:build (docker-build) on project service: Exception caught: The template variable 'git.commit.id.abbrev' has no value -&gt; [Help 1] </code></pre>  <p>I've tried switching to <a href='http://www.mojohaus.org/buildnumber-maven-plugin/' rel='nofollow'>buildnumber-plugin</a> but I get the same kind of error (using <code>${buildNumber}</code> instead of <code>${git.commit.id.abbrev}</code>).</p>  <p>What I am missing? Is the docker plugin executing before the git commit id plugin sets the variables?</p> ",
    "OwnerUserId": "106979",
    "LastActivityDate": "2017-05-10T20:54:48.893",
    "Title": "How do I use the git commit id as a docker image tag in maven?",
    "Tags": "<git><maven><docker>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>I had a similar problem since I was invoking the plugin directly (I have not bound the plugin phases in my pom, so I have to invoke it explicitly):</p>  <pre><code>mvn -f myModule/pom.xml docker:build -DforceTags -DpushImage </code></pre>  <p>With the plugin conf:</p>  <pre class='lang-xml prettyprint-override'><code>  &lt;plugin&gt;     &lt;groupId&gt;com.spotify&lt;/groupId&gt;     &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;     &lt;configuration&gt;         &lt;imageName&gt;registry/myModule&lt;/imageName&gt;         &lt;imageTags&gt;             &lt;imageTag&gt;${project.version}&lt;/imageTag&gt;             &lt;imageTag&gt;latest&lt;/imageTag&gt;             &lt;imageTag&gt;${git.commit.id.abbrev}&lt;/imageTag&gt;         &lt;/imageTags&gt;         &lt;baseImage&gt;java&lt;/baseImage&gt;         &lt;entryPoint&gt;             ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/${project.build.finalName}.jar']         &lt;/entryPoint&gt;         &lt;resources&gt;             &lt;resource&gt;                 &lt;targetPath&gt;/&lt;/targetPath&gt;                 &lt;directory&gt;${project.build.directory}&lt;/directory&gt;                 &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;             &lt;/resource&gt;         &lt;/resources&gt;     &lt;/configuration&gt; &lt;/plugin&gt; </code></pre>  <p>Since the <a href='https://github.com/ktoso/maven-git-commit-id-plugin/' rel='nofollow'>maven-git-commit-plugin</a> is bound to the initialize phase, I had to invoke that phase so the git plugin populated the property</p>  <pre><code>mvn initialize -f myModule/pom.xml docker:build -DforceTags -DpushImage </code></pre> "
  },
  {
    "Id": "35905590",
    "PostTypeId": "1",
    "CreationDate": "2016-03-10T00:49:13.517",
    "Score": "4",
    "ViewCount": "794",
    "Body": "<p>I'm an inexperienced docker user and I'm trying to dockerize my maven web application using Oracle. When I try to build using my maven image it fails saying: 'Could not find artifact com.oracle:ojdbc14:jar:10.2.0.4.0 in central' which is expected since I have not included the driver anywhere. </p>  <p>My question is how can I make docker aware of the driver's location and thereby be able to build the app? Thanks</p> ",
    "OwnerUserId": "3915515",
    "LastActivityDate": "2016-03-10T05:51:22.297",
    "Title": "Dockerizing a maven app that uses oracle-ojdbc: How do you get the driver in there?",
    "Tags": "<java><oracle><maven><docker>",
    "AnswerCount": "1",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<blockquote>   <p>When I try to build using my maven image it fails saying: 'Could not find artifact com.oracle:ojdbc14:jar:10.2.0.4.0 in central' which is expected since I have not included the driver anywhere. </p> </blockquote>  <p>You would need to reproduce in your Dockerfile the same setup (same M2_HOME, sans m2/repository settings) as the one which is working on your host (without docker)</p>  <p>You could start your Dockerfile from a <a href='https://hub.docker.com/_/maven/' rel='nofollow'>maven image</a>, or, as <a href='https://github.com/carlossg/docker-maven/blob/master/jdk-8/Dockerfile' rel='nofollow'>in this Dockerfile</a>, from a jdk image, installing maven yourself, and deploying your missing jar the same way you would on your host.</p> "
  },
  {
    "Id": "36429949",
    "PostTypeId": "1",
    "AcceptedAnswerId": "36541364",
    "CreationDate": "2016-04-05T14:55:53.667",
    "Score": "4",
    "ViewCount": "2416",
    "Body": "<p>I have a docker/jvm instance, which I use from the command line to compile and run java code. IntelliJ's project config requires me to point at a jvm on the filesystem. </p>  <p>So, I was wondering, can I configure intellij to use this docker container? I suppose I could configure a docker container, keep it running, and mount/share its filesystem, but I don't want that -- I want to use my ephemeral container instance.</p>  <p>I have the same idea for using maven -- can I use a docker instance of maven without mounting the filesystem, from within intellij? Again, intellij seems to require a pointer to a filesystem location for maven, so this seems problematic.</p>  <p>Does anyone have any clue if this is possible, or how to go about configuring such a thing?</p> ",
    "OwnerUserId": "2051454",
    "LastActivityDate": "2016-04-12T11:57:07.527",
    "Title": "IntelliJ: use docker jvm or docker maven?",
    "Tags": "<java><maven><intellij-idea><docker><ide>",
    "AnswerCount": "2",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<blockquote>   <p>Again, intellij seems to require a pointer to a filesystem location for maven, so this seems problematic.</p> </blockquote>  <p>The only way for an application to use another <em>containerized</em> one would be for that application itself to be in the same container (or to mount a data volume from another container, which avoids mounting the local filesystem)</p>  <p>So using something like <a href='https://hub.docker.com/r/dlsniper/docker-intellij/' rel='nofollow'><code>dlsniper/docker-intellij/</code></a> (used for go, but easily adapted for java) would work, and allow an IntelliJ <em>container</em> to</p>  <ul> <li>share the X11 socket in order to see the containerized application on the host desktop,</li> <li>uses <strong>data volumes</strong> (again, without mounting a local filesystem directly):  <ul> <li>data-volume for the jvm</li> <li>data-volume for the java sources</li> </ul></li> </ul> ",
    "highest_rated_answer": "<p>If you're on a posix system, you can make a simple executable shell script that takes command line argument and forwards those to:</p>  <pre><code>docker exec [OPTIONS] CONTAINER COMMAND [ARGS...] </code></pre>  <p>This may even work on Windows with a batch file.</p>  <p>One problem is when you have to pass in file paths. A solution could be to mount the working directory at an identical path in the container, as on the host.</p>  <p>Don't forget the <a href='https://en.wikipedia.org/wiki/Shebang_(Unix)' rel='nofollow'>shebang</a> if you go for a shell script.</p>  <p>On Windows, a filepath may be 'unixified' in a batch file like this:</p>  <pre><code>set FILEPATH=%FILEPATH:C:=/c% set FILEPATH=%FILEPATH:\\=/%  </code></pre> "
  },
  {
    "Id": "38972644",
    "PostTypeId": "1",
    "AcceptedAnswerId": "38975024",
    "CreationDate": "2016-08-16T10:34:52.690",
    "Score": "4",
    "ViewCount": "3690",
    "Body": "<p>I am using spotify's Docker maven plugin and want in to build two different images, one is a database (MariaDB) and the other is a Java EE image (Glassfish).</p>  <p>I have managed to get Maven to build the images OK when ran seperately however when I try and run both in the same POM file it will only create the first image. </p>  <p>I have tried putting two configuration sections within the single plugin and get the error below:</p>  <blockquote>   <p>[ERROR]     Non-parseable POM C:\\Users\\607819425\\Documents\\InteliJProjects\\feature_docker\\pom.xml: Duplicated tag: 'configuration' (position:START_TAG seen ...\\r\\n                ... @300:32)  @line 300, column 32 -> [Help 2]</p> </blockquote>  <p>Pom file with 2 configuration tags in one plugin</p>  <pre><code>            &lt;plugin&gt;             &lt;groupId&gt;com.spotify&lt;/groupId&gt;             &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;             &lt;version&gt;0.4.11&lt;/version&gt;             &lt;configuration&gt;                 &lt;imageName&gt;glassfish&lt;/imageName&gt;                 &lt;dockerDirectory&gt;glassfish&lt;/dockerDirectory&gt;                 &lt;baseImage&gt;java&lt;/baseImage&gt;                 &lt;entryPoint&gt;['java', '-jar', '/${project.build.finalName}.jar']&lt;/entryPoint&gt;                 &lt;!-- copy the service's jar file from target into the root directory of the image --&gt;                 &lt;resources&gt;                     &lt;resource&gt;                         &lt;targetPath&gt;/&lt;/targetPath&gt;                         &lt;directory&gt;${project.build.directory}&lt;/directory&gt;                         &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;                     &lt;/resource&gt;                 &lt;/resources&gt;             &lt;/configuration&gt;             &lt;configuration&gt;                 &lt;imageName&gt;mariadb&lt;/imageName&gt;                 &lt;dockerDirectory&gt;mariadb&lt;/dockerDirectory&gt;                 &lt;baseImage&gt;java&lt;/baseImage&gt;                 &lt;entryPoint&gt;['java', '-jar', '/${project.build.finalName}.jar']&lt;/entryPoint&gt;                 &lt;!-- copy the service's jar file from target into the root directory of the image --&gt;                 &lt;resources&gt;                     &lt;resource&gt;                         &lt;targetPath&gt;/&lt;/targetPath&gt;                         &lt;directory&gt;${project.build.directory}&lt;/directory&gt;                         &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;                     &lt;/resource&gt;                 &lt;/resources&gt;             &lt;/configuration&gt;         &lt;/plugin&gt; </code></pre>  <p>And Also with two seperate plugins it only every builds the first image. </p>  <p>Two Plugin POM:</p>  <pre><code>&lt;plugin&gt;             &lt;groupId&gt;com.spotify&lt;/groupId&gt;             &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;             &lt;version&gt;0.4.11&lt;/version&gt;             &lt;configuration&gt;                 &lt;imageName&gt;glassfish&lt;/imageName&gt;                 &lt;dockerDirectory&gt;glassfish&lt;/dockerDirectory&gt;                 &lt;baseImage&gt;java&lt;/baseImage&gt;                 &lt;entryPoint&gt;['java', '-jar', '/${project.build.finalName}.jar']&lt;/entryPoint&gt;                 &lt;!-- copy the service's jar file from target into the root directory of the image --&gt;                 &lt;resources&gt;                     &lt;resource&gt;                         &lt;targetPath&gt;/&lt;/targetPath&gt;                         &lt;directory&gt;${project.build.directory}&lt;/directory&gt;                         &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;                     &lt;/resource&gt;                 &lt;/resources&gt;             &lt;/configuration&gt;         &lt;/plugin&gt;         &lt;plugin&gt;             &lt;groupId&gt;com.spotify&lt;/groupId&gt;             &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;             &lt;version&gt;0.4.11&lt;/version&gt;             &lt;configuration&gt;                 &lt;imageName&gt;mariadb&lt;/imageName&gt;                 &lt;dockerDirectory&gt;mariadb&lt;/dockerDirectory&gt;                 &lt;baseImage&gt;java&lt;/baseImage&gt;                 &lt;entryPoint&gt;['java', '-jar', '/${project.build.finalName}.jar']&lt;/entryPoint&gt;                 &lt;!-- copy the service's jar file from target into the root directory of the image --&gt;                 &lt;resources&gt;                     &lt;resource&gt;                         &lt;targetPath&gt;/&lt;/targetPath&gt;                         &lt;directory&gt;${project.build.directory}&lt;/directory&gt;                         &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;                     &lt;/resource&gt;                 &lt;/resources&gt;             &lt;/configuration&gt;         &lt;/plugin&gt; </code></pre>  <p>Any info you could give would be great!</p> ",
    "OwnerUserId": "2904135",
    "LastActivityDate": "2016-10-11T22:57:15.380",
    "Title": "Spotify docker maven build multiple images",
    "Tags": "<java><maven><docker><spotify>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>I Switched to Fabric8.io's version of the plugin in the end as multiple images are supported.</p>  <p><a href='https://dmp.fabric8.io/' rel='nofollow'>Fabric 8 Docker Maven Plugin</a></p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "39240560",
    "PostTypeId": "1",
    "CreationDate": "2016-08-31T04:06:00.197",
    "Score": "4",
    "ViewCount": "8109",
    "Body": "<p>I'm using spring boot and am trying to set it up with <strong><em>Docker</em></strong>. I've tried everything I could find on google and nothing seems to get me going. I'm running </p>  <pre><code> mvn clean package docker:build  </code></pre>  <p>Running this will do the spring-boot tests, run DB migrations, build the JAR, and then when it comes to Building the <strong><em>Docker image</em></strong>, I get the following error:</p>  <pre><code>Failed to execute goal com.spotify:docker-maven-plugin:0.4.9:build (default-cli)  on project app: Exception caught: java.util.concurrent.ExecutionException: com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: javax.net.ssl.SSLHandshakeException:  sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException:  unable to find valid certification path to requested target -&gt; [Help 1] </code></pre>  <p>Here is the Dockerfile I'm using:</p>  <pre><code>FROM java:8-jdk export DOCKER_TLS_VERIFY='1' export DOCKER_HOST='tcp://192.168.99.100:2376' export DOCKER_CERT_PATH='/Users/james/.docker/machine/machines/default' export DOCKER_MACHINE_NAME='default' EXPOSE 8080 VOLUME /tmp ADD app-0.0.1-SNAPSHOT.jar app.jar RUN sh -c 'touch /app.jar' ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre>  <p>And here is my docker-maven-plugin configuration:</p>  <pre><code> ... pom stuff &lt;docker.image.prefix&gt;jamesone1&lt;/docker.image.prefix&gt;     ... other pom stufff &lt;plugin&gt;     &lt;groupId&gt;com.spotify&lt;/groupId&gt;     &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;     &lt;version&gt;0.4.9&lt;/version&gt;     &lt;configuration&gt;             &lt;dockerHost&gt;https://192.168.99.100:2376&lt;/dockerHost&gt;             &lt;imageName&gt;${docker.image.prefix}/${project.artifactId}&lt;/imageName&gt;             &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt;              &lt;resources&gt;                 &lt;resource&gt;                     &lt;targetPath&gt;/&lt;/targetPath&gt;                     &lt;directory&gt;${project.build.directory}&lt;/directory&gt;                     &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;                 &lt;/resource&gt;             &lt;/resources&gt;     &lt;/configuration&gt; &lt;/plugin&gt; </code></pre>  <p>I'm using the dock for mac &amp; am using a <strong><em>docker-machine</em></strong> with the following env: </p>  <pre><code>export DOCKER_TLS_VERIFY='1' export DOCKER_HOST='tcp://192.168.99.100:2376' export DOCKER_CERT_PATH='/Users/james/.docker/machine/machines/default' export DOCKER_MACHINE_NAME='default' </code></pre>  <p>What's going on?! Am I missing something?</p> ",
    "OwnerUserId": "4140346",
    "LastActivityDate": "2017-01-12T20:54:53.660",
    "Title": "Spring boot with docker unable to find valid certification path to requested target error",
    "Tags": "<spring><maven><docker><spring-boot>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>fixed this in windows 10 by:</p>  <pre><code>        &lt;plugin&gt;             &lt;groupId&gt;com.spotify&lt;/groupId&gt;             &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;             &lt;version&gt;0.4.13&lt;/version&gt;             &lt;configuration&gt;                 &lt;imageName&gt;yourImageName&lt;/imageName&gt;                 &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt;                 &lt;dockerHost&gt;https://192.168.99.100:2376&lt;/dockerHost&gt;                 &lt;dockerCertPath&gt;/Users/your_user/.docker/machine/machines/default&lt;/dockerCertPath&gt;                 &lt;resources&gt;                     &lt;resource&gt;                         &lt;targetPath&gt;/&lt;/targetPath&gt;                         &lt;directory&gt;${project.build.directory}&lt;/directory&gt;                         &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;                     &lt;/resource&gt;                 &lt;/resources&gt;             &lt;/configuration&gt;         &lt;/plugin&gt; </code></pre>  <p>Important are these two tags:</p>  <pre><code>&lt;dockerHost&gt;https://192.168.99.100:2376&lt;/dockerHost&gt; &lt;dockerCertPath&gt;/Users/your_user/.docker/machine/machines/default&lt;/dockerCertPath&gt; </code></pre>  <p>I am using a dockerfile, which path you have to define with this tag:</p>  <pre><code>&lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt;   </code></pre>  <p>Now you can build your jar and generate docker image via: </p>  <p>mvn package docker:build</p>  <p>I think on mac just follwing value has to be different:</p>  <pre><code>&lt;dockerCertPath&gt;/Users/your_user/.docker/machine/machines/default&lt;/dockerCertPath&gt; </code></pre> "
  },
  {
    "Id": "39977955",
    "PostTypeId": "1",
    "AcceptedAnswerId": "39978198",
    "CreationDate": "2016-10-11T13:06:39.467",
    "Score": "4",
    "ViewCount": "3568",
    "Body": "<p>I have a Maven project. I'm running my Maven builds inside Docker. But the problem with that is it downloads all of the Maven dependencies every time I run it and it does not cache any of those Maven downloads. </p>  <p>I found some work arounds for that, where you mount your local .m2 folder into Docker container. But this will make the builds depend on local setup. What I would like to do is to create a volume (long live) and link/mount that volume to <code>.m2</code> folder inside Docker. That way when I run the Docker build for the 2nd time, it will not download everything. And it will not be dependent on environment.</p>  <p>How can I do this with docker-compose?</p> ",
    "OwnerUserId": "393639",
    "LastEditorUserId": "1228454",
    "LastEditDate": "2016-10-11T13:42:48.680",
    "LastActivityDate": "2016-10-11T13:42:48.680",
    "Title": "How to mount docker volume into my docker project using compose?",
    "Tags": "<maven><docker><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "4",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>Without knowing your exact configuration, I would use something like this...</p>  <pre><code>version: '2'  services:   maven:     image: whatever     volumes:       - m2-repo:/home/foo/.m2/repository  volumes:   m2-repo: </code></pre>  <p>This will create a data volume called <code>m2-repo</code> that is mapped to the <code>/home/foo/.m2/repository</code> (adjust path as necessary). The data volume will survive up/down/start/stop of the Docker Compose project.</p>  <p>You can delete the volume by running something like <code>docker-compose down -v</code>, which will destroy containers and volumes.</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "40522967",
    "PostTypeId": "1",
    "AcceptedAnswerId": "40538176",
    "CreationDate": "2016-11-10T08:26:46.197",
    "Score": "4",
    "ViewCount": "2812",
    "Body": "<p>I'm trying to build my java project on a GitLab server using Maven in Docker. Because I use 3rd party jars, I install them locally using the install-file plugin. This is/seems succesfull both on my local machine, as on the Docker:</p>  <pre><code>$ mvn install:install-file -Dfile=lib/customArtifact-1.0.jar -DgroupId=customArtifact -DartifactId=customArtifact -Dversion=1.0 -Dpackaging=jar [INFO] Scanning for projects... [INFO] [INFO] ------------------------------------------------------------------------ [INFO] Building myProject 1.0-SNAPSHOT [INFO] ------------------------------------------------------------------------ [INFO] [INFO] --- maven-install-plugin:2.4:install-file (default-cli) @ myProject --- [INFO] Installing /builds/gitlab/myProject-groep/myProject/lib/customArtifact-1.0.jar to /root/.m2/repository/customArtifact/customArtifact/1.0/customArtifact-1.0.jar [INFO] Installing /tmp/mvninstall2011198835315637645.pom to /root/.m2/repository/customArtifact/customArtifact/1.0/customArtifact-1.0.pom [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 1.191 s [INFO] Finished at: 2016-11-10T07:35:47+00:00 [INFO] Final Memory: 8M/144M [INFO] ------------------------------------------------------------------------ </code></pre>  <p>But on the Docker I get this error, which is absent on my local machine:</p>  <pre><code>$ mvn --batch-mode --quiet clean install -DskipTests [ERROR] Failed to execute goal on project myProject: Could not resolve  dependencies for project groupId:myProject:jar:1.0-SNAPSHOT: Failed to  collect dependencies at customArtifact:customArtifact:jar:1.0: Failed  to read artifact descriptor for customArtifact:customArtifact:jar:1.0:      Could not transfer artifact customArtifact:customArtifact:pom:1.0       from/to myProject_dependencies (/builds/gitlab/myProject-groep/       myProject/lib): Cannot access /builds/gitlab/myProject-groep/       myProject/lib with type default using the available connector        factories: BasicRepositoryConnectorFactory: Cannot access        /builds/gitlab/myProject-groep/myProject/lib using the registered       transporter factories: WagonTransporterFactory: Unsupported        transport protocol -&gt; [Help 1] </code></pre>  <p>I really don't get what is wrong here. Am I missing something in my path, environmental variable? It should be something minor, as I'm literally doing the same locally.</p>  <p>Help is much appreciated!</p>  <p><strong>EDIT</strong>:</p>  <p>I'm using this Docker <a href='https://github.com/carlossg/docker-maven/blob/33eeccbb0ce15440f5ccebcd87040c6be2bf9e91/jdk-7/Dockerfile' rel='nofollow noreferrer'>maven:3-jdk-7</a>, </p>  <pre><code>  FROM openjdk:7-jdk    ARG MAVEN_VERSION=3.3.9   ARG USER_HOME_DIR='/root'    RUN mkdir -p /usr/share/maven /usr/share/maven/ref \\     &amp;&amp; curl -fsSL http://apache.osuosl.org/maven/maven-3/$MAVEN_VERSION/binaries/apache-maven-$MAVEN_VERSION-bin.tar.gz \\       | tar -xzC /usr/share/maven --strip-components=1 \\     &amp;&amp; ln -s /usr/share/maven/bin/mvn /usr/bin/mvn    ENV MAVEN_HOME /usr/share/maven   ENV MAVEN_CONFIG '$USER_HOME_DIR/.m2'    COPY mvn-entrypoint.sh /usr/local/bin/mvn-entrypoint.sh   COPY settings-docker.xml /usr/share/maven/ref/    VOLUME '$USER_HOME_DIR/.m2'    ENTRYPOINT ['/usr/local/bin/mvn-entrypoint.sh']   CMD ['mvn']which is found here </code></pre>  <p>settings-docker.xml</p>  <pre><code>&lt;settings xmlns='http://maven.apache.org/SETTINGS/1.0.0'           xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'           xsi:schemaLocation='http://maven.apache.org/SETTINGS/1.0.0           https://maven.apache.org/xsd/settings-1.0.0.xsd'&gt;     &lt;localRepository&gt;/usr/share/maven/ref/repository&lt;/localRepository&gt; &lt;/settings&gt; </code></pre> ",
    "OwnerUserId": "4613730",
    "LastEditorUserId": "2998222",
    "LastEditDate": "2016-11-11T01:38:02.693",
    "LastActivityDate": "2016-11-11T01:38:02.693",
    "Title": "Maven install-file not effective in GitLab/Docker: 'could not resolve dependencies for project'",
    "Tags": "<java><maven><docker><gitlab>",
    "AnswerCount": "1",
    "CommentCount": "7",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p><strong>Localy</strong> </p>  <p>Installing thrid-party libraries using <code>mvn install:install-file</code> will install them by default in /.m2/repository. Then <code>mvn clean install</code> will pick them from default repository i.e /.m2/repository.</p>  <p><strong>In docker container</strong></p>  <p>Installing thrid-party libraries using <code>mvn install:install-file</code> will install them in <code>/usr/share/maven/ref/repository</code> (inside the container) as defined in settings-docker.xml. Then <code>mvn clean install</code> will pick them from <code>/usr/share/maven/ref/repository</code>.</p>  <p>The issue is that maven is looking for dependencies in <code>/builds/gitlab/myProject-groep/myProject/lib</code> as defined in pom file, but this directory is not exposed to docker container.</p>  <pre><code>&lt;repositories&gt;     &lt;repository&gt;          &lt;id&gt;myProject_dependencies&lt;/id&gt;         &lt;url&gt;${basedir}/lib/&lt;/url&gt;     &lt;/repository&gt; &lt;/repositories&gt; </code></pre>  <p>Removing repositories section from pom file should resolve the issue.</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "40757987",
    "PostTypeId": "1",
    "AcceptedAnswerId": "40771333",
    "CreationDate": "2016-11-23T07:01:53.567",
    "Score": "4",
    "ViewCount": "2681",
    "Body": "<p>I'm building a custom image that contains my java app. Basically I'm calling <code>mvn clean install</code> inside the <code>Dockerfile</code>. I'm using this <code>RUN mvn -T 1C clean install</code> in order to speed up the process. </p>  <p>This will use 1 thread per available CPU core. Will this be enough? How does mvn calculate the available cpu cores? Do I have to do something in order to tell it to check the host's CPUs and not the VM's? I'm using Docker for Mac (which internally uses xhyve as far as I know).</p>  <p>Update:</p>  <p>I'm building one module (fat jar, spring boot application with tomcat embedded), maven 3.3.9, about 30 mins of total duration without the thread boost. The huge overhead is that it downloads dependencies from my private repo in S3.</p> ",
    "OwnerUserId": "1138559",
    "LastEditorUserId": "1138559",
    "LastEditDate": "2016-11-23T08:46:01.667",
    "LastActivityDate": "2016-11-23T17:59:12.100",
    "Title": "Multithreading during image build",
    "Tags": "<java><maven><docker>",
    "AnswerCount": "1",
    "CommentCount": "9",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>According to my humble opinion I think that build application by maven inside Dockerfile get more issues than benefits.</p>  <p>When you run new  build maven cache is empty so your build spend many time to download all dependencis.</p>  <p>Changing threds used by build do not give you any performance boost.</p>  <p>You can try prepare one docker image with maven and try run some maven command to populate maven cache in this image build. Next you use this image as base for your project. </p>  <p>Another solution maybe separate download dependency and build in two RUN, thanks docker cache your next build may be faster.</p>  <pre><code>RUN mvn dependency:go-offline RUN mvn clean install </code></pre> ",
    "highest_rated_answer": null
  },
  {
    "Id": "41261750",
    "PostTypeId": "1",
    "CreationDate": "2016-12-21T11:28:20.540",
    "Score": "4",
    "ViewCount": "12810",
    "Body": "<p>I'm trying to run Maven in Docker.</p>  <p>So I pulled the image from her <a href='https://hub.docker.com/_/maven/' rel='nofollow noreferrer'>https://hub.docker.com/_/maven/</a>.</p>  <pre><code>docker pull maven </code></pre>  <p>However, when I run it:</p>  <pre><code>docker run maven </code></pre>  <p>I get:</p>  <pre><code>[ERROR] No goals have been specified for this build. You must specify a valid lifecycle phase or a goal in the format &lt;plugin-prefix&gt;:&lt;goal&gt; or &lt;plugin-group-id&gt;:&lt;plugin-artifact-id&gt;[:&lt;plugin-version&gt;]:&lt;goal&gt;. Available lifecycle phases are: validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy, pre-clean, clean, post-clean, pre-site, site, post-site, site-deploy. -&gt; [Help 1] [ERROR] [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch. [ERROR] Re-run Maven using the -X switch to enable full debug logging. [ERROR] </code></pre>  <p>I don't have experience with Maven so I don't understand what's causing this issue.</p>  <p>The Docker container only has Maven installed, but it's not running it so I don't understand how Maven can throw an error.</p> ",
    "OwnerUserId": "3122885",
    "LastActivityDate": "2024-01-07T20:00:45.080",
    "Title": "No goals have been specified for this build.",
    "Tags": "<maven><docker>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>You need to define <code>clean install</code> in Goal tab after you click <code>build as maven</code>.</p> "
  },
  {
    "Id": "41411593",
    "PostTypeId": "1",
    "AcceptedAnswerId": "41434110",
    "CreationDate": "2016-12-31T20:43:34.057",
    "Score": "4",
    "ViewCount": "4133",
    "Body": "<p>I'm new to Docker, but have a Java web app project for which my Maven build produces and installs a Docker image. i.e.</p>  <pre><code>mvn clean install </code></pre>  <p>Produces:</p>  <pre><code>REPOSITORY                             TAG                  IMAGE ID            CREATED             SIZE registry.gitlab.com/me/myapp   0.0.1-SNAPSHOT-dev   12d69e5ab28b        45 minutes ago      666 MB </code></pre>  <p>I'm making use of Spotify's Maven plugin to build this, which I can then deploy to the repository using:</p>  <pre><code>mvn docker:push </code></pre>  <p>Which works great. <strong>However:</strong> I'm using GitLab for CI, and my <code>.gitlab-ci.yml</code> file contains:</p>  <pre><code>image: maven:3.3.9-jdk-8  build:   script: 'mvn clean install &amp;&amp; mvn docker:push' </code></pre>  <p>This nearly works, but fails as Docker is not installed <em>in my container</em> which is running the build:</p>  <pre><code>[INFO] Building image registry.gitlab.com/me/myapp Dec 31, 2016 8:30:45 PM org.apache.http.impl.execchain.RetryExec execute INFO: I/O exception (java.io.IOException) caught when processing request to {}-&gt;unix://localhost:80: No such file or directory Dec 31, 2016 8:30:45 PM org.apache.http.impl.execchain.RetryExec execute INFO: Retrying request to {}-&gt;unix://localhost:80 Dec 31, 2016 8:30:45 PM org.apache.http.impl.execchain.RetryExec execute INFO: I/O exception (java.io.IOException) caught when processing request to {}-&gt;unix://localhost:80: No such file or directory ... (more of the same) ... </code></pre>  <p>It seems the solution here is to install Docker into the container. I can't find a pre-built image that has Java, Maven <em>and</em> Docker, but I did try configuring Docker as a service:</p>  <pre><code>services:   - docker:1.13-rc </code></pre>  <p>But the result is the same - it seems services are meant to be used as external services that can be <em>connected to</em>, but that are not immediately installed within the same container.</p>  <p><strong>How should I go about</strong> updating my <code>.yml</code> file so that the GitLab build can build and push a Docker image?</p> ",
    "OwnerUserId": "88111",
    "LastActivityDate": "2017-01-02T22:37:49.457",
    "Title": "Install Docker in container for use by GitLab CI build",
    "Tags": "<maven><docker><gitlab><docker-compose><gitlab-ci>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>I think you're very close.</p>  <p>Gitlab works in <em>stages</em>, and you've correctly defined a proper <code>build</code> stage for your java app. However, you need another stage that will then build your docker image. I'm not all that familiar with Maven and what's configured for your <code>mvn docker:push</code> step, but I'm going to assume that it's a pretty simple wrapper around the <code>docker build</code> and <code>docker push</code> commands.</p>  <p>I'd recommend separating things out into different stages and using artifacts to transfer the built files between containers.</p>  <p>I'd imagine your <code>.gitlab-ci.yml</code> file should look something like this:</p>  <pre><code>image: maven:3.3.9-jdk-8 stages:   - build_application   - build_image  # This stage builds your application build_application:   stage: build_application   script:     - mvn clean install   artifacts:     paths:       - my-application.jar  build_image:     image: docker:latest     services:       - docker:dind     stage: build_image     # Remember that even though the JAR file was built in a separate image     #  Gitlab CI will make it available in this image because I specified it in artifacts     #     # All I really need to build the Docker image is the artifact(s) &amp; Dockerfile     script:       - docker login -u gitlab-ci-token -p $CI_BUILD_TOKEN registry.gitlab.com       - docker build --no-cache=true -t registry.gitlab.com/me/myapp .       - docker push registry.gitlab.com/me/myapp </code></pre> ",
    "highest_rated_answer": null
  },
  {
    "Id": "42903354",
    "PostTypeId": "1",
    "CreationDate": "2017-03-20T12:15:08.787",
    "Score": "4",
    "ViewCount": "1821",
    "Body": "<p>I'm using Jenkins with a Jenkinsfile that runs my builds inside a docker container. I have a simple Java application that I'd like to build and deploy to artifactory using the Jenkins Artifactory plugin. </p>  <p>My Jenkinsfile is below -  </p>  <pre><code>node {   def server = Artifactory.server 'my-artifactory'   def rtMaven = Artifactory.newMavenBuild()    stage('Prepare environment'){     docker.image('driv/docker-maven-java-oracle').inside {        checkout scm        stage('Artifactory configuration') {         rtMaven.deployer releaseRepo:'libs-release-local', snapshotRepo:'libs-snapshot-local', server: server         rtMaven.resolver releaseRepo:'libs-release', snapshotRepo:'libs-snapshot', server: server       }        stage('Maven build') {         def buildInfo = rtMaven.run pom: 'pom.xml', goals: 'clean install'       }     }   } } </code></pre>  <p>However, when I run builds with the above Jenkinsfile I get the error - </p>  <pre><code>java.lang.RuntimeException: Couldn't find maven installation </code></pre>  <p>I know that I can add a line to my Jenkinsfile like this - </p>  <pre><code>rtMaven.tool = MAVEN_TOOL </code></pre>  <p>...that I can use to specify a pre-configured Jenkins Tool to point the Artifactory plugin at Maven. However, it seems to me that such a pre-configured tool would have to be on the Jenkins machine, or a build node, and not inside my docker container.</p>  <p>So, is it possible to point the Artifactory plugin at a maven installation inside my docker container?</p>  <p>Thanks.</p> ",
    "OwnerUserId": "86780",
    "LastActivityDate": "2019-10-18T00:31:47.753",
    "Title": "Jenkinsfile maven plugin inside a docker container",
    "Tags": "<java><maven><docker><jenkins><artifactory>",
    "AnswerCount": "1",
    "CommentCount": "5",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>This should probably be fixed in their jenkins plugin itself but as 'Christopher Orr' suggested mapping environment vars at the pipeline stage level to the same ones set in the container work</p>  <p>For example</p>  <pre><code>stage('mystage') {     environment {         // If your using the official maven image, these are probably where it puts it         MAVEN_HOME = '/usr/share/maven'         JAVA_HOME= '/usr/local/openjdk-8'     }     steps {         sh '''             # confirm location of MAVEN_HOME and JAVA_HOME in container and set in environment directive             printenv          '''         ...         // call rtMavenRun() </code></pre> "
  },
  {
    "Id": "46527028",
    "PostTypeId": "1",
    "CreationDate": "2017-10-02T14:01:30.120",
    "Score": "4",
    "ViewCount": "6424",
    "Body": "<p>maven-plugin to build my docker image.</p>  <p>Whenever I run <code>dockerfile:build</code> </p>  <p>I always get this error :</p>  <pre><code>'failed to execute goal com.spotify:dockerfile-maven-plugin:1.3.6:build (default-cli) on project XXX: Could not build image' 'Caused by: com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: javax.net.ssl.SSLException: Unrecognized SSL message, plaintext connection?' </code></pre>  <p>I will include the error log in the end.</p>  <p>Would you please take a look on what is wrong here?</p>  <p>This is the pom.xml file I am using for this plugin.</p>  <pre><code>&lt;plugin&gt;         &lt;groupId&gt;com.spotify&lt;/groupId&gt;         &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;         &lt;version&gt;1.3.6&lt;/version&gt;         &lt;executions&gt;             &lt;execution&gt;                 &lt;id&gt;default&lt;/id&gt;                 &lt;goals&gt;                     &lt;goal&gt;build&lt;/goal&gt;                     &lt;goal&gt;push&lt;/goal&gt;                 &lt;/goals&gt;             &lt;/execution&gt;         &lt;/executions&gt;         &lt;configuration&gt;             &lt;repository&gt;company/imagename&lt;/repository&gt;             &lt;tag&gt;${project.version}&lt;/tag&gt;         &lt;/configuration&gt; &lt;/plugin&gt; </code></pre>  <p>The docker version is : 17.06.2-ce</p>  <p>OS: Windows 10.</p>  <p>I checked 'general--Expose daemon on tcp://localhost:2375' and also add insecure registries in the docker for windows.</p>  <p>I also add DOCKER_HOST='tcp://localhost:2375' and DOCKER_CERT_PATH in my system variables.</p>  <p>Error log after dockerfile-build:</p>  <pre><code>org.apache.maven.plugin.MojoExecutionException: Could not build image at com.spotify.plugin.dockerfile.BuildMojo.buildImage(BuildMojo.java:185) at com.spotify.plugin.dockerfile.BuildMojo.execute(BuildMojo.java:105) at com.spotify.plugin.dockerfile.AbstractDockerMojo.tryExecute(AbstractDockerMojo.java:240) at com.spotify.plugin.dockerfile.AbstractDockerMojo.execute(AbstractDockerMojo.java:229) at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:134) at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:207) at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153) at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145) at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:116) at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:80) at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51) at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128) at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:307) at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:193) at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:106) at org.apache.maven.cli.MavenCli.execute(MavenCli.java:863) at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:288) at org.apache.maven.cli.MavenCli.main(MavenCli.java:199) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289) at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229) at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415) at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356) at org.codehaus.classworlds.Launcher.main(Launcher.java:47) Caused by: com.spotify.docker.client.exceptions.DockerException: java.util.concurrent.ExecutionException: com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: javax.net.ssl.SSLException: Unrecognized SSL message, plaintext connection? at com.spotify.docker.client.DefaultDockerClient.propagate(DefaultDockerClient.java:2512) at com.spotify.docker.client.DefaultDockerClient.request(DefaultDockerClient.java:2443) at com.spotify.docker.client.DefaultDockerClient.version(DefaultDockerClient.java:501) at com.spotify.docker.client.DefaultDockerClient.authRegistryHeader(DefaultDockerClient.java:2555) at com.spotify.docker.client.DefaultDockerClient.build(DefaultDockerClient.java:1396) at com.spotify.docker.client.DefaultDockerClient.build(DefaultDockerClient.java:1365) at com.spotify.plugin.dockerfile.BuildMojo.buildImage(BuildMojo.java:178) ... 26 more Caused by: java.util.concurrent.ExecutionException: com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: **javax.net.ssl.SSLException: Unrecognized SSL message, plaintext connection?** at jersey.repackaged.com.google.common.util.concurrent.AbstractFuture$Sync.getValue(AbstractFuture.java:299) at jersey.repackaged.com.google.common.util.concurrent.AbstractFuture$Sync.get(AbstractFuture.java:286) at jersey.repackaged.com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:116) at com.spotify.docker.client.DefaultDockerClient.request(DefaultDockerClient.java:2441) ... 31 more Caused by: com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: javax.net.ssl.SSLException: Unrecognized SSL message, plaintext connection? at org.glassfish.jersey.apache.connector.ApacheConnector.apply(ApacheConnector.java:481) at org.glassfish.jersey.apache.connector.ApacheConnector$1.run(ApacheConnector.java:491) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) at java.util.concurrent.FutureTask.run(FutureTask.java:266) ..... </code></pre> ",
    "OwnerUserId": "6524815",
    "LastEditorUserId": "7200715",
    "LastEditDate": "2017-10-02T15:20:19.043",
    "LastActivityDate": "2022-07-14T06:37:30.470",
    "Title": "spotify/dockerfile-maven plugin: Could not build image: javax.net.ssl.SSLException: Unrecognized SSL message, plaintext connection",
    "Tags": "<java><dockerfile><maven-plugin><spotify><sslexception>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>You need to set <strong>pullNewerImage</strong> to false, as it defaults to true. For more detail, please refer below link. <a href='https://github.com/spotify/dockerfile-maven/issues/3' rel='nofollow noreferrer'>https://github.com/spotify/dockerfile-maven/issues/3</a></p> "
  },
  {
    "Id": "46598198",
    "PostTypeId": "1",
    "CreationDate": "2017-10-06T04:16:58.513",
    "Score": "4",
    "ViewCount": "8426",
    "Body": "<p>Integrate Docker with Maven Docker Maven Plugin. I had a problem getting the Docker Run through Maven, on window 10 home machine. Build Failure with the following trace.</p>  <pre><code>DOCKER&gt; Cannot create docker access object  [Cannot extract API version from  server https://192.168.99.100:2376 :  sun.security.validator.ValidatorException: PKIX path building failed:  sun.security.provider.certpath.SunCertPathBuilderException: unable to find  valid certification path to requested target] [INFO] Failed to execute goal io.fabric8:docker-maven-plugin:0.21.0:build (default- cli) on project fleetman: Cannot create docker access object: Cannot extract  API version from server https://192.168.99.100:2376 :  sun.security.validator.ValidatorException: PKIX path building failed:  sun.security.provider.certpath.SunCertPathBuilderException: unable to find  valid certification path to requested target -&gt; [Help 1] [ERROR] </code></pre> ",
    "OwnerUserId": "2211208",
    "LastActivityDate": "2017-10-06T04:57:52.307",
    "Title": "Failed to execute goal io.fabric8:docker-maven-plugin:0.21.0:build window 10 home OR pro",
    "Tags": "<maven><docker><plugins>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p><strong>If you are on window 10 home the solution is:</strong></p>  <p>We are making clean package docker:build as goal</p>  <p>First get the environment variable of your docker installation</p>  <pre><code>$ docker-machine env </code></pre>  <p>You will get something like this</p>  <pre><code>export DOCKER_TLS_VERIFY='1' export DOCKER_HOST='tcp://192.168.99.100:2376' export DOCKER_CERT_PATH='C:\\Users\\vimal\\.docker\\machine\\machines\\default' export DOCKER_MACHINE_NAME='default' export COMPOSE_CONVERT_WINDOWS_PATHS='true' </code></pre>  <p>This <strong>DOCKER_CERT_PATH</strong> is already in your machine, you can verify the folder content that has the CA certificates, already generated during installation, nothing to do further.</p>  <p>You have to only add the entries into your POM file, let us see...</p>  <pre><code>&lt;!-- DMP Docker Maven Plugin  https://dmp.fabric8.io/ --&gt;         &lt;plugin&gt;             &lt;groupId&gt;io.fabric8&lt;/groupId&gt;             &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;             &lt;version&gt;0.21.0&lt;/version&gt;              &lt;configuration&gt;                 &lt;!-- &lt;dockerHost&gt;http://127.0.0.1:2375&lt;/dockerHost&gt; for window 10 pro--&gt;                 &lt;!-- this is for Mac and Amazon Linux --&gt;                 &lt;!-- &lt;dockerHost&gt;unix:///var/run/docker.sock&lt;/dockerHost&gt; --&gt;                 &lt;dockerHost&gt;tcp://192.168.99.100:2376&lt;/dockerHost&gt;                 &lt;verbose&gt;true&lt;/verbose&gt;                  &lt;images&gt;                     &lt;image&gt;                         &lt;name&gt;vimalkrishna/abc-app&lt;/name&gt;                         &lt;build&gt;                             &lt;dockerFileDir&gt;${project.basedir}/src/main/docker/&lt;/dockerFileDir&gt;                              &lt;assembly&gt;                                 &lt;descriptorRef&gt;artifact&lt;/descriptorRef&gt;                             &lt;/assembly&gt;                             &lt;tags&gt;                                 &lt;tag&gt;latest&lt;/tag&gt;                             &lt;/tags&gt;                         &lt;/build&gt;                     &lt;/image&gt;                 &lt;/images&gt;                 &lt;certPath&gt;C:\\Users\\vimal\\.docker\\machine\\machines\\default&lt;/certPath&gt;             &lt;/configuration&gt;         &lt;/plugin&gt;     &lt;/plugins&gt; </code></pre>  <p>You can copy paste above to your POM and change the XXX of your machine. Only below 2 entries are what you get from <strong>env</strong> need to be adjusted. Dockertoolkit(Window 10 home) needs 192.168.99.100 unlike 127.0.0.1 of pro version of window 10</p>  <pre><code>&lt;name&gt;vimalkrishna/abc-app&lt;/name&gt;  &lt;dockerHost&gt;tcp://192.168.99.100:2376&lt;/dockerHost&gt; &lt;certPath&gt;C:\\Users\\XXX\\.docker\\machine\\machines\\default&lt;/certPath&gt; </code></pre>  <p>Thats all, The build will succeed. Put your user and password in local config file</p>  <p><strong>Important!</strong> The location of  the Dickerfile in your application is </p>  <pre><code>&lt;dockerFileDir&gt;${project.basedir}/src/main/docker/&lt;/dockerFileDir&gt; </code></pre>  <p>Means create a folder <strong>docker</strong> inside src/main/</p>  <p><a href='https://i.stack.imgur.com/0nTWu.jpg' rel='nofollow noreferrer'><img src='https://i.stack.imgur.com/0nTWu.jpg' alt='enter image description here'></a></p> "
  },
  {
    "Id": "47224781",
    "PostTypeId": "1",
    "AcceptedAnswerId": "47226093",
    "CreationDate": "2017-11-10T14:16:40.593",
    "Score": "4",
    "ViewCount": "3782",
    "Body": "<p>I'm having hard problems with a Jenkinsfile with a Pipeline.</p>  <p>I have a master Jenkins which runs in a docker container and other Jenkins slaves, which are also docker containers and some are Virtual Machines (e.g., Windows 10).</p>  <p>I perform the code checkout from Git in the master as first stage and for the further stages.</p>  <p>A Stage name 'Build' performs the generation of maven artifacts. I use one docker image to build my project (based on Maven and Java 9) <strong>without</strong> sharing any volume across host and container. I pass the source code using the <code>stash</code> / <code>unstash</code> functions.I'm using also the maven-pipeline plugin and the option <code>withMaven(mavenLocalRepo: '')</code></p>  <p>I'd like to share what I've built on one agent to other agents in a Test stage, but it looks like at this point, stashing of repository is not working (it says: 'no file to stash') and I cannot deploy to a central maven repository (I use Nexus), because there are many concurrent builds possible and the deploy could not be safe.</p>  <p>How can I solve this issue?</p>  <p>Example of pipeline:</p>  <pre><code>pipeline{   agent none   stages{     stage('Checkout Repository'){        agent { node { label 'master' } }       steps{         checkout scm          stash includes: 'project/', name 'project'       }     }     stage('Build'){       agent { node { label 'docker-app-builder' } }       steps{         unstash 'project'         withMaven(mavenLocalRepo: '.repository'){ sh 'mvn clean install' }         stash includes: '.repository', name 'repository'       }     }   }   stage('Test){     steps{       parallel 'docker slave': {         node('docker-app-tester'){           unstash 'repository'           unstash 'project'           withMaven(mavenLocalRepo: '.repository'){ ... }                         }       },       'Windows Slave': {          node('windows-tester'){           unstash 'repository'           unstash 'project'           withMaven(mavenLocalRepo: '.repository'){ ... }                         }       }     }  } } </code></pre> ",
    "OwnerUserId": "2369389",
    "LastEditorUserId": "2369389",
    "LastEditDate": "2017-11-12T10:33:37.090",
    "LastActivityDate": "2017-11-12T10:35:10.130",
    "Title": "Share local maven repository to agents in Jenkins Pipeline",
    "Tags": "<maven><docker><jenkins-pipeline>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>I've found the problem:</p>  <p>the <code>stash</code> command, in case you want to import the full content from a folder, should be invoked with the path including the slash (<code>/</code>) symbol at the end of the path, otherwise it's interpreted as file and it doesn't import anything.</p>  <p>For instance,</p>  <p><strong>Valid Form</strong>:</p>  <pre><code>stash includes: '.repository/', name 'repository' </code></pre>  <p><strong>Invalid Form</strong> (stash fails):</p>  <pre><code>stash includes: '.repository', name 'repository' </code></pre> ",
    "highest_rated_answer": null
  },
  {
    "Id": "49334055",
    "PostTypeId": "1",
    "CreationDate": "2018-03-17T08:33:14.367",
    "Score": "4",
    "ViewCount": "1592",
    "Body": "<p>I have a google cloud container build with the following steps</p>  <ol> <li>gcr.io/cloud-builders/mvn to run a mvn clean package cmd</li> <li>gcr.io/cloud-builders/docker to create a docker image</li> </ol>  <p>My docker image includes and will run tomcat.</p>  <p>Both these steps work fine independently.</p>  <p>How can I copy the artifacts built by step 1 into the correct folder of my docker container? I need to move either the built wars or specific lib files from step 1 to the tomcat dir in my docker container.</p>  <p>Echoing out the /workspace and /root dir in my Dockerfile doesn't show the artifacts. I think I'm misunderstanding this relationship.</p>  <p>Thanks!</p>  <p>Edit:</p>  <p>I ended up changing the Dockerfile to set the <code>WORKDIR to /workspace</code></p>  <p>and</p>  <p><code>COPY /{files built by maven} {target}</code></p> ",
    "OwnerUserId": "4086590",
    "LastEditorUserId": "4086590",
    "LastEditDate": "2018-03-19T22:26:02.210",
    "LastActivityDate": "2018-03-21T08:32:29.040",
    "Title": "Using Maven artifact in Google Cloud Docker build",
    "Tags": "<maven><docker><google-cloud-platform>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>The <em>working directory</em> is a persistent volume mounted in the <strong>builder</strong> containers, by default under <code>/workdir</code>. You can find more details in the documentation here <a href='https://cloud.google.com/container-builder/docs/build-config#dir' rel='nofollow noreferrer'>https://cloud.google.com/container-builder/docs/build-config#dir</a></p>  <p>I am not sure what is happening in your case. But there is an example with a Maven step and a Docker build step in the documentation of the <code>gcr.io/cloud-builders/mvn</code> builder. <a href='https://github.com/GoogleCloudPlatform/cloud-builders/tree/master/mvn/examples/spring_boot' rel='nofollow noreferrer'>https://github.com/GoogleCloudPlatform/cloud-builders/tree/master/mvn/examples/spring_boot</a>. I suggest you compare with your files.</p>  <p>If it does not help, could you share your <code>Dockerfile</code> and <code>cloudbuild.yaml</code>. Please make sure you remove any sensitive information.</p>  <p>Also, you can inspect the working directory by running the build locally <a href='https://cloud.google.com/container-builder/docs/build-debug-locally#preserve_intermediary_artifacts' rel='nofollow noreferrer'>https://cloud.google.com/container-builder/docs/build-debug-locally#preserve_intermediary_artifacts</a></p> "
  },
  {
    "Id": "49631630",
    "PostTypeId": "1",
    "CreationDate": "2018-04-03T13:40:26.423",
    "Score": "4",
    "ViewCount": "3737",
    "Body": "<p>I am using 'dockerfile-maven-plugin' to build &amp; push dockerfiles in maven as docker-maven-plugin is deprecated. However, when I use 'docker-maven plugin', images are build but on using 'dockerfile-maven-plugin' I get below error:</p>  <blockquote>   <p>--- com.spotify.docker.client.exceptions.DockerException: pull access denied for imagename, repository does not exist or may require 'docker   login'</p> </blockquote>  <p>I did docker login, added user to group, installed latest docker version (thinking it requires latest), updated <code>settings.xml</code> with my credentials but still the same error. Any help regarding this will be very helpful.</p> ",
    "OwnerUserId": "8950603",
    "LastEditorUserId": "2992754",
    "LastEditDate": "2018-04-03T18:03:26.750",
    "LastActivityDate": "2018-09-11T06:40:34.547",
    "Title": "Dockerfile maven plugin not working",
    "Tags": "<maven><docker>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<pre><code>   &lt;configuration&gt;         &lt;repository&gt;dockerregistry.xxx.dev/xxxx&lt;/repository&gt;         &lt;tag&gt;O-SANPSHOT&lt;/tag&gt;         &lt;pullNewerImage&gt;false&lt;/pullNewerImage&gt;                   &lt;/configuration&gt; </code></pre>  <p>Add <code>&lt;pullNewerImage&gt;false&lt;/pullNewerImage&gt;</code> inside configuration tag. generally it will try to pull the image from repository. Because of the your local image won't be recognized. This solved my issue.</p>  <p>For more information: <a href='https://github.com/spotify/dockerfile-maven/issues/55' rel='nofollow noreferrer'>read this thread</a> </p> "
  },
  {
    "Id": "52015939",
    "PostTypeId": "1",
    "CreationDate": "2018-08-25T09:39:31.113",
    "Score": "4",
    "ViewCount": "4311",
    "Body": "<p>I tried build a spring boot project in docker container based on below docker file.But every times all mvn dependency download from internet.  How can I bind local .m2 file when i build the docker file. </p>  <p>This is my <strong>Dockerfile</strong></p>  <pre><code>FROM maven:3.5-jdk-8-alpine AS build  COPY /src /usr/src/javaspring/src COPY pom.xml /usr/src/javaspring COPY Dockerfile /usr/src/javaspring RUN mvn -f /usr/src/javaspring/pom.xml clean install   FROM openjdk:8-jre-alpine COPY --from=build /usr/src/javaspring/target/javaspring-1.0.jar app.jar ENTRYPOINT [\u201cjava','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre> ",
    "OwnerUserId": "5446671",
    "LastEditorUserId": "5446671",
    "LastEditDate": "2018-08-25T15:17:43.263",
    "LastActivityDate": "2021-11-20T21:33:09.530",
    "Title": "Bind .m2 file to docker on build stage",
    "Tags": "<maven><docker><spring-boot><dockerfile>",
    "AnswerCount": "2",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>You should mount the content of your project into the docker image and the <code>$HOME/.m2/</code> into the image instead of copying everything into the image and building a new image..</p>  <p>The <code>$PWD</code> is the local directory where your <code>pom.xml</code> file is located and the <code>src</code> directory exists...</p>  <pre><code>docker run -it --rm \\   -v '$PWD':/usr/src/mymaven \\ (1)   -v '$HOME/.m2':/root/.m2 \\ (2)   -v '$PWD/target:/usr/src/mymaven/target' \\ (3)   -w /usr/src/mymaven \\ (4)   maven:3.5-jdk-8-alpine \\ (5)   mvn clean package </code></pre>  <ol> <li>defines the location of your working directory where <code>pom.xml</code> is located. </li> <li>defines the location where you have located your local cache.</li> <li>defines the target directory to map it into the image under the given path</li> <li>defines the working directory.</li> <li>defines the name of the image to be used.</li> </ol>  <p>So you don't need to create an new image to build your stuff with Maven. Simply run an existing image via the following command:</p>  <pre><code>docker run -it --rm \\   -v '$PWD':/usr/src/mymaven \\   -v '$HOME/.m2':/root/.m2 \\   -v '$PWD/target:/usr/src/mymaven/target' \\    -w /usr/src/mymaven \\   maven:3.5-jdk-8-alpine mvn clean package </code></pre> "
  },
  {
    "Id": "52060884",
    "PostTypeId": "1",
    "AcceptedAnswerId": "52063438",
    "CreationDate": "2018-08-28T14:57:06.790",
    "Score": "4",
    "ViewCount": "4395",
    "Body": "<p>I have a multi-modules project configured with maven.</p>  <pre><code>/myProject   /module1     /target     pom.xml   /module2     /target     pom.xml   pom.xml </code></pre>  <p>The pom parent is building the submodules.</p>  <p>Using the <em>com.spotify.dockerfile-maven-plugin</em> I want to build all the modules, build a docker image and copy all the JARs inside that image.</p>  <p>The pom parent</p>  <pre><code>&lt;project&gt;     &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;     &lt;groupId&gt;com.test&lt;/groupId&gt;     &lt;artifactId&gt;myTest&lt;/artifactId&gt;     &lt;name&gt;test&lt;/name&gt;     &lt;version&gt;0.0.1&lt;/version&gt;     &lt;packaging&gt;pom&lt;/packaging&gt;      &lt;modules&gt;         &lt;module&gt;module1&lt;/module&gt;         &lt;module&gt;module2&lt;/module&gt;     &lt;/modules&gt;  &lt;/project&gt; </code></pre>  <p>If I put a Dockerfile at the root of /myProject, the plugin complains there is no Dockerfile for module1</p>  <pre><code>FROM openjdk:8-jdk-alpine ARG JAR_FILE COPY ${JAR_FILE} /home/xyz/jars </code></pre>  <p>maven plugin:</p>  <pre><code>    &lt;plugin&gt;         &lt;groupId&gt;com.spotify&lt;/groupId&gt;         &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;         &lt;configuration&gt;             &lt;repository&gt;mytest&lt;/repository&gt;             &lt;buildArgs&gt;                 &lt;JAR_FILE&gt;target/${project.artifactId}-${project.version}.jar&lt;/JAR_FILE&gt;             &lt;/buildArgs&gt;         &lt;/configuration&gt;     &lt;/plugin&gt; </code></pre>  <p>This works fine with one module if I put the Dockerfile inside that module but how to do with multiple modules and only 1 Dockerfile?</p>  <p>Can I build the submodules and then the docker image with a single <code>mvn clean install</code> on the parent pom?</p>  <p>Maybe by creating a submodule only with a pom and the Dockerfile?</p> ",
    "OwnerUserId": "2882236",
    "LastActivityDate": "2018-08-28T17:34:29.223",
    "Title": "Build multi maven modules then copy JARs inside a docker image",
    "Tags": "<maven><docker>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>If the jars are dependencies for one executable then yes, you could just build that one executable with its dependencies declared in its pom.xml file. Maven should <a href='http://maven.apache.org/guides/mini/guide-multiple-modules.html' rel='nofollow noreferrer'>figure out which order to build the submodules in</a>, so long as you don't create a cycle. As you suggest, you want to make it a submodule and not the root pom as the root pom is parent configuration that is inherited by other modules. Just put the plugin on that one submodule (in its pom.xml) and only give it the Dockerfile.</p>  <p>(If you think of this as a problem about having one executable depending on libraries in the same maven project then it's not really related to docker. You could <a href='https://www.baeldung.com/spring-boot-multiple-modules' rel='nofollow noreferrer'>ask the same question about a spring boot app using libraries in the same multi-module project</a>. In a sense it just is that problem as the jar will get built together with its dependencies and copied into the docker image.)</p>  <p>Or if you mean that each jar for each submodule is an executable in itself (and I don't think you do) then you could create multiple docker images, each from its own Dockerfile, and then you can bundle and start them together if you want to with a docker-compose file.</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "52798237",
    "PostTypeId": "1",
    "AcceptedAnswerId": "52812687",
    "CreationDate": "2018-10-13T23:31:07.893",
    "Score": "4",
    "ViewCount": "319",
    "Body": "<p>I manage a large propriety system that's compromised of about a dozen services in java. We have a core set of java libs that these all share ), and all the components/apps are built using maven. Outside of the core SDK jars though each app has its own unique set of dependencies. I can't figure out what the best approach is to both building and deploying inside docker. Ideally I want the entire lifecycle in docker, using a multi-stage build approach. But, I can't see how to optimize this with the huge number of dependencies.</p>  <p>It looks like I can do 2 approaches.</p>  <ol> <li><p>Build as we have before, using maven and a common cache on the CI server (jenkins) so that dependencies are fetched once and cached, and accessible to all the apps. Then have a dockerfile for each app that just copies the product jar and it's dependencies (or a fat jar) into the container, and set it up to execute. Downside of this approach is that the build itself is something that could differ between developers and the CI server. Potentially use a local maven cache like nexus just to avoid pulling deps from the internet everytime? But that still doesn't solve the problem that a dev build won't necessarily match the CI build environment.</p></li> <li><p>Use multi-stage dockerfile for each project. I've tried this, and it does work and I managed to get the maven dependencies layer to cache so that it doesn't fetch too often. Unfortunately that intermediate build layer was hitting 1-2gb per application, and I can't remove the 'dangling' intermediates from the daemon or all the caching is blowing away. It also means there's a tremendous amount of duplication in the jars that have to be downloaded for each application if something changes in the poms. (ie they all use junit and log4j and many other similarities)</p></li> </ol>  <p>Is there a way to solve this optimally that I'm not seeing? All the blogs I've found basically focus on the 2 approaches above (with some that focus on running maven itself in a container, which really doesn't solve anything for me). I'll probably need to end up going with Option 1 if there aren't any other good solutions.</p>  <p>I've checked around on stackoverflow and blogs, and everything I can find seems to assume that you're really just building a single app and not a suite of them, where it becomes important to not repeat the dependency downloads.</p> ",
    "OwnerUserId": "6436978",
    "LastActivityDate": "2018-10-15T08:36:46.950",
    "Title": "How can I optimize docker builds of multiple, related maven java projects? (caching)",
    "Tags": "<java><maven><docker>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>I think it is OK to use the .m2/repository filesystem cache as long as you set the <code>--update-snapshots</code> option in your maven build. It scales better, because you cache each .jar only once per build environment and not once per application. Additionally a change in a single dependency does not invalidate the entire cache, which would be the case if you use docker-layer-caching.</p>  <p>Unfortunately that cannot be combined well with multi-stage builds at the moment, but you are not the only one asking for it. <a href='https://github.com/moby/moby/issues/32507' rel='nofollow noreferrer'>This issue</a> requests adding a <code>--volume</code> option to the docker build command. <a href='https://github.com/moby/moby/issues/32507' rel='nofollow noreferrer'>This one</a> asks for allowing instructions like this in the Dockerfile: <code>RUN --mount=m2repo=/var/mvn/repo mvn install</code>.</p>  <p>Both features would allow you to use the local maven filesystem cache during your multistage build.</p>  <p>For the moment I would advise to keep your option 1 as solution, unless you are facing many issues which are due to differing build environments.</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "53471581",
    "PostTypeId": "1",
    "CreationDate": "2018-11-25T20:25:35.727",
    "Score": "4",
    "ViewCount": "337",
    "Body": "<p>I have the following test which passes in IDE, and when run as Junit and even from the command line using <code>mvn clean verify</code>. </p>  <pre><code>@FixMethodOrder(MethodSorters.NAME_ASCENDING) @RunWith(SpringRunner.class) @WebFluxTest(controllers = AddNewEntryController.class) @Import({ThymeleafAutoConfiguration.class}) public class AddNewEntryControllerTest {  @Autowired WebTestClient webTestClient;  @MockBean TimeKeepingEntryService service;  @Captor private ArgumentCaptor&lt;Flux&lt;TimeKeepingEntry&gt;&gt; captor;  @Autowired AddNewEntryController controller;  LocalDateTime now = LocalDateTime.now(); String month = now.getMonth().getDisplayName(TextStyle.FULL, Locale.ENGLISH); TimeKeepingEntry entry1 = new TimeKeepingEntry(month,         now.getDayOfMonth(), now.getDayOfWeek().getDisplayName(TextStyle.FULL, Locale.ENGLISH), now.toLocalTime(),         LocalTime.parse('00:30', DateTimeFormatter.ofPattern('HH:mm')),         now.toLocalTime().plusHours(7), '7.5', false );  @Test public void addNewEntryPage() {     EntityExchangeResult&lt;String&gt; result = webTestClient             .get().uri('/add-new-entry')             .exchange()             .expectStatus().isOk()             .expectBody(String.class).returnResult();      assertThat(result.getResponseBody())             .contains('&lt;title&gt;Add New Time Entry&lt;/title&gt;')             .contains('&lt;input type=\\'text\\' class=\\'form-control\\' readonly=\\'readonly\\' id=\\'month\\' name=\\'month\\' value=\\'' + month + '\\'&gt;')             .contains('&lt;input data-date-format=\\'dd\\' id=\\'datepicker\\' name=\\'dateOfMonth\\' value=\\'0\\'&gt;')             .contains('&lt;input type=\\'text\\' class=\\'form-control\\' id=\\'day\\' name=\\'day\\' value=\\'' + now.getDayOfWeek().getDisplayName(TextStyle.FULL, Locale.ENGLISH) + '\\'&gt;'); }  @Test public void addNewEntrySubmit() {     MultiValueMap&lt;String, String&gt; formData = new LinkedMultiValueMap&lt;&gt;();     formData.add('month', month);     formData.add('dateOfMonth', Integer.toString(21));     formData.add('day', 'Tuesday');     formData.add('startTime', '09:00');     formData.add('endTime', '17:00');     formData.add('breakLength', '00:30');     formData.add('onsite', Boolean.toString(false));      given(service.addTimeKeepingEntry(any())).willReturn(Mono.empty());      webTestClient.post().uri('/add-new-entry').accept(MediaType.TEXT_HTML).contentType(MediaType.APPLICATION_FORM_URLENCODED)             .body(BodyInserters.fromFormData(formData)).exchange().expectStatus().isSeeOther().expectHeader().valueEquals(HttpHeaders.LOCATION, '/');      verify(service).addTimeKeepingEntry(captor.capture());     TimeKeepingEntry timeKeepingEntry = captor.getValue().blockFirst();     assertThat(timeKeepingEntry.getMonth()).isEqualTo(month); } </code></pre>  <p>}</p>  <p>However when I push the code to Gitlab.com and the CI takes over and uses the maven docker container 3.5.4-jdk8 it fails with the following error.</p>  <pre><code>Field error in object 'timeKeepingEntry' on field 'startTime': rejected `value [09:00]; codes typeMismatch.timeKeepingEntry.startTime,typeMismatch.startTime,typeMismatch.java.time.LocalTime,typeMismatch]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [timeKeepingEntry.startTime,startTime]; arguments []; default message [startTime]]; default message [Failed to convert property value of type 'java.lang.String' to required type 'java.time.LocalTime' for property 'startTime'; nested exception is org.springframework.core.convert.ConversionFailedException: Failed to convert from type [java.lang.String] to type [@javax.validation.constraints.NotNull java.time.LocalTime] for value '09:00'; nested exception is java.lang.IllegalArgumentException: Parse attempt failed for value [09:00]]]`  </code></pre> ",
    "OwnerUserId": "10536178",
    "LastEditorUserId": "10536178",
    "LastEditDate": "2018-11-25T21:11:20.127",
    "LastActivityDate": "2018-11-25T21:11:20.127",
    "Title": "How come my Test fails in Docker Maven container 3.5.4-jdk8 when it passes using maven on command line",
    "Tags": "<maven><spring-boot><docker><gitlab-ci>",
    "AnswerCount": "0",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": null
  }
]