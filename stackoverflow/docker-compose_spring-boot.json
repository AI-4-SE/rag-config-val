[
  {
    "Id": "44738469",
    "PostTypeId": "1",
    "CreationDate": "2017-06-24T16:20:56.010",
    "Score": "9",
    "ViewCount": "7110",
    "Body": "<p>I have a spring cloud config server and packaged it as a docker image then I have spring cloud eureka server which is also packaged as docker image.</p>  <p>When I run the two using docker compose I get the following error.</p>  <p><code>discovery-service_1  | 2017-06-24 15:36:12.059  INFO 5 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Fetching config from server at: http://config-service:9001 discovery-service_1  | 2017-06-24 15:36:12.997  WARN 5 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Could not locate PropertySource: I/O error on GET request for 'http://config-service:9001/cls-discovery-service/default': Connection refused (Connection refused); nested exception is java.net.ConnectException: Connection refused (Connection refused) </code></p>  <blockquote>   <p>Although the config service is up and running successfully, discover service still does not find it for some reason.</p> </blockquote>  <p><strong>Docker compose file being used here is this</strong>  <code> version: '2' services:         config-service:                 image: cloudsea/cls-config-service                 ports:                 - 9001:9001                 expose:                 - '9001'         discovery-service:                 image: cloudsea/cls-discovery-service                 depends_on:                 - config-service                 environment:                         CLOUD_SEA_CONFIG_SERVER_URI: http://config-service:9001                         EUREKA_DEFAULT_ZONE_URL: http://discovery-service:8761/eureka/                 ports:                 - 8761:8761                 links:                 - config-service:config-service </code></p>  <p>Below is the <strong>bootstrap.properties</strong> for DISCOVERY SERVICE</p>  <p><code>spring.cloud.config.uri = ${CLOUD_SEA_CONFIG_SERVER_URI:http://localhost:9001} spring.application.name = ${SPRING_APPLICATION_NAME:cls-discovery-service} </code></p>  <p>Below is the <strong>cls-discovery-service.properties</strong> for DISCOVERY SERVICE located in github.</p>  <p><code>server.port=${SERVER_PORT:8761} eureka.client.registerWithEureka: false eureka.client.fetchRegistry: false eureka.client.serviceUrl.defaultZone: ${EUREKA_DEFAULT_ZONE_URL:http://localhost:8761/eureka/} eureka.server.eviction-interval-timer-in-ms: 1000 </code></p>  <p>I am assuming something is wrong with my docker-compose.yml but I am not sure.</p>  <p>Any help will I am stick in this for hours ... heading close to days :(</p> ",
    "OwnerUserId": "3058432",
    "LastActivityDate": "2018-02-06T23:23:47.990",
    "Title": "Spring Cloud Config Server not working with Docker compose",
    "Tags": "<spring-boot><docker-compose><spring-cloud><spring-cloud-netflix><spring-cloud-config>",
    "AnswerCount": "3",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>I solved it by adding this configuration to the <strong>discovery service's bootstrap.yml</strong>.</p>  <pre><code>spring:   cloud:     config:       failFast: true       retry:         initialInterval: 3000         multiplier: 1.3         maxInterval: 5000         maxAttempts: 20 </code></pre>  <p>Then add <strong>spring-boot-starter-aop</strong> and <strong>spring-retry</strong> to the <strong>discovery service's maven dependencies</strong>.</p>  <pre><code>&lt;dependency&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;     &lt;version&gt;${spring-boot-starter-aop.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;     &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;     &lt;version&gt;${spring-retry.version}&lt;/version&gt; &lt;/dependency&gt; </code></pre>  <p>The problem is they're both starting at the same time. But the discovery service depends on the config service.</p>  <p>When you start the discovery service, it's going to say '<strong>Fetching config from server</strong>' again and again until config service is up.</p>  <p><strong>After the config service starts, discovery service is going to get its configuration successfully</strong> and then it's going to start itself.</p> "
  },
  {
    "Id": "44125915",
    "PostTypeId": "1",
    "CreationDate": "2017-05-23T04:38:27.997",
    "Score": "8",
    "ViewCount": "16961",
    "Body": "<p>I have a spring boot application that connects to a mongo db and deployed the app with docker.  I am using this docker-compose.yml file, which works fine:</p>  <pre><code>version: '2' services:   db:       container_name: app-db       image: mongo       volumes:         - /data/db:/data/db       ports:         - 27017:27017   web:     container_name: spring-app     image: spring-app     depends_on:       - db     environment:       SPRING_DATA_MONGODB_URI: mongodb://db:27017/appDB       SPRING_DATA_MONGODB_HOST: db     ports:       - 8080:8080 </code></pre>  <p>Currently, the app is using the application.properties file embedded in the spring app docker image (spring-app).  How do I externalize / pass-in the application.properties file using docker-compose?</p>  <p>Thank you for your help</p> ",
    "OwnerUserId": "107216",
    "LastActivityDate": "2020-07-16T23:38:45.787",
    "Title": "docker-compose - externalize spring application.properties",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>You must make use of the Spring Profiles to define the environment variables depending on your requirement.</p>  <pre><code>server:     port: 9000 ---  spring:     profiles: development server:     port: 9001  ---  spring:     profiles: production server:     port: 0 </code></pre>  <p>Reference: <a href='https://docs.spring.io/spring-boot/docs/current/reference/html/howto-properties-and-configuration.html#howto-change-configuration-depending-on-the-environment' rel='noreferrer'>https://docs.spring.io/spring-boot/docs/current/reference/html/howto-properties-and-configuration.html#howto-change-configuration-depending-on-the-environment</a></p>  <p>You can define which profile needs to be picked up during the runtime.</p>  <pre><code>version: '2' services:   db:       container_name: app-db       image: mongo       volumes:         - /data/db:/data/db       ports:         - 27017:27017   web:     container_name: spring-app     image: spring-app     depends_on:       - db     environment:       SPRING_DATA_MONGODB_URI: mongodb://db:27017/appDB       SPRING_DATA_MONGODB_HOST: db       SPRING_PROFILES_ACTIVE=development     ports:       - 8080:8080 </code></pre>  <p>But this will require you to rebuild the docker image if there is a change in the configuration which is not ideal. Here comes the Spring Cloud Config (Vault) comes in handy which helps you to externalize your configuration.</p>  <p><a href='http://cloud.spring.io/spring-cloud-static/spring-cloud-config/1.3.0.RELEASE/' rel='noreferrer'>http://cloud.spring.io/spring-cloud-static/spring-cloud-config/1.3.0.RELEASE/</a></p> "
  },
  {
    "Id": "44157039",
    "PostTypeId": "1",
    "CreationDate": "2017-05-24T11:26:58.923",
    "Score": "8",
    "ViewCount": "3335",
    "Body": "<p>I want to configure my spring interceptor in such a way that with every request it should get called.</p>  <ul> <li>I am using interceptor in API-GATEWAY <strong>(Spring-Boot)</strong></li> <li>From API-GATEWAY I am calling other microservices.</li> <li>The call's to other microservices from API-GATEWAY is working fine.</li> <li>Other Services which I am calling are Node.js Service, on the other hand, my API-Gateway is in spring boot.</li> <li>All the services (Node.js + Spring-Boot) are running on <strong>Docker Container</strong>.</li> </ul>  <p>I am facing an issue in Interceptor. I want to configure it in such a way that with every request it should be called the <code>preHandle()</code> and perform the operations that I have written in it.</p>  <p>I have notice one issue that I want to mention here.</p>  <p><strong>If the services which I am calling is stopped (Not Running), Interceptor is working properly and giving me a response like somename-service not found. If the same services are running at this time Interceptor is not executed.</strong></p>  <p>Here is my code snippet </p>  <pre><code>@EnableEurekaClient @SpringBootApplication @EnableZuulProxy @Configuration public class Application extends WebMvcConfigurerAdapter {      public static void main(String[] args) {         SpringApplication.run(Application.class, args);     }      @Autowired     private TokenValidateInterceptor tokenValidateInterceptor;      @Override     public void addInterceptors(InterceptorRegistry registry) {          registry.addInterceptor(tokenValidateInterceptor).addPathPatterns('/**');       } </code></pre>  <p>Interceptor </p>  <pre><code>@Component public class TokenValidateInterceptor extends HandlerInterceptorAdapter {       @Override     public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {         LOG.info('#### Starting TokenValidateInterceptor.preHandle ####');          String apiKey = null;         try {             apiKey = request.getHeader('apikey');              LOG.info('The request come with apikey ======' + apiKey);              LOG.info('Actual apikey ======' + azureApikey);   } </code></pre> ",
    "OwnerUserId": "7789526",
    "LastEditorUserId": "7789526",
    "LastEditDate": "2017-05-25T13:38:26.887",
    "LastActivityDate": "2020-08-10T12:15:30.360",
    "Title": "How to configure spring interceptor to get called with every request",
    "Tags": "<java><node.js><docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>You have to add this interceptor to your dispatcher xml file:</p>  <pre><code>&lt;?xml version='1.0' encoding='UTF-8'?&gt; &lt;beans xmlns='http://www.springframework.org/schema/beans'     xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'     xmlns:p='http://www.springframework.org/schema/p'     xsi:schemaLocation='http://www.springframework.org/schema/beans      http://www.springframework.org/schema/beans/spring-beans.xsd'&gt;       &lt;bean id='handlerMapping' class='org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping' p:interceptors-ref='tokenInterceptor' /&gt;      &lt;bean id='tokenInterceptor' class='yourpackage.TokenValidateInterceptor' /&gt;  &lt;/beans&gt; </code></pre>  <p>There are few nice samples here:</p>  <ul> <li><a href='https://examples.javacodegeeks.com/enterprise-java/spring/mvc/spring-mvc-interceptor-tutorial/' rel='nofollow noreferrer'>Spring MVC Interceptot</a></li> <li><a href='https://dzone.com/sites/all/files/SpringExample9.zip' rel='nofollow noreferrer'>Dzone Spring Interceptor</a> </li> </ul> "
  },
  {
    "Id": "47266795",
    "PostTypeId": "1",
    "AcceptedAnswerId": "50781480",
    "CreationDate": "2017-11-13T14:34:43.837",
    "Score": "8",
    "ViewCount": "8110",
    "Body": "<p>I took this example <a href='https://github.com/paulc4/microservices-demo' rel='noreferrer'>https://github.com/paulc4/microservices-demo</a> and I created 3 docker images from it, with the following Dockerfiles:</p>  <p>springdocker-registration:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ADD target/microservice-demo-1.1.0.RELEASE.jar app.jar EXPOSE 1111 ENTRYPOINT exec java -jar /app.jar registration </code></pre>  <p>springdocker-accounts:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ADD target/microservice-demo-1.1.0.RELEASE.jar app.jar EXPOSE 2222 ENTRYPOINT exec java -jar /app.jar accounts </code></pre>  <p>springdocker-web:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ADD target/microservice-demo-1.1.0.RELEASE.jar app.jar EXPOSE 3333 ENTRYPOINT exec java -jar /app.jar web </code></pre>  <p>If I run the three images separately everything works ok, the <code>web</code> and <code>accounts</code> services register to the <code>registration</code> service (which is an implementation of the eureka registry) and I can use my application. However when using <code>docker-compose</code> with the following <code>docker-compose.yml</code> file</p>  <pre><code>version: '3.4' services:  registration:   image: springdocker-registration   ports:    - '1111:1111'   accounts:   image: springdocker-accounts   ports:    - '2222:2222'   links:    - registration   depends_on:    - registration   web:   image: springdocker-web   ports:    - '3333:3333'   depends_on:    - registration    - accounts   links:    - registration </code></pre>  <p>the services <code>web</code> and <code>accounts</code> are not able to register to the <code>registration</code> service. Here are the configuration files for the applications:</p>  <p>registration-server.yml:</p>  <pre><code>eureka:   instance:     hostname: localhost   client:       registerWithEureka: false     fetchRegistry: false     serviceUrl:      defaultZone: http://localhost:1111/eureka/  server:   port: 1111     spring:   thymeleaf:     enabled: false  </code></pre>  <p>accounts-server.yml:</p>  <pre><code>spring:   application:      name: accounts-service     freemarker:     enabled: false              thymeleaf:     cache: false                 prefix: classpath:/accounts-server/templates/      error:   path: /error  server:   port: 2222     eureka:   client:     serviceUrl:       defaultZone: http://localhost:1111/eureka   instance:     leaseRenewalIntervalInSeconds: 5        preferIpAddress: true </code></pre>  <p>web-server.yml</p>  <pre><code>spring:   application:     name: web-service    freemarker:     enabled: false        thymeleaf:     cache: false            prefix: classpath:/web-server/templates/     error:   path: /error  eureka:   client:     serviceUrl:       defaultZone: http://localhost:1111/eureka   instance:     leaseRenewalIntervalInSeconds: 5      preferIpAddress: true  server:   port: 3333   </code></pre>  <p>I can post the full console log of <code>docker-compose up</code> but I think this is the interesting point:</p>  <pre><code>1: ERROR RedirectingEurekaHttpClient - Request execution error com.sun.jersey.api.client.ClientHandlerException: java.net.ConnectException: Connection refused (Connection refused)  1: ERROR DiscoveryClient - DiscoveryClient_WEB-SERVICE/e3b5e6b3396c:web-service:3333 - was unable to refresh its cache! status = Cannot execute request on any known server com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server </code></pre> ",
    "OwnerUserId": "1534252",
    "LastEditorUserId": "1534252",
    "LastEditDate": "2017-11-14T08:36:09.360",
    "LastActivityDate": "2020-05-02T19:12:28.273",
    "Title": "Applications not registering to eureka when using docker-compose",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>Since its running in docker, don't use <code>localhost</code>. Docker compose lets you refer to container names.</p>  <pre><code>eureka:   client:     serviceUrl:       defaultZone: http://registration:1111/eureka </code></pre>  <p>Side note: <code>defaultZone</code> must be exact, I spent 2 days wondering why it wouldn't work since intellij auto completes to do <code>default-zone</code> which wont work.</p> ",
    "highest_rated_answer": "<p>For those who are working with docker-compose and if in your services yml file you have the following:</p>  <pre><code>eureka:   client:     serviceUrl:       # Will get overridden in docker-compose       defaultZone: http://localhost:1111/eureka </code></pre>  <p>You can override this in your docker-compose file like below while running <code>docker-compose up</code></p>  <pre><code>version: '3.3' services:   # Other services registered above   web:   image: springdocker-web   environment:     # Important for clients to register with eureka    - eureka.client.serviceUrl.defaultZone=http://registration:8761/eureka/   ports:    - '3333:3333'   depends_on:    - registration    - accounts   links:    - registration </code></pre>  <p>Tested on Docker version 19.03.8</p> "
  },
  {
    "Id": "48359972",
    "PostTypeId": "1",
    "AcceptedAnswerId": "48360582",
    "CreationDate": "2018-01-20T19:01:14.387",
    "Score": "8",
    "ViewCount": "14597",
    "Body": "<p>I am attempting to build a 'service' consisting of a Spring Boot application and PostgreSQL database. I have been able to access the database (running in a container) from the Spring Boot app while the Spring Boot application was running on my local machine. Now, when I attempt to move the Spring Boot application to a container, I am received the following error:</p>  <pre><code>inventory_1  | 2018-01-20 18:43:06.108 ERROR 1 --- [nio-8080-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.transaction.CannotCreateTransactionException: Could not open JPA EntityManager for transaction; nested exception is org.hibernate.exception.JDBCConnectionException: Unable to acquire JDBC Connection] with root cause inventory_1  | inventory_1  | java.net.ConnectException: Connection refused (Connection refused) </code></pre>  <p>However, I am able to connect to DB from my local machine: <code>psql -h localhost -p 5000 -U kelly_psql -d leisurely_diversion</code></p>  <p>My application.properties file:</p>  <pre><code>spring.jpa.hibernate.ddl-auto=none spring.jpa.show-sql=false spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect spring.datasource.url=jdbc:postgresql://localhost:5432/leisurely_diversion spring.datasource.username=kelly_psql spring.datasource.password=pass spring.datasource.driver-class-name=org.postgresql.Driver </code></pre>  <p>My docker-compose file:</p>  <pre><code>    # Use postgres/example user/password credentials version: '3.2'  services:   db:     image: postgres     ports:       - 5000:5432     environment:       POSTGRES_PASSWORD: example     volumes:       - type: volume         source: psql_data         target: /var/lib/postgresql/data     networks:        - app     restart: always   inventory:     image: kellymarchewa/inventory_api     depends_on:         - db     ports:       - 8080:8080     networks:       - app     restart: always volumes:   psql_data: networks:    app: </code></pre>  <p>My Dockerfile (from the <a href='https://spring.io/guides/gs/spring-boot-docker/' rel='noreferrer'>Spring website</a>)</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ARG JAR_FILE ADD ${JAR_FILE} app.jar ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre>  <p>I suspect the issue lies in a misunderstanding (on my part) of Docker or containers, but I am not sure. Any advice would be appreciated.</p> ",
    "OwnerUserId": "4783710",
    "LastEditorUserId": "2597143",
    "LastEditDate": "2018-01-21T15:35:31.800",
    "LastActivityDate": "2020-09-16T11:15:30.143",
    "Title": "Spring Boot, PostgreSQL, and Docker - Connection Refused whil Running in Container",
    "Tags": "<spring><postgresql><docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>You are pointing your application towards <code>localhost</code>, but this is not shared between containers.</p>  <p>To access another container you have to refer to its <code>hostname</code>.</p>  <p>In your case, I understand that you want the <code>inventory</code> service to access the <code>db</code> service. So you should use the following <code>datasource</code> url:</p>  <pre><code>spring.datasource.url=jdbc:postgresql://db:5432/leisurely_diversion </code></pre>  <p>See this simple tutorial about connecting to a container from another container with docker compose: <a href='https://docs.docker.com/compose/gettingstarted/' rel='noreferrer'>https://docs.docker.com/compose/gettingstarted/</a></p> ",
    "highest_rated_answer": "<p>Like in my case if you are using <strong>Docker Toolbox</strong> for windows 8.1 then you cannot use &quot;localhost&quot;,</p> <p>Instead you have to use docker machine ip;</p> <pre><code> host&gt; docker-machine ip default   192.168.99.100 </code></pre> <p>After that your url will look like;</p> <pre><code> spring.datasource.url=jdbc:postgresql://192.168.99.100:5432/bankdb </code></pre> <p>This will successfully connect to docker Postgres DB.</p> <p>Cheers!!</p> "
  },
  {
    "Id": "50216280",
    "PostTypeId": "1",
    "AcceptedAnswerId": "50222583",
    "CreationDate": "2018-05-07T14:09:25.160",
    "Score": "8",
    "ViewCount": "62148",
    "Body": "<p>The docker container is not able to access the jar file, that is being accessed over the mount point <code>/my/project/dir</code>. I am certain it is not a permission issue, because I changed the access rights locally, so it should be able to read/write/execute it.</p>  <p>This is the <code>Dockerfile</code>:</p>  <pre><code>FROM tomcat:9-jre8 RUN apt-get update &amp;&amp; apt-get install librrds-perl rrdtool -y VOLUME ['/data/rrdtool', '/my/project/dir'] ENTRYPOINT [ 'java','-jar','/my/project/dir/build/libs/spring-project-0.1.0.jar' ] </code></pre>  <p>And this is the <code>docker-compose.yml</code> file:</p>  <pre><code>version: '2' services:  db:    container_name: db1    image: mysql:8    restart: always    environment:      MYSQL_ROOT_PASSWORD: password123      MYSQL_USER: user123      MYSQL_PASSWORD: pasw      MYSQL_DATABASE: mydb    expose:      - '3307'  db2:    container_name: db2    image: mysql:8    restart: always    environment:      MYSQL_ROOT_PASSWORD: password123      MYSQL_USER: user123      MYSQL_PASSWORD: pasw      MYSQL_DATABASE: mydb2    expose:      - '3308'  spring:    container_name: spring-boot-project    build:       context: ./      dockerfile: Dockerfile    links:      - db:db1      - db2:db2    depends_on:      - db      - db2    expose:      - '8081'    ports:      - '8081:8081'    restart: always </code></pre>  <p>This is the output from <code>docker-compose logs spring</code>:</p>  <pre><code>Error: Unable to access jarfile /my/project/dir/build/libs/spring-project-0.1.0.jar </code></pre> ",
    "OwnerUserId": "5703530",
    "LastEditorUserId": "5703530",
    "LastEditDate": "2018-05-07T18:25:15.080",
    "LastActivityDate": "2022-09-12T12:19:49.007",
    "Title": "Docker unable to access jar file",
    "Tags": "<java><docker><spring-boot><jar><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "4",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>I don't see you copying the <code>jar</code> into the container anywhere. You should try moving a <code>VOLUME</code> declaration from <code>Dockerfile</code> to the <code>compose</code> file into the <code>spring</code> service  like this:</p>  <pre><code>  volumes:     - /my/project/dir:/app </code></pre>  <p>And then inside Dockerfile you should point to the dir:</p>  <pre><code>ENTRYPOINT [ 'java','-jar','/app/build/libs/spring-project-0.1.0.jar' ] </code></pre>  <p>Later on if you'd like to deploy it (for example) you should copy the project files directly into the image instead of utilizing the <code>volumes</code> approach. So in <code>Dockerfile</code> you'd then do:</p>  <pre><code>COPY . /app </code></pre>  <p>instead of <code>VOLUME [..]</code></p>  <p><strong>Putting it all together:</strong></p>  <p><strong>development:</strong></p>  <p>Dockerfile:</p>  <pre><code>FROM tomcat:9-jre8 RUN apt-get update &amp;&amp; apt-get install librrds-perl rrdtool -y ENTRYPOINT [ 'java','-jar','/app/build/libs/spring-project-0.1.0.jar' ] </code></pre>  <p>compose-file:</p>  <pre><code>version: '2' services:     [..]     spring:        container_name: spring-boot-project        build: .        links:          - db:db1          - db2:db2        depends_on:          - db          - db2        ports:          - '8081:8081'        restart: always        volumes:          - /my/project/dir:/app </code></pre>  <p><strong>deployment:</strong></p>  <p>Dockerfile (that is placed inside project's folder, docker build requires it's build context to be in a current directory):</p>  <pre><code>FROM tomcat:9-jre8 RUN apt-get update &amp;&amp; apt-get install librrds-perl rrdtool -y COPY . /app ENTRYPOINT [ 'java','-jar','/app/build/libs/spring-project-0.1.0.jar' ] </code></pre>  <p>compose-file:</p>  <pre><code>version: '2' services:     [..]     spring:        container_name: spring-boot-project        build: .        links:          - db:db1          - db2:db2        depends_on:          - db          - db2        expose:          - '8081' </code></pre> ",
    "highest_rated_answer": "<p>If you are using <code>Spring-Boot</code> Project with <code>Maven</code> build. Try with below</p> <p><strong>Dockerfile</strong>.</p> <pre><code>FROM maven:3.8.4-openjdk-17 as maven-builder COPY src /app/src COPY pom.xml /app  RUN mvn -f /app/pom.xml clean package -DskipTests FROM openjdk:17-alpine  COPY --from=maven-builder app/target/dockube-spring-boot.jar /app-service/dockube-spring-boot.jar WORKDIR /app-service  EXPOSE 8080 ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;dockube-spring-boot.jar&quot;] </code></pre> <blockquote> <p>dockube-spring-boot.jar // replace with your generated jar name</p> </blockquote> <p>Here is the <a href='https://github.com/Maheshbhusanoor/dockube-spring-boot' rel='nofollow noreferrer'>Sample Code Available</a></p> "
  },
  {
    "Id": "53407287",
    "PostTypeId": "1",
    "CreationDate": "2018-11-21T07:39:54.870",
    "Score": "8",
    "ViewCount": "18758",
    "Body": "<p>I have a spring boot project which I'd like to containerize using docker. I have a couple of spring boot applications which connect to same MySql server.</p>  <p>My spring applications requires the database to be completely setup (i.e. all the tables to be created and some data to be inserted in some of the tables) in order to start.</p>  <p>I am using <strong>Docker</strong> version <strong>18.09.0</strong> and <strong>docker-compose</strong> version <strong>1.23.1</strong> and ubuntu <strong>16.04</strong> LTS</p>  <hr>  <p>I have two files <strong><code>create.sql</code></strong> and <strong><code>insert.sql</code></strong>, which I use to initialise the database to be used by the application.</p>  <p>I create the images using the command <strong><code>docker-compose.yml</code></strong> and it runs successfully and creates the images.</p>  <p>I have the following questions.</p>  <ol> <li><p>I assume when using docker-compose, a container starts as soon as all its dependent containers have started. Is there a way to wait for the mysql server to be up and ready to accept connections, before my API container gets started?</p></li> <li><p>If I chose to create containers separately for the applications and mysql, and not use docker-compose, how do I make sure that my applications connect to the mysql container?</p></li> <li><p>Is there any other tool which might help me achieve this?</p></li> </ol>  <p><strong>Note:</strong> I have tried to use <strong><code>docker inspect &lt;container_id&gt;</code></strong> to find the the IpAddress for the mysql container and use it to connect, but it doesn't work as well.</p>  <hr>  <p>The following are the files I am using to create images.</p>  <p><strong><code>docker-compose.yml</code></strong> file.</p>  <pre><code>version: '3'  services:   demo-mysql:     image: demo-mysql     build: ./demo-mysql     volumes:       - /mnt/data/mysql-data:/var/lib/mysql     ports:       - 3306:3306     environment:       - MYSQL_ROOT_PASSWORD=root       - MYSQL_DATABASE=demo       - MYSQL_PASSWORD=root    demo-api:     image: demo-api-1.0     build: ./api     depends_on:       - demo-mysql     ports:       - 8080:8080     environment:       - DATABASE_HOST=demo-mysql       - DATABASE_USER=root       - DATABASE_PASSWORD=root       - DATABASE_NAME=demo       - DATABASE_PORT=3306    demo1-app:     image: demo1-app-1.0     build: ./demo1     depends_on:       - demo-mysql     ports:       - 8090:8090     environment:       - DATABASE_HOST=demo-mysql       - DATABASE_USER=root       - DATABASE_PASSWORD=root       - DATABASE_NAME=demo       - DATABASE_PORT=3306 </code></pre>  <p>The following is the <strong><code>Dockerfile</code></strong> for the spring boot project</p>  <pre><code>FROM java:8  VOLUME /tmp  ARG DATA_PATH=/src/main/resources ARG APP_PORT=8080  EXPOSE ${APP_PORT}  ADD /build/libs/demo-api.jar demo-api.jar  ENTRYPOINT ['java','-jar','demo-api.jar'] </code></pre>  <p>The following is the <strong><code>Dockerfile</code></strong> I used to create my mysql image</p>  <pre><code>FROM mysql:5.7  ENV MYSQL_DATABASE=demo \\     MYSQL_USER=root \\     MYSQL_ROOT_PASSWORD=root  ADD ./1.0/create.sql /docker-entrypoint-initdb.d ADD ./1.0/insert.sql /docker-entrypoint-initdb.d  EXPOSE 3306 </code></pre> ",
    "OwnerUserId": "5788945",
    "LastActivityDate": "2023-10-15T19:43:52.260",
    "Title": "Docker compose wait for database service initialisation",
    "Tags": "<mysql><spring-boot><docker><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Use the <code>healthcheck</code> feature of docker-compose (<a href='https://docs.docker.com/compose/compose-file/#healthcheck' rel='nofollow noreferrer'>https://docs.docker.com/compose/compose-file/#healthcheck</a>).  Something like this:</p>  <pre><code>services:   demo-mysql:     image: demo-mysql     build: ./demo-mysql     volumes:       - /mnt/data/mysql-data:/var/lib/mysql     ports:       - 3306:3306     environment:       - MYSQL_ROOT_PASSWORD=root       - MYSQL_DATABASE=demo       - MYSQL_PASSWORD=root     healthcheck:       test: ['CMD-SHELL', 'mysqladmin ping']       interval: 10s       timeout: 2s       retries: 10 </code></pre>  <p>The depending containers will not start until the demo-mysql container is healthy</p> "
  },
  {
    "Id": "56441497",
    "PostTypeId": "1",
    "AcceptedAnswerId": "56441664",
    "CreationDate": "2019-06-04T09:52:04.153",
    "Score": "8",
    "ViewCount": "19487",
    "Body": "<p>What I'm trying to do is, connect from my spring-boot app to mysql database in Docker. Each in their own container.</p>  <p>But I must be having something wrong because I can't do it.</p>  <p><strong>To keep it simple :</strong></p>  <p>application-properties :</p>  <pre><code># URL for the mysql db spring.datasource.url=jdbc:mysql://workaround-mysql:3308/workaround?serverTimezone=UTC&amp;max_allowed_packet=15728640 # User name in mysql spring.datasource.username=springuser # Password for mysql spring.datasource.password=admin #Port at which application runs server.port=8080 </code></pre>  <p>docker-compose for MySQL:</p>  <pre><code>version: '3' services:   workaround-mysql:     container_name: workaround-mysql     image: mysql     environment:       MYSQL_DATABASE: workaround       MYSQL_USER: springuser       MYSQL_PASSWORD: admin       MYSQL_ROOT_PASSWORD: admin       MYSQL_ROOT_HOST: '%'     ports:       - '3308:3306'     restart: always </code></pre>  <p>So pretty simple right ? Database I start with <code>docker-compose up</code>:</p>  <p><a href='https://i.stack.imgur.com/NKfvA.png' rel='noreferrer'><img src='https://i.stack.imgur.com/NKfvA.png' alt='enter image description here'></a></p>  <p>All seems to be working fine so far.</p>  <p>Now that I have db started, to the application, this is its <code>docker-compose.yml</code>:</p>  <pre><code>version: '3' services:    workaround:     restart: always     # will build ./docker/workaround/Dockerfile     build: ./docker/workaround     working_dir: /workaround     volumes:       - ./:/workaround       - ~/.m2:/root/.m2     expose:       - '8080'     command: 'mvn clean spring-boot:run' </code></pre>  <p>For its <code>Dockerfile</code> I use Linux Alpine and Java.</p>  <pre><code>FROM alpine:3.9 ....add java... RUN apk update RUN apk add dos2unix --update-cache --repository http://dl-3.alpinelinux.org/alpine/edge/community/ --allow-untrusted RUN apk add bash RUN apk add maven </code></pre>  <p>Super simple. Now let's start the application :</p>  <p><a href='https://i.stack.imgur.com/VFGe0.png' rel='noreferrer'><img src='https://i.stack.imgur.com/VFGe0.png' alt='enter image description here'></a></p>  <p><a href='https://i.stack.imgur.com/WEpR6.png' rel='noreferrer'><img src='https://i.stack.imgur.com/WEpR6.png' alt='enter image description here'></a></p>  <p><a href='https://i.stack.imgur.com/w6o93.png' rel='noreferrer'><img src='https://i.stack.imgur.com/w6o93.png' alt='enter image description here'></a></p>  <p>Unknown host, so let's try the IP then :</p>  <pre><code>    docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' workaround-mysql  # URL for the mysql db spring.datasource.url=jdbc:mysql://172.20.0.2:3308/workaround?serverTimezone=UTC&amp;max_allowed_packet=15728640 </code></pre>  <p>Now I get timeout:</p>  <p><a href='https://i.stack.imgur.com/AOtVs.png' rel='noreferrer'><img src='https://i.stack.imgur.com/AOtVs.png' alt='enter image description here'></a></p>  <p>As you can see I get error. What is wrong with my setup and how to fix this? Either I have unknown host exception or Refused to connect or connection timeout.</p>  <p>I have tried:</p>  <ul> <li>Using ip of a container in my application.properties, didn't work</li> <li>Different ports for MySQL and application </li> <li>Different images and versions of MySQL </li> <li>Having everything in one docker compose with wait</li> <li>timer for database.</li> <li>Minimal setup with <a href='https://github.com/hellokoding/hellokoding-courses/tree/master/docker-examples/dockercompose-springboot-mysql-nginx' rel='noreferrer'>https://github.com/hellokoding/hellokoding-courses/tree/master/docker-examples/dockercompose-springboot-mysql-nginx</a> Also resulted in communication link failure, Site was accessible but I doubt that db was connected properly.</li> </ul>  <p><strong>Notes</strong>: </p>  <ul> <li><p>I run this all on one computer I use port 3308 because I have local MySQL db at 3306.</p></li> <li><p>Here is <code>docker ps -a</code></p></li> </ul>  <p><a href='https://i.stack.imgur.com/z7YJK.png' rel='noreferrer'><img src='https://i.stack.imgur.com/z7YJK.png' alt='enter image description here'></a></p>  <p>@Vusal ANSWER output :</p>  <p><a href='https://i.stack.imgur.com/EIUFN.png' rel='noreferrer'><img src='https://i.stack.imgur.com/EIUFN.png' alt='enter image description here'></a></p>  <p>Only thing different from code in answer I did wait for database to be ready 30 seconds</p>  <pre><code>command: /bin/bash -c 'sleep 30;mvn clean spring-boot:run;' </code></pre> ",
    "OwnerUserId": "2733333",
    "LastEditorUserId": "472495",
    "LastEditDate": "2019-06-04T21:39:08.083",
    "LastActivityDate": "2020-07-19T06:01:40.877",
    "Title": "Docker MySQL - can't connect from Spring Boot app to MySQL database",
    "Tags": "<mysql><spring><spring-boot><docker><docker-compose>",
    "AnswerCount": "4",
    "CommentCount": "7",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>Try this <code>docker-compose.yml</code>: </p>  <pre><code>version: '3' services:   workaround-mysql:     container_name: workaround-mysql     image: mysql     environment:       MYSQL_DATABASE: workaround       MYSQL_USER: springuser       MYSQL_PASSWORD: admin       MYSQL_ROOT_PASSWORD: admin       MYSQL_ROOT_HOST: '%'     ports:       - '3308:3306'     restart: always   workaround:     depends_on:        - workaround-mysql     restart: always     # will build ./docker/workaround/Dockerfile     build: ./docker/workaround     working_dir: /workaround     volumes:       - ./:/workaround       - ~/.m2:/root/.m2     expose:       - '8080'     command: 'mvn clean spring-boot:run' </code></pre>  <p>And update your <code>application.properties</code> to use the next JDBC connection url: </p>  <pre><code>spring.datasource.url=jdbc:mysql://workaround-mysql:3306/workaround?serverTimezone=UTC&amp;max_allowed_packet=15728640 </code></pre>  <p>It should work when both containers in the same docker-compose file, because docker-compose creates default network for containers, so they can resolve each other by name.</p> ",
    "highest_rated_answer": "<p>What you haven't tried so far is running both containers on the same Docker network.</p> <p>First, forget about IP addressing - using it should be avoided by all means.</p> <p>Second, launch both compose instances with the same Docker network.</p> <p>Third, <strong>do not</strong> expose ports - inside bridge network all ports are accessible to running containers.</p> <ol> <li><p>Create global network</p> <pre><code> docker network create foo </code></pre> </li> <li><p>Modify both compose files so that they use this network instead of creating each one its own:</p> <pre><code> version: '3.5'  services:   ....   networks:    default:      external: true      name: foo </code></pre> </li> <li><p>Remove <code>expose</code> directives from compose files - inside one network all ports are exposed by default</p> </li> <li><p>Modify connection strings to use default <code>3306</code> port instead of <code>3308</code></p> </li> <li><p>Enjoy</p> </li> </ol> "
  },
  {
    "Id": "56938511",
    "PostTypeId": "1",
    "CreationDate": "2019-07-08T15:50:21.217",
    "Score": "8",
    "ViewCount": "7029",
    "Body": "<p>I have a Spring Boot Application and developed it with a mongo db which was running in brew services. </p>  <p>To get a connection to the db I just had to put the following into application.properties in Spring Boot </p>  <pre><code>spring.data.mongodb.uri=mongodb://localhost:27017/db </code></pre>  <p>changing the application properties to </p>  <pre><code>spring.data.mongodb.uri=mongodb://mongo:27017/db </code></pre>  <p>didtn't change anything, same Error as before.</p>  <p>Now I'm trying to put the SpringBoot Application and the MongoDB into Docker-Containers, but cant get any connection working.</p>  <p>So this is my Dockerfile in the SpringBoot Application:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp EXPOSE 8080 ADD /build/libs/dg-0.0.1-SNAPSHOT.jar dg-0.0.1-SNAPSHOT.jar ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/dg-0.0.1-SNAPSHOT.jar'] </code></pre>  <p>This is my Docker-Compose.yml file:</p>  <pre><code>version: '3'  services:  mongo:  container_name: docker-mongo  image: mongo:latest  ports:    - '27017:27017'  volumes:   - ./data/db:/data/db  spring:  depends_on:    - mongo  image:    docker-spring-http-alpine  ports:    - '8080:8080'  links:    - mongo </code></pre>  <p>After executing Docker-Compose with </p>  <pre><code>docker-compose up </code></pre>  <p>I get the following error: (this is the actual error message )</p>  <pre><code>2019-07-08 23:10:19.990  INFO 1 --- [localhost:27017] org.mongodb.driver.cluster: Exception in monitor thread while connecting to server localhost:27017       com.mongodb.MongoSocketOpenException: Exception opening socket at com.mongodb.internal.connection.SocketStream.open(SocketStream.java:67) ~[mongodb-driver-core-3.8.2.jar!/:na] at com.mongodb.internal.connection.InternalStreamConnection.open(InternalStreamConnection.java:126) ~[mongodb-driver-core-3.8.2.jar!/:na] at com.mongodb.internal.connection.DefaultServerMonitor$ServerMonitorRunnable.run(DefaultServerMonitor.java:117) ~[mongodb-driver-core-3.8.2.jar!/:na] at java.lang.Thread.run(Thread.java:748) [na:1.8.0_212] Caused by: java.net.ConnectException: Connection refused (Connection refused) at java.net.PlainSocketImpl.socketConnect(Native Method) ~[na:1.8.0_212] at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350) ~[na:1.8.0_212] at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206) ~[na:1.8.0_212] at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188) ~[na:1.8.0_212] at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392) ~[na:1.8.0_212] at java.net.Socket.connect(Socket.java:589) ~[na:1.8.0_212] at com.mongodb.internal.connection.SocketStreamHelper.initialize(SocketStreamHelper.java:64) ~[mongodb-driver-core-3.8.2.jar!/:na] at com.mongodb.internal.connection.SocketStream.open(SocketStream.java:62) ~[mongodb-driver-core-3.8.2.jar!/:na] ... 3 common frames omitted </code></pre>  <p>Does someone know whats the problem here? In development environment it works like a charm.</p>  <p>Thanks in advance</p>  <p>Adding the following line to the Dockerfile </p>  <pre><code>'-Dspring.data.mongodb.uri=mongodb://mongo:27017/dg' </code></pre>  <p>into Entrypoint like this solved the connection issue</p>  <pre><code>ENTRYPOINT ['java', '-Dspring.data.mongodb.uri=mongodb://mongo:27017/dg','-Djava.security.egd=file:/dev/./urandom','-jar','/dg-0.0.1-SNAPSHOT.jar'] </code></pre>  <p>I was able to get connection to the db without the mentioned line above in the Entrypoint in the Dockerfile. I guess this is if you like to connect your db over 'links'</p>  <p>But now I was able to connect over Network, this is my code:</p>  <pre><code>version: '3.6'  services:   mongo:  container_name: docker_mongo  networks:    - gateway  ports:    - '27017:27017'  hostname: mongo  image: mongo:latest  volumes:    - ./data/db:/data/db   spring:  container_name: docker-spring  networks:    - gateway  ports:    - '8080:8080'  hostname: spring  depends_on:    - mongo  image: dg-docker-spring-http-alpine-j  networks: gateway: driver: 'bridge' </code></pre>  <p>and the following in application properties</p>  <pre><code>spring.data.mongodb.host=docker_mongo spring.data.mongodb.port=27017 spring.data.mongodb.database=db </code></pre>  <p>So it looks like the connection is working over Network now. The same code did not work with Version 3.0</p>  <p>To prevent SpringBoot to connect automatically to mongo over localhost it's also necessary to exclude MongoAutoConfiguration!</p>  <pre><code>@SpringBootApplication(exclude={MongoAutoConfiguration.class}) </code></pre>  <p>Thank you all for your help</p> ",
    "OwnerUserId": "4461271",
    "LastEditorUserId": "4461271",
    "LastEditDate": "2019-07-12T13:51:34.053",
    "LastActivityDate": "2019-07-12T13:51:34.053",
    "Title": "SpringBoot in Docker not connecting to Mongo in Docker",
    "Tags": "<mongodb><spring-boot><docker><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>EDIT:</p>  <p>I've never done spring-boot development, but the error you are saying is being displayed may very well be unrelated to the mongo issue. However, here is an explanation as to why your mongo-connection is failing:</p>  <hr>  <p><code>docker-compose</code> creates a virtual network if one hasn't been specified in the file (like in your case). </p>  <p>All your applications run inside of this network, completely isolated from each other. As such, <code>localhost</code> in your spring-boot container actually refers to itself. Meaning your spring-boot application is expecting the <code>mongo</code> instance to be running inside of its container (which its not, it's in a different container).</p>  <p>This would have been fine when both the database and application was running on your laptop's network. But as mentioned, they are now running in the <code>docker-compose</code> network, in complete isolation.</p>  <p>However, <code>docker-compose</code> is really clever! It creates a DNS for each of your containers which uses the service-name (in your case <code>mongo</code> and <code>spring</code>) specified in your <code>docker-compose</code> file to allow for easy access to the containers inside of the network. </p>  <p>So, you should be able to change <code>spring.data.mongodb.uri=mongodb://localhost:27017/db</code>to <code>spring.data.mongodb.uri=mongodb://mongo:27017/db</code> and that should allow it to connect.  </p> "
  },
  {
    "Id": "33660966",
    "PostTypeId": "1",
    "CreationDate": "2015-11-11T22:22:02.403",
    "Score": "7",
    "ViewCount": "1925",
    "Body": "<p>We've three Spring Boot applications:</p>  <ul> <li>Eureka Service</li> <li>Config Server</li> <li>Simple Web Service making use of Eureka and Config Server</li> </ul>  <p>I've set up the services so that we use a Eureka First Discovery, i.e. the simple web application finds out about the config server from the eureka service. </p>  <p>When started separately (either locally or by starting them as individual docker images) everything is ok, i.e. start config server after discovery service is running, and the Simple web service is started once the config server is running.</p>  <p>When docker-compose is used to start the services, they obviously start at the same time and essentially race to get up and running. This isn't an issue as we've added failFast: true and retry values to the simple web service and also have the docker container restarting so that the simple web service will eventually restart at a time when the discovery service and config server are both running but this doesn't feel optimal. </p>  <p>The unexpected behaviour we noticed was the following:</p>  <ul> <li>The simple web service reattempts a number of times to connect to the discovery service. This is sensible and expected</li> <li>At the same time the simple web service attempts to contact the config server. Because it cannot contact the discovery service, it retries to connect to a config server on localhost, e.g. logs show retries going to <a href='http://localhost:8888' rel='noreferrer'>http://localhost:8888</a>. This wasn't expected.</li> <li>The simple web service will eventually successfully connect to the discovery service but the logs show it stills tries to establish communication to the config server by going to <a href='http://localhost:8888' rel='noreferrer'>http://localhost:8888</a>. Again, this wasn't ideal.</li> </ul>  <p>Three questions/observations:</p>  <ul> <li>Is it a sensible strategy for the config client to fall back to trying localhost:8888 when it has been configured to use discovery to find the config server?</li> <li>When the eureka connections is established, should the retry mechanism not now switch to trying the config server endpoint as indicated by Eureka? Essentially putting in higher/longer retry intervals and periods for the config server connection is pointless in this case as it's never going to connect to it if it's looking at localhost so we're better just failing fast.</li> <li>Are there any properties that can override this behaviour?</li> </ul>  <p>I've created a sample github repo that demonstrates this behaviour:</p>  <p><a href='https://github.com/KramKroc/eurekafirstdiscovery/' rel='noreferrer'>https://github.com/KramKroc/eurekafirstdiscovery/tree/master</a></p> ",
    "OwnerUserId": "530846",
    "LastEditorUserId": "530846",
    "LastEditDate": "2015-11-12T15:51:39.393",
    "LastActivityDate": "2015-11-12T15:51:39.393",
    "Title": "Eureka First Discovery & Config Client Retry with Docker Compose",
    "Tags": "<spring-boot><spring-cloud><docker-compose><netflix-eureka>",
    "AnswerCount": "0",
    "CommentCount": "5",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": null
  },
  {
    "Id": "37490324",
    "PostTypeId": "1",
    "AcceptedAnswerId": "37490325",
    "CreationDate": "2016-05-27T18:40:07.273",
    "Score": "7",
    "ViewCount": "8961",
    "Body": "<p>I've got a Spring Boot application implementing a service which I want to run in a Docker container. I've followed the guideline of the official <a href='https://spring.io/guides/gs/spring-boot-docker/' rel='nofollow noreferrer'>Spring docs</a> which suggest to create a DockerFile similar to this:</p>  <pre><code>FROM frolvlad/alpine-oraclejdk8:slim VOLUME /tmp ADD gs-spring-boot-docker-0.1.0.jar app.jar RUN sh -c 'touch /app.jar' ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre>  <p>Then once the image is pushed to Docker I use <a href='https://docs.docker.com/compose/' rel='nofollow noreferrer'>Docker Compose</a> to launch it this way:</p>  <pre><code>  spring-boot-docker:     ports:     - '80:80'     expose:     - '80'     image: my-repo/spring-boot-docker:0.1.0-SNAPSHOT     container_name: spring-boot-docker     environment:       JAVA_OPTS: '-Xmx64m' </code></pre>  <p>Here I've got the <code>JAVA_OPTS</code> variable which limits the memory allocation, however, when I execute <code>docker stats spring-boot-docker</code>, the memory taken by the container is excessive (I understand the total memory taken by the JVM might be much more than 64M, but in this case is totally boundless).</p>  <p>I've also tried with the <a href='https://stackoverflow.com/questions/28837544/can-i-use-mem-limit-in-docker-compose-and-how'><code>mem_limit</code> param</a>, but this slows down the application noticeably.</p> ",
    "OwnerUserId": "1199132",
    "LastEditorUserId": "-1",
    "LastEditDate": "2017-05-23T12:02:31.193",
    "LastActivityDate": "2016-05-29T07:48:44.820",
    "Title": "Limit JVM memory consumption in a Docker container",
    "Tags": "<java><docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>After struggling for a while, it seems the <code>JAVA_OPTS</code> variable can be passed to the container <a href='https://stackoverflow.com/a/29926938/1199132'>when it's based in a Tomcat image</a>, but Spring Boot uses Java itself as the base image.</p>  <p>I've found out <a href='https://medium.com/@cl4r1ty/docker-spring-boot-and-java-opts-ba381c818fa2#.ubbv3dcca' rel='nofollow noreferrer'>this tutorial</a> which solved the problem for me, just modifying the way the process is launched in the DockerFile and adding a JAVA_OPTS variable directly in the ENTRYPOINT:</p>  <pre><code>ENTRYPOINT exec java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app.jar </code></pre>  <p>This way, the JVM will pick the value from the command itself.</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "42175951",
    "PostTypeId": "1",
    "AcceptedAnswerId": "42175990",
    "CreationDate": "2017-02-11T12:38:20.267",
    "Score": "7",
    "ViewCount": "16754",
    "Body": "<p>I am setting up a Spring application to run using compose. The application needs to establish a connection to ActiveMQ either running locally for developers or to existing instances for staging/production.</p>  <p>I setup the following which is working great for local dev:</p>  <pre><code>amq:     image: rmohr/activemq:latest     ports:       - '61616:61616'       - '8161:8161' legacy-bridge:     image:  myco/myservice     links:       - amq </code></pre>  <p>and in the application configuration I am declaring the AMQ connection as </p>  <pre><code>broker-url=tcp://amq:61616 </code></pre>  <p>Running docker-compose up is working great, activeMQ is fired up locally and my application constiner starts and connects to it.</p>  <p>Now I need to set this up for staging/production where the ActiveMQ instances are running on existing hardware within the infrastructure. My thoughts are to either use spring profiles to handle a different configurations in which case the application configuration entry for 'broker-url=tcp://amq:61616' would become something like <code>broker-url=tcp://some.host.here:61616</code> or find some way to create a dns entry within my production docker-compose.yml which will point an <code>amq</code> dns entry to the associated staging or production queues.</p>  <p>What is the best approach here and if it is DNS, how to I set that up in compose?</p>  <p>Thanks!</p> ",
    "OwnerUserId": "1232376",
    "LastActivityDate": "2023-06-25T00:49:27.493",
    "Title": "How to configure dns entries for Docker Compose",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<h1>Using the <code>extra_hosts</code> flag</h1> <p>First thing that comes to mind is using <a href='https://docs.docker.com/compose/compose-file/#/extrahosts' rel='nofollow noreferrer'>Compose's <code>extra_hosts</code></a> flag:</p> <pre><code>legacy-bridge:   image:  myco/myservice   extra_hosts:     - &quot;amq:1.2.3.4&quot; </code></pre> <p>This will not create a DNS record, but an entry in the container's <code>/etc/hosts</code> file, effectively allowing you to continue using <code>tcp://amq:61616</code> as your broker URL in your application.</p> <h1>Using an ambassador container</h1> <p>If you're not content with directly specifying the production broker's IP address and would like to leverage existing DNS records, you can use the <a href='https://web.archive.org/web/20191127090430/https://docs.docker.com/v17.09/engine/admin/ambassador_pattern_linking/' rel='nofollow noreferrer'>ambassador pattern</a>:</p> <pre><code>amq-ambassador:   image: svendowideit/ambassador   command: [&quot;your-amq-dns-name&quot;, &quot;61616&quot;]   ports:     - 61616 legacy-bridge:   image:  myco/myservice   links:     - &quot;amq-ambassador:amq&quot; </code></pre> ",
    "highest_rated_answer": null
  },
  {
    "Id": "45996171",
    "PostTypeId": "1",
    "AcceptedAnswerId": "46000034",
    "CreationDate": "2017-09-01T08:32:44.300",
    "Score": "7",
    "ViewCount": "4794",
    "Body": "<p>I'm running Elasticsearch instance from Docker. The image is from jHipster docker hub repo: <a href='https://hub.docker.com/r/jhipster/jhipster-elasticsearch/' rel='noreferrer'>jhipster/jhipster-elasticsearch/</a> - I'm using image v1.3.2 because I need Elasticsearch 2.4.0 (to be in line with Spring Boot version of the project).</p>  <p>I'm starting ES container along with Logstash and Kibana images, with <code>docker-compose</code>. This are the settings for starting ES container:</p>  <pre><code>jhipster-elasticsearch:     image: jhipster/jhipster-elasticsearch:v1.3.2     ports:         - 9400:9200         - 9500:9300     volumes:        - ./log-es-config/elasticsearch_custom.yml:/usr/share/elasticsearch/config/elasticsearch.yml </code></pre>  <p>So I'm using 9400 for REST and 9500 for transport communication.</p>  <p>This is configuration inside <code>elasticsearch_custom.yml</code> that is mounted to ES config:</p>  <pre><code>cluster.name: 'log-cluster' node.name: 'log-node' http.host: 0.0.0.0 transport.host: 127.0.0.1 transport.tcp.port: 9500 transport.publish_port: 9500 </code></pre>  <p>When I start container, this is what I get from <code>http://localhost:9400/_nodes</code>:</p>  <pre><code>'cluster_name': 'log-cluster',   'nodes': {     'xLsGj2DyTdCF89I7sAToVw': {       'name': 'log-node',       'transport_address': '127.0.0.1:9500',       'host': '127.0.0.1',       'ip': '127.0.0.1',       'version': '2.4.0',       'build': 'ce9f0c7',       'http_address': '172.18.0.5:9200',       'settings': {         'cluster': {           'name': 'log-cluster'         },         ... (I can put all response if needed) </code></pre>  <p><strong>JAVA API:</strong></p>  <p>Now I'm trying to connect to this ES node like this:</p>  <pre><code>    @Bean     public ElasticsearchOperations logsElasticsearchOperations() throws UnknownHostException {         Settings settings = Settings.settingsBuilder()             .put('cluster.name', 'log-cluster')             .put('node.name', 'log-node')             .build();          Client client = TransportClient.builder()             .settings(settings)             .build()             .addTransportAddress(new InetSocketTransportAddress(new InetSocketAddress('127.0.0.1', 9500)));           ElasticsearchTemplate template = new ElasticsearchTemplate(client);         template.createIndex(ProcessLog.class);         log.debug('Elasticsearch for logs configured.');         return template;     } </code></pre>  <p>The error I'm getting is the most famous one:</p>  <p><strong><code>Caused by: org.elasticsearch.client.transport.NoNodeAvailableException: None of the configured nodes are available: [{#transport#-1}{127.0.0.1}{127.0.0.1:9500}]</code></strong></p>  <p>I googled and tried different config approaches, also with <code>client.transport.sniff</code> set to <code>false</code>, but non of those worked. Now I spent lots of time trying to configure this one and I'm still missing something.</p>  <p>Thanks in advance for help. </p>  <p><strong>UPDATE:</strong></p>  <p>There is also embedded ES instance running when I start the app. So host ports config is like this:</p>  <ul> <li>Embedded ES: 9200 (http), 9300 (tcp)</li> <li>Docker's ES: 9400 (http), 9500 (tcp)</li> </ul>  <p>Here is full <code>docker-compose.yml</code>:</p>  <pre><code>    version: '2'     services:     jhipster-elasticsearch:         # elasticsearch 2.4.0 - to be in line with spring boot version         image: jhipster/jhipster-elasticsearch:v1.3.2         ports:             - 9400:9200             - 9500:9300         volumes:            - ./log-es-config/elasticsearch_custom.yml:/usr/share/elasticsearch/config/elasticsearch.yml     jhipster-logstash:         image: jhipster/jhipster-logstash:v2.2.1         command: logstash -f /conf/logstash_custom.conf         ports:             - 5000:5000/udp             - 6000:6000/tcp         volumes:             - ./logstash-log-es-conf/:/conf     jhipster-console:         image: jhipster/jhipster-console:v2.0.1         ports:             - 5601:5601     jhipster-zipkin:         image: jhipster/jhipster-zipkin:v2.0.1         ports:             - 9411:9411         environment:             - ES_HOSTS=http://jhipster-elasticsearch:9400             - ZIPKIN_UI_LOGS_URL=http://localhost:5601/app/kibana#/dashboard/logs-dashboard?_g=(refreshInterval:(display:Off,pause:!f,value:0),time:(from:now-1h,mode:quick,to:now))&amp;_a=(filters:!(),options:(darkTheme:!f),panels:!((col:1,id:logs-levels,panelIndex:2,row:1,size_x:6,size_y:3,type:visualization),(col:7,columns:!(stack_trace),id:Stacktraces,panelIndex:7,row:1,size_x:4,size_y:3,sort:!('@timestamp',desc),type:search),(col:11,id:Log-forwarding-instructions,panelIndex:8,row:1,size_x:2,size_y:3,type:visualization),(col:1,columns:!(app_name,level,message),id:All-logs,panelIndex:9,row:4,size_x:12,size_y:7,sort:!('@timestamp',asc),type:search)),query:(query_string:(analyze_wildcard:!t,query:'{traceId}')),title:logs-dashboard,uiState:()) </code></pre> ",
    "OwnerUserId": "5250885",
    "LastEditorUserId": "5250885",
    "LastEditDate": "2017-09-01T09:04:49.137",
    "LastActivityDate": "2017-09-01T13:59:55.687",
    "Title": "Connecting to Docker Elasticsearch instance through Java/Spring Boot",
    "Tags": "<java><elasticsearch><docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>I managed to get this working by defining the <code>transport.host</code> as <code>0.0.0.0</code> inside <code>elasticsearch_custom.yml</code>, so the instance binds to the container's ip.</p>  <p>Maybe this should be also default setup for <code>elasticsearch.yml</code> on the project's github <a href='https://github.com/jhipster/jhipster-console/tree/master/jhipster-elasticsearch' rel='nofollow noreferrer'>repo</a>.</p> ",
    "highest_rated_answer": "<p>From your docker compose file, port 9500 on the host is mapped to port 9300 inside the container, i.e.:</p>  <pre><code>ports:     - 9500:9300 </code></pre>  <p>So since port 9500 is the TCP port outside of the Docker container, in your <code>elasticsearch_custom.yml</code> config file you should have this instead</p>  <pre><code>transport.tcp.port: 9300 transport.publish_port: 9300 </code></pre>  <p>or simply leave those two lines out since 9300 is the default TCP port.</p> "
  },
  {
    "Id": "53152471",
    "PostTypeId": "1",
    "CreationDate": "2018-11-05T10:25:04.230",
    "Score": "7",
    "ViewCount": "7176",
    "Body": "<p>is there a way to choose if I want to have a logback appender or not, via environment variable?<br> <br> I have a dockerized spring boot Microservice and added now the ELK stack.<br> That works fine so far.<br> But now if I want to start my service without ELK stack, the application throws an error, that it doesn't know the host of Logstash:</p>  <pre><code>app | 10:09:23,537 |-ERROR in ch.qos.logback.classic.net.SyslogAppender[SYSLOG] - Could not create SyslogWriter java.net.UnknownHostException: logstash: Name or service not known app |   at java.net.UnknownHostException: logstash: Name or service not known </code></pre>  <p>Here is my logback.xml file:</p>  <pre><code>&lt;?xml version='1.0' encoding='UTF-8'?&gt; &lt;configuration&gt;      &lt;appender name='SYSLOG' class='ch.qos.logback.classic.net.SyslogAppender'&gt;         &lt;syslogHost&gt;logstash&lt;/syslogHost&gt;         &lt;port&gt;5000&lt;/port&gt;         &lt;facility&gt;LOCAL1&lt;/facility&gt;         &lt;suffixPattern&gt;[%thread] %logger %msg&lt;/suffixPattern&gt;     &lt;/appender&gt;      &lt;root level='INFO'&gt;         &lt;appender-ref ref='SYSLOG'/&gt;     &lt;/root&gt;  &lt;/configuration&gt; </code></pre>  <p>I know this is a very simple version, but I am new in logging with logback/ELK stack.<br> <br> So is there a way to inject something with an environment variable like in yaml files e.g. <code>active=${LOGBACK_ACTIVE:false}</code> like I can do it with my prometheus metrics?</p> ",
    "OwnerUserId": "8344100",
    "LastEditorUserId": "8344100",
    "LastEditDate": "2018-11-05T10:27:43.633",
    "LastActivityDate": "2020-05-25T18:10:37.513",
    "Title": "How can I dynamically (by env variable) activate/deactivate logback or logback appender?",
    "Tags": "<spring-boot><logging><docker-compose><logback><elastic-stack>",
    "AnswerCount": "2",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>In your logback.xml you could use the <code>&lt;if&gt;</code> construct to enable the <code>SYSLOG</code> appender when a named JVM parameter is present. </p>  <p>In the following example if you run your application with <code>-Dsyslog</code> then your <code>SYSLOG</code> appender will be engaged otherwise it will be ignored and the default appender, <code>CONSOLE</code>, will be engaged:</p>  <pre><code>&lt;if condition='isDefined('syslog')'&gt;   &lt;then&gt;     &lt;appender name='SYSLOG' class='ch.qos.logback.classic.net.SyslogAppender'&gt;       ...     &lt;/appender&gt;      &lt;root level='INFO'&gt;       &lt;appender-ref ref='SYSLOG' /&gt;     &lt;/root&gt;   &lt;/then&gt;   &lt;else&gt;     &lt;appender name='CONSOLE' class='ch.qos.logback.core.ConsoleAppender'&gt;       ...     &lt;/appender&gt;      &lt;root level='INFO'&gt;       &lt;appender-ref ref='CONSOLE' /&gt;     &lt;/root&gt;   &lt;/else&gt; &lt;/if&gt; </code></pre>  <p>This requires some duplication of the <code>root</code> declaration but since you need to conditionally prevent the SYSLOG appender from being <strong>instantiated</strong> I think this might be your only option.</p> "
  },
  {
    "Id": "53429062",
    "PostTypeId": "1",
    "CreationDate": "2018-11-22T10:38:36.987",
    "Score": "7",
    "ViewCount": "14310",
    "Body": "<p>I am building my first Springboot 2.0 application. I am trying to put my Springboot application into one docker container and my PostgresDB into another container.  </p>  <p><strong>My Dockerfile</strong></p>  <pre><code>    FROM frolvlad/alpine-oraclejdk8:slim     VOLUME /tmp     ADD springboot-api-demo-0.1*.jar app.jar     RUN sh -c 'touch /app.jar'     EXPOSE 9443     ENTRYPOINT [ 'sh', '-c', 'java $JAVA_OPTS -Djava.security.egd=file:/dev/urandom -jar /app.jar' ] </code></pre>  <p><strong>My docker-compose.yml file</strong></p>  <pre><code>version: '2.1'  services:   springboot-api-demo:     image: 'fw/springboot-api-demo'     mem_limit: 1024m     ports:       - '8080:8080'     environment:       - SPRING_PROFILES_ACTIVE=local       - AWS_REGION=local       - ENVIRONMENT=local       - AUTH_ENABLED=false   postgres:     container_name: pgdb     image: postgres:9.6-alpine     environment:     - 'POSTGRES_ROOT_PASSWORD=postgres'     - 'POSTGRES_USER=postgres'     - 'POSTGRES_PASSWORD=postgres'     ports:     - '54321:5432' </code></pre>  <p>I am using Springboot JPA Data 2.0 with below config data in my <strong>application.properties</strong></p>  <pre><code>spring.datasource.url= jdbc:postgresql://localhost:54321/java_learning spring.datasource.username=postgres spring.datasource.password=postgres </code></pre>  <p>I can test that Both of the Images are up. Also from docker log and docker events, I see that postgres  Container is running fine, even I can access it and also created a DB too. But springboot container started but i died because it could not connect to postgress and throwing error below. </p>  <blockquote>   <p>Unable to obtain connection from database: The connection attempt   failed</p> </blockquote>  <p>Note that my host machine already has Postgres on port 5432 thats why I did a port mapping ofr 54321:5432 on my postgres container. Here is Proof :) -</p>  <pre><code>\u279c  springboot-api-demo git:(master) \u2717 lsof -i:54321               COMMAND     PID             USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME com.docke 44345 shailendra.singh   18u  IPv4 0xf62897fbdd69e31d      0t0  TCP *:54321 (LISTEN) com.docke 44345 shailendra.singh   21u  IPv6 0xf62897fbdd119975      0t0  TCP localhost:54321 (LISTEN)  \u279c  springboot-api-demo git:(master) \u2717 lsof -i:5432  COMMAND  PID             USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME postgres 715 shailendra.singh    5u  IPv6 0xf62897fbb43e03b5      0t0  TCP localhost:postgresql (LISTEN) postgres 715 shailendra.singh    6u  IPv4 0xf62897fbbaeea9bd      0t0  TCP localhost:postgresql (LISTEN) </code></pre>  <p>I am not sure what is the problem. But my Springboot application is not able to connect my postgres container which is running fine with proper creadentials. </p> ",
    "OwnerUserId": "3511619",
    "LastEditorUserId": "2275818",
    "LastEditDate": "2018-11-22T10:52:45.053",
    "LastActivityDate": "2022-06-09T04:12:13.973",
    "Title": "Docker: Springboot container can not connect to PostgreSql Container Connection error",
    "Tags": "<postgresql><spring-boot><docker><docker-compose>",
    "AnswerCount": "4",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Try with :</p>  <pre><code>spring.datasource.url= jdbc:postgresql://pgdb:5432/java_learning </code></pre>  <p>The postgres database is not running on localhost, it's running in the other container which has an other IP (yet unknown). </p>  <p>Thanksfully, docker-compose automatically create a network shared among all the containers in the docker-compose.yml (unless explicitly said to do not), as a result you can magically use the <strong>service name as an hostname</strong>.</p>  <p>Also, you have a typo in the port, Postgres use <code>5432</code> by default, not <code>54321</code></p> "
  },
  {
    "Id": "59330607",
    "PostTypeId": "1",
    "AcceptedAnswerId": "59339438",
    "CreationDate": "2019-12-13T22:32:51.567",
    "Score": "6",
    "ViewCount": "8806",
    "Body": "<p>My web app can't connect to the MongoDB container</p> <p>here are my application.yml</p> <pre class='lang-yaml prettyprint-override'><code>spring:   data:     mongodb:       uri: mongodb://mongo:27017       host: mongo       port: 27017       database: my-db-name </code></pre> <p>and this is my Docker-Compose</p> <pre class='lang-yaml prettyprint-override'><code>version: &quot;3&quot; services:    java:     build:       context: ./     ports:       - &quot;8080:8080&quot;     links:       - mongo     depends_on:       - mongo     networks:       - shared-net    mongo:     image: 'mongo'     ports:       - 27017:27017     hostname: mongo     volumes:       - ./data/db:/data/db     networks:       - shared-net  networks:   shared-net:     driver: bridge </code></pre> <p>and this is the Dockerfile wrote for running java</p> <pre><code>FROM openjdk:11 COPY ./code/lemon-backend/target/lemon-0.0.1-SNAPSHOT.jar /usr/src/ WORKDIR /usr/src/ EXPOSE 8080 CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;lemon-0.0.1-SNAPSHOT.jar&quot;] </code></pre> <p>I can't even build the application using these options I get this exception:</p> <p><code>org.mongodb.driver.cluster: Exception in monitor thread while connecting to server mongo:27017</code></p> <p>if possible try giving solutions with docker-compose, thanks</p> ",
    "OwnerUserId": "9614342",
    "LastEditorUserId": "9614342",
    "LastEditDate": "2021-01-23T14:16:50.327",
    "LastActivityDate": "2021-01-23T14:35:11.350",
    "Title": "Connect To Docker Compose MongoDb Via Spring boot application",
    "Tags": "<java><mongodb><spring-boot><docker><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p><strong>OLD VERSION ANSWER</strong></p> <p><strong>IMPORTANT NOTE:</strong> older versions of MongoDB ignore this configuration in <code>application.properties</code>, proceed ahead &amp; use the new solutions I added</p> <hr/> <p>This workaround is used for old versions of spring and mongo that ignore the normal configuration (other than uri)</p> <p>. <em>I had a warning that this property cant be resolved but hopefully, it worked :)</em></p> <pre><code>dockerspring.data.mongodb.uri= mongodb://&lt;your_mongodb_container_name&gt;:27017/&lt;name_of_your_db&gt; </code></pre> <p><em>the mongodb part is not changeable but mongo before the port number is actually the name of the container witch you have specified in your docker-compose</em></p> <hr/> <p><strong>SPRING BOOT SOLUTION</strong></p> <pre class='lang-yaml prettyprint-override'><code>spring:   data:     mongodb:       host: &lt;mongo-db-container-name&gt;       port: &lt;mongo-db-port&gt;       database: &lt;database-name&gt; </code></pre> <hr/> <p><strong>DOCKER SOLUTION</strong></p> <p>In Your Dockerfile Add This Option For Executing Java</p> <pre><code>ENTRYPOINT [\u201cjava\u201d,\u201d-Dspring.data.mongodb.uri=mongodb://mongo:27017/name_of_your_db\u201d, \u201c-Djava.security.egd=file:/dev/./urandom\u201d,\u201d-jar\u201d,\u201d/&lt;name_of_your_app&gt;.jar\u201d] </code></pre> <hr/> <p><strong>Linking Java And Mongo Containers + Giving Them Names</strong></p> <p>here this is my final docker-compose.yml, I hope that it helps you</p> <pre class='lang-yaml prettyprint-override'><code>version: &quot;3&quot; services:    java:     build:       context: ./     ports:       - &quot;8080:8080&quot;     container_name: java     links:       - mongo     depends_on:       - mongo     networks:       - shared-net    mongo:     image: 'mongo'     ports:       - 27017:27017     container_name: mongo     volumes:       - /home/sinoed/data/db:/data/db     networks:       - shared-net  networks:   shared-net:     driver: bridge </code></pre> <p><strong>Compare this version and the one specified in the question carefully</strong></p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "60109556",
    "PostTypeId": "1",
    "CreationDate": "2020-02-07T08:21:38.050",
    "Score": "6",
    "ViewCount": "6444",
    "Body": "<p>I need multiple instance of same application, for that I am using  <code>server.port=0</code> to run application in random port.  my question is how can I map randomly generated port to docker-compose.yml to create multiple instances.  I am using spring boot at the back-end. I am unable to find any solution.  Any help much appreciated. </p> ",
    "OwnerUserId": "8133014",
    "LastActivityDate": "2020-02-07T10:16:29.903",
    "Title": "Expose random port to docker-compose.yml",
    "Tags": "<java><spring><spring-boot><docker><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Each Docker container runs a single process in an isolated network namespace, so this isn't necessary.  Pick a fixed port.  For HTTP services, common port numbers include 80, 3000, 8000, and 8080, depending on permissions and the language runtime (80 requires elevated privileges, 3000 is Node's default, and so on).  The exact port number doesn't matter.</p>  <p>You access the port from outside Docker space using a published port.  If you're running multiple containers, there is the potential for conflict if multiple services use the same host port, which is probably what you're trying to avoid.  In the <a href='https://docs.docker.com/engine/reference/commandline/run/#publish-or-expose-port--p---expose' rel='noreferrer'><code>docker run -p</code></a> option or the Docker Compose <a href='https://docs.docker.com/compose/compose-file/#ports' rel='noreferrer'><code>ports:</code></a> setting, it's possible to list only the port running inside the container, and Docker will choose a host port for you.</p>  <pre class='lang-yaml prettyprint-override'><code>version: '3' services:   web:     image: ...     ports:       - '8000'                       # no explicit host port     command: ... -Dserver.port=8000  # fixed container port </code></pre>  <p><a href='https://docs.docker.com/compose/reference/port/' rel='noreferrer'><code>docker-compose port</code></a> <code>web 8000</code> will tell you what the host (public) port number is.  For communication between containers in the same <code>docker-compose.yml</code> file, you can use the service name and the (fixed, known) internal port, <code>http://web:8000</code>.</p> "
  },
  {
    "Id": "60945565",
    "PostTypeId": "1",
    "AcceptedAnswerId": "60961132",
    "CreationDate": "2020-03-31T07:40:57.793",
    "Score": "6",
    "ViewCount": "3085",
    "Body": "<p>This is my docker-compose.yaml:</p>  <pre><code>version: '2.0' services:   mongo_container:     image: mongo:latest     environment:       MONGO_INITDB_ROOT_USERNAME: root       MONGO_INITDB_ROOT_PASSWORD: example       MONGO_INITDB_DATABASE: testdb     ports:       - '27017:27017'     volumes:       - ./mongodata:/data/db </code></pre>  <p>And this in my spring configuration:</p>  <pre><code>spring.data.mongodb.host=localhost spring.data.mongodb.port=27017 spring.data.mongodb.username=root spring.data.mongodb.password=example spring.data.mongodb.database=testdb </code></pre>  <p>But everytime when I try to connect my app to Mongo I get following error in Docker console:</p>  <pre><code>mongo_container_1  | 2020-03-31T07:37:24.803+0000 I  ACCESS   [conn2] SASL SCRAM-SHA-1 authentication failed for root on testdb from client 172.29.0.1:36628 ; UserNotFound: Could not find user 'root' for db 'testdb' </code></pre>  <p>What am I doing wrong? I tried to remove all containers with <code>docker system prune</code> and run it again but it still gives the same error.</p> ",
    "OwnerUserId": "4650497",
    "LastEditorUserId": "4650497",
    "LastEditDate": "2020-03-31T07:46:33.423",
    "LastActivityDate": "2020-03-31T22:49:43.027",
    "Title": "Mongodb with docker-compose - create user",
    "Tags": "<mongodb><spring-boot><docker><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>You need to add the following line in your application.properties :</p> <pre><code>spring.data.mongodb.authentication-database=admin </code></pre> <p><a href='https://hub.docker.com/_/mongo' rel='nofollow noreferrer'>From docker-hub mongodb readme</a> :</p> <blockquote> <p>MONGO_INITDB_ROOT_USERNAME, MONGO_INITDB_ROOT_PASSWORD</p> <p>These variables, used in conjunction, create a new user and set that user's password. <strong>This user is created in the admin authentication database</strong> and given the role of root, which is a &quot;superuser&quot; role.</p> </blockquote> <p>And for database :</p> <blockquote> <p>MONGO_INITDB_DATABASE This variable allows you to specify the name of a database to be used for creation scripts in /docker-entrypoint-initdb.d/*.js ... MongoDB is fundamentally designed for &quot;create on first use&quot;, <strong>so if you do not insert data with your JavaScript files, then no database is created.</strong></p> </blockquote> <p>In MongoDB, when authentication is enabled you allways authenticate against a particular database (by default admin), then connect and use another one. That's why there are two different properties : authentication-database (to authenticate against) and database (the one to use)</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "77385146",
    "PostTypeId": "1",
    "AcceptedAnswerId": "77393967",
    "CreationDate": "2023-10-29T20:48:18.027",
    "Score": "6",
    "ViewCount": "2443",
    "Body": "<p>I tried to remake a SpringBoot project from scratch, and i met this error <code>spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning</code> and nothing that i found online worked. I tried to reinstall docker and now all of my projects wont start. i always get this error in my terminal:</p> <pre><code>Cannot invoke &quot;org.springframework.boot.docker.compose.core.DockerCliInspectResponse.hostConfig()&quot; because &quot;inspectResponse&quot; is null     at org.springframework.boot.docker.compose.core.DefaultConnectionPorts.isHostNetworkMode(DefaultConnectionPorts.java:56) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.core.DefaultConnectionPorts.&lt;init&gt;(DefaultConnectionPorts.java:47) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.core.DefaultRunningService.&lt;init&gt;(DefaultRunningService.java:55) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.core.DefaultDockerCompose.getRunningServices(DefaultDockerCompose.java:83) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.lifecycle.DockerComposeLifecycleManager.start(DockerComposeLifecycleManager.java:120) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.lifecycle.DockerComposeListener.onApplicationEvent(DockerComposeListener.java:53) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.boot.docker.compose.lifecycle.DockerComposeListener.onApplicationEvent(DockerComposeListener.java:35) ~[spring-boot-docker-compose-3.1.2.jar:3.1.2]     at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) ~[spring-context-6.0.11.jar:6.0.11]     at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) ~[spring-context-6.0.11.jar:6.0.11]     at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:143) ~[spring-context-6.0.11.jar:6.0.11]     at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:131) ~[spring-context-6.0.11.jar:6.0.11]     at org.springframework.boot.context.event.EventPublishingRunListener.multicastInitialEvent(EventPublishingRunListener.java:136) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.context.event.EventPublishingRunListener.contextLoaded(EventPublishingRunListener.java:98) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplicationRunListeners.lambda$contextLoaded$4(SpringApplicationRunListeners.java:72) ~[spring-boot-3.1.2.jar:3.1.2]     at java.base/java.lang.Iterable.forEach(Iterable.java:75) ~[na:na]     at org.springframework.boot.SpringApplicationRunListeners.doWithListeners(SpringApplicationRunListeners.java:118) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplicationRunListeners.doWithListeners(SpringApplicationRunListeners.java:112) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplicationRunListeners.contextLoaded(SpringApplicationRunListeners.java:72) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplication.prepareContext(SpringApplication.java:416) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplication.run(SpringApplication.java:311) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306) ~[spring-boot-3.1.2.jar:3.1.2]     at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295) ~[spring-boot-3.1.2.jar:3.1.2]     at com.example.springboot3jwtauthenticationserver.SpringBoot3JwtAuthenticationServerApplication.main(SpringBoot3JwtAuthenticationServerApplication.java:10) ~[classes/:na]     at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]     at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) ~[na:na]     at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]     at java.base/java.lang.reflect.Method.invoke(Method.java:568) ~[na:na]     at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:50) ~[spring-boot-devtools-3.1.2.jar:3.1.2] </code></pre> <p>Does anyone have a solution?</p> ",
    "OwnerUserId": "13436670",
    "LastActivityDate": "2023-11-09T19:34:18.873",
    "Title": "Springboot-docker error: cannot invoke 'DockerCliInspectResponse.hostConfig()' because 'inspectResponse' is null",
    "Tags": "<spring-boot><docker><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>Today I encountered the same problem: <a href='https://github.com/spring-projects/spring-boot/issues/37982' rel='noreferrer'>issue</a> on this topic has already been created on GitHub. This is caused by updating Docker Compose to version 2.23.0; Spring boot does not yet work with this version.</p> <p>You need to either downgrade docker compose to 2.20.3 or wait for Spring Boot update, I think this will be fixed in next version</p> ",
    "highest_rated_answer": "<p>I'm trying to downgrade docker-compose to 2.20.3 on Mac m1 but I can't, I've tried several ways:</p> <pre><code>brew install docker-compose@2.20.4 </code></pre> <p>reinstall docker, but it installs in the latest version which is 2.23.0</p> "
  },
  {
    "Id": "39967945",
    "PostTypeId": "1",
    "CreationDate": "2016-10-10T22:53:52.573",
    "Score": "5",
    "ViewCount": "4195",
    "Body": "<p>I have a spring-boot app which talks to couchbase. I build the spring app as a docker image. There are some preconditions that need to be fulfilled in couchbase set up in order for the app to run. When I run my couchbase image first and then run my spring-boot app image everything runs fine. However, I need this to be automated and run from a docker-compose file meaning by a single docker-compose up command I should be able to run the couchbase image first, configure it with all presettings and then start to run the spring-boot app. I ran into quite a few discussion threads, but unfortunately I am not able to make it work somehow. I tried using cmd and entrypoint, but without success. Here is my docker-compose file</p>  <pre><code>version: '2' services:   expensetracker-cb:     image: chakrar27/expensetracker-cb     command: sh test_hello.sh     ports:       - 8080:8080     depends_on:       - mycouchbase    mycouchbase:     image: chakrar27/couchbase_new_10_08_2016     ports:       - 8091:8091       - 8092:8092        - 8093:8093        - 8094:8094       - 11210:11210 </code></pre>  <p>In fact it doesn't trigger the test_hello.sh at all. Here's the dockerfile for the spring-boot expensetracker app</p>  <pre><code>FROM frolvlad/alpine-oraclejdk8:slim VOLUME /tmp ADD expensetracker-cb-0.1.0.jar app.jar RUN sh -c 'touch /app.jar' ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/app.jar'] </code></pre>  <p>Can someone please help? </p> ",
    "OwnerUserId": "2943994",
    "LastEditorUserId": "5237",
    "LastEditDate": "2019-11-12T16:07:07.140",
    "LastActivityDate": "2019-11-12T16:07:07.140",
    "Title": "How do i wait for a db container to be up before my spring-boot app starts",
    "Tags": "<spring-boot><docker><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "1",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Ok...I could get it working by including the script in the Dockerfile of the app container. Not the best solution because I feel waiting code should not be part of the container itself. Also, I need to find a way to wait for the couchbase cluster to be up and running with sample buckets and include that in the script or the couchbase container itself. For now though this work-around works for me. Here's the dockerfile contents</p>  <pre><code>FROM frolvlad/alpine-oraclejdk8:slim VOLUME /tmp ADD expensetracker-cb-0.1.0.jar app.jar RUN sh -c 'touch /app.jar' ADD test_hello.sh . RUN chmod +x test_hello.sh CMD sh test_hello.sh </code></pre> "
  },
  {
    "Id": "46315744",
    "PostTypeId": "1",
    "AcceptedAnswerId": "46318061",
    "CreationDate": "2017-09-20T07:26:30.170",
    "Score": "5",
    "ViewCount": "13670",
    "Body": "<p>I've got a spring boot application which uses <code>com.spotify.dockerfile-maven-plugin</code> to build a docker image of my application org.rtu/some-importer</p>  <p>My docker-compose.yml is:</p>  <pre><code>version: '3' services:   some-importer:     image: org.rtu/some-importer     build: .   zookeeper:     image: wurstmeister/zookeeper     ports:       - '2181:2181'   kafka:      image: wurstmeister/kafka     ports:       - '9092:9092'     environment:       KAFKA_ADVERTISED_HOST_NAME: 172.17.0.1       KAFKA_CREATE_TOPICS: 'test:1:1'       KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181     volumes:       - /var/run/docker.sock:/var/run/docker.sock </code></pre>  <p>How can I say the during <code>docker-compose up</code> that it should be used an external <code>config.properties</code> from <code>/data/some-importer/config</code> folder?</p> ",
    "OwnerUserId": "1485401",
    "LastActivityDate": "2017-09-20T09:37:34.470",
    "Title": "Using external config in spring boot application within docker-compose",
    "Tags": "<spring><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "1",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>As mentioned in <a href='https://stackoverflow.com/questions/46315744/using-external-config-in-spring-boot-application-within-docker-compose#comment79596379_46315744'>the comments</a>, the first step is to <a href='https://stackoverflow.com/questions/23439126/how-to-mount-host-directory-in-docker-container'>mount a host directory in a docker container</a> (just like you did for Kafka). For example, you can use:</p>  <pre class='lang-yaml prettyprint-override'><code>version: '3' services:   some-importer:     image: org.rtu/some-importer     build: .     # Adding a volume/mount     volumes:       - /data/some-importer/config:/config </code></pre>  <p>This will map the <code>/data/some-importer/config</code> folder to <code>/config</code> in your Docker container. </p>  <blockquote>   <p><strong>NOTE</strong>: The linked answer also mentions that you can add it within your <code>Dockerfile</code> using <code>ADD</code>. However, this will add it to the image itself. If you make a change to the configuration, you'll have to rebuild your image to make those changes work.</p> </blockquote>  <p>The next step is to tell Spring boot to use this configuration file. If you want a completely customised location (eg. <code>/config/config.properties</code>), then you can use the <a href='https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-application-property-files' rel='noreferrer'><code>spring.config.location</code></a> parameter during startup.</p>  <blockquote>   <p><strong>NOTE</strong>: Spring boot will automatically pick up your configuration if it's located in <a href='https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-application-property-files' rel='noreferrer'>certain folders</a>. Otherwise you'll have to configure it with <code>spring.config.location</code>.</p> </blockquote>  <p>I don't know how your image looks like, but you should be able to do something like this:</p>  <pre><code>ENTRYPOINT [ 'sh', '-c', 'java -jar /app.jar --spring.config.location=$CONFIG_LOCATION' ] </code></pre>  <p>I'm using an environment variable called <code>$CONFIG_LOCATION</code> here, which makes it easier to customise the location by using environment variables. For example, you can add the following in your <code>docker-compose.yml</code> file:</p>  <pre class='lang-yml prettyprint-override'><code>version: '3' services:   some-importer:     image: org.rtu/some-importer     build: .     volumes:       - /data/some-importer/config:/config     # Configuring the environment variable     environment:       - CONFIG_LOCATION=file:/config/config.properties </code></pre> ",
    "highest_rated_answer": null
  },
  {
    "Id": "48121123",
    "PostTypeId": "1",
    "AcceptedAnswerId": "66119737",
    "CreationDate": "2018-01-05T20:53:38.520",
    "Score": "5",
    "ViewCount": "3706",
    "Body": "<pre><code>creditcard-monk:  build:   context: ./creditcard   dockerfile: Dockerfile   args:     JAR_FILE: target/creditcard-1.0.0.jar </code></pre>  <p>Docker compose version 3.0. The jar_file argument is used to copy the jar-file to spring-boot jar under docker container</p>  <p>I get the error <code>failed to build: COPY failed: stat /var/lib/docker/tmp/docker-builder347176151/target/creditcard-1.0.0.jar: no such file or directory</code></p>  <p>i thought the mentioning of context ,will read jar from target folder .but it seems docker-compose is not reading the file from context specified</p>  <p>Please help. Note:- the docker file is simple, built from alpine-java-8 and a copy command to copy jar to container to start spring boot app</p> ",
    "OwnerUserId": "1132758",
    "LastActivityDate": "2021-02-09T13:14:08.253",
    "Title": "Docker compose build relative path",
    "Tags": "<java><docker><spring-boot><build><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<pre><code>version: &quot;3.1&quot; services:     creditcard-monk:      build:       context: ./       dockerfile: Dockerfile       args:         JAR_FILE: target/creditcard-1.0.0.jar </code></pre> <p>or</p> <pre><code>docker build --build-arg JAR_FILE=target/creditcard-1.0.0.jar </code></pre> <p>both commands worked now. But the second command worked in most cases and never failed.</p> <p>As the docker is already running inside the folder</p> ",
    "highest_rated_answer": "<p>Your current code assumes the following path exists:</p>  <pre><code>./creditcard/target/creditcard-1.0.0.jar </code></pre>  <p>The JAR_FILE path will be inside the path you specified for context. Double check what the path should be and update your context and JAR_FILE argument accordingly.</p> "
  },
  {
    "Id": "50573224",
    "PostTypeId": "1",
    "AcceptedAnswerId": "50575615",
    "CreationDate": "2018-05-28T20:41:53.570",
    "Score": "5",
    "ViewCount": "4313",
    "Body": "<p>I'm trying to run a Spring Boot app as one of the services in a Docker Compose setup, but whenever I run <code>docker-compose up -d</code> the container running the Spring Boot app fails and exits immediately. For purposes of this post I'm using generic names like 'mycontainer' and 'myfile'.</p>  <p>Running <code>docker-compose logs core</code> shows that the error message is:</p>  <p><code>mycontainer | Error: unable to access jarfile myjar.jar</code></p>  <p>My docker-compose file is:</p>  <pre><code>version: '3.3'  services:   webapp:     image: webapp_image     container_name: webapp-container     build:       context: ./webapp       dockerfile: Dockerfile     volumes:       - './webapp:/usr/src/app'     ports:       - 3000:3000       - 35729:35729     environment:       - NODE_ENV=development       - env_file=./webapp/.env    core:     image: core_image     container_name: core-container     build:       context: ./core       dockerfile: Dockerfile     volumes:       - './core:/usr/src/core'       - './algorithms:/usr/src/algorithms'     ports:       - 8080:8080     environment:       - JARFILE=myjar.jar       - JAVA_OPTIONS=-Djava.security.egd=file:/dev/./urandom </code></pre>  <p>The Dockerfile for the <code>core</code> service, which is the one running the Spring Boot app, is this:</p>  <pre><code>FROM openjdk:8-jdk-alpine RUN mkdir -p /usr/src/core RUN mkdir -p /usr/src/algorithms ADD ./myproject/target/myjar.jar /usr/src/core ADD ./algorithms /usr/src/algorithms WORKDIR /usr/src/core  CMD java $JAVA_OPTIONS -jar $JARFILE </code></pre>  <p>If I run an individual container from the <code>core_image</code> image, and set the same environment vars that I defined in the docker-compose file, I can launch the Spring Boot app successfully, like so:</p>  <pre><code>$ docker run -it -p 8080:8080 --name mycontainer core_image sh $ /usr/src/core # ls -l total 15852 -rwxr-xr-x    1 root     root      16228579 Apr 21 22:44 myjar.jar $ /usr/src/core # java $JAVA_OPTIONS -jar $JARFILE </code></pre>  <p>But if I run a container from the same image as part of <code>docker-compose up -d</code> the container fails with the error that Java couldn't access the jarfile. I've tried specifying the absolute path to the jarfile in the <code>CMD</code> of the Dockerfile, but that doesn't help when running from Docker Compose.</p>  <p>Does anyone know what might be causing this? I'm on a Windows 10 host. Any help is greatly appreciated.</p> ",
    "OwnerUserId": "1565742",
    "LastActivityDate": "2018-05-29T02:43:23.803",
    "Title": "docker-compose java cannot access jarfile",
    "Tags": "<java><shell><docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>It seems you are overriding content of /usr/src/core [where you copy the jar file to] by mounting content from ./core in docker-compose. Remove below mount from services->core->volumes and give a try. <code>   volumes:       - './core:/usr/src/core' </code></p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "51176617",
    "PostTypeId": "1",
    "CreationDate": "2018-07-04T15:04:48.813",
    "Score": "5",
    "ViewCount": "8918",
    "Body": "<p>I've looked at SO posts related to this questions <a href='https://stackoverflow.com/questions/48350843/how-to-connect-from-docker-compose-to-host-postgresql'>here</a>, <a href='https://stackoverflow.com/questions/38199851/mongodb-connection-refused-docker-compose'>here</a>, <a href='https://stackoverflow.com/questions/45122028/docker-compose-up-connection-refused'>here</a>, and <a href='https://stackoverflow.com/questions/33357567/econnrefused-for-postgres-on-nodejs-with-dockers'>here</a> but I haven't had any luck with the fixes proposed.  Whenever I run the command <code>docker-compose -f stack.yml up</code> I receive the following stack trace:</p>  <pre><code>Attaching to weg-api_db_1, weg-api_weg-api_1 db_1       | 2018-07-04 14:57:15.384 UTC [1] LOG:  listening on IPv4 address '0.0.0.0', port 5432 db_1       | 2018-07-04 14:57:15.384 UTC [1] LOG:  listening on IPv6 address '::', port 5432 db_1       | 2018-07-04 14:57:15.388 UTC [1] LOG:  listening on Unix socket '/var/run/postgresql/.s.PGSQL.5432' db_1       | 2018-07-04 14:57:15.402 UTC [23] LOG:  database system was interrupted; last known up at 2018-07-04 14:45:24 UTC db_1       | 2018-07-04 14:57:15.513 UTC [23] LOG:  database system was not properly shut down; automatic recovery in progress db_1       | 2018-07-04 14:57:15.515 UTC [23] LOG:  redo starts at 0/16341E0 db_1       | 2018-07-04 14:57:15.515 UTC [23] LOG:  invalid record length at 0/1634218: wanted 24, got 0 db_1       | 2018-07-04 14:57:15.515 UTC [23] LOG:  redo done at 0/16341E0 db_1       | 2018-07-04 14:57:15.525 UTC [1] LOG:  database system is ready to accept connections weg-api_1  |  weg-api_1  |   .   ____          _            __ _ _ weg-api_1  |  /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\ weg-api_1  | ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ weg-api_1  |  \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) ) weg-api_1  |   '  |____| .__|_| |_|_| |_\\__, | / / / / weg-api_1  |  =========|_|==============|___/=/_/_/_/ weg-api_1  |  :: Spring Boot ::        (v1.5.3.RELEASE) weg-api_1  |  weg-api_1  | 2018-07-04 14:57:16.908  INFO 7 --- [           main] api.ApiKt                                : Starting ApiKt v0.0.1-SNAPSHOT on f9c58f4f2f27 with PID 7 (/app/spring-jpa-postgresql-spring-boot-0.0.1-SNAPSHOT.jar started by root in /app) weg-api_1  | 2018-07-04 14:57:16.913  INFO 7 --- [           main] api.ApiKt                                : No active profile set, falling back to default profiles: default weg-api_1  | 2018-07-04 14:57:17.008  INFO 7 --- [           main] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@6e5e91e4: startup date [Wed Jul 04 14:57:17 GMT 2018]; root of context hierarchy weg-api_1  | 2018-07-04 14:57:19.082  INFO 7 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http) weg-api_1  | 2018-07-04 14:57:19.102  INFO 7 --- [           main] o.apache.catalina.core.StandardService   : Starting service Tomcat weg-api_1  | 2018-07-04 14:57:19.104  INFO 7 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/8.5.14 weg-api_1  | 2018-07-04 14:57:19.215  INFO 7 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext weg-api_1  | 2018-07-04 14:57:19.215  INFO 7 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 2211 ms weg-api_1  | 2018-07-04 14:57:19.370  INFO 7 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean  : Mapping servlet: 'dispatcherServlet' to [/] weg-api_1  | 2018-07-04 14:57:19.375  INFO 7 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'characterEncodingFilter' to: [/*] weg-api_1  | 2018-07-04 14:57:19.376  INFO 7 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'hiddenHttpMethodFilter' to: [/*] weg-api_1  | 2018-07-04 14:57:19.376  INFO 7 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'httpPutFormContentFilter' to: [/*] weg-api_1  | 2018-07-04 14:57:19.376  INFO 7 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'requestContextFilter' to: [/*] weg-api_1  | 2018-07-04 14:57:19.867 ERROR 7 --- [           main] o.a.tomcat.jdbc.pool.ConnectionPool      : Unable to create initial connections of pool. weg-api_1  |  weg-api_1  | org.postgresql.util.PSQLException: Connection to localhost:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections. </code></pre>  <p>I thought that my .yml file was brain-dead-simple, but I must be missing something vital for the internal routing between the two containers to fail.  </p>  <p><strong>EDIT</strong></p>  <p>My stack.yml is below:</p>  <pre><code>version: '3' services:   db:     image: postgres     restart: always     container_name: db     environment:       POSTGRES_USER: root       POSTGRES_PASSWORD: password       POSTGRES_DB: weg     ports:       - '5432:5432'   weg-api:     image: weg-api     restart: always     container_name: weg-api     ports:       - '8080:8080'     depends_on:       - 'db' </code></pre>  <p><strong>EDIT</strong></p>  <p>My Springboot application properties are below:</p>  <pre><code>spring.datasource.url=jdbc:postgresql://db:5432/weg spring.datasource.username=root spring.datasource.password=password spring.jpa.generate-ddl=true </code></pre>  <p>I'm at a loss as to how to proceed.</p> ",
    "OwnerUserId": "4520965",
    "LastEditorUserId": "4520965",
    "LastEditDate": "2018-07-05T16:34:07.173",
    "LastActivityDate": "2018-07-05T16:34:07.173",
    "Title": "Running docker compose causes 'Connection to localhost:5432 refused.' exception",
    "Tags": "<postgresql><docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Your database is running on <code>db</code> container, not on your <code>localhost</code> inside your <code>weg-api</code> container. Therefore, you have to change</p>  <pre><code>spring.datasource.url=jdbc:postgresql://localhost:5432/weg </code></pre>  <p>to</p>  <pre><code>spring.datasource.url=jdbc:postgresql://db:5432/weg </code></pre>  <p>I would also suggest you give <code>container_name</code> to each of your containers to be sure the container names are always same. Otherwise you might sometimes get different names depending on your configuration.</p>  <pre><code>version: '3' services:   db:     image: postgres     restart: always     container_name: db     environment:       POSTGRES_USER: root       POSTGRES_PASSWORD: password       POSTGRES_DB: weg     ports:       - '5432:5432'   weg-api:     image: weg-api     restart: always     container_name: weg-api     ports:       - '8080:8080'     depends_on:       - 'db' </code></pre> "
  },
  {
    "Id": "52608571",
    "PostTypeId": "1",
    "CreationDate": "2018-10-02T12:41:24.083",
    "Score": "5",
    "ViewCount": "4275",
    "Body": "<p>I'm currently experimenting with Spring Boot-based microservices and getting to grips with docker, but I'm hitting a snag.</p>  <p>Basically what I'm trying to do is containerize 2 small services: a spring cloud config service and a spring cloud eureka service (discovery service). The eureka service fetches its configuration from the config service.</p>  <p>Both services are separate projects with their own Dockerfiles:</p>  <p><strong>Dockerfile-cloud-config-service:</strong></p>  <pre><code>FROM openjdk:10.0.2-13-jre-sid ENV APP_FILE cloud-config-service.jar ENV APP_HOME /usr/apps EXPOSE 8888 COPY target/$APP_FILE $APP_HOME/ WORKDIR $APP_HOME ENTRYPOINT ['sh', '-c'] CMD ['exec java -jar $APP_FILE'] </code></pre>  <p><strong>Dockerfile-discovery-service:</strong></p>  <pre><code>FROM openjdk:10.0.2-13-jre-sid ENV APP_FILE discovery-service.jar ENV APP_HOME /usr/apps EXPOSE 8761 COPY target/$APP_FILE $APP_HOME/ WORKDIR $APP_HOME ENTRYPOINT ['sh', '-c'] CMD ['exec java -jar $APP_FILE'] </code></pre>  <p>Using docker-compose I'm trying to tie them together using the following <strong>docker-compose.yml:</strong></p>  <pre><code>version: '3.7' services:   cloud-config-service:     container_name: cloud-config-service     build:       context: cloud-config-service       dockerfile: Dockerfile-cloud-config-service     image: cloud-config-service:latest     ports:       - 8888:8888     networks:       - emp-network    discovery-service:     container_name: discovery-service     build:       context: discovery-service       dockerfile: Dockerfile-discovery-service     image: discovery-service:latest     ports:       - 8761:8761     networks:       - emp-network     links:       - cloud-config-service  networks:   emp-network:     driver: bridge </code></pre>  <p>At first I configured the discovery-service to fetch its configuration from <em><a href='http://localhost:8888' rel='nofollow noreferrer'>http://localhost:8888</a></em>, but after some digging I found that localhost in a container refers to the container itself and found in the Docker documentation that services can refer to each other using their names. So I changed discovery-service's properties to fetch its config from <em><a href='http://cloud-config-service:8888' rel='nofollow noreferrer'>http://cloud-config-service:8888</a></em>. That doesn't work, hence this post.</p>  <p>Both Dockerfiles build and run just fine, except the fact that the discovery-service fails to GET the config-service on <em><a href='http://cloud-config-service:8888' rel='nofollow noreferrer'>http://cloud-config-service:8888</a></em>.</p>  <p>It does work if I use the <code>host</code> network driver and the <em><a href='http://localhost:8888' rel='nofollow noreferrer'>http://localhost:8888</a></em> endpoint, but this 'feels' hacky and not how it is supposed to be done.</p>  <p>I'm probably missing something trivial, but I'm afraid I can't find what.</p>  <p><strong>EDIT:</strong> Small snippet of discovery-service's console log:</p>  <pre><code>discovery-service       | 2018-10-02 13:14:26.798  INFO 1 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Fetching config from server at : http://cloud-config-service:8888 cloud-config-service    | 2018-10-02 13:14:26.836  INFO 1 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration' of type [org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration$$EnhancerBySpringCGLIB$$8a18e3b3] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying) discovery-service       | 2018-10-02 13:14:27.129  INFO 1 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Connect Timeout Exception on Url - http://cloud-config-service:8888. Will be trying the next url if available discovery-service       | 2018-10-02 13:14:27.129  WARN 1 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Could not locate PropertySource: I/O error on GET request for 'http://cloud-config-service:8888/discovery-service/default': Connection refused (Connection refused); nested exception is java.net.ConnectException: Connection refused (Connection refused) </code></pre> ",
    "OwnerUserId": "5818149",
    "LastEditorUserId": "5818149",
    "LastEditDate": "2018-10-02T13:20:01.067",
    "LastActivityDate": "2018-10-03T06:04:17.057",
    "Title": "docker-compose inter container communication",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Firstly, communication between docker containers is a subset of a much bigger problem prevalent in distributed services - You don't know what service (and hence <a href='https://en.wikipedia.org/wiki/Cascading_failure' rel='nofollow noreferrer'>their dependencies</a>) will go down at any moment, and so you should take into account such failures when you build your application.</p>  <p>The problem that you are facing is common, even more so with Docker containers, and I believe inter-container communication is a major piece in Docker that is under frequent development changes.</p>  <p>To address your problem, first, I would like to put forth some points - </p>  <ol> <li><code>localhost</code> from within a container will refer to that container itself.</li> <li><code>localhost</code> on your machine does in fact refer to your local host and will be mapped with services you map through the <code>ports</code> configuration for each of your services in the <code>docker-compose</code> file.</li> <li><code>depends_on</code> only waits for the container to start and not for the actual process to start running - which might mean that the service you are waiting for isn't necessarily up and running yet, and so, cause timeouts for the dependent service(s).</li> </ol>  <p>What you need is to wait for the service to start running, not just the container to be up. There are two possible ways you can accomplish this - </p>  <ol> <li><p>Specify a <code>restart</code> policy for your <code>discovery-service</code> based on failure. In your case, failure would be when it times out while connecting to the <code>cloud-config-service</code>. Something like <code>restart: on-failure:10</code> which means you are asking docker to restart the <code>discover-service</code> when it fails with a maximum retry of 10. That way, you would have given reasonable time for the other container (service) to be up and running and make sure that the container with the restart policy <em>eventually</em> connects to that one.</p></li> <li><p>Use another tool like <a href='https://github.com/jwilder/dockerize' rel='nofollow noreferrer'>dockerize</a> that allows you to <a href='https://github.com/jwilder/dockerize#waiting-for-other-dependencies' rel='nofollow noreferrer'>wait</a> on other services before starting up the container.</p></li> </ol>  <p>Also, to make sure you are debugging the problem correctly, be sure to check the logs of your container to see what the issue really is - <code>docker logs -f --tail=100 &lt;container_name/container_id&gt;</code>.</p>  <p>Hope this helps.</p> "
  },
  {
    "Id": "54241346",
    "PostTypeId": "1",
    "AcceptedAnswerId": "54265759",
    "CreationDate": "2019-01-17T17:33:03.213",
    "Score": "5",
    "ViewCount": "17633",
    "Body": "<p><em>docker-compose.yml:</em></p>  <pre><code>services:   server:     image: server:latest     environment:     - SPRING_PROFILES_ACTIVE=dev     ports:     - 8080:8080     - 18080:18080 </code></pre>  <p><em>Dockerfile:</em></p>  <pre><code>FROM openjdk:8-jre-alpine  ENV SPRING_OUTPUT_ANSI_ENABLED=ALWAYS \\     SLEEP=0 \\     JAVA_OPTS='' \\  RUN adduser -D -s /bin/sh server WORKDIR /home/server  ADD entrypoint.sh entrypoint.sh RUN chmod 755 entrypoint.sh &amp;&amp; chown server:server entrypoint.sh USER server  ENTRYPOINT ['./entrypoint.sh'] # expose server ports EXPOSE 8080 18080  ADD *.jar server.jar </code></pre>  <p><em>entrypoint.sh:</em></p>  <pre><code>#!/bin/sh  echo 'The application will start in ${SLEEP}s...' &amp;&amp; sleep ${SLEEP} exec java ${JAVA_OPTS} -Djava.security.egd=file:/dev/./urandom -jar '${HOME}/server.jar' '$@' </code></pre>  <p>I have 3 application.yml: <code>application.yml</code>, <code>application-dev.yml</code> and <code>application-prod.yml</code> which differ from database address.</p>  <p>But when I run <code>docker-compose up</code>, the server always use the default setting even I mentionned as in <em>docker-compose.yml</em> that the active profile is dev.</p>  <p>I'd like to know how to enable different profile in docker-compose file. Thanks.</p>  <p><strong>edit:</strong> the <em>server.jar</em> file is built using <code>assemble</code> of gradle.</p> ",
    "OwnerUserId": "5265472",
    "LastEditorUserId": "5265472",
    "LastEditDate": "2019-01-17T17:42:39.810",
    "LastActivityDate": "2019-01-23T21:09:14.720",
    "Title": "Switching spring profile based on docker environment variable does not work",
    "Tags": "<spring-boot><docker><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>Add a command: name space like below:</p>  <pre><code>services:   server:     image: server:latest     environment:     - SPRING_PROFILES_ACTIVE=dev     ports:     - 8080:8080     - 18080:18080     command: --spring.profiles.active=prod </code></pre>  <p>After your container runs this will be appended to your entry point and spring boot will pickup this profile. It will be executed like : </p>  <p>Java -jar yourJar.jar --spring.profiles.active = prod. </p>  <p>And if you want to run your project app in various environment of your company and for various environment you have different kubernetes cluster configured then configure this setting differently on different kubernetes environment for your app . Means while running your docker image in qa environmner qa Kubernetes cluster will pass --spring.profiles.active = qa and similarily staging and Prod cluster.  </p>  <p>And even  if you you want to use environment variable you are using  then use </p>  <pre><code>exec java ${JAVA_OPTS} -Dspring.profiles.active={your envronment variable name describe in docker compose} -Djava.security.egd=file:/dev/./urandom -jar '${HOME}/server.jar' '$@' </code></pre>  <p>Check this on github: <a href='https://github.com/vaneetkataria/MicroService_Architecture/blob/master/docker-compose.yml' rel='noreferrer'>https://github.com/vaneetkataria/MicroService_Architecture/blob/master/docker-compose.yml</a></p> ",
    "highest_rated_answer": "<p>.yaml files are handled differently than .properties files.    </p>  <p>properties will look for a file with the active profile in the name:<br> application-dev.properties<br> application-prod.properties<br> ...    </p>  <p>yaml files, however you store all profiles in a single file separated by '---'.      </p>  <p>Example [using your existing docker-compose.yaml]:</p>  <p>application.yaml:</p>  <pre><code>spring:       application:         your-application-name   [other global application settings]       ...     --- spring:     profiles: dev     [other settings which apply only to dev environment]   --- spring:     profiles: prod [all production settings (will overwrite other values if present] </code></pre> "
  },
  {
    "Id": "56202090",
    "PostTypeId": "1",
    "AcceptedAnswerId": "56202686",
    "CreationDate": "2019-05-18T19:10:43.963",
    "Score": "5",
    "ViewCount": "4154",
    "Body": "<p>The Dockerfile of my spring-boot app:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp COPY target/media-0.0.1-SNAPSHOT.jar app.jar ENTRYPOINT ['java', '-jar', '/app.jar'] </code></pre>  <p><code>application.yml</code></p>  <pre><code>spring:   datasource:     url: jdbc:postgresql://localhost:5432/media     username: postgres     password: postgres     hikari:       connectionTimeout: 30000 </code></pre>  <p>and here is the <code>docker-compose.yml</code>:</p>  <pre><code>version: '3' services:   db:     image: postgres     ports:       - '5432:5432'     environment:       POSTGRES_DB: media       POSTGRES_USER: postgres       POSTGRES_PASSWORD: postgres    app:     build:       context: ./       dockerfile: Dockerfile     depends_on:       - db     ports:       - '8080:8080' </code></pre>  <p>Running <code>docker-compose up --build</code> results in:</p>  <blockquote>   <p>app_1  | org.postgresql.util.PSQLException: Connection to 0.0.0.0:5432   refused. Check that the hostname and port are correct and that the   postmaster is accepting TCP/IP connections. app_1 </p> </blockquote>  <p>My guess is that the spring app tries to connect to postgres before postgres is ready, but I get the following log:</p>  <blockquote>   <p>db_1   | 2019-05-18 19:05:53.692 UTC [1] LOG:  database system is   ready to accept connections</p> </blockquote> ",
    "OwnerUserId": "7451566",
    "LastEditorUserId": "472495",
    "LastEditDate": "2019-05-18T19:32:20.167",
    "LastActivityDate": "2019-05-18T20:40:55.853",
    "Title": "Spring Docker container cannot access Postgres Docker container",
    "Tags": "<postgresql><spring-boot><docker><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>The main purpose of Docker Compose is to spin up a set of Docker containers, which will then function as independent entities. By default, all containers will have a virtual network connection to all others, though you can change that if you wish; you will get that feature, since you have not specified a custom configuration.</p>  <p>Each of the containers will get a virtual IP address inside the virtual network set up by Docker. Since these are dynamic, Docker Compose makes it easier for you by creating internal DNS entries corresponding to each service. So, you will have two containers, which can be addressed as <code>app</code> and <code>db</code> respectively, either from themselves or the other. If you have ping installed, you can ping these names too, either via <code>docker-compose exec</code>, or via a manually-created shell.</p>  <p>Thus, as we discovered in the comments, you can connect from <code>app</code> to <code>jdbc:postgresql://db:5432/media</code>, and it should work.</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "56753810",
    "PostTypeId": "1",
    "AcceptedAnswerId": "56754341",
    "CreationDate": "2019-06-25T12:14:26.713",
    "Score": "5",
    "ViewCount": "2260",
    "Body": "<p>I'm pretty new to Docker and I need to startup my Angular/SpringBoot/MySQL project with docker-compose on the docker toolbox. I copied a docker yml file into my project which used the same technologies and changed the paths inside of it to match my project. However when I try docker-compose, it throws the following error:</p>  <pre><code>com.mysql.cj.jdbc.exceptions.CommunicationsException: Communications link failure [...] 84 common frames omitted Caused by: java.net.ConnectException: Connection refused (Connection refused) </code></pre>  <p>the docker-compose.yml looks like:</p>  <pre><code>version: '3'  services:   database:     image: mysql     container_name: database     environment:       MYSQL_ROOT_PASSWORD: ****       MYSQL_DATABASE: db_example       MYSQL_USER: springuser       MYSQL_PASSWORD: ****     ports:       - 3306:3306     volumes:       - db_exampleData:/var/lib/mysql    springapi:     image: openjdk:10-jre-slim     container_name: springapi     ports:       - 8443:8443     depends_on:       - database     volumes:       - ./backend/target/backend-0.1.0.jar:/application.jar     command: ['java', '-jar', 'application.jar']    angular:     image: nginx:alpine     container_name: angular     ports:       - 4200:80     depends_on:       - springapi     volumes:       - ./nginx.conf:/etc/nginx/nginx.conf       - ./frontend/my-app/dist/my-app:/usr/share/nginx/html  volumes:   db_exampleData: </code></pre>  <p>the application.properties:</p>  <pre><code>spring.jpa.hibernate.ddl-auto=none spring.jpa.open-in-view=false spring.datasource.url=jdbc:mysql://localhost:3306/db_example spring.datasource.username=springuser spring.datasource.password=****  server.port=8443 </code></pre>  <p>any suggestion would be helpful!</p> ",
    "OwnerUserId": "9204008",
    "LastEditorUserId": "9204008",
    "LastEditDate": "2019-06-25T12:38:18.313",
    "LastActivityDate": "2019-06-25T12:58:39.813",
    "Title": "docker compose: spring boot connection to mysql database refused",
    "Tags": "<mysql><spring-boot><docker><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>you need to change your connecion like this:</p>  <pre><code>jdbc:mysql://database:3306/db_example </code></pre>  <p>and add this to your docker-compose under <code>springapi</code> service:</p>  <pre><code>links:    - database </code></pre>  <p>on the other hand you may use <a href='https://raw.githubusercontent.com/vishnubob/wait-for-it/master/wait-for-it.sh' rel='nofollow noreferrer'>wait-for-it.sh</a> to check if DB is up by add a command section under <code>springapi</code> service:</p>  <pre><code>command: ['path/to/wait-for-it.sh', 'database:3306', '-t', '6000', '--', 'YOUR ACTUAL COMMAND'] </code></pre> ",
    "highest_rated_answer": null
  },
  {
    "Id": "63026751",
    "PostTypeId": "1",
    "CreationDate": "2020-07-22T04:12:18.483",
    "Score": "5",
    "ViewCount": "10118",
    "Body": "<p>I am securing the Eureka server with spring security, the eureka server and config server is dockerized in a container and the config server is registered with the Eureka server</p> <p><a href='https://i.stack.imgur.com/iY7EC.png' rel='noreferrer'><img src='https://i.stack.imgur.com/iY7EC.png' alt='enter image description here' /></a></p> <p>Now I am trying to register other services to the Eureka, Other services are running from IDE they are not dockerized. I am using discovery first approach</p> <h1>Eureka server</h1> <pre><code>server:   port: 8761  # Discovery Server Access eureka:   instance:     hostname: localhost   client:     register-with-eureka: false     fetch-registry: false   serviceUrl:     defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ spring:   profiles:     active: dev   security:     basic:       enabled: true     user:       name: fetebird       password: fetebird </code></pre> <h1>Config Server</h1> <pre><code>server:   port: 8085  eureka:   client:     register-with-eureka: true     fetch-registry: true     service-url:       defaultZone: http://fetebird:fetebird@fetebird-eurekaservice:8761/eureka/ </code></pre> <h1>Other service</h1> <pre><code>spring:   application:     name: APIGATEWAY-SERVICE   cloud:     config:       discovery:         service-id: CONFIG-SERVER         enabled: true </code></pre> <h1>Error</h1> <pre><code>org.springframework.core.codec.DecodingException: JSON decoding error: Root name 'timestamp' does not match expected ('applications') for type [simple type, class com.netflix.discovery.shared.Applications]; nested exception is com.fasterxml.jackson.databind.exc.MismatchedInputException: Root name 'timestamp' does not match expected ('applications') for type [simple type, class com.netflix.discovery.shared.Applications]  at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 2] (through reference chain: com.netflix.discovery.shared.Applications[&quot;timestamp&quot;])     at org.springframework.http.codec.json.AbstractJackson2Decoder.processException(AbstractJackson2Decoder.java:215) ~[spring-web-5.2.7.RELEASE.jar:5.2.7.RELEASE]     Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Error has been observed at the following site(s):     |_ checkpoint \u21e2 Body from GET http://localhost:8761/eureka/apps/?regions=us-east-1 [DefaultClientResponse] Stack trace:         at org.springframework.http.codec.json.AbstractJackson2Decoder.processException(AbstractJackson2Decoder.java:215) ~[spring-web-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.http.codec.json.AbstractJackson2Decoder.decode(AbstractJackson2Decoder.java:173) ~[spring-web-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.http.codec.json.AbstractJackson2Decoder.lambda$decodeToMono$1(AbstractJackson2Decoder.java:159) ~[spring-web-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:118) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxContextStart$ContextStartSubscriber.onNext(FluxContextStart.java:96) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:287) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:330) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1782) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:152) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:252) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:252) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.netty.channel.FluxReceive.terminateReceiver(FluxReceive.java:427) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]         at reactor.netty.channel.FluxReceive.drainReceiver(FluxReceive.java:210) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]         at reactor.netty.channel.FluxReceive.request(FluxReceive.java:121) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]         at reactor.core.publisher.FluxMap$MapSubscriber.request(FluxMap.java:155) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxPeek$PeekSubscriber.request(FluxPeek.java:130) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxPeek$PeekSubscriber.request(FluxPeek.java:130) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxMap$MapSubscriber.request(FluxMap.java:155) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.MonoCollect$CollectSubscriber.onSubscribe(MonoCollect.java:112) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:86) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxPeek$PeekSubscriber.onSubscribe(FluxPeek.java:163) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxPeek$PeekSubscriber.onSubscribe(FluxPeek.java:163) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:86) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:300) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]         at reactor.netty.channel.FluxReceive.lambda$subscribe$2(FluxReceive.java:138) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]         at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]         at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]         at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) ~[netty-transport-4.1.50.Final.jar:4.1.50.Final]         at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]         at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]         at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]         at java.base/java.lang.Thread.run(Thread.java:832) ~[na:na]     Suppressed: java.lang.Exception: #block terminated with an error         at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:99) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at reactor.core.publisher.Mono.block(Mono.java:1679) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]         at org.springframework.cloud.netflix.eureka.http.WebClientEurekaHttpClient.getApplicationsInternal(WebClientEurekaHttpClient.java:143) ~[spring-cloud-netflix-eureka-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.netflix.eureka.http.WebClientEurekaHttpClient.getApplications(WebClientEurekaHttpClient.java:124) ~[spring-cloud-netflix-eureka-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.netflix.eureka.config.EurekaConfigServerBootstrapConfiguration.lambda$eurekaConfigServerInstanceProvider$0(EurekaConfigServerBootstrapConfiguration.java:112) ~[spring-cloud-netflix-eureka-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.config.client.ConfigServerInstanceProvider.getConfigServerInstances(ConfigServerInstanceProvider.java:50) ~[spring-cloud-config-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.config.client.DiscoveryClientConfigServiceBootstrapConfiguration$HeartbeatListener.refresh(DiscoveryClientConfigServiceBootstrapConfiguration.java:120) ~[spring-cloud-config-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.config.client.DiscoveryClientConfigServiceBootstrapConfiguration$HeartbeatListener.startup(DiscoveryClientConfigServiceBootstrapConfiguration.java:106) ~[spring-cloud-config-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.config.client.DiscoveryClientConfigServiceBootstrapConfiguration$HeartbeatListener.onApplicationEvent(DiscoveryClientConfigServiceBootstrapConfiguration.java:98) ~[spring-cloud-config-client-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:404) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:361) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:898) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:554) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:758) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:750) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:315) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.builder.SpringApplicationBuilder.run(SpringApplicationBuilder.java:140) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.cloud.bootstrap.BootstrapApplicationListener.bootstrapServiceContext(BootstrapApplicationListener.java:212) ~[spring-cloud-context-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.bootstrap.BootstrapApplicationListener.onApplicationEvent(BootstrapApplicationListener.java:117) ~[spring-cloud-context-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.cloud.bootstrap.BootstrapApplicationListener.onApplicationEvent(BootstrapApplicationListener.java:74) ~[spring-cloud-context-2.2.3.RELEASE.jar:2.2.3.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:127) ~[spring-context-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.boot.context.event.EventPublishingRunListener.environmentPrepared(EventPublishingRunListener.java:80) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplicationRunListeners.environmentPrepared(SpringApplicationRunListeners.java:53) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.prepareEnvironment(SpringApplication.java:345) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:308) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1237) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) ~[spring-boot-2.3.1.RELEASE.jar:2.3.1.RELEASE]         at fete.bird.fetebirdapigateway.FeteBirdApiGatewayApplication.main(FeteBirdApiGatewayApplication.java:13) ~[main/:na]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]         at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]         at java.base/java.lang.reflect.Method.invoke(Method.java:564) ~[na:na]         at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:49) ~[spring-boot-devtools-2.3.1.RELEASE.jar:2.3.1.RELEASE] Caused by: com.fasterxml.jackson.databind.exc.MismatchedInputException: Root name 'timestamp' does not match expected ('applications') for type [simple type, class com.netflix.discovery.shared.Applications]  at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 2] (through reference chain: com.netflix.discovery.shared.Applications[&quot;timestamp&quot;])     at com.fasterxml.jackson.databind.exc.MismatchedInputException.from(MismatchedInputException.java:63) ~[jackson-databind-2.11.0.jar:2.11.0]     at com.fasterxml.jackson.databind.DeserializationContext.reportPropertyInputMismatch(DeserializationContext.java:1499) ~[jackson-databind-2.11.0.jar:2.11.0]     at com.fasterxml.jackson.databind.DeserializationContext.reportPropertyInputMismatch(DeserializationContext.java:1515) ~[jackson-databind-2.11.0.jar:2.11.0]     at com.fasterxml.jackson.databind.ObjectReader._unwrapAndDeserialize(ObjectReader.java:2188) ~[jackson-databind-2.11.0.jar:2.11.0]     at com.fasterxml.jackson.databind.ObjectReader._bindAndClose(ObjectReader.java:2054) ~[jackson-databind-2.11.0.jar:2.11.0]     at com.fasterxml.jackson.databind.ObjectReader.readValue(ObjectReader.java:1431) ~[jackson-databind-2.11.0.jar:2.11.0]     at org.springframework.http.codec.json.AbstractJackson2Decoder.decode(AbstractJackson2Decoder.java:168) ~[spring-web-5.2.7.RELEASE.jar:5.2.7.RELEASE]     at org.springframework.http.codec.json.AbstractJackson2Decoder.lambda$decodeToMono$1(AbstractJackson2Decoder.java:159) ~[spring-web-5.2.7.RELEASE.jar:5.2.7.RELEASE]     at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:118) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxContextStart$ContextStartSubscriber.onNext(FluxContextStart.java:96) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:287) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:330) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1782) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:152) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:252) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:252) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.netty.channel.FluxReceive.terminateReceiver(FluxReceive.java:427) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]     at reactor.netty.channel.FluxReceive.drainReceiver(FluxReceive.java:210) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]     at reactor.netty.channel.FluxReceive.request(FluxReceive.java:121) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]     at reactor.core.publisher.FluxMap$MapSubscriber.request(FluxMap.java:155) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxPeek$PeekSubscriber.request(FluxPeek.java:130) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxPeek$PeekSubscriber.request(FluxPeek.java:130) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxMap$MapSubscriber.request(FluxMap.java:155) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.MonoCollect$CollectSubscriber.onSubscribe(MonoCollect.java:112) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:86) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxPeek$PeekSubscriber.onSubscribe(FluxPeek.java:163) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxPeek$PeekSubscriber.onSubscribe(FluxPeek.java:163) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:86) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE]     at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:300) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]     at reactor.netty.channel.FluxReceive.lambda$subscribe$2(FluxReceive.java:138) ~[reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE]     at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]     at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]     at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) ~[netty-transport-4.1.50.Final.jar:4.1.50.Final]     at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]     at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]     at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.50.Final.jar:4.1.50.Final]     at java.base/java.lang.Thread.run(Thread.java:832) ~[na:na] </code></pre> <h1>Docker compose (Application is running successfully on the Docker)</h1> <pre><code>version: '3' services:     fetebird-eurekaservice:         container_name: FeteBird-EurekaService         build:             context: ../../Eureka-Service-Registry/             dockerfile: Dockerfile         image: fetebird/eurekaservice         ports:             - &quot;8761:8761&quot;         networks:             - spring-cloud-network         volumes:             - ./fetebird-eurekaservice/data:/data         logging:             driver: json-file          fetebird-configserver:         container_name: FeteBird-ConfigServer         build:             context: ../../FeteBird-ConfigServer             dockerfile: Dockerfile         image: fetebird/configserver         ports:             - &quot;8085:8085&quot;         links:             - fetebird-eurekaservice         depends_on:             - fetebird-eurekaservice         networks:             - spring-cloud-network         volumes:             - ./fetebird-configserver/data:/data         logging:             driver: json-file                    networks:     spring-cloud-network:         driver: bridge </code></pre> ",
    "OwnerUserId": "1162409",
    "LastActivityDate": "2021-07-21T14:22:39.523",
    "Title": "JSON decoding error: Root name 'timestamp' does not match expected Eureka +spring security + Docker",
    "Tags": "<java><spring><spring-boot><docker-compose><netflix-eureka>",
    "AnswerCount": "1",
    "CommentCount": "4",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Solved this by correcting Eureka URL eureka: client: serviceUrl: defaultZone: ${EUREKA_URI:http://localhost:8761/eureka}</p> "
  },
  {
    "Id": "68586177",
    "PostTypeId": "1",
    "CreationDate": "2021-07-30T06:08:46.747",
    "Score": "5",
    "ViewCount": "9081",
    "Body": "<p>I'm struggling to create a Docker Compose to create a Redis Cluster. I saw that there is a Redis Cluster image from Bitnami, I tried but it my Spring Boot App cannot connect to it due to the below error: <a href='https://i.stack.imgur.com/BX3mN.jpg' rel='noreferrer'><img src='https://i.stack.imgur.com/BX3mN.jpg' alt='enter image description here' /></a></p> <p>I tried another approach is to create 2 Redis instances master-slave and I can connect to it. Now I'm trying to create 6 Redis Instances and later create a Redis Cluster with 3 master and 3 slaves with the following command:</p> <pre><code>redis-cli --cluster create 127.0.0.1:6380 127.0.0.1:6381 \\ 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 127.0.0.1:6385 --cluster-replicas 1 </code></pre> <p>But when I executed the command it said that</p> <pre><code>Could not connect to Redis at 127.0.0.1:6380: Connection refused </code></pre> <p>Below is my current Docker-compose.yaml:</p> <pre><code>version: '3.8' services:   redis-node-0:     image: redis:latest     container_name: redis-0     ports:       - &quot;6380:6379&quot;     command: [&quot;redis-server&quot;,&quot;--appendonly yes&quot;,&quot;--cluster-enabled yes&quot;,&quot;--cluster-node-timeout 5000&quot;]     volumes:       - redis-cluster_data-0:/redis/data    redis-node-1:     image: redis:latest     container_name: redis-1     ports:       - &quot;6381:6379&quot;     command: [&quot;redis-server&quot;,&quot;--appendonly yes&quot;,&quot;--cluster-enabled yes&quot;,&quot;--cluster-node-timeout 5000&quot;]       volumes:       - redis-cluster_data-1:/redis/data    redis-node-2:     image: redis:latest     container_name: redis-2     ports:       - &quot;6382:6379&quot;     command: [&quot;redis-server&quot;,&quot;--appendonly yes&quot;,&quot;--cluster-enabled yes&quot;,&quot;--cluster-node-timeout 5000&quot;]     volumes:       - redis-cluster_data-2:/redis/data    redis-node-3:     image: redis:latest     container_name: redis-3     ports:       - &quot;6383:6379&quot;     command: [&quot;redis-server&quot;,&quot;--appendonly yes&quot;,&quot;--cluster-enabled yes&quot;,&quot;--cluster-node-timeout 5000&quot;]     volumes:       - redis-cluster_data-3:/redis/data    redis-node-4:     image: redis:latest     container_name: redis-4     ports:       - &quot;6384:6379&quot;     command: [&quot;redis-server&quot;,&quot;--appendonly yes&quot;,&quot;--cluster-enabled yes&quot;,&quot;--cluster-node-timeout 5000&quot;]     volumes:       - redis-cluster_data-4:/redis/data    redis-node-5:     image: redis:latest     container_name: redis-5     ports:       - &quot;6385:6379&quot;     command: [&quot;redis-server&quot;,&quot;--appendonly yes&quot;,&quot;--cluster-enabled yes&quot;,&quot;--cluster-node-timeout 5000&quot;]     volumes:       - redis-cluster_data-5:/redis/data   networks:    default:     name: overlay volumes:   redis-cluster_data-0:     driver: local   redis-cluster_data-1:     driver: local   redis-cluster_data-2:     driver: local   redis-cluster_data-3:     driver: local   redis-cluster_data-4:     driver: local   redis-cluster_data-5:     driver: local </code></pre> <p>I'm totally new to Both Docker and Redis, I'm learning so any help would be really appreciated. Thanks in advance.</p> ",
    "OwnerUserId": "11503182",
    "LastEditorUserId": "11503182",
    "LastEditDate": "2021-07-30T17:13:14.613",
    "LastActivityDate": "2022-12-21T12:49:10.700",
    "Title": "Redis Cluster Docker Compose",
    "Tags": "<spring-boot><docker-compose><redis-cluster>",
    "AnswerCount": "1",
    "CommentCount": "5",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>The way to do this is not obvious, because Redis Cluster doesn't easily work with Docker bridge networking. The simplest way to setup a single-node cluster is to cheat and bind it to 127.0.0.1:</p> <pre><code>version: '3.8'  services:   redis-single-node-cluster:     image: docker.io/bitnami/redis-cluster:7.0     environment:       - 'ALLOW_EMPTY_PASSWORD=yes'       - 'REDIS_CLUSTER_REPLICAS=0'       - 'REDIS_NODES=127.0.0.1 127.0.0.1 127.0.0.1'       - 'REDIS_CLUSTER_CREATOR=yes'       - 'REDIS_CLUSTER_DYNAMIC_IPS=no'       - 'REDIS_CLUSTER_ANNOUNCE_IP=127.0.0.1'     ports:       - '6379:6379' </code></pre> <p>You can then connect to it with this Spring Boot config:</p> <pre><code>spring:   redis:     cluster:       nodes: [localhost:6379]     ssl: false </code></pre> <p>If you want to setup multiple nodes, you'll have to create a custom network and assign static IPs. You'll probably also have to set <code>network_mode: host</code>.</p> "
  },
  {
    "Id": "72138430",
    "PostTypeId": "1",
    "AcceptedAnswerId": "72138773",
    "CreationDate": "2022-05-06T08:27:47.650",
    "Score": "5",
    "ViewCount": "9264",
    "Body": "<p>Caused by: org.postgresql.util.PSQLException: Connection to localhost:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.</p> <p>I am facing the problem in creation of docker image.</p> <p>when i check postgres port</p> <pre><code>postgres   4318 iqbal    8u  IPv4 0xbccc4b164eb6b423      0t0  TCP 127.0.0.1:5432 (LISTEN) com.docke 11144 iqbal   45u  IPv6 0xbccc4b1b1bb15e0b      0t0  TCP *:5432 (LISTEN) </code></pre> <p>Application.properties file</p> <pre><code>spring.mvc.converters.preferred-json-mapper=gson spring.datasource.url= jdbc:postgresql://localhost:5432/flightbed spring.datasource.username= iqbal spring.datasource.password= postgres  spring.datasource.hikari.connectionTimeout=20000 spring.datasource.hikari.maximumPoolSize=5  spring.jpa.properties.hibernate.dialect= org.hibernate.dialect.PostgreSQLDialect spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true  spring.jpa.hibernate.ddl-auto= update spring.jpa.show-sql=true </code></pre> <p>Docker-compose file is here:</p> <pre><code>    version: '3.1' services:   app:     image: 'docker-spring-boot-postgres:latest'     build:         context: .       container_name: app       depends_on:         - localhost       environment:         - SPRING_DATASOURCE_URL=jdbc:postgresql://postgresqldb:5432/flightbed         - SPRING_DATASOURCE_USERNAME=iqbal         - SPRING_DATASOURCE_PASSWORD=postgres         - SPRING_JPA_HIBERNATE_DDL_AUTO=update    localhost:         image: 'postgres:13.1-alpine'         container_name: postgresqldb         environment:           - POSTGRES_USER=iqbal           - POSTGRES_PASSWORD=postgres  </code></pre> <p>Dockerfile is here :</p> <pre><code>FROM  openjdk:17.0.1-jdk-slim  ADD target/flightdata-0.0.1-SNAPSHOT.jar flightdata-0.0.1-SNAPSHOT.jar  ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;flightdata-0.0.1-SNAPSHOT.jar&quot;] </code></pre> <p>Error log</p> <pre><code>iqbal@MacBook-Pro-von-furqan flightbed % docker run -p 8085:8085 flight1    .   ____          _            __ _ _  /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\ ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\  \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )   '  |____| .__|_| |_|_| |_\\__, | / / / /  =========|_|==============|___/=/_/_/_/  :: Spring Boot ::                (v2.5.3)  2022-05-06 07:44:22.422  INFO 1 --- [           main] flightdata.FlightdataApplication         : Starting FlightdataApplication v0.0.1-SNAPSHOT using Java 17.0.1 on be5bdb7475e9 with PID 1 (/flightdata-0.0.1-SNAPSHOT.jar started by root in /) 2022-05-06 07:44:22.423  INFO 1 --- [           main] flightdata.FlightdataApplication         : No active profile set, falling back to default profiles: default 2022-05-06 07:44:22.919  INFO 1 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode. 2022-05-06 07:44:22.961  INFO 1 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 37 ms. Found 2 JPA repository interfaces. 2022-05-06 07:44:23.334  INFO 1 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 9090 (http) 2022-05-06 07:44:23.341  INFO 1 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat] 2022-05-06 07:44:23.341  INFO 1 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.50] 2022-05-06 07:44:23.379  INFO 1 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext 2022-05-06 07:44:23.380  INFO 1 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 898 ms 2022-05-06 07:44:23.499  INFO 1 --- [           main] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default] 2022-05-06 07:44:23.531  INFO 1 --- [           main] org.hibernate.Version                    : HHH000412: Hibernate ORM core version 5.4.32.Final 2022-05-06 07:44:23.597  INFO 1 --- [           main] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {5.1.2.Final} 2022-05-06 07:44:23.641  INFO 1 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting... 2022-05-06 07:44:24.692 ERROR 1 --- [           main] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Exception during pool initialization.  org.postgresql.util.PSQLException: Connection to localhost:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:303) ~[postgresql-42.2.23.jar!/:42.2.23]         at          at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.9.jar!/:5.3.9]         at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.9.jar!/:5.3.9]         at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.9.jar!/:5.3.9]         at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1154) ~[spring-context-5.3.9.jar!/:5.3.9]         at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:908) ~[spring-context-5.3.9.jar!/:5.3.9]         at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:583) ~[spring-context-5.3.9.jar!/:5.3.9]         at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:145) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:434) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:338) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1343) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1332) ~[spring-boot-2.5.3.jar!/:2.5.3]         at flightdata.FlightdataApplication.main(FlightdataApplication.java:17) ~[classes!/:0.0.1-SNAPSHOT]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) ~[na:na]         at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]         at java.base/java.lang.reflect.Method.invoke(Method.java:568) ~[na:na]         at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:49) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT]         at org.springframework.boot.loader.Launcher.launch(Launcher.java:108) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT]         at org.springframework.boot.loader.Launcher.launch(Launcher.java:58) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT]         at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:88) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT] Caused by: java.net.ConnectException: Connection refused         at java.base/sun.nio.ch.Net.pollConnect(Native Method) ~[na:na]         at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672) ~[na:na]         at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:542) ~[na:na]         at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:597) ~[na:na]         at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327) ~[na:na]         at java.base/java.net.Socket.connect(Socket.java:633) ~[na:na]         at org.postgresql.core.PGStream.createSocket(PGStream.java:231) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.PGStream.&lt;init&gt;(PGStream.java:95) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.v3.ConnectionFactoryImpl.tryConnect(ConnectionFactoryImpl.java:98) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:213) ~[postgresql-42.2.23.jar!/:42.2.23]         ... 58 common frames omitted  2022-05-06 07:44:24.694  WARN 1 --- [           main] o.h.e.j.e.i.JdbcEnvironmentInitiator     : HHH000342: Could not obtain connection to query metadata  org.postgresql.util.PSQLException: Connection to localhost:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:303) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.ConnectionFactory.openConnection(ConnectionFactory.java:51) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.jdbc.PgConnection.&lt;init&gt;(PgConnection.java:223) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.Driver.makeConnection(Driver.java:465) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.Driver.connect(Driver.java:264) ~[postgresql-42.2.23.jar!/:42.2.23]         at com.zaxxer.hikari.util.DriverDataSource.getConnection(DriverDataSource.java:138) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.PoolBase.newConnection(PoolBase.java:364) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.PoolBase.newPoolEntry(PoolBase.java:206) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.createPoolEntry(HikariPool.java:476) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.checkFailFast(HikariPool.java:561) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.&lt;init&gt;(HikariPool.java:115) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:112) ~[HikariCP-4.0.3.jar!/:na]         at org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection(DatasourceConnectionProviderImpl.java:122) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess.obtainConnection(JdbcEnvironmentInitiator.java:180) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.initiateService(JdbcEnvironmentInitiator.java:68) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.initiateService(JdbcEnvironmentInitiator.java:35) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.boot.registry.internal.StandardServiceRegistryImpl.initiateService(StandardServiceRegistryImpl.java:101) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.service.internal.AbstractServiceRegistryImpl.createService(AbstractServiceRegistryImpl.java:263) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.service.internal.AbstractServiceRegistryImpl.initializeService(AbstractServiceRegistryImpl.java:237) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.service.internal.AbstractServiceRegistryImpl.getService(AbstractServiceRegistryImpl.java:214) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.injectServices(DefaultIdentifierGeneratorFactory.java:152) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.service.internal.AbstractServiceRegistryImpl.injectDependencies(AbstractServiceRegistryImpl.java:286) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.service.internal.AbstractServiceRegistryImpl.initializeService(AbstractServiceRegistryImpl.java:243) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.service.internal.AbstractServiceRegistryImpl.getService(AbstractServiceRegistryImpl.java:214) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.boot.internal.InFlightMetadataCollectorImpl.&lt;init&gt;(InFlightMetadataCollectorImpl.java:176) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.boot.model.process.spi.MetadataBuildingProcess.complete(MetadataBuildingProcess.java:127) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.metadata(EntityManagerFactoryBuilderImpl.java:1224) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build(EntityManagerFactoryBuilderImpl.java:1255) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.springframework.orm.jpa.vendor.SpringHibernateJpaPersistenceProvider.createContainerEntityManagerFactory(SpringHibernateJpaPersistenceProvider.java:58) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.createNativeEntityManagerFactory(LocalContainerEntityManagerFactoryBean.java:365) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.buildNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:409) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.afterPropertiesSet(AbstractEntityManagerFactoryBean.java:396) ~[spring-orm-5.3.9.jar!/:5.3.9]         at ]         at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:145) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:434) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:338) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1343) ~[spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1332) ~[spring-boot-2.5.3.jar!/:2.5.3]         at flightdata.FlightdataApplication.main(FlightdataApplication.java:17) ~[classes!/:0.0.1-SNAPSHOT]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) ~[na:na]         at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]         at java.base/java.lang.reflect.Method.invoke(Method.java:568) ~[na:na]         at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:49) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT]         at org.springframework.boot.loader.Launcher.launch(Launcher.java:108) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT]         at org.springframework.boot.loader.Launcher.launch(Launcher.java:58) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT]         at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:88) ~[flightdata-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT] Caused by: java.net.ConnectException: Connection refused         at java.base/sun.nio.ch.Net.pollConnect(Native Method) ~[na:na]         at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672) ~[na:na]         at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:542) ~[na:na]         at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:597) ~[na:na]         at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327) ~[na:na]         at java.base/java.net.Socket.connect(Socket.java:633) ~[na:na]         at org.postgresql.core.PGStream.createSocket(PGStream.java:231) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.PGStream.&lt;init&gt;(PGStream.java:95) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.v3.ConnectionFactoryImpl.tryConnect(ConnectionFactoryImpl.java:98) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:213) ~[postgresql-42.2.23.jar!/:42.2.23]         ... 58 common frames omitted  2022-05-06 07:44:24.707  INFO 1 --- [           main] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.PostgreSQLDialect 2022-05-06 07:44:25.046  INFO 1 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting... 2022-05-06 07:44:26.055 ERROR 1 --- [           main] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Exception during pool initialization.  org.postgresql.util.PSQLException: Connection to localhost:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:303) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.ConnectionFactory.openConnection(ConnectionFactory.java:51) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.jdbc.PgConnection.&lt;init&gt;(PgConnection.java:223) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.Driver.makeConnection(Driver.java:465) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.Driver.connect(Driver.java:264) ~[postgresql-42.2.23.jar!/:42.2.23]         at com.zaxxer.hikari.util.DriverDataSource.getConnection(DriverDataSource.java:138) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.PoolBase.newConnection(PoolBase.java:364) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.PoolBase.newPoolEntry(PoolBase.java:206) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.createPoolEntry(HikariPool.java:476) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.checkFailFast(HikariPool.java:561) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.&lt;init&gt;(HikariPool.java:115) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:112) ~[HikariCP-4.0.3.jar!/:na]         at org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection(DatasourceConnectionProviderImpl.java:122) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess.obtainConnection(JdbcEnvironmentInitiator.java:180) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl.getIsolatedConnection(DdlTransactionIsolatorNonJtaImpl.java:43) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.internal.exec.ImprovedExtractionContextImpl.getJdbcConnection(ImprovedExtractionContextImpl.java:60) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.extract.internal.SequenceInformationExtractorLegacyImpl.extractMetadata(SequenceInformationExtractorLegacyImpl.java:40) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.extract.internal.DatabaseInformationImpl.initializeSequences(DatabaseInformationImpl.java:65) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.extract.internal.DatabaseInformationImpl.&lt;init&gt;(DatabaseInformationImpl.java:59) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.internal.Helper.buildDatabaseInformation(Helper.java:155) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.internal.AbstractSchemaMigrator.doMigration(AbstractSchemaMigrator.java:96) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.performDatabaseAction(SchemaManagementToolCoordinator.java:184) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.process(SchemaManagementToolCoordinator.java:73) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.internal.SessionFactoryImpl.&lt;init&gt;(SessionFactoryImpl.java:318) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.boot.internal.SessionFactoryBuilderImpl.build(SessionFactoryBuilderImpl.java:468) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build(EntityManagerFactoryBuilderImpl.java:1259) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.springframework.orm.jpa.vendor.SpringHibernateJpaPersistenceProvider.createContainerEntityManagerFactory(SpringHibernateJpaPersistenceProvider.java:58) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.createNativeEntityManagerFactory(LocalContainerEntityManagerFactoryBean.java:365) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.buildNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:421) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.afterPropertiesSet(AbstractEntityManagerFactoryBean.java:396) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.afterPropertiesSet(LocalContainerEntityManagerFactoryBean.java:341) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1845) ~[spring-beans-5.3.9.jar!/:5.3.9]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1782) ~[spring-beans-5.3.9.jar!/:5.3.9]         ... 24 common frames omitted Caused by: org.hibernate.exception.JDBCConnectionException: Unable to open JDBC Connection for DDL execution         at org.hibernate.exception.internal.SQLStateConversionDelegate.convert(SQLStateConversionDelegate.java:112) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.exception.internal.StandardSQLExceptionConverter.convert(StandardSQLExceptionConverter.java:42) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.spi.SqlExceptionHelper.convert(SqlExceptionHelper.java:113) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.spi.SqlExceptionHelper.convert(SqlExceptionHelper.java:99) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl.getIsolatedConnection(DdlTransactionIsolatorNonJtaImpl.java:69) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.internal.exec.ImprovedExtractionContextImpl.getJdbcConnection(ImprovedExtractionContextImpl.java:60) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.extract.internal.SequenceInformationExtractorLegacyImpl.extractMetadata(SequenceInformationExtractorLegacyImpl.java:40) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.extract.internal.DatabaseInformationImpl.initializeSequences(DatabaseInformationImpl.java:65) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.extract.internal.DatabaseInformationImpl.&lt;init&gt;(DatabaseInformationImpl.java:59) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.internal.Helper.buildDatabaseInformation(Helper.java:155) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.internal.AbstractSchemaMigrator.doMigration(AbstractSchemaMigrator.java:96) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.performDatabaseAction(SchemaManagementToolCoordinator.java:184) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.process(SchemaManagementToolCoordinator.java:73) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.internal.SessionFactoryImpl.&lt;init&gt;(SessionFactoryImpl.java:318) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.boot.internal.SessionFactoryBuilderImpl.build(SessionFactoryBuilderImpl.java:468) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build(EntityManagerFactoryBuilderImpl.java:1259) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.springframework.orm.jpa.vendor.SpringHibernateJpaPersistenceProvider.createContainerEntityManagerFactory(SpringHibernateJpaPersistenceProvider.java:58) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.createNativeEntityManagerFactory(LocalContainerEntityManagerFactoryBean.java:365) ~[spring-orm-5.3.9.jar!/:5.3.9]         at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.buildNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:409) ~[spring-orm-5.3.9.jar!/:5.3.9]         ... 28 common frames omitted Caused by: org.postgresql.util.PSQLException: Connection to localhost:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:303) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.ConnectionFactory.openConnection(ConnectionFactory.java:51) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.jdbc.PgConnection.&lt;init&gt;(PgConnection.java:223) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.Driver.makeConnection(Driver.java:465) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.Driver.connect(Driver.java:264) ~[postgresql-42.2.23.jar!/:42.2.23]         at com.zaxxer.hikari.util.DriverDataSource.getConnection(DriverDataSource.java:138) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.PoolBase.newConnection(PoolBase.java:364) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.PoolBase.newPoolEntry(PoolBase.java:206) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.createPoolEntry(HikariPool.java:476) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.checkFailFast(HikariPool.java:561) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.pool.HikariPool.&lt;init&gt;(HikariPool.java:115) ~[HikariCP-4.0.3.jar!/:na]         at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:112) ~[HikariCP-4.0.3.jar!/:na]         at org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection(DatasourceConnectionProviderImpl.java:122) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess.obtainConnection(JdbcEnvironmentInitiator.java:180) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         at org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl.getIsolatedConnection(DdlTransactionIsolatorNonJtaImpl.java:43) ~[hibernate-core-5.4.32.Final.jar!/:5.4.32.Final]         ... 42 common frames omitted Caused by: java.net.ConnectException: Connection refused         at java.base/sun.nio.ch.Net.pollConnect(Native Method) ~[na:na]         at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672) ~[na:na]         at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:542) ~[na:na]         at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:597) ~[na:na]         at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327) ~[na:na]         at java.base/java.net.Socket.connect(Socket.java:633) ~[na:na]         at org.postgresql.core.PGStream.createSocket(PGStream.java:231) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.PGStream.&lt;init&gt;(PGStream.java:95) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.v3.ConnectionFactoryImpl.tryConnect(ConnectionFactoryImpl.java:98) ~[postgresql-42.2.23.jar!/:42.2.23]         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:213) ~[postgresql-42.2.23.jar!/:42.2.23]         ... 56 common frames omitted  </code></pre> ",
    "OwnerUserId": "5949561",
    "LastEditorUserId": "2576372",
    "LastEditDate": "2022-05-08T05:18:08.807",
    "LastActivityDate": "2022-05-08T05:18:08.807",
    "Title": "I have a Java Spring boot with Postgresql within docker-compose, org.postgresql.util.PSQLException: Connection to localhost:5432",
    "Tags": "<postgresql><spring-boot><docker><docker-compose><devops>",
    "AnswerCount": "1",
    "CommentCount": "5",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>docker-compose.yml</p> <pre><code>version: '3.1' services:   app:     image: 'docker-spring-boot-postgres:latest'     build:       context: .       container_name: app       depends_on:         - postgresqldb       ports:         - 8085:8085       environment:         - SPRING_DATASOURCE_URL=jdbc:postgresql://postgresqldb:5432/flightbed         - SPRING_DATASOURCE_USERNAME=iqbal         - SPRING_DATASOURCE_PASSWORD=postgres         - SPRING_JPA_HIBERNATE_DDL_AUTO=update    postgresqldb:         image: 'postgres:13.1-alpine'         container_name: postgresqldb         ports:           - 5432:5432         environment:           - POSTGRES_USER=iqbal           - POSTGRES_PASSWORD=postgres </code></pre> <p>Run <code>docker-compose up -d</code>, wait until it's up, then run <code>docker ps -a</code> to check if your containers are running or have crashed, use <code>docker logs {container name}</code> to get the stdout from a given container to find out why it's crashed.</p> <p>You may also need to adjust your Java code so it doesn't attempt to connect to postgresql against localhost and instead trys to connect to postgresqldb:5432. You should be able to use your $SPRING_DATASOURCE_URL environment variable for that.</p> <p>If you're still getting connection issues comment your new error for me and I'll update this answer.</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "72659587",
    "PostTypeId": "1",
    "CreationDate": "2022-06-17T12:43:09.937",
    "Score": "5",
    "ViewCount": "1628",
    "Body": "<p>I am a newbie to SpringBoot. I am trying to create a spring boot application which i am running using docker. when i run this app, i get the following error</p> <pre><code>org.postgresql.util.PSQLException: FATAL: role &quot;amigoscode&quot; does not exist </code></pre> <p>I don't have any hint, as i am not able to trace this error. Role &quot;amigoscode&quot; already exists. I am attaching below the application.yml and docker-compose.yml</p> <p>application.yml</p> <pre><code>server:   port: 8080  spring:   application:     name: customer   datasource:     password: password     url: jdbc:postgresql://localhost:5432/customer     username: amigoscode   jpa:     hibernate:       ddl-auto: create-drop     properties:       hibernate:         dialect: org.hibernate.dialect.PostgreSQLDialect         format_sql: 'true'     show-sql: 'true' </code></pre> <p>docker-compose.yml</p> <pre><code>services:   postgres:     container_name: postgres     image: postgres     environment:       POSTGRES_USER: amigoscode       POSTGRES_PASSWORD: password       PGDATA: /data/postgres     volumes:       - postgres:/data/postgres     ports:       - &quot;5432:5432&quot;     networks:       - postgres     restart: unless-stopped    pgadmin:     container_name: pgadmin     image: dpage/pgadmin4     environment:       PGADMIN_DEFAULT_EMAIL: ${PGADMIN_DEFAULT_EMAIL:-pgadmin4@pgadmin.org}       PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_DEFAULT_PASSWORD:-admin}       PGADMIN_CONFIG_SERVER_MODE: 'False'     volumes:       - pgadmin:/var/lib/pgadmin     ports:       - &quot;5050:80&quot;     networks:       - postgres     restart: unless-stopped  networks:   postgres:     driver: bridge  volumes:   postgres:   pgadmin: </code></pre> <p>Can you please guide me, what i might be doing wrong here? I have referred other similar question here, but none of them solves my issue. Thank you.</p> ",
    "OwnerUserId": "1468328",
    "LastActivityDate": "2023-12-25T16:49:48.390",
    "Title": "org.postgresql.util.PSQLException: FATAL: role 'amigoscode' does not exist",
    "Tags": "<postgresql><spring-boot><docker><docker-compose>",
    "AnswerCount": "5",
    "CommentCount": "8",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Additional to hints above, make sure that <strong>Postgres is not running on the local machine out of Docker</strong> because it might conflict with the Postgres instance in Docker</p> "
  },
  {
    "Id": "74220706",
    "PostTypeId": "1",
    "CreationDate": "2022-10-27T10:36:27.207",
    "Score": "5",
    "ViewCount": "956",
    "Body": "<p>I am confused about the use case where HashiCorp Vault is used to provide database secrets dynamically for Spring Boot. Lets say you have two microservices: one containing the application logic and one running a database engine. The first obviously needs to authenticate towards the database and this is where dynamic secrets come into play. Vault can provide such credentials to the first microservice so you don't have to use e.g. ENV variables in a docker-compose file managing both microservices. <a href='https://i.stack.imgur.com/jSFCP.png' rel='nofollow noreferrer'><img src='https://i.stack.imgur.com/jSFCP.png' alt='enter image description here' /></a></p> <p>The App could be a Spring Boot microservice relying on Spring Cloud Vault to handle communication with HashiCorp Vault for credentials management. The microservice asks Vault for temporary db credentials (in this case they last for one hour) when it is started. During this one hour interval, the app can connect to the database and do whatever needs to be done. After one hour, the credentials expire and no communications is allowed.</p> <p>The Spring Boot Cloud Vault documentation mentions</p> <blockquote> <p>Spring Cloud Vault does not support getting new credentials and configuring your DataSource with them when the maximum lease time has been reached. That is, if max_ttl of the Database role in Vault is set to 24h that means that 24 hours after your application has started it can no longer authenticate with the database.</p> </blockquote> <p>In other words, after one hour, the connection is lost and there seems to be no other way to get new db credentials other then by restarting the microservice. So if have the following questions:</p> <ol> <li>What is the added value of using Vault in this particular example if you are (seemingly) forced to restart your entire application each time the TTL expires?</li> <li>Does the same apply when you use static secrets instead?</li> <li>Can this issue be solved without changing microservice code? (K8S, Istio, etc.?)</li> </ol> <p>My guess is the intended use of Vault with Spring Boot is different compared to my understanding.</p> ",
    "OwnerUserId": "5585819",
    "LastEditorUserId": "5585819",
    "LastEditDate": "2023-01-10T16:18:12.580",
    "LastActivityDate": "2023-01-11T08:56:02.500",
    "Title": "HashiCorp Vault dynamic secrets and Spring Boot",
    "Tags": "<spring-boot><docker-compose><microservices><hashicorp-vault>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p><a href='https://secrets-as-a-service.com/posts/hashicorp-vault/spring-boot-max_ttl/' rel='nofollow noreferrer'>This article</a> describes 4 possible solutions to mitigate the issue described in the question. Being valid approaches to solve the problem, a more generic (referring to the 'heavy rotation of dynamic secrets'-approach) and less aggressive (referring to the 'restarting the service when connectivity is lost'-approaches) should be in place.</p> "
  },
  {
    "Id": "76876515",
    "PostTypeId": "1",
    "AcceptedAnswerId": "76936788",
    "CreationDate": "2023-08-10T14:08:28.497",
    "Score": "5",
    "ViewCount": "424",
    "Body": "<p>I have following docker-compose file for local development:</p> <pre><code>version: '3.4'  networks:   mynetwork:  services:   samba:     image: instantlinux/samba-dc:latest     container_name: samba-dc     cap_add:       - CAP_SYS_ADMIN     hostname: my.org     environment:       DOMAIN_ACTION: provision       REALM: my.org     volumes:       - etc:/etc/samba       - lib:/var/lib/samba     ports:       - &quot;53:53&quot;       - &quot;53:53/udp&quot;       - &quot;88:88&quot;       - &quot;88:88/udp&quot;       - &quot;389:389&quot;     secrets:       - samba-admin-password  volumes:   etc:   lib:  secrets:   samba-admin-password:     file: secrets.yaml </code></pre> <p>Now I try to implement integration tests using testContainers for that purpose:</p> <pre><code>@Testcontainers @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) @ActiveProfiles(&quot;test&quot;) ....          init {             try {                 val ldapContainer =                     GenericContainer(&quot;instantlinux/samba-dc:latest&quot;)                         .withEnv(&quot;DOMAIN_ACTION&quot;, &quot;provision&quot;)                         .withEnv(&quot;REALM&quot;, &quot;my.company&quot;)                         .withEnv(&quot;ADMIN_PASSWORD_SECRET&quot;, &quot;samba-admin-password&quot;)                         .withExposedPorts(53, 88, 389)                                     ldapContainer.start()                 print(&quot;Containers has started&quot;)             } catch (e: Exception) {                 e.printStackTrace()             }         } </code></pre> <p>But when I try to run it I receive an error:</p> <pre><code>Container startup failed for image instantlinux/samba-dc:latest .... rg.testcontainers.containers.GenericContainer expected the predicate to return &lt;true&gt; but it returned &lt;false&gt; for input of &lt;InspectContainerResponse(args=[], config=ContainerConfig(attachStderr=false, attachStdin=false, attachStdout=false, cmd=null, domainName=, entrypoint=[/usr/local/bin/entrypoint.sh], env=[DOMAIN_ACTION=provision, ADMIN_PASSWORD_SECRET=samba-admin-password, REALM=my.company, PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin, ALLOW_DNS_UPDATES=secure, BIND_INTERFACES_ONLY=yes, DOMAIN_LOGONS=yes, DOMAIN_MASTER=no, INTERFACES=lo eth0, LOG_LEVEL=1, MODEL=standard, NETBIOS_NAME=, SERVER_STRING=Samba Domain Controller, TZ=UTC, WINBIND_USE_DEFAULT_DOMAIN=yes, WORKGROUP=AD], exposedPorts=.... ... 17:01:51.548 [Test worker] ERROR tc.instantlinux/samba-dc:latest -- Log output from the failed container: Set timezone Cannot read secret $ADMIN_PASSWORD_SECRET in /run/secrets </code></pre> <p>Looks like I have to configure secrets somehow but I don' see a way how to acheve it.</p> <h2>Update 1</h2> <p>Secret file looks like this:</p> <pre><code>kind: Secret apiVersion: v1 metadata:   name: samba-admin-password data:   ADMIN_PASSWORD_SECRET: superpassword </code></pre> <h2>Update 2</h2> <p>Based on VonC answer I've created the example:</p> <pre><code>@Testcontainers @SpringBootTest(webEnvironment = RANDOM_PORT) @ActiveProfiles(&quot;test&quot;) class TestContainersBase {      @Test     fun test() {         val mapper = ObjectMapper(YAMLFactory())         val secretPathOnHost = &quot;C:\\\\work\\\\MyApp\\\\docker\\\\secrets.yaml&quot;         val secretsFile = File(secretPathOnHost)          val secretsData: Map&lt;String, Any&gt; = mapper.readValue(secretsFile, object: TypeReference&lt;Map&lt;String, Any&gt;&gt;(){})          // Extract the secret from the parsed data         val adminPassword = (secretsData[&quot;data&quot;] as Map&lt;*,*&gt;?)!![&quot;ADMIN_PASSWORD_SECRET&quot;] as String?          val secretPathInContainer = &quot;/run/secrets/samba-admin-password&quot;;         // Create and start the container         val ldapContainer = GenericContainer(&quot;instantlinux/samba-dc:latest&quot;)             .withEnv(&quot;DOMAIN_ACTION&quot;, &quot;provision&quot;)             .withEnv(&quot;REALM&quot;, &quot;my.company&quot;)             .withEnv(&quot;ADMIN_PASSWORD_SECRET&quot;, adminPassword) // Set the extracted secret as an environment variable             .withExposedPorts(53, 88, 389)             .withFileSystemBind(secretPathOnHost, secretPathInContainer, BindMode.READ_ONLY);          ldapContainer.start()          print(&quot;qwerty&quot;)                  Thread.sleep(100000000)      } } </code></pre> <p>In app logs I see:</p> <pre><code>2023-08-21T13:38:50.555+03:00  INFO 15136 --- [    Test worker] o.t.utility.ImageNameSubstitutor         : Image name substitution will be performed by: DefaultImageNameSubstitutor (composite of 'ConfigurationFileImageNameSubstitutor' and 'PrefixingImageNameSubstitutor') 2023-08-21T13:38:51.739+03:00  INFO 15136 --- [    Test worker] o.t.d.DockerClientProviderStrategy       : Loaded org.testcontainers.dockerclient.NpipeSocketClientProviderStrategy from ~/.testcontainers.properties, will try it first 2023-08-21T13:38:52.779+03:00  INFO 15136 --- [    Test worker] o.t.d.DockerClientProviderStrategy       : Found Docker environment with local Npipe socket (npipe:////./pipe/docker_engine) 2023-08-21T13:38:52.784+03:00  INFO 15136 --- [    Test worker] org.testcontainers.DockerClientFactory   : Docker host IP address is localhost 2023-08-21T13:38:52.814+03:00  INFO 15136 --- [    Test worker] org.testcontainers.DockerClientFactory   : Connected to docker:    Server Version: 20.10.21   API Version: 1.41   Operating System: Docker Desktop   Total Memory: 38292 MB 2023-08-21T13:38:52.889+03:00  INFO 15136 --- [    Test worker] tc.testcontainers/ryuk:0.4.0             : Creating container for image: testcontainers/ryuk:0.4.0 2023-08-21T13:38:53.928+03:00  INFO 15136 --- [    Test worker] o.t.utility.RegistryAuthLocator          : Credential helper/store (docker-credential-desktop) does not have credentials for https://index.docker.io/v1/ 2023-08-21T13:38:54.201+03:00  INFO 15136 --- [    Test worker] tc.testcontainers/ryuk:0.4.0             : Container testcontainers/ryuk:0.4.0 is starting: b4a10e2647f83d6fc404644fb09edabf930e987e2c5d138eb3d1b9414b1400ac 2023-08-21T13:38:55.320+03:00  INFO 15136 --- [    Test worker] tc.testcontainers/ryuk:0.4.0             : Container testcontainers/ryuk:0.4.0 started in PT2.488268S 2023-08-21T13:38:55.330+03:00  INFO 15136 --- [    Test worker] o.t.utility.RyukResourceReaper           : Ryuk started - will monitor and terminate Testcontainers containers on JVM exit 2023-08-21T13:38:55.330+03:00  INFO 15136 --- [    Test worker] org.testcontainers.DockerClientFactory   : Checking the system... 2023-08-21T13:38:55.332+03:00  INFO 15136 --- [    Test worker] org.testcontainers.DockerClientFactory   : ?? Docker server version should be at least 1.6.0 2023-08-21T13:38:55.334+03:00  INFO 15136 --- [    Test worker] tc.instantlinux/samba-dc:latest          : Creating container for image: instantlinux/samba-dc:latest 2023-08-21T13:38:56.834+03:00  INFO 15136 --- [    Test worker] tc.instantlinux/samba-dc:latest          : Container instantlinux/samba-dc:latest is starting: 496246f47398809c3a7327b0c73a9b7d7fbe6440865b1cad4c124849f6069acb 2023-08-21T13:39:07.361+03:00  WARN 15136 --- [ntainers-wait-0] .c.w.i.InternalCommandPortListeningCheck : An exception while executing the internal check: Container.ExecResult(exitCode=137, stdout=, stderr=/bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found /bin/sh: /bin/bash: not found ) 2023-08-21T13:39:07.367+03:00  INFO 15136 --- [    Test worker] tc.instantlinux/samba-dc:latest          : Container instantlinux/samba-dc:latest started in PT12.0305603S </code></pre> <p>In docker desktop:</p> <p><a href='https://i.stack.imgur.com/2WJiX.png' rel='nofollow noreferrer'><img src='https://i.stack.imgur.com/2WJiX.png' alt='enter image description here' /></a></p> <p>And the first container(based on ports I think that it is Samba) logs:</p> <pre><code>2023-08-21 13:38:58 Set timezone 2023-08-21 13:38:59 INFO 2023-08-21 10:38:59,067 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #2108: Looking up IPv4 addresses 2023-08-21 13:38:59 INFO 2023-08-21 10:38:59,068 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #2125: Looking up IPv6 addresses 2023-08-21 13:38:59 WARNING 2023-08-21 10:38:59,068 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #2132: No IPv6 address will be assigned 2023-08-21 13:38:59 INFO 2023-08-21 10:38:59,721 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #2274: Setting up share.ldb 2023-08-21 13:38:59 INFO 2023-08-21 10:38:59,874 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #2278: Setting up secrets.ldb 2023-08-21 13:38:59 INFO 2023-08-21 10:38:59,936 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #2283: Setting up the registry 2023-08-21 13:39:00 INFO 2023-08-21 10:39:00,304 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #2286: Setting up the privileges database 2023-08-21 13:39:00 INFO 2023-08-21 10:39:00,466 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #2289: Setting up idmap db 2023-08-21 13:39:00 INFO 2023-08-21 10:39:00,555 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #2296: Setting up SAM db 2023-08-21 13:39:00 INFO 2023-08-21 10:39:00,573 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #880: Setting up sam.ldb partitions and settings 2023-08-21 13:39:00 INFO 2023-08-21 10:39:00,574 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #892: Setting up sam.ldb rootDSE 2023-08-21 13:39:00 INFO 2023-08-21 10:39:00,591 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1305: Pre-loading the Samba 4 and AD schema 2023-08-21 13:39:00 Unable to determine the DomainSID, can not enforce uniqueness constraint on local domainSIDs 2023-08-21 13:39:00  2023-08-21 13:39:00 INFO 2023-08-21 10:39:00,638 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1383: Adding DomainDN: DC=my,DC=company 2023-08-21 13:39:00 INFO 2023-08-21 10:39:00,659 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1415: Adding configuration container 2023-08-21 13:39:00 INFO 2023-08-21 10:39:00,678 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1430: Setting up sam.ldb schema 2023-08-21 13:39:03 INFO 2023-08-21 10:39:03,229 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1448: Setting up sam.ldb configuration data 2023-08-21 13:39:03 INFO 2023-08-21 10:39:03,356 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1489: Setting up display specifiers 2023-08-21 13:39:05 INFO 2023-08-21 10:39:05,522 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1497: Modifying display specifiers and extended rights 2023-08-21 13:39:05 INFO 2023-08-21 10:39:05,569 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1504: Adding users container 2023-08-21 13:39:05 INFO 2023-08-21 10:39:05,570 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1510: Modifying users container 2023-08-21 13:39:05 INFO 2023-08-21 10:39:05,571 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1513: Adding computers container 2023-08-21 13:39:05 INFO 2023-08-21 10:39:05,572 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1519: Modifying computers container 2023-08-21 13:39:05 INFO 2023-08-21 10:39:05,574 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1523: Setting up sam.ldb data 2023-08-21 13:39:05 INFO 2023-08-21 10:39:05,728 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1553: Setting up well known security principals 2023-08-21 13:39:05 INFO 2023-08-21 10:39:05,770 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1567: Setting up sam.ldb users and groups 2023-08-21 13:39:05 INFO 2023-08-21 10:39:05,993 pid:18 /usr/lib/python3.10/site-packages/samba/provision/__init__.py #1575: Setting up self join 2023-08-21 13:39:06 Repacking database from v1 to v2 format (first record CN=Structural-Object-Class,CN=Schema,CN=Configuration,DC=my,DC=company) 2023-08-21 13:39:06 Repack: re-packed 10000 records so far 2023-08-21 13:39:06 Repacking database from v1 to v2 format (first record CN=nTDSSiteSettings-Display,CN=406,CN=DisplaySpecifiers,CN=Configuration,DC=my,DC=company) 2023-08-21 13:39:06 Repacking database from v1 to v2 format (first record CN=ObjectMoveTable,CN=FileLinks,CN=System,DC=my,DC=company) 2023-08-21 13:39:07 set_nt_acl_no_snum: fset_nt_acl returned NT_STATUS_ACCESS_DENIED. 2023-08-21 13:39:07 ERROR(runtime): uncaught exception - (3221225506, '{Access Denied} A process has requested access to an object but has not been granted those access rights.') 2023-08-21 13:39:07   File &quot;/usr/lib/python3.10/site-packages/samba/netcmd/__init__.py&quot;, line 186, in _run 2023-08-21 13:39:07     return self.run(*args, **kwargs) 2023-08-21 13:39:07   File &quot;/usr/lib/python3.10/site-packages/samba/netcmd/domain.py&quot;, line 493, in run 2023-08-21 13:39:07     result = provision(self.logger, 2023-08-21 13:39:07   File &quot;/usr/lib/python3.10/site-packages/samba/provision/__init__.py&quot;, line 2325, in provision 2023-08-21 13:39:07     provision_fill(samdb, secrets_ldb, logger, names, paths, 2023-08-21 13:39:07   File &quot;/usr/lib/python3.10/site-packages/samba/provision/__init__.py&quot;, line 1965, in provision_fill 2023-08-21 13:39:07     setsysvolacl(samdb, paths.netlogon, paths.sysvol, paths.root_uid, 2023-08-21 13:39:07   File &quot;/usr/lib/python3.10/site-packages/samba/provision/__init__.py&quot;, line 1742, in setsysvolacl 2023-08-21 13:39:07     _setntacl(sysvol) 2023-08-21 13:39:07   File &quot;/usr/lib/python3.10/site-packages/samba/provision/__init__.py&quot;, line 1736, in _setntacl 2023-08-21 13:39:07     return setntacl( 2023-08-21 13:39:07   File &quot;/usr/lib/python3.10/site-packages/samba/ntacls.py&quot;, line 228, in setntacl 2023-08-21 13:39:07     smbd.set_nt_acl( </code></pre> <p><strong>docker ps</strong></p> <pre><code>PS C:\\work\\myApp\\docker&gt; docker ps CONTAINER ID   IMAGE                       COMMAND       CREATED          STATUS          PORTS                     NAMES 5541e9f96005   testcontainers/ryuk:0.4.0   &quot;/bin/ryuk&quot;   24 seconds ago   Up 23 seconds   0.0.0.0:64762-&gt;8080/tcp   testcontainers-ryuk-6d02415f-7042-4de8-bf0d-a1be71ea5172 PS C:\\work\\myApp\\docker&gt; </code></pre> ",
    "OwnerUserId": "2674303",
    "LastEditorUserId": "2674303",
    "LastEditDate": "2023-08-21T12:17:00.510",
    "LastActivityDate": "2023-08-21T12:17:13.157",
    "Title": "How to pass secrets to testContainers?",
    "Tags": "<spring-boot><docker><kotlin><docker-compose><testcontainers>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p><a href='https://testcontainers.com/' rel='nofollow noreferrer'>Testcontainers</a> does not seem to support Docker Compose's secrets directly. The only notion of secret is when using a <a href='https://java.testcontainers.org/modules/vault/' rel='nofollow noreferrer'>HashiCorp Vault Module</a> <code>.withSecretInVault()</code>.</p> <p>In your case, you can try and use a volume to emulate a secret: it is a workaround, a volume to bind-mount your secrets into the container at the expected path.</p> <pre class='lang-java prettyprint-override'><code>val secretPathOnHost = &quot;/path/to/your/secrets.yaml&quot;; val secretPathInContainer = &quot;/run/secrets/samba-admin-password&quot;;  val ldapContainer = GenericContainer(&quot;instantlinux/samba-dc:latest&quot;)     .withEnv(&quot;DOMAIN_ACTION&quot;, &quot;provision&quot;)     .withEnv(&quot;REALM&quot;, &quot;my.company&quot;)     .withEnv(&quot;ADMIN_PASSWORD_SECRET&quot;, &quot;samba-admin-password&quot;)     .withExposedPorts(53, 88, 389)     .withFileSystemBind(secretPathOnHost, secretPathInContainer, BindMode.READ_ONLY);  ldapContainer.start(); </code></pre> <p>Do replace <code>/path/to/your/secrets.yaml</code> with the absolute path to your <code>secrets.yaml</code> file on the host machine.</p> <p>Note: Emulating secrets as volumes means the secret is available as a plaintext file on your host system, so make sure you manage its permissions and access properly. That might be fine for local development and testing, but might not be ideal for production-like environments.</p> <p>And... never commit secrets or secret paths to source control.</p> <hr /> <p>Since the secret file is:</p> <pre><code>kind: Secret apiVersion: v1 metadata:   name: samba-admin-password data:   ADMIN_PASSWORD_SECRET: superpassword </code></pre> <p>Given this format, which is similar to a Kubernetes secret, you will need to parse the file in your test setup and then set the secret as an environment variable to the container.</p> <p>Using <code>testcontainers</code> and the Jackson library for YAML parsing:</p> <pre class='lang-java prettyprint-override'><code>import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.dataformat.yaml.YAMLFactory; import java.io.File; import java.util.Map;  // ...  // Load and parse the secrets.yaml file ObjectMapper mapper = new ObjectMapper(new YAMLFactory()); File secretsFile = new File(&quot;/path/to/your/secrets.yaml&quot;); Map&lt;String, Object&gt; secretsData = mapper.readValue(secretsFile, Map.class);  // Extract the secret from the parsed data String adminPassword = (String) ((Map) secretsData.get(&quot;data&quot;)).get(&quot;ADMIN_PASSWORD_SECRET&quot;);  // Create and start the container val ldapContainer = GenericContainer(&quot;instantlinux/samba-dc:latest&quot;)     .withEnv(&quot;DOMAIN_ACTION&quot;, &quot;provision&quot;)     .withEnv(&quot;REALM&quot;, &quot;my.company&quot;)     .withEnv(&quot;ADMIN_PASSWORD_SECRET&quot;, adminPassword) // Set the extracted secret as an environment variable     .withExposedPorts(53, 88, 389);  ldapContainer.start(); </code></pre> <p>That method involves reading the secret into your Java application, which you then pass as an environment variable to the container.</p> <hr /> <p>From the example provided by the OP, it looks like a Samba container using Testcontainers in a Spring Boot application. The container seems to be starting correctly as you can see the initialization logs of Samba.</p> <blockquote> <p>The main problem that samba container shutdown immediately after start(application is hanging on in Thread sleep). Looks like root cause could be find in samba logs:</p> <p><code>2023-08-21 13:39:07 ERROR(runtime): uncaught exception - (3221225506, '{Access Denied} A process has requested access to an object but has not been granted those access rights.') </code></p> </blockquote> <p>Since you are using Docker, remember that the Samba container will have its own user system. You may need to adjust the user or group IDs to match your host system if you are mounting volumes.</p> <p>Add in your container entry point the <code>id -a</code> and <code>ls -alrth /path/to/your/secrets.yaml</code> commands to see who you are inside the container, and how you see the mounted file system.<br /> Check the ownership and permissions of any volumes you have mounted into the container. The UID and GID inside the container might differ from those outside, leading to permission issues.</p> <p>If you are running Samba inside a Docker container, ensure that you have provided <a href='https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities' rel='nofollow noreferrer'>all necessary capabilities using <code>--cap-add</code></a> if needed.</p> <p>Review your Samba configuration (<code>smb.conf</code>). Ensure that the shares and paths defined have the correct permissions.<br /> Also, check for any <code>valid users</code>, <code>read list</code>, or <code>write list</code> directives and ensure that the users listed have the appropriate permissions.</p> <p>And if you are running a system with SELinux enabled, this can cause permission issues. You can temporarily set SELinux to permissive mode to see if it resolves the issue:</p> <pre><code>sudo setenforce 0 </code></pre> <p>If this resolves the issue, you will need to create the appropriate SELinux policies or adjust the context for the Samba-related files and directories.</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "33662300",
    "PostTypeId": "1",
    "AcceptedAnswerId": "33663246",
    "CreationDate": "2015-11-12T00:16:18.793",
    "Score": "4",
    "ViewCount": "3828",
    "Body": "<p>I'm trying to run <a href='https://spring.io/guides/gs/spring-boot-docker/' rel='nofollow'>spring boot sample</a> on osx (mbp) and I'm getting following exception (Trying buildDocker task). I'm sure I have configured docker properly as I can run command <code>docker-machine run hello-world</code> and receive proper output. </p>  <pre><code>Caused by: java.io.FileNotFoundException: /src/main/docker/Dockerfile (No such file or directory)     at se.transmode.gradle.plugins.docker.image.Dockerfile.fromExternalFile(Dockerfile.groovy:45)     at se.transmode.gradle.plugins.docker.image.Dockerfile$fromExternalFile.call(Unknown Source)     at se.transmode.gradle.plugins.docker.DockerTask.buildDockerfile(DockerTask.groovy:223)     at se.transmode.gradle.plugins.docker.DockerTask.build(DockerTask.groovy:238)     at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:63)     ... 54 more </code></pre>  <p>Other validation would be I can run gradle-docker default build task (i.e. distDocker) without any problem. Problem occur when I try to run build following build task on the gradle script.</p>  <pre><code>    // tag::task[] task buildDocker(type: Docker, dependsOn: build) {   push = true   applicationName = jar.baseName   dockerfile = file('/src/main/docker/Dockerfile')   doFirst {     copy {       from jar       into stageDir     }   } } // end::task[] </code></pre>  <p>I can't workout why it cannot determine the file when it's already exists. I tried copying into root and change path for no luck. </p>  <p>OSX : 10.10.4 Java : 1.8</p> ",
    "OwnerUserId": "718149",
    "LastActivityDate": "2015-11-12T02:07:09.167",
    "Title": "Docker plugin : java.io.FileNotFoundException: /src/main/docker/Dockerfile gradle-docker fails",
    "Tags": "<docker><spring-boot><boot2docker><dockerfile><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "6",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>Remove the '/' before src in the path. The path is relative from the current directory (project root) and not the volume root. </p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "44804018",
    "PostTypeId": "1",
    "AcceptedAnswerId": "44882772",
    "CreationDate": "2017-06-28T13:33:23.630",
    "Score": "4",
    "ViewCount": "3991",
    "Body": "<p>I'm working through the Spring tutorial here;</p>  <p><a href='https://spring.io/guides/gs/messaging-rabbitmq/' rel='nofollow noreferrer'>Messaging with RabbitMQ</a></p>  <p>I found this question but it did not address my query regarding the <code>docker-compose.yml</code> file found in the tutorial;</p>  <p><a href='https://stackoverflow.com/questions/30223203/spring-rabbitmq-tutorial-results-in-connection-refused-error'>Spring RabbitMQ tutorial results in Connection Refused error</a></p>  <p>I've completed all necessary steps up until the actual running of the application, at which point I'm getting <code>ConnectException</code> exceptions suggesting that the server is not running or not running correctly.</p>  <p>The docker-compose.yml file specified in the tutorial is as follows;</p>  <pre><code>rabbitmq: image: rabbitmq:management ports:   - '5672:5672'   - '15672:15672' </code></pre>  <p>Basically I am unsure what this docker-compose file actually does, because it doesn't seem to set up the RabbitMQ server as the tutorial suggests (or at least not in the way the tutorial expects). I'm quite new to Docker also so perhaps I am mistaken in thinking this file would run a new instance of the RabbitMQ server.</p>  <p>When I run <code>docker-compose up</code> I get the following console output;</p>  <pre><code>rabbitmq_1  | rabbitmq_1  | =INFO REPORT==== 28-Jun-2017::13:27:26 === rabbitmq_1  | Starting RabbitMQ 3.6.10 on Erlang 20.0-rc2 rabbitmq_1  | Copyright (C) 2007-2017 Pivotal Software, Inc. rabbitmq_1  | Licensed under the MPL.  See http://www.rabbitmq.com/ rabbitmq_1  | rabbitmq_1  |               RabbitMQ 3.6.10. Copyright (C) 2007-2017            Pivotal Software, Inc. rabbitmq_1  |   ##  ##      Licensed under the MPL.  See  http://www.rabbitmq.com/ rabbitmq_1  |   ##  ## rabbitmq_1  |   ##########  Logs: tty rabbitmq_1  |   ######  ##        tty rabbitmq_1  |   ########## rabbitmq_1  |               Starting broker... rabbitmq_1  | rabbitmq_1  | =INFO REPORT==== 28-Jun-2017::13:27:26 === rabbitmq_1  | node           : rabbit@bd20dc3d3d2a rabbitmq_1  | home dir       : /var/lib/rabbitmq rabbitmq_1  | config file(s) : /etc/rabbitmq/rabbitmq.config rabbitmq_1  | cookie hash    : DTVsmjdKvD5KtH0o/OLVJA== rabbitmq_1  | log            : tty rabbitmq_1  | sasl log       : tty rabbitmq_1  | database dir   : /var/lib/rabbitmq/mnesia/rabbit@bd20dc3d3d2a </code></pre>  <p>...plus a load of INFO reports. This led me to believe that the RabbitMQ server was up and running, but apparently not as I cannot connect.</p>  <p>The only way I have gotten this to work is by manually installing Erlang and RabbitMQ (on a Windows system here) which does appear to let me complete the tutorial.</p>  <p>Why is Docker even mentioned in this tutorial though? The <code>docker-compose.yml</code> does not appear to do what the tutorial suggests. </p>  <p>What is this file actually doing here and how would one run RabbitMQ in a docker container for the purposes of this tutorial? Is this an issue with port numbers?</p> ",
    "OwnerUserId": "8215811",
    "LastActivityDate": "2018-08-02T12:34:23.720",
    "Title": "Docker image for Spring/RabbitMQ tutorial results in connection refused",
    "Tags": "<spring-boot><rabbitmq><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>It turns out the issue was with the Spring RabbitMQ template connection information.</p>  <p>The Spring tutorial assumes the use of the normal, manual installation of RabbitMQ (plus Erlang) and the RabbitMQ Spring template uses some default connection parameters that are not compatible with the image in <code>docker-compose</code> file specified in the tutorial.</p>  <p>To solve this I needed to add an Spring <code>application.properties</code> file and add it to the <code>resources</code> folder in my application directory structure. Next I needed to find the IP address of my Docker container using the following command;</p>  <pre><code>docker-machine ip </code></pre>  <p>which will gives the IP address. I added the following parameters to the <code>application.properties</code> file;</p>  <pre><code>spring.rabbitmq.host={docker-machine ip address} spring.rabbitmq.port=5672 spring.rabbitmq.username=guest spring.rabbitmq.password=guest </code></pre>  <p>The port, username and password here are all defaults and can be found in the RabbitMQ documentation.</p>  <p>Doing this I was able to have my application connect correctly to the RabbitMQ server running in the Docker container.</p>  <p>It appears the Spring tutorial is slightly incomplete as it does not inform the reader that some extra steps are required when using the RabbitMQ <code>docker-compose</code> file over the manual installation of RabbitMQ that the rest of the tutorial assumes.</p> ",
    "highest_rated_answer": "<p>From what I know, it is not possible to know all the time the IP address and you should instead of the ip address, provide the DNS which is the name of the rabbitmq server defined in your docker-compose file.</p> "
  },
  {
    "Id": "45492903",
    "PostTypeId": "1",
    "CreationDate": "2017-08-03T19:22:41.647",
    "Score": "4",
    "ViewCount": "2342",
    "Body": "<p>I'm having difficulty linking these containers together using Docker Compose, let me preface by saying that I am currently running on a Mac as well. </p>  <p>The application is currently working without the use of Docker Compose, in that if I run these all individually (not with Docker) the application works as intended. </p>  <p>As intended means that the application is reading from Redis as well as pulling data that comes across certain Kafka topics and displaying them on the front-end. </p>  <p>On to what I believe are the necessary files.</p>  <p><strong><code>docker-compose.yml</code></strong></p>  <pre><code>version: '2' services:   zookeeper:     image: wurstmeister/zookeeper     ports:       - '2181:2181'   kafka:     image: wurstmeister/kafka:0.10.2.0     ports:       - '9092:9092'     environment:       KAFKA_ADVERTISED_HOST_NAME: localhost       KAFKA_CREATE_TOPICS: 'flight-events:1:1,reported-flight-time-events:1:1,pax-flight-events:1:1'       KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181     volumes:       - /var/run/docker.sock:/var/run/docker.sock     depends_on:       - zookeeper   redis:     image: redis     ports:       - '6379'     restart: always   kafka-websocket-connector:     build: ./kafka-websocket-connector     image: &lt;user&gt;/kafka-websocket-connector     ports:       - '8077:8077'     depends_on:       - kafka       - redis       - zookeeper     links:       - 'kafka'       - 'redis' </code></pre>  <p>The <code>Dockerfile</code> that is being referenced under <code>kafka-websocket-connector</code> is as follows:</p>  <p><strong><code>Dockerfile</code></strong></p>  <pre><code>FROM frolvlad/alpine-oraclejdk8:slim VOLUME /tmp ADD target/kafka-websocket-connector-0.0.1-SNAPSHOT.jar app.jar ENV JAVA_OPTS='' ENTRYPOINT [ 'sh', '-c', 'java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app.jar' ] </code></pre>  <p>If I attempt to run the command <code>docker-compose up --build</code> I receive the following error: </p>  <pre><code>ERROR: Service 'kafka-websocket-connector' failed to build: ADD failed:      stat /var/lib/docker/tmp/docker-builder838069739/target/kafka-websocket-connector-0.0.1-SNAPSHOT.jar: no such file or directory </code></pre>  <p>I don't know if this necessarily relates to the connecting these components, but my <code>build.gradle</code> for the Spring application is as follows:</p>  <p><strong><code>build.gradle</code></strong></p>  <pre><code>buildscript {     ext {         springBootVersion = '1.5.4.RELEASE'     }     repositories {         mavenCentral()     }     dependencies {         classpath('org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}')          classpath('se.transmode.gradle:gradle-docker:1.2')     } }  apply plugin: 'java' apply plugin: 'eclipse' apply plugin: 'org.springframework.boot'  apply plugin: 'docker'  group = '&lt;user&gt;'  jar {     baseName = 'kafka-websocket-connector'     version = '0.0.1-SNAPSHOT'     sourceCompatibility = 1.8 }  task buildDocker(type: Docker, dependsOn: build) {   applicationName = jar.baseName   dockerfile = file('Dockerfile')   doFirst {     copy {       from jar       into '${stageDir}/target'     }   } }    repositories {     mavenCentral() }   ext {     springCloudVersion = 'Dalston.SR1' }  dependencies {      compile('org.springframework.boot:spring-boot-starter-data-redis')     compile('org.springframework.kafka:spring-kafka')     compile('org.springframework.boot:spring-boot-starter-web')     compile('org.springframework.boot:spring-boot-starter-websocket')     compile('org.webjars:webjars-locator')     compile('org.webjars:sockjs-client:1.0.2')     compile('org.webjars:stomp-websocket:2.3.3')     compile('org.webjars:bootstrap:3.3.7')     compile('org.webjars:jquery:3.1.0')     compile group: 'org.webjars', name: 'd3js', version: '4.2.1'     testCompile('org.springframework.boot:spring-boot-starter-test')     testCompile('org.springframework.restdocs:spring-restdocs-mockmvc')  }  dependencyManagement {     imports {         mavenBom 'org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}'     } }  bootRepackage {     executable = true     enabled = true } </code></pre>  <p>So to restate the problem, I am having trouble connecting the following components using Docker Compose: Zookeeper, Kafka, Redis, and a Spring Boot application. </p> ",
    "OwnerUserId": "5451356",
    "LastActivityDate": "2017-08-03T19:35:31.480",
    "Title": "Docker Compose with Zookeeper, Kafka, Redis, and Java Spring Boot",
    "Tags": "<docker><spring-boot><apache-kafka><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>The <code>KAFKA_ADVERTISED_HOST_NAME: localhost</code> environment variable in your <code>kafka</code> service is likely the cause of the problem. It needs to be reachable by other containers. Try change it to <code>KAFKA_ADVERTISED_HOST_NAME: kafka</code>.</p>  <p>All the containers of the services defined in your docker-compose.yml are added to a user-defined network, named after your compose project. The containers in this network are reachable and discoverable by other each, using hostnames that are identical to the container name. You can find out more information on Docker Compose networking in their <a href='https://docs.docker.com/compose/networking/' rel='noreferrer'>documentation</a>.</p> "
  },
  {
    "Id": "48781110",
    "PostTypeId": "1",
    "AcceptedAnswerId": "48781877",
    "CreationDate": "2018-02-14T06:39:31.180",
    "Score": "4",
    "ViewCount": "5559",
    "Body": "<p>everyone. I have some problems with project deployment, and i already spent few days to solve it. I developing mobile backend on stack:</p>  <ol> <li>Spring Boot 1.5 + Dev Tools </li> <li>PostgreSQL </li> <li>Docker</li> <li>Gradle</li> </ol>  <p><strong>docker-compose.yml</strong> </p>  <pre><code>version: '3' services:     web:       image: mobilebackend             ports:           - 8088:8080       depends_on:           - db       links:          - db     db:         container_name: transneft_db         image: postgres         restart: always         volumes:             - transneft_db:/var/lib/postgresql/data         environment:             - POSTGRES_PASSWORD=pass             - POSTGRES_USER=user             - POSTGRES_DB=db             - PGDATA=/var/lib/postgresql/data/pgdata         ports:             - 54320:5432     adminer:         image: adminer         restart: always         ports:             - 8082:8080 volumes:     transneft_db: {} </code></pre>    <p><strong>application.properties</strong></p>    <pre><code>spring.datasource.url=jdbc:postgresql://localhost:54320/db spring.datasource.username=user spring.datasource.password=pass spring.datasource.platform=postgres spring.datasource.driver-class-name=org.postgresql.Driver  spring.jpa.database=POSTGRESQL spring.jpa.hibernate.ddl-auto=update spring.jpa.show-sql=true spring.jpa.generate-ddl=true spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect  jwt.secret =aotransneftsibir  logging.level.org.springframework.web=DEBUG logging.level.org.hibernate=ERROR </code></pre>    <p><strong>build.gradle</strong></p>    <pre><code>buildscript {     ext {         springBootVersion = '1.5.10.RELEASE'     }     repositories {         mavenCentral()     }     dependencies {         classpath('org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}')         classpath('se.transmode.gradle:gradle-docker:1.2')     } }  apply plugin: 'java' apply plugin: 'eclipse' apply plugin: 'org.springframework.boot' apply plugin: 'docker' apply plugin: 'application'  repositories {     mavenCentral() }  compileJava {     sourceCompatibility = 1.8     targetCompatibility = 1.8     mainClassName       = 'com.backend.MobilebackendApplication' }  jar {     baseName = 'backend-api'     group    = 'com.backend'     version  = '0.0.1-SNAPSHOT'     manifest { attributes 'Main-Class': 'com.backend.mobilebackend.MobilebackendApplication' } }  docker {     baseImage 'frolvlad/alpine-oraclejdk8:slim'     maintainer 'Alex Scrobot 'scrobot91@gmail.com'' }  dependencies {     // spring boot     compile('org.springframework.boot:spring-boot-starter-data-jpa')     compile('org.springframework.boot:spring-boot-starter-data-rest')     compile('org.springframework.boot:spring-boot-starter-web')     runtime('org.springframework.boot:spring-boot-devtools')      //postgresql     runtime('org.postgresql:postgresql')      //gson     compile group: 'com.google.code.gson', name: 'gson', version: '2.7'      // JWT     compile 'io.jsonwebtoken:jjwt:0.9.0'      //test env     testCompile('org.springframework.boot:spring-boot-starter-test')     testCompile('org.springframework.security:spring-security-test') } </code></pre>    <p>On localhost working good, project are building with DevTools and working fine. Docker container with postgresql is up, i can access connection to it with localhost:port, all fine.</p>  <p>Problems started, then i tried to call: </p>  <p><code>./gradlew build distDocker --refresh-dependencies</code></p>  <p>In this case property <code>spring.datasource.url</code> have to contain localhost value, of build will fail. I put localhost value, get success message, that image is built. So, then i try to run container with Spring Boot .jar i get 'Connection Refused Error'. I have some thoughts about this case: container with .jar is running up, it tries to get database access by localhost:db_port, but inside this container cannot be db connection to its localhost. So, then i put in application.property </p>  <p><code>spring.datasource.url=jdbc:postgresql://db:54320/db</code></p>  <p>but then, i cannot build updated image. Then gradle try to boot assembled .jar, it cannot access to db:54320, because boot is running not in container, and right connections localhost:54320. Do you feel the vicious circle of how I feel it?)) </p>  <p>I don't understand, what i'm doing wrong... please, help me to solve this problem.. Thank you.</p> ",
    "OwnerUserId": "3775934",
    "LastActivityDate": "2018-02-14T07:34:03.713",
    "Title": "Deploy of Spring Boot/PostgreSQL project with Gradle and Docker",
    "Tags": "<java><postgresql><docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "1",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>The quick and dirty solution would be putting 127.0.0.2 db into your /etc/hosts file, and use jdbc:postgresql://db:54320/db as database URL and thing would work.</p>  <p>The nicer solution is using a build container for your application. So your docker-compose would look like this:</p>  <pre><code>version: '3' services:   web:     image: mobilebackend     # The value of build refers to a directory at where your compose file is.     build: mobilebackend     ... </code></pre>  <p>Within the mobilebackend directory, you create a Dockerfile like this:</p>  <pre><code>FROM gradle AS build RUN gradle build ...  FROM openjdk COPY --from=build mobilebackend.jar . RUN java -jar mobilebackend.jar </code></pre>  <p>As you don't need to expose your database port for this, you can even use the standard port: jdbc:postgresql://db/db</p>  <p>Now you can compile and run your whole application with</p>  <pre><code>docker-compose build docker-compose up </code></pre> ",
    "highest_rated_answer": null
  },
  {
    "Id": "51632753",
    "PostTypeId": "1",
    "CreationDate": "2018-08-01T11:59:35.583",
    "Score": "4",
    "ViewCount": "2888",
    "Body": "<p>I'm trying to introduce a Spring Boot REST service in our development setup. The development setup is using docker-compose and an API gateway to expose the individual services on the same domain (ie. localhost). </p>  <p>When I try to make a HTTP request to my service from inside another container via the service name in the shared docker-compose file, the service returns a 400.</p>  <h3>The setup</h3>  <p>I've edited our docker-compose file, so it looks like the below to introduce the Spring Boot Java service. The service is based on spring-boot-starter-parent (2.0.3.RELEASE) and spring-boot-starter-web. I haven't configured anything related to the web server (except adding the server.server-header property to ensure myself that the request is hitting my service).</p>  <pre><code>version: '3' services:   ...    hello_java:     build:       context: ../hello-java/       dockerfile: Dockerfile     depends_on:       - postgres       - castle_black     ports:       - '8301:8080'    castle_black:     build: ../castle-black/tyk-gateway     ports:       - '8191:8080'     depends_on:       - redis </code></pre>  <h3>The behaviour</h3>  <p>If I request the hello service from outside the containers (e.g. in my browser on localhost:8301) it replies back correctly. If I'm inside a container, but obtain the IP that the container with my new service gets in the docker network and use that the new service also responds correctly back.</p>  <p>Below I have shown a request from inside the API gateway container to the Java service, first by using the service name and then afterwards with the IP that was resolved. It only replies with a correct response in the IP case.</p>  <pre><code># curl -v http://hello_java:8080/hello-java/greet?username=Java * Hostname was NOT found in DNS cache *   Trying 172.19.0.6... * Connected to hello_java (172.19.0.6) port 8080 (#0) &gt; GET /hello-java/greet?username=Java HTTP/1.1 &gt; User-Agent: curl/7.35.0 &gt; Host: hello_java:8080 &gt; Accept: */* &gt;  &lt; HTTP/1.1 400  &lt; Transfer-Encoding: chunked &lt; Date: Wed, 01 Aug 2018 11:34:34 GMT &lt; Connection: close * Server MySpringBootApp is not blacklisted &lt; Server: MySpringBootApp &lt;  * Closing connection 0  # curl -v http://172.19.0.6:8080/hello-java/greet?username=Java * Hostname was NOT found in DNS cache *   Trying 172.19.0.6... * Connected to 172.19.0.6 (172.19.0.6) port 8080 (#0) &gt; GET /hello-java/greet?username=Java HTTP/1.1 &gt; User-Agent: curl/7.35.0 &gt; Host: 172.19.0.6:8080 &gt; Accept: */* &gt;  &lt; HTTP/1.1 200  &lt; Content-Type: text/plain;charset=UTF-8 &lt; Content-Length: 10 &lt; Date: Wed, 01 Aug 2018 11:34:55 GMT * Server MySpringBootApp is not blacklisted &lt; Server: MySpringBootApp &lt;  * Connection #0 to host 172.19.0.6 left intact Hello Java </code></pre>  <h3>The questions</h3>  <p>Is there something in the standard spring-boot-starter-web setup that prevents the web server from servicing the request, when the client adds the 'Host: hello_java:8080' header? Or why is the web server behaving differently in the two scenarios? And what can I do about it?</p> ",
    "OwnerUserId": "10165285",
    "LastEditorUserId": "10165285",
    "LastEditDate": "2018-08-01T13:03:16.450",
    "LastActivityDate": "2018-10-31T14:34:34.933",
    "Title": "Spring Boot REST app returns 400 when requested from other docker-compose service by service name",
    "Tags": "<java><spring-boot><docker-compose><bad-request>",
    "AnswerCount": "2",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>After some experimentation it turned out that the it was the underscore in the service name that caused the issue. Changing the service name to not have an underscore solved the problem.</p> "
  },
  {
    "Id": "52719225",
    "PostTypeId": "1",
    "CreationDate": "2018-10-09T10:49:12.993",
    "Score": "4",
    "ViewCount": "3044",
    "Body": "<p>I have a Spring Boot app running in a docker container that's setup using a Dockerfile and then a docker-compose.yml file. I recently added in the Java command <code>-agentlib:jdwp=transport=dt_socket,address=5050,server=y,suspend=n</code> into the Dockerfile to enable debugging. I have exposed the port 5050 and also mapped it in the docker-compose file.  When I run the app on the container I start debugging through IntelliJ and it connects but if I set a breakpoint, it is never hit. Now I am not sure what I am doing wrong here as the remote debugger is connecting. I even tried changing the setting <code>suspend=y</code> and that worked i.e. the server wouldn't start until I started the debugger.</p>  <p>Here's the relevant work I have done;</p>  <p><strong>Dockerfile</strong></p>  <pre><code>FROM openjdk:8-alpine WORKDIR / EXPOSE 8000 5050 COPY target / CMD java -agentlib:jdwp=transport=dt_socket,address=5050,server=y,suspend=n -jar /target/blockchain*.jar </code></pre>  <p><strong>docker-compose.yml</strong></p>  <pre><code>multichain-api:   build:     context: ./blockchain   networks:     - multichain-network   ports:     - '8000:8000'     - '5050:5050'   volumes:     - type: bind       source: ${PWD}/blockchain/target       target: /target   container_name: multichain-api </code></pre>  <p>Any ideas on where I am gone wrong?</p> ",
    "OwnerUserId": "2199102",
    "LastActivityDate": "2019-11-07T19:19:14.103",
    "Title": "Debugging spring-boot app in docker doesn't work",
    "Tags": "<docker><spring-boot><docker-compose><remote-debugging>",
    "AnswerCount": "3",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>You may need to add 0.0.0.0 or * to the address argument</p>  <ul> <li>address=0.0.0.0:5050</li> <li>address=*:5050</li> </ul> "
  },
  {
    "Id": "53328497",
    "PostTypeId": "1",
    "AcceptedAnswerId": "53328552",
    "CreationDate": "2018-11-15T22:00:11.923",
    "Score": "4",
    "ViewCount": "5282",
    "Body": "<p>I am trying to containerize my spring boot application, however I am running into issues with docker...</p>  <pre><code>docker-compose build db uses an image, skipping    Building drools-average-docker-app Step 1/5 : FROM java:8  ---&gt; d23bdf5b1b1b Step 2/5 : VOLUME /tmp  ---&gt; Using cache  ---&gt; 6bbb9078c3f0 Step 3/5 : ADD target/DroolsAverage-0.0.1-SNAPSHOT.war DroolsAverage.war  ---&gt; 8a01751a6ac9 Step 4/5 : RUN bash -c 'touch /DroolsAverage.war'  ---&gt; Running in 330ed2275089 Removing intermediate container 330ed2275089  ---&gt; 65cf51ebf28f Step 5/5 : ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/DroolsAverage.war']  ---&gt; Running in 65357cc5afed Removing intermediate container 65357cc5afed  ---&gt; acb6358e4c0e Successfully built acb6358e4c0e Successfully tagged drools-average-docker-image:latest </code></pre>  <p>Then running <code>docker-compose up</code> yields the following error</p>  <pre><code>Recreating droolsaverage_drools-average-docker-app_1_2d763cdbed6c ... done Starting droolsaverage_db_1_efa205bdb880                          ... done Attaching to droolsaverage_db_1_efa205bdb880, droolsaverage_drools-average-docker-app_1_2d763cdbed6c db_1_efa205bdb880            | 2018-11-15 21:54:13.781 UTC [1] LOG:  listening on IPv4 address '0.0.0.0', port 5432 db_1_efa205bdb880            | 2018-11-15 21:54:13.781 UTC [1] LOG:  listening on IPv6 address '::', port 5432 db_1_efa205bdb880            | 2018-11-15 21:54:13.795 UTC [1] LOG:  listening on Unix socket '/var/run/postgresql/.s.PGSQL.5432' db_1_efa205bdb880            | 2018-11-15 21:54:13.827 UTC [18] LOG:  database system was shut down at 2018-11-15 21:51:44 UTC db_1_efa205bdb880            | 2018-11-15 21:54:13.837 UTC [1] LOG:  database system is ready to accept connections drools-average-docker-app_1_2d763cdbed6c | no main manifest attribute, in /DroolsAverage.war droolsaverage_drools-average-docker-app_1_2d763cdbed6c exited with code 1 </code></pre>  <p>I don't understand why it is saying I have no main manifest attribute? </p>  <p>Here is my <code>Main.java</code></p>  <pre><code>package com.techgap.droolsaverage.droolsaverage;   import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.ConfigurableApplicationContext; import org.springframework.context.annotation.ComponentScan;   @SpringBootApplication @ComponentScan (basePackages = {         'com.techgap.droolsaverage.controller',         'com.techgap.droolsaverage.model',         'com.techgap.droolsaverage.util',         'com.techgap.droolsaverage.config',         'com.techgap.droolsaverage.exception' }) public class Main{       @SuppressWarnings('unused')     private static ConfigurableApplicationContext ctx;     @SuppressWarnings('unused')     private int maxUploadSizeInMb = 10 * 1024 * 1024; // 10 MB      public static void main(String[] argv) {          SpringApplication.run(Main.class, argv);     } } </code></pre>  <p>My <code>docker-compose.yml</code> and <code>Dockerfile</code></p>  <pre><code>version: '3.1'  services:   drools-average-docker-app:     image: drools-average-docker-image     build:         context: ./         dockerfile: Dockerfile     ports:         - 8080:8080   db:     image: postgres:11-alpine     environment:       POSTGRES_DB: 'droolsTestDB'       POSTGRES_USER: 'postgres'       POSTGRES_PASSWORD: 'postgres'     ports:     - '5432:5432' ~ </code></pre>  <p>And the Dockerfile</p>  <pre><code>FROM java:8 VOLUME /tmp ADD target/DroolsAverage-0.0.1-SNAPSHOT.war DroolsAverage.war RUN bash -c 'touch /DroolsAverage.war' ENTRYPOINT ['java','-Djava.security.egd=file:/dev/./urandom','-jar','/DroolsAverage.war'] </code></pre>  <p>Can someone point me in the correct direction?</p> ",
    "OwnerUserId": "8685240",
    "LastActivityDate": "2018-11-15T22:06:43.157",
    "Title": "Docker-compose: no main manifest attribute in /app.war",
    "Tags": "<java><spring><spring-boot><docker><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>If you intend to run your app as a stand alone application, package it as a jar file instead of war file. Packaging as a war file implies you'll be deploying it to a web server such as Tomcat, and therefore the <code>java -jar</code> option won't work.</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "55021077",
    "PostTypeId": "1",
    "AcceptedAnswerId": "55021609",
    "CreationDate": "2019-03-06T10:40:37.307",
    "Score": "4",
    "ViewCount": "13580",
    "Body": "<p>I have a spring-boot application and I have some files placed inside /src/main/java/resources which I am trying to read it in my code.  When the same code tries to read from docker container it says file does not exist. The same code works perfectly fine via localhost</p>  <p>The files are under /src/main/java/resources/data folder and this is my code which tries to read the file</p>  <pre><code> private String getJson(String folderName, String id, StringBuilder sb) throws Exception {         String responseJson = null;         String filePath = 'data' + File.separator + folderName + File.separator + id + '.json';         LOG.info('printing filePath : ' + filePath);         LOG.info('printing id : ' + id);         File f = new File(filePath);        // if(f.exists()){             try (InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(filePath)) {                 LOG.info('printing inputStream : ' + inputStream);                 if (inputStream != null) {                     responseJson = IOUtils.toString(inputStream, StandardCharsets.UTF_8.name());                 }                 if (responseJson == null || responseJson.isEmpty()) {                     LOG.info('json response is null : ');                     throw new JsonNotFoundException(Constant.JSON_NOT_FOUND);                 }                 sb.append(responseJson);             } catch (IOException e) {                 LOG.info('IO exception : ');                 throw new IOException(e);             } catch (Exception e) {                 LOG.info(' exception : ');                 throw new Exception(e);             } //        } //        else{ //            LOG.info('file doesnt exists : ' + filePath); //        }         return sb.toString();     }  </code></pre>  <p>An example for the file path : src/main/resources/data/get-products/1420-17612-82.json Docker file content</p>  <pre><code>{   'commands':   [     'rm -rf .tmp',     'git clone git@github.com:{orgnname}/{test-service.git} -b COECP-973-Configure-logging-mechanism-for-Service .tmp/test-service',     'docker build .tmp/test-service/.docker/build/db -t local/test-service/db',     'docker build .tmp/test-service -t local/test-service/app'   ] } </code></pre> ",
    "OwnerUserId": "5648526",
    "LastEditorUserId": "5648526",
    "LastEditDate": "2019-03-06T10:59:49.210",
    "LastActivityDate": "2019-03-06T11:06:21.980",
    "Title": "Cannot read file via docker container",
    "Tags": "<java><spring-boot><docker><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "5",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>So... you messed path for <code>File</code> and for resources from class path. What is the reason to have <code>File f = new File(filePath);</code>? </p>  <p>Here are things:</p>  <ol> <li><p>If you use <code>File</code> - files must be available to the JVM and as long as you use relative path like <code>data\\folderxxx\\filexxx.json</code> it must be available in container file system. I.e. <code>data</code> folder must be placed in image or mounted from outside exactly into directory from where JVM runs</p></li> <li><p>If you use <code>ClassLoader</code> and <code>ResourceAsStream</code> root of your <code>data</code> directory must be defined in class path for JVM or be in Jar file - it is a root in classpath as well. Check your jar file - if <code>data</code> directory is in root of jar - all fine and files will be available by <code>this.getClass().getClassLoader().getResourceAsStream(filePath)</code>, <em>but not for <code>new File(filePath)</code>!</em> </p></li> </ol>  <p>if not - make it happen or update your filePath for <code>ResourceAsStream</code> accordingly.</p> ",
    "highest_rated_answer": "<p>I have had faced the same issue earlier, though our requirement got more complex over time, but the following code should solve your problem: </p>  <pre><code>    ClassPathResource cp = new ClassPathResource('relative_path_to_file');     File f = null;      if (cp.exists())         f = cp.getFile(); </code></pre> "
  },
  {
    "Id": "55708104",
    "PostTypeId": "1",
    "CreationDate": "2019-04-16T12:24:34.797",
    "Score": "4",
    "ViewCount": "4271",
    "Body": "<p>I am trying to dockerize 4 services and I have a problem with one of the services. Particularly, this service is implemented is spring boot service and uses google vision API. When building the images and starting the containers everything works fine, until it gets to the part where the google vision API code is used. I then have the following runtime errors when running the containers:</p>  <pre><code>netty-tcnative unavailable (this may be normal) java.lang.IllegalArgumentException: Failed to load any of the given libraries: [netty_tcnative_linux_x86_64, netty_tcnative_linux_x86_64_fedora, netty_tcnative_x86_64, netty_tcnative] at io.grpc.netty.shaded.io.netty.util.internal.NativeLibraryLoader.loadFirstAvailable(NativeLibraryLoader.java:104) ~[grpc-netty-shaded-1.18.0.jar!/:1.18.0] at io.grpc.netty.shaded.io.netty.handler.ssl.OpenSsl.loadTcNative(OpenSsl.java:526) ~[grpc-netty-shaded-1.18.0.jar!/:1.18.0] at io.grpc.netty.shaded.io.netty.handler.ssl.OpenSsl.&lt;clinit&gt;(OpenSsl.java:93) ~[grpc-netty-shaded-1.18.0.jar!/:1.18.0] at io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts.defaultSslProvider(GrpcSslContexts.java:244) [grpc-netty-shaded-1.18.0.jar!/:1.18.0] at io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts.configure(GrpcSslContexts.java:171) [grpc-netty-shaded-1.18.0.jar!/:1.18.0] at io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts.forClient(GrpcSslContexts.java:120) [grpc-netty-shaded-1.18.0.jar!/:1.18.0] at io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder.buildTransportFactory(NettyChannelBuilder.java:385) [grpc-netty-shaded-1.18.0.jar!/:1.18.0] at io.grpc.internal.AbstractManagedChannelImplBuilder.build(AbstractManagedChannelImplBuilder.java:435) [grpc-core-1.18.0.jar!/:1.18.0] at com.google.api.gax.grpc.InstantiatingGrpcChannelProvider.createSingleChannel(InstantiatingGrpcChannelProvider.java:223) [gax-grpc-1.42.0.jar!/:1.42.0] at com.google.api.gax.grpc.InstantiatingGrpcChannelProvider.createChannel(InstantiatingGrpcChannelProvider.java:164) [gax-grpc-1.42.0.jar!/:1.42.0] at com.google.api.gax.grpc.InstantiatingGrpcChannelProvider.getTransportChannel(InstantiatingGrpcChannelProvider.java:156) [gax-grpc-1.42.0.jar!/:1.42.0] at com.google.api.gax.rpc.ClientContext.create(ClientContext.java:157) [gax-1.42.0.jar!/:1.42.0] at com.google.cloud.vision.v1.stub.GrpcImageAnnotatorStub.create(GrpcImageAnnotatorStub.java:84) [google-cloud-vision-1.66.0.jar!/:1.66.0] at com.google.cloud.vision.v1.stub.ImageAnnotatorStubSettings.createStub(ImageAnnotatorStubSettings.java:120) [google-cloud-vision-1.66.0.jar!/:1.66.0] at com.google.cloud.vision.v1.ImageAnnotatorClient.&lt;init&gt;(ImageAnnotatorClient.java:136) [google-cloud-vision-1.66.0.jar!/:na] at com.google.cloud.vision.v1.ImageAnnotatorClient.create(ImageAnnotatorClient.java:117) [google-cloud-vision-1.66.0.jar!/:na] at com.google.cloud.vision.v1.ImageAnnotatorClient.create(ImageAnnotatorClient.java:108) [google-cloud-vision-1.66.0.jar!/:na] </code></pre>  <p>Complete log file of the error can be found in this link: <a href='https://drive.google.com/file/d/1K2FYUGvZ2II4jbjUzcg3uhL6TRD626Qw/view?usp=sharing' rel='nofollow noreferrer'>Complete Log File</a>.</p>  <p>Here are my <strong>docker-compose.yml</strong> file and the <strong>Dockerfile</strong> of the service causing problem:</p>  <p><strong>DockerFile</strong></p>  <pre><code>FROM maven:3.6.0-jdk-8-alpine WORKDIR /app/back COPY src src COPY pom.xml . RUN mvn clean package  FROM openjdk:8-jdk-alpine RUN apk add --no-cache curl WORKDIR /app/back  COPY --from=0 /app/back/target/imagescanner*.jar ./imagescanner.jar COPY --from=0 /app/back/target/classes/API-Key.json . ENV GOOGLE_APPLICATION_CREDENTIALS ./API-Key.json EXPOSE 8088  ENTRYPOINT ['java', '-jar', './imagescanner.jar'] </code></pre>  <p><strong>docker-compose.yml</strong></p>  <pre><code>version: '3'  services:    front:      container_name: demoLab_front      build: ./front      image: demolab/front:latest      expose:        - '3000'      ports:        - '8087:3000'      restart: always    back:      container_name: demoLab_backGCV      build: ./backGCV      image: demolab/backgcv:latest      depends_on:        - lab      ports:        - '8088:8088'      restart: always    lab:      container_name: demoLab_labGCV      build: ./lab      image: demolab/labgcv:latest      expose:        - '8089'      ports:        - '8089:8089'      restart: always    sift:      container_name: demoLab_labSIFT      build: ./detect-label-service      image: demolab/labsift:latest      expose:        - '5000'      ports:        - '5000:5000'      restart: always </code></pre>  <p><strong>EDIT</strong></p>  <p>After some googling I found out that: GRPC Java examples are not working on Alpine Linux since required libnetty-tcnative-boringssl-static depends on glibc. Alpine is using musl libc and application startup will fail with message similar to mine. I found <a href='https://github.com/netty/netty-tcnative/issues/111' rel='nofollow noreferrer'>this project</a> that try to build the right images but it seems broken for a lot of pepole (the build didn't work for my case)</p> ",
    "OwnerUserId": "3081406",
    "LastEditorUserId": "3081406",
    "LastEditDate": "2019-04-16T13:02:08.567",
    "LastActivityDate": "2021-08-14T04:00:26.933",
    "Title": "Docker - Problem with java netty_tcnative",
    "Tags": "<spring-boot><docker><docker-compose><netty><grpc-java>",
    "AnswerCount": "2",
    "CommentCount": "2",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Problem solved by replacing this line of the Dockerfile: </p>  <pre><code>FROM openjdk:8-jdk-alpine </code></pre>  <p>with this line:</p>  <pre><code>FROM koosiedemoer/netty-tcnative-alpine </code></pre> "
  },
  {
    "Id": "56074108",
    "PostTypeId": "1",
    "CreationDate": "2019-05-10T08:59:08.400",
    "Score": "4",
    "ViewCount": "2945",
    "Body": "<p>Flyway tries to connect to MySQL Docker-Container. Flyway is integrated in a Spring Boot Project. Spring Boot Project and the database are starting from a docker-compose.</p>  <p>There is no possibility to connect with the database-client to the database-container.</p>  <p>In the error-log of Flyway, there is the message: </p>  <pre><code>Access denied for user 'root'@'172.19.0.3' (using password: NO) </code></pre>  <p>I've tried to solve the problem with several solutions from Stackoverflow. I have tried to change up the application.properties file. Also tried to create a new user with a init.sql. With docker-compose, I tried to set the MySQL-root-password.</p>  <p>docker-compose.yml</p>  <pre><code>version: '3'  services:    docker-mysql:     image: mysql:latest     container_name: docker-mysql     command: --init-file /data/application/init.sql     volumes:         - .init.sql:/data/application/init.sql     networks:       - mt-network     environment:       - MYSQL_ROOT_PASSWORD=       - MYSQL_DATABASE=chat       - MYSQL_USER=thelegend27       - MYSQL_PASSWORD=1234       - MYSQL_ALLOW_EMPTY_PASSWOR=yes   spring-boot-jpa-docker-webapp:     image: chat     depends_on:       - docker-mysql     links:       - docker-mysql     ports:       - 8080:8080     networks:       - mt-network     environment:       - SPRING_DATASOURCE_URL=jdbc:mysql://docker-mysql:3306/chat?useUnicode=true&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC       - DATABASE_HOST_1=docker-mysql       - DATABASE_HOST=localhost       - DATABASE_USER=thelegend27       - DATABASE_PASSWORD=1234       - DATABASE_NAME=chat         - DATABASE_PORT=3306 networks:   mt-network:     driver: bridge </code></pre>  <p>application.properties</p>  <pre><code>#spring.jpa.hibernate.ddl-auto=create spring.datasource.url=jdbc:mysql://docker-mysql:3306/chat?useUnicode=true&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC spring.datasource.username=thelegend27 spring.datasource.password=1234  flyway.user=thelegend27 flyway.password=1234   logging.level.org.flywaydb=debug </code></pre>  <p>Errorlog</p>  <pre><code>spring-boot-jpa-docker-webapp_1  | SQL State  : 28000 spring-boot-jpa-docker-webapp_1  | Error Code : 1045 spring-boot-jpa-docker-webapp_1  | Message    : Access denied for user 'root'@'172.19.0.3' (using password: NO) spring-boot-jpa-docker-webapp_1  | spring-boot-jpa-docker-webapp_1  |  at org.flywaydb.core.internal.jdbc.JdbcUtils.openConnection(JdbcUtils.java:60) ~[flyway-core-5.2.4.jar!/:na] spring-boot-jpa-docker-webapp_1  |  at org.flywaydb.core.internal.database.DatabaseFactory.createDatabase(DatabaseFactory.java:72) ~[flyway-core-5.2.4.jar!/:na] spring-boot-jpa-docker-webapp_1  |  at org.flywaydb.core.Flyway.execute(Flyway.java:1670) ~[flyway-core-5.2.4.jar!/:na] spring-boot-jpa-docker-webapp_1  |  at org.flywaydb.core.Flyway.migrate(Flyway.java:1356) ~[flyway-core-5.2.4.jar!/:na] spring-boot-jpa-docker-webapp_1  |  at org.springframework.boot.autoconfigure.flyway.FlywayMigrationInitializer.afterPropertiesSet(FlywayMigrationInitializer.java:66) ~[spring-boot-autoconfigure-2.1.4.RELEASE.jar!/:2.1.4.RELEASE] spring-boot-jpa-docker-webapp_1  |  at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1837) ~[spring-beans-5.1.6.RELEASE.jar!/:5.1.6.RELEASE] spring-boot-jpa-docker-webapp_1  |  at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1774) ~[spring-beans-5.1.6.RELEASE.jar!/:5.1.6.RELEASE] spring-boot-jpa-docker-webapp_1  |  ... 26 common frames omitted spring-boot-jpa-docker-webapp_1  | Caused by: java.sql.SQLException: Access denied for user 'root'@'172.19.0.3' (using password: NO) spring-boot-jpa-docker-webapp_1  |  at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:129) ~[mysql-connector-java-8.0.15.jar!/:8.0.15] spring-boot-jpa-docker-webapp_1  |  at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:97) ~[mysql-connector-java-8.0.15.jar!/:8.0.15] spring-boot-jpa-docker-webapp_1  |  at com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException(SQLExceptionsMapping.java:122) ~[mysql-connector-java-8.0.15.jar!/:8.0.15] spring-boot-jpa-docker-webapp_1  |  at com.mysql.cj.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:835) ~[mysql-connector-java-8.0.15.jar!/:8.0.15] spring-boot-jpa-docker-webapp_1  |  at com.mysql.cj.jdbc.ConnectionImpl.&lt;init&gt;(ConnectionImpl.java:455) ~[mysql-connector-java-8.0.15.jar!/:8.0.15] spring-boot-jpa-docker-webapp_1  |  at com.mysql.cj.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:240) ~[mysql-connector-java-8.0.15.jar!/:8.0.15] spring-boot-jpa-docker-webapp_1  |  at com.mysql.cj.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:199) ~[mysql-connector-java-8.0.15.jar!/:8.0.15] spring-boot-jpa-docker-webapp_1  |  at com.zaxxer.hikari.util.DriverDataSource.getConnection(DriverDataSource.java:136) ~[HikariCP-3.2.0.jar!/:na] spring-boot-jpa-docker-webapp_1  |  at com.zaxxer.hikari.pool.PoolBase.newConnection(PoolBase.java:369) ~[HikariCP-3.2.0.jar!/:na] spring-boot-jpa-docker-webapp_1  |  at com.zaxxer.hikari.pool.PoolBase.newPoolEntry(PoolBase.java:198) ~[HikariCP-3.2.0.jar!/:na] spring-boot-jpa-docker-webapp_1  |  at com.zaxxer.hikari.pool.HikariPool.createPoolEntry(HikariPool.java:467) ~[HikariCP-3.2.0.jar!/:na] spring-boot-jpa-docker-webapp_1  |  at com.zaxxer.hikari.pool.HikariPool.checkFailFast(HikariPool.java:541) ~[HikariCP-3.2.0.jar!/:na] spring-boot-jpa-docker-webapp_1  |  at com.zaxxer.hikari.pool.HikariPool.&lt;init&gt;(HikariPool.java:115) ~[HikariCP-3.2.0.jar!/:na] spring-boot-jpa-docker-webapp_1  |  at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:112) ~[HikariCP-3.2.0.jar!/:na] spring-boot-jpa-docker-webapp_1  |  at org.flywaydb.core.internal.jdbc.JdbcUtils.openConnection(JdbcUtils.java:56) ~[flyway-core-5.2.4.jar!/:na] spring-boot-jpa-docker-webapp_1  |  ... 32 common frames omitted </code></pre>  <p>MySQL-log</p>  <pre><code>docker-mysql                     | 2019-05-10T08:39:28.600028Z 0 [Warning] [MY-011070] [Server] 'Disabling symbolic links using --skip-symbolic-links (or equivalent) is the default. Consider not using this option as it' is deprecated and will be removed in a future release. docker-mysql                     | 2019-05-10T08:39:28.600195Z 0 [System] [MY-010116] [Server] /usr/sbin/mysqld (mysqld 8.0.16) starting as process 1 docker-mysql                     | 2019-05-10T08:39:29.618709Z 0 [System] [MY-010229] [Server] Starting crash recovery... docker-mysql                     | 2019-05-10T08:39:29.630817Z 0 [System] [MY-010232] [Server] Crash recovery finished. docker-mysql                     | 2019-05-10T08:39:29.717531Z 0 [Warning] [MY-010068] [Server] CA certificate ca.pem is self signed. docker-mysql                     | 2019-05-10T08:39:29.720926Z 0 [Warning] [MY-011810] [Server] Insecure configuration for --pid-file: Location '/var/run/mysqld' in the path is accessible to all OS users. Consider choosing a different directory. docker-mysql                     | 2019-05-10T08:39:29.777044Z 6 [ERROR] [MY-000061] [Server] 1105  Bootstrap file error, return code (1). Nearest query: ''. docker-mysql                     | 2019-05-10T08:39:29.777578Z 0 [System] [MY-010931] [Server] /usr/sbin/mysqld: ready for connections. Version: '8.0.16'  socket: '/var/run/mysqld/mysqld.sock'  port: 3306  MySQL Community Server - GPL. docker-mysql                     | 2019-05-10T08:39:29.819539Z 0 [System] [MY-011323] [Server] X Plugin ready for connections. Socket: '/var/run/mysqld/mysqlx.sock' bind-address: '::' port: 33060 </code></pre>  <p>How can I connect to the MySQL-container? Is something wrong in my docker-compose-file? Or do we need to open the 3306-port?</p> ",
    "OwnerUserId": "6742078",
    "LastActivityDate": "2019-05-14T15:24:40.850",
    "Title": "Flyway cannot connect to MySQL from Docker-Container",
    "Tags": "<mysql><spring-boot><docker><docker-compose><flyway>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Since Spring Boot 2.x, the <a href='https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide#flyway' rel='nofollow noreferrer'>flyway configuration keys need to be prefixed</a> with <code>spring.</code>:</p>  <pre><code>spring.flyway.user=thelegend27 spring.flyway.password=1234 </code></pre>  <p>Without that prefix, your settings are ignored and it defaults to the root user and an empty password.</p>  <p>Setting the empty MYSQL_ROOT_PASSWORD environment variable would have worked except for a typo:</p>  <pre><code>- MYSQL_ALLOW_EMPTY_PASSWOR=yes </code></pre>  <p>should be:</p>  <pre><code>- MYSQL_ALLOW_EMPTY_PASSWORD=yes </code></pre> "
  },
  {
    "Id": "56369595",
    "PostTypeId": "1",
    "CreationDate": "2019-05-29T23:03:20.783",
    "Score": "4",
    "ViewCount": "1342",
    "Body": "<p>I'm working on a Spring Boot App that makes a bulk insert from Oracle database to an Elasticsearch cluster hosted on a CentOS 7 server. When I use some HTTP client like Insomnia or Postman then cluster responses with status 200 OK, even CURL does not have problems to make a correct PUT request to server. Spring Boot app just can't establish the connection.</p>  <p>When I up the docker-compose on the same develop PC where Spring Boot App is running bulk inserts are OK, but just not on CentOS server.</p>  <p>I'm sure that SELinux and firewalld services was stopped in CentOS server. Ping to the server, external HTTP client request, CURL request, all of them return a correct response.</p>  <p>docker-compose.yml</p>  <pre><code>version: '2.2' services:   es01:     image: docker.elastic.co/elasticsearch/elasticsearch:7.1.0     container_name: es01     environment:       - node.name=es01       - discovery.seed_hosts=es02,es03,es04,es05       - cluster.initial_master_nodes=es01,es02,es03,es04,es05       - cluster.name=docker-cluster       - bootstrap.memory_lock=true       - 'ES_JAVA_OPTS=-Xms1024m -Xmx1024m'       - http.host=0.0.0.0       - transport.host=0.0.0.0       - xpack.security.enabled=false       - 'http.cors.enabled=false'     ulimits:       memlock:         soft: -1         hard: -1     volumes:       - esdata01:/usr/share/elasticsearch/data     ports:       - 9200:9200       - 9300:9300     networks:       - esnet   es02:     image: docker.elastic.co/elasticsearch/elasticsearch:7.1.0     container_name: es02     environment:       - node.name=es02       - discovery.seed_hosts=es01,es03,es04,es05       - cluster.initial_master_nodes=es01,es02,es03,es04,es05       - cluster.name=docker-cluster       - bootstrap.memory_lock=true       - 'ES_JAVA_OPTS=-Xms1024m -Xmx1024m'       - http.host=0.0.0.0       - transport.host=0.0.0.0       - xpack.security.enabled=false       - 'http.cors.enabled=false'     ulimits:       memlock:         soft: -1         hard: -1     volumes:       - esdata02:/usr/share/elasticsearch/data     networks:       - esnet   es03:     image: docker.elastic.co/elasticsearch/elasticsearch:7.1.0     container_name: es03     environment:       - node.name=es03       - discovery.seed_hosts=es01,es02,es04,es05       - cluster.initial_master_nodes=es01,es02,es03,es04,es05       - cluster.name=docker-cluster       - bootstrap.memory_lock=true       - 'ES_JAVA_OPTS=-Xms1024m -Xmx1024m'       - http.host=0.0.0.0       - transport.host=0.0.0.0       - xpack.security.enabled=false       - 'http.cors.enabled=false'     ulimits:       memlock:         soft: -1         hard: -1     volumes:       - esdata03:/usr/share/elasticsearch/data     networks:       - esnet   es04:     image: docker.elastic.co/elasticsearch/elasticsearch:7.1.0     container_name: es04     environment:       - node.name=es04       - discovery.seed_hosts=es01,es02,es03,es05       - cluster.initial_master_nodes=es01,es02,es03,es04,es05       - cluster.name=docker-cluster       - bootstrap.memory_lock=true       - 'ES_JAVA_OPTS=-Xms1024m -Xmx1024m'       - http.host=0.0.0.0       - transport.host=0.0.0.0       - xpack.security.enabled=false       - 'http.cors.enabled=false'     ulimits:       memlock:         soft: -1         hard: -1     volumes:       - esdata04:/usr/share/elasticsearch/data     networks:       - esnet   es05:     image: docker.elastic.co/elasticsearch/elasticsearch:7.1.0     container_name: es05     environment:       - node.name=es05       - discovery.seed_hosts=es01,es02,es03,es04       - cluster.initial_master_nodes=es01,es02,es03,es04,es05       - cluster.name=docker-cluster       - bootstrap.memory_lock=true       - 'ES_JAVA_OPTS=-Xms1024m -Xmx1024m'       - http.host=0.0.0.0       - transport.host=0.0.0.0       - xpack.security.enabled=false       - 'http.cors.enabled=false'     ulimits:       memlock:         soft: -1         hard: -1     volumes:       - esdata05:/usr/share/elasticsearch/data     networks:       - esnet  volumes:   esdata01:     driver: local   esdata02:     driver: local   esdata03:     driver: local   esdata04:     driver: local   esdata05:     driver: local  networks:   esnet:  </code></pre>  <p>Elasticsearch config</p>  <pre class='lang-java prettyprint-override'><code>package artifact.busquedas.config;  import org.apache.http.HttpHost; import org.elasticsearch.client.RestClient; import org.elasticsearch.client.RestHighLevelClient; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Value; import org.springframework.beans.factory.config.AbstractFactoryBean; import org.springframework.context.annotation.Configuration;  @Configuration public class ElasticsearchConfig extends AbstractFactoryBean {      private static final Logger LOG = LoggerFactory.getLogger(ElasticsearchConfig.class);      @Value('${elasticsearch.host}')     private String host;     @Value('${elasticsearch.port}')     private int port;     @Value('${elasticsearch.cluster-name}')     private String clusterName;     private RestHighLevelClient restHighLevelClient;        @Override     public void destroy() {         try {             if (restHighLevelClient != null) {                 restHighLevelClient.close();             }         } catch (final Exception e) {             LOG.error('Error closing ElasticSearch client: ', e);         }     }      @Override     public Class&lt;RestHighLevelClient&gt; getObjectType() {         return RestHighLevelClient.class;     }      @Override     public boolean isSingleton() {         return false;     }      @Override     public RestHighLevelClient createInstance() {         return buildClient();     }      private RestHighLevelClient buildClient() {         try {             restHighLevelClient = new RestHighLevelClient(                     RestClient.builder(                             new HttpHost(host, port, 'http')));         } catch (Exception e) {             LOG.error(e.getMessage());         }         return restHighLevelClient;     }  } </code></pre>  <p>Elasticsearch params on application.properties file</p>  <pre><code>#Elasticsearch config     elasticsearch.repositories.enabled=true     elasticsearch.host=10.10.20.XX     elasticsearch.port=9200     elasticsearch.cluster-name=docker-cluster </code></pre>  <p>Elasticsearch repository that makes the bulk insert</p>  <pre class='lang-java prettyprint-override'><code>public void bulkInsert(List&lt;NacimientoElastic&gt; nacimientos) {       try {         BulkRequest bulkRequest = new BulkRequest();         for (int i = 0; i &lt; nacimientos.size(); i++) {               Map data = objectMapper.convertValue(nacimientos.get(i), Map.class);               IndexRequest indexRequest = new IndexRequest(INDEX,TYPE,nacimientos.get(i).getId()).source(data);               bulkRequest.add(indexRequest);             }           restHighLevelClient.bulk(bulkRequest, RequestOptions.DEFAULT).getTook());           }            } catch (IOException e) {               e.printStackTrace();           } }  </code></pre>  <p>The Spring Boot App returns the following message:</p>  <pre><code> 'java.net.ConnectException: Conexi\u00f3n rehusada     at org.elasticsearch.client.RestClient.extractAndWrapCause(RestClient.java:804)     at org.elasticsearch.client.RestClient.performRequest(RestClient.java:225)     at org.elasticsearch.client.RestClient.performRequest(RestClient.java:212)     at org.elasticsearch.client.RestHighLevelClient.internalPerformRequest(RestHighLevelClient.java:1433)     at org.elasticsearch.client.RestHighLevelClient.performRequest(RestHighLevelClient.java:1403)     at org.elasticsearch.client.RestHighLevelClient.performRequestAndParseEntity(RestHighLevelClient.java:1373)     at org.elasticsearch.client.RestHighLevelClient.bulk(RestHighLevelClient.java:477)     at artifact.repositorio.RegistroRepositorioElastic.bulkInsert(RegistroRepositorioElastic.java:67)     at artifact.repositorio.RegistroRepositorioElastic$$FastClassBySpringCGLIB$$9c045f6e.invoke(&lt;generated&gt;)     at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)     at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:749)     at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)     at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:139)     at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)     at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688)     at artifact.repositorio.RegistroRepositorioElastic$$EnhancerBySpringCGLIB$$abc7eab.bulkInsert(&lt;generated&gt;)     at artifact.busquedas.serviciosImp.NacimientosImplementacion.replicarOracleAElastic(NacimientosImplementacion.java:50)     at artifact.busquedas.controladores.BusquedaControlador.replicarRegistroCivil(BusquedaControlador.java:33)     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke(Method.java:498)     at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)     at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)     at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:104)     at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:892)     at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)     at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)     at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1039)     at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942)     at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005)     at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:897)     at javax.servlet.http.HttpServlet.service(HttpServlet.java:634)     at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:882)     at javax.servlet.http.HttpServlet.service(HttpServlet.java:741)     at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)     at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)     at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)     at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)     at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)     at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99)     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)     at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)     at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)     at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:92)     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)     at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)     at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)     at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93)     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)     at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)     at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)     at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200)     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)     at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)     at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)     at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:200)     at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)     at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490)     at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139)     at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)     at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)     at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)     at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408)     at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)     at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:836)     at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1747)     at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)     at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)     at java.lang.Thread.run(Thread.java:748) Caused by: java.net.ConnectException: Conexi\u00f3n rehusada     at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method)     at sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:717)     at org.apache.http.impl.nio.reactor.DefaultConnectingIOReactor.processEvent(DefaultConnectingIOReactor.java:171)     at org.apache.http.impl.nio.reactor.DefaultConnectingIOReactor.processEvents(DefaultConnectingIOReactor.java:145)     at org.apache.http.impl.nio.reactor.AbstractMultiworkerIOReactor.execute(AbstractMultiworkerIOReactor.java:351)     at org.apache.http.impl.nio.conn.PoolingNHttpClientConnectionManager.execute(PoolingNHttpClientConnectionManager.java:221)     at org.apache.http.impl.nio.client.CloseableHttpAsyncClientBase$1.run(CloseableHttpAsyncClientBase.java:64)     ... 1 more ' </code></pre>  <p>Not sure if there are some CORS config in Elasticsearch cluster or something like that, but I'm guess it is disabled on the docker-compose.yml for all nodes.</p> ",
    "OwnerUserId": "6090923",
    "LastEditorUserId": "6090923",
    "LastEditDate": "2019-05-30T22:25:05.907",
    "LastActivityDate": "2019-05-30T22:25:05.907",
    "Title": "Connection refused with Java restHighLevelClient",
    "Tags": "<spring-boot><elasticsearch><docker-compose><centos>",
    "AnswerCount": "0",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": null
  },
  {
    "Id": "60767510",
    "PostTypeId": "1",
    "AcceptedAnswerId": "60856055",
    "CreationDate": "2020-03-20T01:51:07.053",
    "Score": "4",
    "ViewCount": "7202",
    "Body": "<p>I'm setting an environment variable inside my docker-compose.yaml file and want to use that variable's value inside my Spring Boot's application.yaml. I was told that doing something like </p>  <pre><code>app:   auth:     tokenSecret: tokensecretvaluehere     tokenExpirationMsec: 864000000   oauth2:     sso:       url: ${SSO_URL} </code></pre>  <p>(where SSO_URL is defined in my docker-compose.yaml) in my Spring application.yaml. However, this causes an error when I run docker-compose up --build because it can't find that variable (error is like: Could not resolve placeholder SSO_URL in value '${SSO_URL}'). This is an example of what my docker-compose.yaml:</p>  <pre><code>api:     restart: always     ports:       - '8080:8080'     links:       - redis       - db     environment:       - SERVER_SERVLET_SESSION_COOKIE_DOMAIN=localhost       - SSO_URL=myvaluehere </code></pre>  <p>I was asked to not uses the System.getenv functions in Java and instead set the variable like above. From there I would just use the @Value annotation to get it in my Java code as like below:</p>  <pre><code>@Value('${app.oauth2.sso.url}') private String ssoUrl; </code></pre>  <p>This is more of the application.yaml:</p>  <pre><code>heb:   togglr:     jwt:       secret:         id: 101       session:         seconds: 600       tokenheader: X-TOGGLR-TOKEN logging:   level:     com:       heb: debug     default: debug   path: logs server:   error:     whitelabel:       enabled: false   port: 8080   servlet:     context-path: /togglr-api   use-forward-headers: true spring:   application:     name: togglr_api   freemarker:     enabled: false   groovy:     template:       enabled: false   jmx:     enabled: false   main:     banner-mode: 'off'   thymeleaf:     cache: false   security:     oauth2:       client:         registration:           github:             clientId:             clientSecret:             redirectUri:              scope:               - user:email               - read:user app:   auth:     tokenSecret:     tokenExpirationMsec: 864000000   oauth2:     sso:       url: ${SSO_URL} </code></pre> ",
    "OwnerUserId": "7858114",
    "LastEditorUserId": "7858114",
    "LastEditDate": "2020-03-20T15:36:09.637",
    "LastActivityDate": "2022-02-22T10:54:04.660",
    "Title": "Read docker env variable inside Spring application.yaml",
    "Tags": "<spring-boot><docker><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>Solution was to not use an underscore character in the variable name. </p> ",
    "highest_rated_answer": "<p>In general spring boot applications are able to read the Environment variables accessible in the docker container. Its stated in the <a href='https://docs.spring.io/spring-boot/docs/2.1.8.RELEASE/reference/html/boot-features-external-config.html' rel='nofollow noreferrer'>documentation</a> (see item 10 in the list at the very beginning of the document).</p>  <p>So the problem might be elsewhere:</p>  <ol> <li>It might be a typo in the question, but if you're using application.yaml as opposed to application properties, then you should have something like:</li> </ol>  <pre><code>  sso:     url: ${SSO_URL} </code></pre>  <ol start='2'> <li>Make sure, that the env variable SSO_URL is indeed accessible in the container even before you start the spring boot application. In java (for debugging purposes only) you can do something like:</li> </ol>  <pre><code>@SpringBootApplication public class MyApp {    public static void main(String [] args) {           System.out.println(System.getenv('SSO_URL'));           SpringApplication.run(MyApp.class);    } } </code></pre> "
  },
  {
    "Id": "62238113",
    "PostTypeId": "1",
    "CreationDate": "2020-06-06T21:15:10.920",
    "Score": "4",
    "ViewCount": "3378",
    "Body": "<p>I'm new to docker-compose, wanted to run a container with Postgres db in it. For this I've created a docker-compose.yml with the following content:</p>  <pre><code>services:   postgresql:     image: postgres     container_name: postgres_db     ports:       - '5433:5433'     environment:       - POSTGRES_PASSWORD=admin       - POSTGRES_USER=postgres       - POSTGRES_DB=testdb </code></pre>  <p>So far I didn't pack my Spring Boot app in a container as well, as I'd like to do it step by step and for now run only the database in container. </p>  <p>I start it with  <code>docker-compose -f docker-compose.yml up</code>, then I run my app in Intellij and see that in logs:</p>  <p>org.postgresql.util.PSQLException: The connection attempt failed. Caused by: java.io.EOFException: null</p>  <p>Via  <code>docker-exec</code> I was able to connect to my testdb. However, in Intellij I can't do the same via Database tool, I keep getting authentication error (username/password are wrong).</p>  <p>I'm struggling with these new concepts. What am I missing here?</p> ",
    "OwnerUserId": "6335101",
    "LastActivityDate": "2020-06-06T21:15:10.920",
    "Title": "java.io.EOFException: null while running Postgres via docker-compose",
    "Tags": "<postgresql><spring-boot><docker><intellij-idea><docker-compose>",
    "AnswerCount": "0",
    "CommentCount": "2",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": null
  },
  {
    "Id": "62800536",
    "PostTypeId": "1",
    "CreationDate": "2020-07-08T17:39:18.990",
    "Score": "4",
    "ViewCount": "4613",
    "Body": "<p>I am trying to shift my spring-boot microservices to dockers. My microservices are running absolutely fine when implemented on STS on the local system. But when I dockerize them I get a connection timeout error.</p> <p>I am sharing my code snippets below:</p> <p><strong>Docker-compose:</strong></p> <pre><code>version: '3.6' services:   db:     image: 'mysql:8.0.18'     container_name: mysqldb     ports:       - '3300:3300'     environment:       - MYSQL_ROOT_PASSWORD=root       - MYSQL_USER=root     networks:       - truyum-nw       - movie-cruiser-nw     volumes:       - './mysqldb:/var/lib/mysql'       - './dbscripts:/docker-entrypoint-initdb.d'   config-server:     image: spring-cloud-config-server     build: ./spring-cloud-config-server     container_name: spring-cloud-config-server     ports:       - '8888:8888'     networks:       - truyum-nw       - movie-cruiser-nw   eureka:     image: eureka-discovery-service     build: ./eureka-discovery-service     container_name: eureka-discovery     ports:       - '8761:8761'     depends_on:       - config-server       - db     networks:       - truyum-nw       - movie-cruiser-nw   zuul:     image: zuul-service     build: ./zuul-gateway     container_name: zuul-bridge     ports:       - '8762:8762'     depends_on:       - eureka       - config-server     networks:       - truyum-nw       - movie-cruiser-nw   auth-service:     image: auth-service     build: ./Authentication-service     container_name: auth-service     ports:       - '9100:9100'     depends_on:       - eureka       - config-server     networks:       - truyum-nw       - movie-cruiser-nw   menu-item-service:     image: menu-item-service     build: ./menuitem-service     container_name: menu-item-service     ports:       - '34000:34000'     depends_on:       - eureka       - config-server       - zuul       - db       - auth-service     networks:       - truyum-nw   cart-service:     image: cart-service     build: ./cart-service     container_name: cart-service     ports:       - '34001:34001'     depends_on:       - eureka       - config-server       - zuul       - db       - menu-item-service       - auth-service     networks:       - truyum-nw   movie-service:     image: movie-service     build: ./movie-service     container_name: movie-service     ports:       - '35000:35000'     depends_on:       - eureka       - config-server       - db       - zuul       - auth-service     networks:       - movie-cruiser-nw   favourite-service:     image: favourite-service     build: ./favorite-service     container_name: favourite-service     ports:       - '35001:35001'     depends_on:       - eureka       - config-server       - db       - zuul       - auth-service       - movie-service     networks:       - movie-cruiser-nw networks:   truyum-nw:     name: truyum-nw     driver: bridge   movie-cruiser-nw:     name: movie-cruiser-nw     driver: bridge </code></pre> <p><strong>application.properties</strong> of <strong>spring-cloud-config-server</strong>:</p> <pre><code>spring.cloud.config.server.git.uri = https://github.com/satyamthedeveloper/Stage4_Week2_841418_SatyamKumar server.port=8888 </code></pre> <p><strong>application.properties</strong> of <strong>Eureka-Discovery-Server</strong>:</p> <pre><code>spring.application.name=discoveryservice spring.cloud.config.uri = http://spring-cloud-config-server:8888    </code></pre> <p>When I do <code>docker-compose up</code> and I check <code>http://localhost:8888/discoveryservice/default</code> I get the result as</p> <pre><code>{     &quot;name&quot;: &quot;discoveryservice&quot;,     &quot;profiles&quot;: [         &quot;default&quot;     ],     &quot;label&quot;: null,     &quot;version&quot;: &quot;8450532e432fb103ef30d0002fa254b23d2158d6&quot;,     &quot;state&quot;: null,     &quot;propertySources&quot;: [         {             &quot;name&quot;: &quot;https://github.com/satyamthedeveloper/Stage4_Week2_841418_SatyamKumar/discoveryservice.properties&quot;,             &quot;source&quot;: {                 &quot;server.port&quot;: &quot;8761&quot;,                 &quot;eureka.client.register-with-eureka&quot;: &quot;false&quot;,                 &quot;eureka.client.fetch-registry&quot;: &quot;false&quot;,                 &quot;info.app.name&quot;: &quot;Spring Eureka Server Application&quot;             }         },         {             &quot;name&quot;: &quot;https://github.com/satyamthedeveloper/Stage4_Week2_841418_SatyamKumar/application.yml&quot;,             &quot;source&quot;: {                 &quot;eureka.client.service-url.defaultZone&quot;: &quot;http://eureka-discovery:8761/eureka&quot;,                 &quot;logging.level.org.springframework.web&quot;: &quot;DEBUG&quot;,                 &quot;management.endpoints.web.exposure.include&quot;: &quot;*&quot;             }         }     ] } </code></pre> <p>But still, my <code>Eureka discovery service</code> starts on 8080 which is not accessible as I have not exposed it. I have tried a few of these steps which didn't help.</p> <ol> <li>tried stopping and restarting discovery service when my cloud-config is up and ready.</li> <li>tried it separately without docker-compose by creating network still it not worked.</li> </ol> <p>I am not sure why my services are not able to fetch the link which I can easily fetch using URL.</p> <p><a href='https://i.stack.imgur.com/lFKoh.png' rel='nofollow noreferrer'><img src='https://i.stack.imgur.com/lFKoh.png' alt='This is a screenshot of my log which I get every time, no matter whatever I try.' /></a></p> ",
    "OwnerUserId": "9437271",
    "LastEditorUserId": "9437271",
    "LastEditDate": "2020-07-09T02:40:01.600",
    "LastActivityDate": "2021-10-15T06:30:22.507",
    "Title": "Spring Cloud Config Server gives Connect Timeout Exception on Url -http://localhost:8888 When deployed on Dockers",
    "Tags": "<spring-boot><docker><docker-compose><microservices><spring-cloud-config-server>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>The name that you must refer in your eureka configuration for config server is only <code>config-server</code> since this is the service name in your compose yaml.</p> "
  },
  {
    "Id": "64822632",
    "PostTypeId": "1",
    "AcceptedAnswerId": "64918554",
    "CreationDate": "2020-11-13T14:25:13.373",
    "Score": "4",
    "ViewCount": "11198",
    "Body": "<p>I have two containers backend (spring boot application) and Keycloak. if I run keycloak in a container and backend locally : it works</p> <p>If both of them are run in container the backend doesn't start and shows the following error :</p> <pre><code>Failed to instantiate [org.springframework.security.oauth2.jwt.JwtDecoder]: Factory method 'jwtDecoderByIssuerUri' threw exception; nested exception is java.lang.IllegalArgumentException: Unable to resolve the Configuration with the provided Issuer of &quot;http://keycloak:8082/auth/realms/myrealm&quot;  Caused by: org.springframework.web.client.ResourceAccessException: I/O error on GET request for &quot;http://keycloak:8082/auth/realms/myrealm/.well-known/openid-configuration&quot;: Connection refused (Connection refused);  </code></pre> <p>following are my configs :</p> <p>docker-compose :</p> <pre><code>services:    keycloak:     image: jboss/keycloak:8.0.1     command:       - &quot; -b 0.0.0.0&quot;     container_name: &quot;keycloak&quot;     networks:       - myproject     volumes:       - &quot;./keycloak/realm-export.json:/opt/jboss/keycloak/bin/keycloak_export_dir/realm-export.json&quot;     environment:       KEYCLOAK_USER: admin       KEYCLOAK_PASSWORD: admin       KEYCLOAK_IMPORT: /opt/jboss/keycloak/bin/keycloak_export_dir/realm-export.json     ports:       - &quot;8082:8080&quot;    backend:     build:       context: ./backend       dockerfile: Dockerfile     container_name: &quot;backend&quot;     environment:       - spring.oauth2.resourceserver.jwt.issuer-uri= http://keycloak:8082/auth/realms/myrealm     links:       - keycloak     networks:       - myproject     restart: on-failure     ports:       - &quot;8080:8080&quot;  networks:   myproject:     driver: bridge </code></pre> <p>application.yml:</p> <pre><code>  application:     name: backend   security:     oauth2:       resourceserver:         jwt:           issuer-uri: http://localhost:8082/auth/realms/myrealm </code></pre> <p>do you have any Idea why do I get connection refused ? any help is appreciated :)</p> ",
    "OwnerUserId": "1636319",
    "LastActivityDate": "2020-11-19T19:18:15.353",
    "Title": "Connection refused when connecting to keycloak container from backend container",
    "Tags": "<spring-boot><docker><spring-security><docker-compose><keycloak>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>Your Keycloak container using the following port configuration</p> <pre><code>ports:   - &quot;8082:8080&quot; </code></pre> <p>That mean:</p> <p>Keycloak is reachable from Outside via Port <code>8082</code>.</p> <p>But internally (in this docker network), keycloak is only reachable via the exposed <code>8080</code> port. So your backend application need to connect (internally) to <code>http://keycloak:8080</code></p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "65182243",
    "PostTypeId": "1",
    "CreationDate": "2020-12-07T13:03:43.733",
    "Score": "4",
    "ViewCount": "4354",
    "Body": "<p>I have this docker-compose.yml in which I run <strong>Zookeeper</strong>, <strong>Kafka</strong>, <strong>Kafka Connect</strong>, and <strong>KafDrop</strong>, the thing is, when I run locally I can connect from my <strong>Spring Boot</strong> application to consume some topic messages.</p> <p>What I need is to run the same configuration on a Linux machine and be able to connect from the Spring Boot application the same way.</p> <p>When run it remotely on the Linux machine everything seems to be running Ok, but when I try to connect from the Spring Boot application I receive some erros showing that somethin is wrong in the connection.</p> <p>I will try to explain step by step and see if someone can give a &quot;light&quot; on that:</p> <p>docker-compose.yml:</p> <pre><code>version: '3'  services:    zookeeper:     image: confluentinc/cp-zookeeper:latest     networks:        - broker-kafka     ports:       - 2181:2181     environment:       ZOOKEEPER_CLIENT_PORT: 2181       ZOOKEEPER_TICK_TIME: 2000    kafka:     image: confluentinc/cp-kafka:latest     networks:        - broker-kafka     restart: unless-stopped     depends_on:       - zookeeper     ports:       - 9092:9092     environment:       KAFKA_BROKER_ID: 1       KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181       KAFKA_LISTENERS:           INTERNAL://kafka:29092,          EXTERNAL://localhost:9092       KAFKA_ADVERTISED_LISTENERS:           INTERNAL://kafka:29092,          EXTERNAL://localhost:9092       KAFKA_LISTENER_SECURITY_PROTOCOL_MAP:           INTERNAL:PLAINTEXT,          EXTERNAL:PLAINTEXT       KAFKA_INTER_BROKER_LISTENER_NAME: INTERNAL       KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1       KAFKA_LOG_RETENTION_HOURS: 12        connect:     image: cdc:latest     networks:        - broker-kafka     depends_on:       - zookeeper       - kafka     ports:       - 8083:8083     environment:       CONNECT_BOOTSTRAP_SERVERS: kafka:29092       CONNECT_REST_PORT: 8083       CONNECT_GROUP_ID: connect-1       CONNECT_CONFIG_STORAGE_TOPIC: connect-1-config       CONNECT_OFFSET_STORAGE_TOPIC: connect-1-offsets       CONNECT_STATUS_STORAGE_TOPIC: connect-1-status       CONNECT_KEY_CONVERTER: org.apache.kafka.connect.json.JsonConverter       CONNECT_VALUE_CONVERTER: org.apache.kafka.connect.json.JsonConverter       CONNECT_OFFSET.STORAGE.REPLICATION.FACTOR: 1       CONNECT_CONFIG.STORAGE.REPLICATION.FACTOR: 1       CONNECT_OFFSET.STORAGE.PARTITIONS: 1       CONNECT_STATUS.STORAGE.REPLICATION.FACTOR: 1       CONNECT_STATUS.STORAGE.PARTITIONS: 1       CONNECT_REST_ADVERTISED_HOST_NAME: localhost          kafdrop:     image: obsidiandynamics/kafdrop:latest     networks:        - broker-kafka     depends_on:       - kafka     ports:       - 19000:9000     environment:       KAFKA_BROKERCONNECT: kafka:29092        networks:    broker-kafka:     driver: bridge </code></pre> <p>What I need is to expose to my network this IP machine to be accessed by my Spring Boot application. Let\u00b4s suppose this Linux machine has the IP 10.12.54.99. How can I make it Kafka be accessible by: 10.12.54.99:9090 ?</p> <p>Here is my application.properties:</p> <pre><code>spring.kafka.bootstrap-servers=10.12.54.99:9092  spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer  spring.kafka.consumer.enable-auto-commit=false spring.kafka.consumer.auto-commit-interval=100 spring.kafka.consumer.max-poll-records=10 spring.kafka.consumer.key-deserializer=org.springframework.kafka.support.serializer.ErrorHandlingDeserializer spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.ErrorHandlingDeserializer spring.kafka.consumer.group-id=connect-sql-server spring.kafka.consumer.auto-offset-reset=earliest  spring.kafka.listener.ack-mode=manual-immediate spring.kafka.listener.poll-timeout=3000 spring.kafka.listener.concurrency=3  spring.kafka.properties.spring.deserializer.key.delegate.class=org.apache.kafka.common.serialization.StringDeserializer spring.kafka.properties.spring.deserializer.value.delegate.class=org.apache.kafka.common.serialization.StringDeserializer </code></pre> <p>This is a only consumer-specif application (no producers are used here).</p> <p>When I run the application:</p> <pre><code>2020-12-07 10:59:40.361  WARN 58716 --- [ntainer#0-0-C-1] org.apache.kafka.clients.NetworkClient   : [Consumer clientId=consumer-connect-sql-server-1, groupId=connect-sql-server] Connection to node -1 (/10.12.54.99:9092) could not be established. Broker may not be available. 2020-12-07 10:59:40.362  WARN 58716 --- [ntainer#0-0-C-1] org.apache.kafka.clients.NetworkClient   : [Consumer clientId=consumer-connect-sql-server-1, groupId=connect-sql-server] Bootstrap broker 10.12.54.99:9092 (id: -1 rack: null) disconnected </code></pre> <p>All the firewall ports are enabled in the Linux firewall machie.</p> <p>Any enlightenment would be very much appreciated.</p> ",
    "OwnerUserId": "2011091",
    "LastEditorUserId": "2308683",
    "LastEditDate": "2020-12-07T22:34:06.353",
    "LastActivityDate": "2021-02-18T13:08:08.853",
    "Title": "Access Kafka in Remote Host by IP Address running with Docker-Compose and Spring Boot",
    "Tags": "<spring-boot><apache-kafka><docker-compose><spring-kafka>",
    "AnswerCount": "1",
    "CommentCount": "6",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>You need to bind your server's public ip in order to be able to access brokers remotely. However if you don't want to hardcode the ip, you can use .env file.</p> <p>Do the following:</p> <ol> <li><p>Create config.env file.</p> </li> <li><p>Add this line in config.env and add your host ip as below:</p> <p>DOCKER_HOST_IP=111.111.11.111</p> </li> <li><p>Update your docker-compose:</p> </li> </ol> <p><div class='snippet' data-lang='js' data-hide='false' data-console='true' data-babel='false'>  <div class='snippet-code'>  <pre class='snippet-code-html lang-html prettyprint-override'><code>version: '3'  services:    zookeeper:     image: confluentinc/cp-zookeeper:latest     networks:        - broker-kafka     ports:       - ${DOCKER_HOST_IP:-127.0.0.1}:2181:2181     environment:       ZOOKEEPER_CLIENT_PORT: 2181       ZOOKEEPER_TICK_TIME: 2000    kafka:     image: confluentinc/cp-kafka:latest     networks:        - broker-kafka     restart: unless-stopped     depends_on:       - zookeeper     ports:       - ${DOCKER_HOST_IP:-127.0.0.1}:9092:9092     environment:       KAFKA_BROKER_ID: 1       KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181       KAFKA_LISTENERS:           INTERNAL://kafka:29092,          EXTERNAL://localhost:9092       KAFKA_ADVERTISED_LISTENERS:           INTERNAL://kafka:29092,          EXTERNAL://${DOCKER_HOST_IP:-127.0.0.1}:9092:9092       KAFKA_LISTENER_SECURITY_PROTOCOL_MAP:           INTERNAL:PLAINTEXT,          EXTERNAL:PLAINTEXT       KAFKA_INTER_BROKER_LISTENER_NAME: INTERNAL       KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1       KAFKA_LOG_RETENTION_HOURS: 12        connect:     image: cdc:latest     networks:        - broker-kafka     depends_on:       - zookeeper       - kafka     ports:       - 8083:8083     environment:       CONNECT_BOOTSTRAP_SERVERS: kafka:29092       CONNECT_REST_PORT: 8083       CONNECT_GROUP_ID: connect-1       CONNECT_CONFIG_STORAGE_TOPIC: connect-1-config       CONNECT_OFFSET_STORAGE_TOPIC: connect-1-offsets       CONNECT_STATUS_STORAGE_TOPIC: connect-1-status       CONNECT_KEY_CONVERTER: org.apache.kafka.connect.json.JsonConverter       CONNECT_VALUE_CONVERTER: org.apache.kafka.connect.json.JsonConverter       CONNECT_OFFSET.STORAGE.REPLICATION.FACTOR: 1       CONNECT_CONFIG.STORAGE.REPLICATION.FACTOR: 1       CONNECT_OFFSET.STORAGE.PARTITIONS: 1       CONNECT_STATUS.STORAGE.REPLICATION.FACTOR: 1       CONNECT_STATUS.STORAGE.PARTITIONS: 1       CONNECT_REST_ADVERTISED_HOST_NAME: localhost          kafdrop:     image: obsidiandynamics/kafdrop:latest     networks:        - broker-kafka     depends_on:       - kafka     ports:       - 19000:9000     environment:       KAFKA_BROKERCONNECT: kafka:29092        networks:    broker-kafka:     driver: bridge</code></pre>  </div>  </div>  </p> <p>It will bind to 127.0.0.1, if DOCKER_HOST_IP is not found.</p> <ol start='4'> <li>Run the following command:</li> </ol> <p><div class='snippet' data-lang='js' data-hide='false' data-console='true' data-babel='false'>  <div class='snippet-code'>  <pre class='snippet-code-html lang-html prettyprint-override'><code>sudo docker-compose -f path-to-docker-compose.yml --env-file path-to-config.env up -d --force-recreate</code></pre>  </div>  </div>  </p> "
  },
  {
    "Id": "65544346",
    "PostTypeId": "1",
    "AcceptedAnswerId": "65659496",
    "CreationDate": "2021-01-02T21:36:07.503",
    "Score": "4",
    "ViewCount": "8305",
    "Body": "<p>I ran into this &quot;java.net.UnknownHostException: host.docker.internal: Name or service not known&quot; problem when deploying a dockerized spring boot application on an AWS EC2 T2.micro instance. The spring boot application failed to start because of this error.</p> <p>But the weird part is, I did not use the variable &quot;host.docker.internal&quot; anywhere in my application: not in the code, not in the yaml file, not in the .env file:</p> <pre><code>$ sudo grep -Rl &quot;host.docker.internal&quot; ~ /home/ec2-user/.bash_history </code></pre> <p>And when I run the following command it shows nothing but previous command to search for it:</p> <blockquote> <p>$ cat /home/ec2-user/.bash_history | grep &quot;host.docker.internal&quot;</p> </blockquote> <p>Locally I am using Windows 10 for development, and I can successfully bring up the stack with docker-compose.</p> <p>Here is the EC2 instance OS version info:</p> <pre><code>$ cat /etc/*release NAME=&quot;Amazon Linux&quot; VERSION=&quot;2&quot; ID=&quot;amzn&quot; ID_LIKE=&quot;centos rhel fedora&quot; VERSION_ID=&quot;2&quot; PRETTY_NAME=&quot;Amazon Linux 2&quot; ANSI_COLOR=&quot;0;33&quot; CPE_NAME=&quot;cpe:2.3:o:amazon:amazon_linux:2&quot; HOME_URL=&quot;https://amazonlinux.com/&quot; Amazon Linux release 2 (Karoo) </code></pre> <p>And here is the docker-compose file that I used on the EC2 instance:</p> <pre><code>version: '2' services:   backend:     container_name: backend     image: 'dockerhubuser/backend:0.0.4'     ports:       - '8080:8080'     volumes:       - /var/log/backend/logs:/var/log/backend/logs       - ./backend-ssl:/etc/ssh/backend     env_file:       - .env     depends_on:       - mysql       - redis   redis:     container_name: redis     image: 'redis:alpine'     ports:       - '6379:6379'     volumes:       - $PWD/redis/redis-data:/var/lib/redis       - $PWD/redis/redis.conf:/usr/local/etc/redis/redis.conf   mysql:     container_name: mysql     image: 'mysql:8.0.21'     ports:       - '3306:3306'     environment:       MYSQL_DATABASE: dbname       MYSQL_USER: dbuser       MYSQL_PASSWORD: dbpass       MYSQL_ROOT_PASSWORD: dbrootpass     volumes:       - ./my_volume/mysql:/var/lib/mysql volumes:   my_volume: </code></pre> <p>And here is my .env file on the EC2 instance:</p> <pre><code>SERVER_PORT=8080 KEY_STORE=/etc/ssh/backend/keystore.p12 KEY_STORE_PASSWORD=keystorepass REDIS_HOST=redis REDIS_PORT=6379 DB_HOST=mysql DB_PORT=3306 DB_USERNAME=dbuser DB_PASSWORD=dbpass </code></pre> <p>I am pretty sure that this .env file is being used when bringing up the stack with &quot;docker-compose up&quot; because I can see the SERVER_PORT in the log matches this file when I change it.</p> <blockquote> <p>2021-01-02 20:55:44.870 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat initialized with port(s): <strong>8080</strong> (https)</p> </blockquote> <p>But I keep getting the error complaining about &quot;host.docker.internal&quot;.</p> <p>Here are things that I have tried but not working:</p> <ol> <li>Hard-code the db host in property spring.datasource.url in application.yml</li> <li>Add the following entry to /etc/hosts file (see <a href='https://stackoverflow.com/a/48547074/1852496'>https://stackoverflow.com/a/48547074/1852496</a>)</li> </ol> <blockquote> <p>172.17.0.1    host.docker.internal</p> </blockquote> <ol start='3'> <li>Add the following entry to /etc/hosts file, where &quot;ip-172-31-33-56.us-east-2.compute.internal&quot; is what I got when running command &quot;echo $HOSTNAME&quot;</li> </ol> <blockquote> <p>ip-172-31-33-56.us-east-2.compute.internal    host.docker.internal</p> </blockquote> <ol start='4'> <li>Terminate the instance and created another T2.micro instance, but got same result.</li> <li>Edit inbound rules to allow TCP:3306 from anywhere.</li> </ol> <p>Can someone take a look? Any help appreciated.</p> ",
    "OwnerUserId": "1852496",
    "LastEditorUserId": "1852496",
    "LastEditDate": "2021-01-02T21:57:49.560",
    "LastActivityDate": "2021-01-10T23:11:56.077",
    "Title": "java.net.UnknownHostException: host.docker.internal: Name or service not known on AWS EC2",
    "Tags": "<spring-boot><docker><amazon-ec2><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>It works on Ubuntu 20.04 after adding &quot;172.17.0.1 host.docker.internal&quot; to /etc/hosts file. Make sure the docker engine version is 20.10-beta1 or newer.</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "67011915",
    "PostTypeId": "1",
    "AcceptedAnswerId": "67025843",
    "CreationDate": "2021-04-08T21:08:50.437",
    "Score": "4",
    "ViewCount": "1257",
    "Body": "<h3>What am I wanting to do?</h3> <p>I want to convert to run my <em><strong>containerized of Spring-Boot's app</strong></em> which is can run on amd64 systems, on Raspberry Pi 4's Docker. How can I fix the my problem?</p> <br/>  <h3>What's the running OS on Raspberry Pi?</h3> <p>I've installed <em><strong>Ubuntu Server 20.04.2 LTS for arm64 architectures</strong></em> using via <em><strong>Raspberry Pi Imager v1.6.1</strong></em> on <em><strong>Raspberry Pi 4</strong></em>.</p> <br/> <hr /> <h3>What are the steps I have done to fix the problem?(problem is still continue)</h3> <p>In default version does not work on my <em><strong>Raspberry Pi.</strong></em> Thus, I've tried some couple of things at below.</p> <p>I changed row of &quot;FROM&quot; from <em><strong><a href='https://hub.docker.com/_/openjdk' rel='nofollow noreferrer'>openjdk:15-jdk-slim</a></strong></em> to <em><strong><a href='https://hub.docker.com/r/arm64v8/openjdk/' rel='nofollow noreferrer'>arm64v8/openjdk:17</a></strong></em> at my <em><strong>dockerfile</strong></em> as you can see:</p> <pre><code>FROM arm64v8/openjdk:17 COPY . /projects/red-dir WORKDIR /projects/red-dir ARG JAR_FILE=target/*.jar COPY ${JAR_FILE} /projects/red-dir/my_red_app.jar ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/projects/red-dir/my_red_app.jar&quot;] </code></pre> <p>Afterwards, I've built and pushed my app using with <em><strong>Maven</strong></em> and <em><strong>Docker</strong></em>:</p> <pre><code>$ ./mvnw clean package -Dmaven.test.skip=true &amp;&amp; java -jar target/my_red_app.jar $ docker build -t user/my_red_app:v1.0.0 . </code></pre> <p>Then, My app's depend on a MongoDB, so I changed this <em><strong>image</strong></em> from <em><strong><a href='https://hub.docker.com/_/mongo' rel='nofollow noreferrer'>mongo</a></strong></em> to <em><strong><a href='https://hub.docker.com/r/arm64v8/mongo/' rel='nofollow noreferrer'>arm64v8/mongo</a></strong></em> on <em><strong>docker-compose.yml</strong></em> as you can see at below:</p> <pre><code>version: &quot;3&quot; services:     mongodb:         container_name: mongodb         image: arm64v8/mongo         restart: always         ports:             - 27017:27017         environment:             MONGO_INITDB_ROOT_USERNAME: admin             MONGO_INITDB_ROOT_PASSWORD: 12345         networks:             - shared-net     colour_app:         container_name: my_red_app         image: user/my_red_app         restart: always         ports:             - 7070:7070         depends_on:             - mongodb         networks:             - shared-net networks:     shared-net:         driver: bridge </code></pre> <br/> <hr /> <h3>Things that work and things that don't work</h3> <p><em><strong>MongoDB</strong></em> is running. I can reach using via <em><strong>MongoDBCompass</strong></em>, but my <em><strong>Spring-Boot app</strong></em> doesn't work. In <code>docker-compose up</code> command, I've encountered an output like this:</p> <pre><code>... ... colour_app    | standard_init_linux.go:219: exec user process caused: exec format error colour_app    | standard_init_linux.go:219: exec user process caused: exec format error colour_app    | standard_init_linux.go:219: exec user process caused: exec format error colour_app    | standard_init_linux.go:219: exec user process caused: exec format error </code></pre> <p>Let me know what things I didn't catch. Thank you for reading.</p> ",
    "OwnerUserId": "10876165",
    "LastEditorUserId": "10876165",
    "LastEditDate": "2021-04-09T07:49:21.710",
    "LastActivityDate": "2021-04-09T17:36:47.330",
    "Title": "How to create containerized Spring Boot App on Raspberry Pi 4?",
    "Tags": "<spring-boot><docker><maven><docker-compose><raspberry-pi4>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>I've solved my problem and tried to create simple guide for ones who are encountered this problem.</p> <h3>BUILD FOR OTHER OS (multi-architecture / buildx command)</h3> <ol> <li>Turn On &quot;experimental&quot; feature's on Docker Settings. <ul> <li><em><strong>For Linux OS</strong></em>: <ol> <li><code>sudo nano /etc/docker/daemon.json</code></li> <li>Add below content to it: <pre class='lang-json prettyprint-override'><code>{   &quot;experimental&quot;: true } </code></pre> </li> </ol> </li> <li><em><strong>For Win10 OS / MAC OS</strong></em>: <ol> <li>Open <strong>Docker Desktop</strong> application.</li> <li>Go to Settings.</li> <li>Select <em><strong>Docker Engine</strong></em> Tab on the left-side.</li> <li>Find <code>&quot;experimental&quot;: false</code>.</li> <li>Change it to <code>&quot;experimental&quot;: true</code>.</li> </ol> </li> </ul> </li> <li>Restart Docker.</li> <li>Create multi-architecture os. (<em><strong>Important</strong>: The <strong>image</strong> you are using should contain the <strong>OS</strong> you want to create it</em>) <ul> <li><p>Creating a just <strong>SINGLE OS</strong> :</p> <ol> <li>You can use load or push commands. <ul> <li><code>--load</code> means that docker saves it to local disk: <pre><code>docker buildx build --load --platform linux/arm64 -t &lt;dockerhub_username&gt;/&lt;repository_name&gt;:&lt;tag_name&gt; . </code></pre> </li> <li><code>--push</code> means that docker doesn't save it to local disk but save it to cloud (docker hub): <pre><code>docker buildx build --push --platform linux/arm64 -t &lt;dockerhub_username&gt;/&lt;repository_name&gt;:&lt;tag_name&gt; . </code></pre> </li> <li><code>--load</code> and <code>--push</code> can not be set together.</li> </ul> </li> </ol> </li> <li><p>Creating a <strong>MANY OS</strong> :</p> <ol start='2'> <li><p>You can just use push command with many OS.</p> <ul> <li><p><code>--push</code> means that docker doesn't save it to local disk but save it to cloud (docker hub):</p> <pre><code>docker buildx build --push --platform linux/amd64,linux/arm64,linux/ppc64le -t &lt;dockerhub_username&gt;/&lt;repository_name&gt;:&lt;tag_name&gt; . </code></pre> </li> </ul> </li> </ol> </li> </ul> </li> </ol> ",
    "highest_rated_answer": null
  },
  {
    "Id": "68931264",
    "PostTypeId": "1",
    "CreationDate": "2021-08-26T00:46:47.150",
    "Score": "4",
    "ViewCount": "698",
    "Body": "<p>I was trying to deploy multi containers docker into Elastic Beanstalk. But it doesn't work. I tried running on local by using the docker-compose it is working.</p> <p>Below is my Dockerrun.aws.json and docker-compose.yml</p> <p><strong>docker-compose.yml</strong></p> <pre><code>version: '3'  services:    nginx:       image: nginx:alphine       restart: always       ports:       - 80:80       volumes:       - ./nginx/conf.d:/etc/nginx/conf.d       depends_on:       - sbapi    db:       image: mysql:latest       environment:       - MYSQL_ROOT_PASSWORD=P@ssw0rd       - MYSQL_DATABASE=sbapi       - MYSQL_USER=user       - MYSQL_PASSWORD=password       ports:       - 3306:3306       restart: always       volumes:       - mysql-data:/var/lib/mysql    sbapi:       image: sbapi       build:          context: ./          dockerfile: Dockerfile       ports:       - 8080:8080       restart: always       volumes:       - ./app:/app       depends_on:       - db        volumes:   mysql-data: </code></pre> <p><strong>Dockerrun.aws.json</strong></p> <pre><code> {    &quot;AWSEBDockerrunVersion&quot;:2,    &quot;containerDefinitions&quot;:[       {          &quot;name&quot;:&quot;db&quot;,          &quot;hostname&quot;: &quot;db&quot;,          &quot;image&quot;:&quot;mysql:latest&quot;,          &quot;essential&quot;:true,          &quot;memory&quot;:512,          &quot;environment&quot;: [             {                 &quot;name&quot;: &quot;MYSQL_ROOT_PASSWORD&quot;,                 &quot;value&quot;: &quot;P@ssw0rd&quot;             },             {                 &quot;name&quot;: &quot;MYSQL_DATABASE&quot;,                 &quot;value&quot;: &quot;sbapi&quot;             },             {                 &quot;name&quot;: &quot;MYSQL_USER&quot;,                 &quot;value&quot;: &quot;user&quot;             },             {                 &quot;name&quot;: &quot;MYSQL_PASSWORD&quot;,                 &quot;value&quot;: &quot;password&quot;             }          ],          &quot;portMappings&quot;:[             {                &quot;hostPort&quot;:3306,                &quot;containerPort&quot;:3306             }          ],          &quot;mountPoints&quot;:[             {                &quot;containerPath&quot;:&quot;/var/lib/mysql&quot;,                &quot;sourceVolume&quot;:&quot;mysql-data&quot;             }          ]       },       {          &quot;name&quot;:&quot;sbapi&quot;,          &quot;hostname&quot;: &quot;sbapi&quot;,          &quot;essential&quot;:true,          &quot;image&quot;:&quot;xxxxxxxxxxxxxxxx.dkr.ecr.ap-southeast-1.amazonaws.com/sbapi&quot;,          &quot;memory&quot;:512,          &quot;portMappings&quot;:[             {                &quot;hostPort&quot;:8080,                &quot;containerPort&quot;:8080             }          ],          &quot;links&quot;: [             &quot;db&quot;          ]       },       {          &quot;name&quot;:&quot;nginx&quot;,          &quot;image&quot;:&quot;nginx:alpine&quot;,          &quot;essential&quot;:true,          &quot;memory&quot;: 128,          &quot;portMappings&quot;:[             {                &quot;hostPort&quot;:80,                &quot;containerPort&quot;:80             }          ],          &quot;mountPoints&quot;:[             {                &quot;containerPath&quot;:&quot;/etc/nginx/conf.d&quot;,                &quot;sourceVolume&quot;:&quot;nginx-data&quot;             }          ],          &quot;links&quot;:[             &quot;sbapi&quot;          ]       }    ],    &quot;family&quot;: &quot;&quot;,    &quot;volumes&quot;:[       {          &quot;host&quot;:{},          &quot;name&quot;:&quot;mysql-data&quot;       },       {          &quot;name&quot;: &quot;nginx-data&quot;,          &quot;host&quot;: {             &quot;sourcePath&quot;: &quot;/var/app/current/nginx/conf.d&quot;          }       }    ] } </code></pre> <p>This is my nginx.stouterr.log. Not sure will it will auto shutdown.</p> <pre><code>/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration /docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/ /docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh 10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf 10-listen-on-ipv6-by-default.sh: info: /etc/nginx/conf.d/default.conf differs from the packaged version /docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh /docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh /docker-entrypoint.sh: Configuration complete; ready for start up 2021/08/26 00:21:11 [notice] 1#1: using the &quot;epoll&quot; event method 2021/08/26 00:21:11 [notice] 1#1: nginx/1.21.1 2021/08/26 00:21:11 [notice] 1#1: built by gcc 8.3.0 (Debian 8.3.0-6)  2021/08/26 00:21:11 [notice] 1#1: OS: Linux 4.14.238-125.422.amzn1.x86_64 2021/08/26 00:21:11 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 133489:133489 2021/08/26 00:21:11 [notice] 1#1: start worker processes 2021/08/26 00:21:11 [notice] 1#1: start worker process 30 2021/08/26 00:21:11 [notice] 1#1: start worker process 31 2021/08/26 00:21:11 [notice] 1#1: signal 3 (SIGQUIT) received, shutting down 2021/08/26 00:21:11 [notice] 30#30: gracefully shutting down 2021/08/26 00:21:11 [notice] 30#30: exiting 2021/08/26 00:21:11 [notice] 30#30: exit 2021/08/26 00:21:11 [notice] 31#31: gracefully shutting down 2021/08/26 00:21:11 [notice] 31#31: exiting 2021/08/26 00:21:11 [notice] 31#31: exit 2021/08/26 00:21:11 [notice] 1#1: signal 17 (SIGCHLD) received from 30 2021/08/26 00:21:11 [notice] 1#1: worker process 30 exited with code 0 2021/08/26 00:21:11 [notice] 1#1: worker process 31 exited with code 0 2021/08/26 00:21:11 [notice] 1#1: exit </code></pre> <p>I checked the ECS, at first, 3 containers are running. But later on, all status changed to stopped and it spawns another new task again.</p> <p>I also get the error &quot;connection refused&quot; to connect the MySQL from my spring boot application.</p> <pre><code>Caused by: com.mysql.cj.exceptions.CJCommunicationsException: Communications link failure  The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server.     at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) ~[na:na]     at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(Unknown Source) ~[na:na]     at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(Unknown Source) ~[na:na]     at java.base/java.lang.reflect.Constructor.newInstance(Unknown Source) ~[na:na]     at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:61) ~[mysql-connector-java-8.0.23.jar!/:8.0.23]     at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:105) ~[mysql-connector-java-8.0.23.jar!/:8.0.23]     at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:151) ~[mysql-connector-java-8.0.23.jar!/:8.0.23]     at com.mysql.cj.exceptions.ExceptionFactory.createCommunicationsException(ExceptionFactory.java:167) ~[mysql-connector-java-8.0.23.jar!/:8.0.23]     at com.mysql.cj.protocol.a.NativeSocketConnection.connect(NativeSocketConnection.java:89) ~[mysql-connector-java-8.0.23.jar!/:8.0.23]     at com.mysql.cj.NativeSession.connect(NativeSession.java:144) ~[mysql-connector-java-8.0.23.jar!/:8.0.23]     at com.mysql.cj.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:953) ~[mysql-connector-java-8.0.23.jar!/:8.0.23]     at com.mysql.cj.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:823) ~[mysql-connector-java-8.0.23.jar!/:8.0.23]     ... 58 common frames omitted Caused by: java.net.ConnectException: Connection refused (Connection refused)     at java.base/java.net.PlainSocketImpl.socketConnect(Native Method) ~[na:na]     at java.base/java.net.AbstractPlainSocketImpl.doConnect(Unknown Source) ~[na:na]     at java.base/java.net.AbstractPlainSocketImpl.connectToAddress(Unknown Source) ~[na:na]     at java.base/java.net.AbstractPlainSocketImpl.connect(Unknown Source) ~[na:na]     at java.base/java.net.SocksSocketImpl.connect(Unknown Source) ~[na:na]     at java.base/java.net.Socket.connect(Unknown Source) ~[na:na]     at com.mysql.cj.protocol.StandardSocketFactory.connect(StandardSocketFactory.java:155) ~[mysql-connector-java-8.0.23.jar!/:8.0.23]     at com.mysql.cj.protocol.a.NativeSocketConnection.connect(NativeSocketConnection.java:63) ~[mysql-connector-java-8.0.23.jar!/:8.0.23]     ... 61 common frames omitted </code></pre> <p>This is my application.properties</p> <pre><code>spring.datasource.url=jdbc:mysql://db:3306/sbapi?allowPublicKeyRetrieval=true&amp;useSSL=false spring.datasource.username=user spring.datasource.password=password  server.port = 8080 </code></pre> <p>I was able to access the API when running docker-compose up from local. However, when deploying to Elastic Beanstalk, it doesn't work. I'm not sure which part goes wrong, and I was curious why the ECS will stop itself and respawn new task again and again?</p> ",
    "OwnerUserId": "5469630",
    "LastEditorUserId": "2756409",
    "LastEditDate": "2021-08-26T15:38:27.167",
    "LastActivityDate": "2021-08-31T07:36:54.447",
    "Title": "Failed to deploy multi-containers docker to ElasticBeanstalk",
    "Tags": "<mysql><amazon-web-services><spring-boot><docker-compose><amazon-elastic-beanstalk>",
    "AnswerCount": "2",
    "CommentCount": "9",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>EB's  Docker platform supports docker-compose.yml as explained in <a href='https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/single-container-docker-configuration.html' rel='nofollow noreferrer'>Docker environment with Docker Compose</a>:</p> <blockquote> <p>Create a docker-compose.yml file to deploy a Docker image from a hosted repository to Elastic Beanstalk. No other files are required if all your deployments are sourced from images in public repositories.</p> </blockquote> <p>So you may need <code>Dockerrun.aws.json v3</code> only to <a href='https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/single-container-docker-configuration.html#docker-configuration.remote-repo' rel='nofollow noreferrer'>enable access to private docker registry</a>.</p> "
  },
  {
    "Id": "69540366",
    "PostTypeId": "1",
    "CreationDate": "2021-10-12T12:14:58.787",
    "Score": "4",
    "ViewCount": "267",
    "Body": "<p>Issue detail:</p> <p>I have a docker-compose file with 1 MariaDb database and 1 simple SpringBoot application which connects to the database.</p> <p>The docker-compose.yml file:</p> <pre><code>version: '3.9' volumes:   out:     driver: local  services:    users:     image: &lt;MY_HOST&gt;/users:0.0.1-SNAPSHOT     container_name: users     environment:       spring.datasource.url: jdbc:mariadb://users-db:3306/users     ports:       - &quot;9003:9003&quot;     depends_on:       - users-db     networks:       - my-network    users-db:     image: mariadb:10.6.4     restart: always     container_name: users-db     environment:       MYSQL_ROOT_PASSWORD: admin       MYSQL_DATABASE: users       MYSQL_USER: testuser       MYSQL_PASSWORD: test     ports:       - &quot;3306:3306&quot;     command: --default-authentication-plugin=mysql_native_password     networks:       - my-network     volumes:       - ./out/users_db:/var/lib/mysql  networks:   my-network:     driver: bridge </code></pre> <p>In my SpringBoot application.properties file (users server name in docker-compose.yml) i have the following content:</p> <pre><code>spring.datasource.url=jdbc:mariadb://localhost:3306/users spring.datasource.driver-class-name=org.mariadb.jdbc.Driver spring.datasource.username=testuser spring.datasource.password=test spring.jpa.hibernate.ddl-auto=validate spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl spring.jpa.hibernate.naming.implicit-strategy=org.springframework.boot.orm.jpa.hibernate.SpringImplicitNamingStrategy logging.level.hibernate=trace spring.datasource.hikari.data-source-properties.useUnicode=true spring.datasource.hikari.data-source-properties.characterEncoding=UTF-8 </code></pre> <p>The environment variable is overriding the default value of the mariadb URL inside the application.properties file.</p> <p>Actually, when only the database is running and i use the localhost property inside my springboot application, i am able to connect to it. When i dockerize my springboot application and i try to use the service-name users-db it is not able anymore.</p> <p>Here's the output from docker:</p> <pre><code>java.sql.SQLNonTransientConnectionException: Could not connect to address=(host=users-db)(port=3306)(type=master) : Socket fail to connect to host:users-db, port:3306. Connection refused  at org.mariadb.jdbc.internal.util.exceptions.ExceptionFactory.createException(ExceptionFactory.java:73) ~[mariadb-java-client-2.7.4.jar!/:na]  at org.mariadb.jdbc.internal.util.exceptions.ExceptionFactory.create(ExceptionFactory.java:197) ~[mariadb-java-client-2.7.4.jar!/:na]  at org.mariadb.jdbc.internal.protocol.AbstractConnectProtocol.connectWithoutProxy(AbstractConnectProtocol.java:1394) ~[mariadb-java-client-2.7.4.jar!/:na]  at org.mariadb.jdbc.internal.util.Utils.retrieveProxy(Utils.java:635) ~[mariadb-java-client-2.7.4.jar!/:na]  at org.mariadb.jdbc.MariaDbConnection.newConnection(MariaDbConnection.java:150) ~[mariadb-java-client-2.7.4.jar!/:na]  at org.mariadb.jdbc.Driver.connect(Driver.java:89) ~[mariadb-java-client-2.7.4.jar!/:na] </code></pre> <p>Does anybody have an idea about what the issue is?</p> ",
    "OwnerUserId": "17134377",
    "LastActivityDate": "2021-10-12T12:14:58.787",
    "Title": "Docker application not able to connect to database",
    "Tags": "<java><spring-boot><docker><docker-compose><mariadb>",
    "AnswerCount": "0",
    "CommentCount": "1",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": null
  },
  {
    "Id": "71635000",
    "PostTypeId": "1",
    "AcceptedAnswerId": "71635142",
    "CreationDate": "2022-03-27T09:05:40.317",
    "Score": "4",
    "ViewCount": "15154",
    "Body": "<p>Tried to simply dockerize my mongodb and spring boot application. Had a lot of struggles and thought I almost had it running and than the terminal hits me with this error:</p> <pre><code>Building user [+] Building 0.0s (1/2)  =&gt; ERROR [internal] load build definition from Dockerfile                                                                                                                         0.0s  =&gt; =&gt; transferring dockerfile: 121B                                                                                                                                               0.0s ------  &gt; [internal] load build definition from Dockerfile: ------ failed to solve with frontend dockerfile.v0: failed to read dockerfile: error from sender: walk \\\\?\\C:\\Users\\ZRC\\Documents\\GitHub\\s6-kwetter-backend\\user\\Dockerfile: The system cannot find the path specified. ERROR: Service 'user' failed to build : Build failed </code></pre> <p>Dockerfile (which is in a sub-directory; user-module):</p> <pre><code>FROM openjdk:11 EXPOSE 8081 ADD target/user-module-docker.jar user-docker.jar CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;user-docker.jar&quot;] </code></pre> <p>docker-compose.yml (which is in the main directory that has multiple modules/microservices):</p> <pre><code>version: '3.8'  services:   user:     build: ./user/Dockerfile     restart: unless-stopped     container_name: user-ms     ports:     - 8081:8080   mongodb:     image: mongo     restart: always     container_name: mongodb     ports:       - 27017:27017 </code></pre> <p>Like it says that the path specified cannot be found but it literally exists, so where could I have gone wrong?</p> ",
    "OwnerUserId": "10557540",
    "LastActivityDate": "2023-12-16T11:14:38.800",
    "Title": "docker-compose up gives 'failed to read dockerfile: error from sender'",
    "Tags": "<spring-boot><docker><docker-compose><dockerfile>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>The error is telling you that the Dockerfile was not found, because the path doesn't exist. That's because it is trying to enter the path as folder.</p> <blockquote> <p>The system cannot find the path specified.</p> </blockquote> <p>This comes because you made a mistake in the compose build syntax. There are 2 ways it can be used.</p> <h4>1. The simple form:</h4> <p>This is using ./users/ as context, expecting a Dockerfile to be in this directory.</p> <pre class='lang-yaml prettyprint-override'><code>user:   build: ./user </code></pre> <h4>2. The complex form:</h4> <pre class='lang-yaml prettyprint-override'><code>user:   build:     context: ./     dockerfile: ./users/Dockerfile </code></pre> <p>This lets you separate the context and where the Dockerfile is. In this example, the current folder is used as context, and the Dockerfile is taken from ./users/Dockerfile. It is also useful when you have a different name for your Dockerfile. I.E. Dockerfile.dev.</p> <p>Note that this is just an example, I don't know if this would make sense in your project. You need to know what context is the correct one.</p> <hr /> <h4>What do I mean by context?</h4> <blockquote> <p>The <a href='https://docs.docker.com/engine/reference/commandline/build/' rel='nofollow noreferrer'>docker build command</a> builds Docker images from a Dockerfile and a \u201ccontext\u201d. A build\u2019s context is the set of files located in the specified PATH or URL. The build process can refer to any of the files in the context. For example, your build can use a COPY instruction to reference a file in the context.</p> </blockquote> <p>As example:</p> <pre class='lang-sh prettyprint-override'><code>docker build --file /path/to/Dockerfile /path/to/context </code></pre> ",
    "highest_rated_answer": null
  },
  {
    "Id": "72148859",
    "PostTypeId": "1",
    "AcceptedAnswerId": "72148953",
    "CreationDate": "2022-05-07T01:48:12.503",
    "Score": "4",
    "ViewCount": "4141",
    "Body": "<p>so im making a spring boot application that im supposed to put in and run from a docker container, and i would like to build the whole image using a docker file. <br> im using this dockerFile:</p> <pre><code>FROM openjdk:8-jdk-alpine ADD . /analytics-service WORKDIR /analytics-service ENTRYPOINT ./mvnw spring-boot:run  </code></pre> <p>when i create the image it just copies the files, and only after i run it, it starts downloading all the maven dependencies. which takes a while, given that i will be running a few containers. so how do i do it ? i want it to get all the dependencies when the image is created, so when i create a container it doesnt start downloading.</p> ",
    "OwnerUserId": "17383009",
    "LastActivityDate": "2022-05-07T02:20:09.720",
    "Title": "how do i store maven dependencies inside docker image using a Dockerfile",
    "Tags": "<java><spring-boot><docker><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>If I understood you correctly, you would like to have the Maven dependencies downloaded first then combine them with your app into an image?</p> <p>If that's what you want then the proper way to do that is as follows:</p> <ol> <li>Pull a maven image (normally you call this stage the 'builder' - it's just a name)</li> <li>Copy your pom.xml file into a working directory</li> <li>Run maven once to get your dependencies and then again to package it up</li> <li>Create a new image base from openjdk</li> <li>Copy the result of step 3 into your app image</li> <li>Expose a port</li> <li>Provide an entry point</li> </ol> <p>Here's what that looks like in a Dockerfile:</p> <pre class='lang-sh prettyprint-override'><code>FROM maven AS builder WORKDIR /usr/src/analytics COPY pom.xml . RUN mvn -B dependency:go-offline  COPY . . RUN mvn package  FROM openjdk:8-jdk-alpine WORKDIR /analytics-service COPY --from=builder /usr/src/analytics/target/YOUR_JAR_FILENAME.jar . EXPOSE 80 ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/analytics-service/YOUR_JAR_FILENAME.jar&quot;] </code></pre> <p>You'll need to know how your jar file is named before you run this. You can run mvn package outside of Docker on your computer and see the filename that is generated. Copy that into the two spots above in the Dockerfile.</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "75006135",
    "PostTypeId": "1",
    "CreationDate": "2023-01-04T13:25:12.427",
    "Score": "4",
    "ViewCount": "6607",
    "Body": "<p>I just migrated from Spring boot 2 to Spring boot 3.</p> <p>When I run the project I get the error</p> <pre><code>| Caused by: io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: localhost/127.0.0.1:6379 | Caused by: java.net.ConnectException: Connection refused |    at java.base/sun.nio.ch.Net.pollConnect(Native Method) ~[na:na] |    at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672) ~[na:na]  </code></pre> <p>I changed the redis dependency from</p> <pre><code>&lt;dependency&gt;     &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;     &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;     &lt;version&gt;2.3.3.RELEASE&lt;/version&gt;  &lt;/dependency&gt; </code></pre> <p>to</p> <pre><code>&lt;dependency&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;     &lt;version&gt;3.0.1&lt;/version&gt; &lt;/dependency&gt; </code></pre> <p>My redis is running and I have tried to change the host from localhost to my local ip but still will not work.</p> <p>Below are configs.</p> <h4>application.yml</h4> <pre><code>spring:   datasource:     username: username     password: password     driver: org.postgresql.Driver     test-on-borrow: true     validation-query: SELECT 1     tomcat:       max-active: 1   session:     store-type: none     timeout: 86400   redis:     host: 172.22.64.1     port: 6379 </code></pre> <h4>docker-compose</h4> <pre><code>  db:     container_name: redis     image: redis     hostname: redis     expose:       - &quot;6379&quot;     ports:       - &quot;6379:6379&quot; </code></pre> ",
    "OwnerUserId": "7358866",
    "LastEditorUserId": "7358866",
    "LastEditDate": "2023-01-20T07:47:31.487",
    "LastActivityDate": "2023-04-04T11:21:15.713",
    "Title": "Caused by: io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: localhost/127.0.0.1:6379",
    "Tags": "<spring-boot><docker><docker-compose><redis>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>I faced the same error after migrating from Spring Boot 2.7.4 to 3.0.1 and after a long time trying different things I could finally solve the issue by adapting the naming of some environment variables that were set in the configmap of my application deployment.</p> <p>I changed the following variable names:</p> <pre><code>  SPRING_REDIS_HOST: &quot;your_host&quot;   SPRING_REDIS_PASSWORD: &quot;your_password&quot; </code></pre> <p>to</p> <pre><code>SPRING_DATA_REDIS_HOST: &quot;your_host&quot; SPRING_DATA_REDIS_PASSWORD: &quot;your_password&quot; </code></pre> <p>I guess it is related to the changed property names since Spring Boot 3 (<a href='https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.data' rel='nofollow noreferrer'>https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.data</a>).</p> <p>Hope it helps</p> "
  },
  {
    "Id": "35791179",
    "PostTypeId": "1",
    "AcceptedAnswerId": "35816286",
    "CreationDate": "2016-03-04T08:23:25.543",
    "Score": "3",
    "ViewCount": "2694",
    "Body": "<p>I have a small spring boot web application which saves the data to redis.</p>  <p>After running docker-compose.yml containers are started but on <code>localhost:8085</code> i have 'The connection was reset'.</p>  <h3>spring boot aplication.yml</h3>  <pre><code>server:     address: 127.0.0.1 --- spring:     profiles: development server:     address: 127.0.0.1 --- spring:     profiles: production server:     address: 127.0.0.1 </code></pre>  <h3>docker-compose.yml</h3>  <pre><code>web:   build: docker_app   ports:    - '8085:8080'   links:    - redis  redis:       image: redis </code></pre>  <p>How do I link spring boot and redis?</p>  <p>What did I miss?</p> ",
    "OwnerUserId": "3222910",
    "LastEditorUserId": "3222910",
    "LastEditDate": "2016-03-04T13:33:11.337",
    "LastActivityDate": "2016-03-05T15:58:16.980",
    "Title": "How to configure spring boot web app with redis using Docker",
    "Tags": "<docker><redis><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p><code>127.0.0.1</code> is the wrong address. Use <code>redis</code> as the hostname.</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "36245276",
    "PostTypeId": "1",
    "CreationDate": "2016-03-27T08:16:21.517",
    "Score": "3",
    "ViewCount": "551",
    "Body": "<p>I have been trying to user docker-compose to spin up a <a href='https://hub.docker.com/_/postgres' rel='nofollow'>postgres container</a> container, with a single, persisted named volume.</p>  <p>The goal is to have different postgres containers share the same persisted data (not concurrently!) - one container dies or is killed, another takes it place without losing previously persisted data.</p>  <p>As I understand 'named volumes' are supposed to replace 'Data Volume Containers'. However, so far either one of two things happen:</p>  <ol> <li>The postgres container fails to start up, with error message 'ERROR: Container command not found or does not exist.'</li> <li>I achieve persistance for only that specific container. If it is stopped and removed and another container started, we start with a blank slate.</li> </ol>  <p>SO, as far as I understand, the postgres image does create it's own volume, which is of course bound to that specific container. Which would be fine, if I could just get THAT volume aliased or linked or something with the named volume.</p>  <p>Current incarnation of docker-compose.yml:</p>  <pre><code>version: '2' services:  db:    image: postgres    restart: allways    volumes:      - myappdb:/var/lib/postgresql/data/    environment:      - POSTGRES_PASSWORD=mysecretpasswordPleaseChangeME volumes:  myappdb:   driver: local </code></pre>  <p>Am I doing something stupidly wrong, or attempting something that is simply not supported?</p>  <ul> <li>Docker version 1.10.3, build 20f81dd </li> <li>docker-compose version 1.6.0, build d99cad6</li> </ul> ",
    "OwnerUserId": "842832",
    "LastEditorUserId": "842832",
    "LastEditDate": "2016-03-27T21:34:53.770",
    "LastActivityDate": "2016-03-29T07:46:57.267",
    "Title": "How can I link an image created volume with a docker-compose specified named volume?",
    "Tags": "<docker><spring-boot><docker-compose><postgresql-9.4>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Ok, after a lot of trial and error, things are now working as they should (meaning I am able to run <code>docker-compose down</code> and then <code>docker-compose up</code> and my data is in the state where it was left with the <code>down</code> command).</p>  <p>In general, a few things:</p>  <ol> <li>Don't use the PGDATA environment option with the official <a href='https://hub.docker.com/_/postgres/' rel='nofollow'>postgres image</a></li> <li>If using spring boot (like I was), and docker compose (as I was) and passing <code>environment</code> options to a service linked to your database container, do not wrap a profile name in double quotes. It is passed as-is to the Spring as-is, resulting in a non-existing profile to be used as the active profile.</li> </ol>  <p>I had some subtle and strange things incorrectly configured initially, but I suspect the killer was point 2 above - it caused my app,when running in a container, to use in-mem H2 database instead of the linked container database. So everything functioned (almost) perfectly - until container shutdown. And, when running from IDE, against container DB (with ports exposed to host), all worked perfectly (including persistence), since the active profile parameter was correctly set in the IDE launcher (NO quotes!). </p>  <p>Live and learn I guess (but I do feel a LOT of egg on my face).</p> "
  },
  {
    "Id": "37102273",
    "PostTypeId": "1",
    "AcceptedAnswerId": "37105058",
    "CreationDate": "2016-05-08T16:44:26.663",
    "Score": "3",
    "ViewCount": "8094",
    "Body": "<p>I have a Spring boot app that connects to a Redis instance that works as a cache. When I'm in dev environment, I have the following:</p>  <pre><code>---  spring:   profiles: default redis:    host: localhost   port: 6379 </code></pre>  <p>And my cache configuration class is like this:</p>  <pre><code>@Configuration @EnableCaching public class CacheConfiguration {     @Value('${redis.host}')     String redisHost;     @Value('${redis.port}')     int redisPort; </code></pre>  <p>In production, this app is Dockerized, and I have the following <code>docker-compose.yml</code> file:</p>  <pre><code>redis:    image: tutum/redis   ports:     - '6379:6379'   volumes:     - /data app:    build: .   ports:     - '8080:8080'   links:     - redis </code></pre>  <p>And the <code>application.yml</code> is:</p>  <pre><code>---  spring:   profiles: docker redis:    host: redis   port: 6379 </code></pre>  <p>To start the app on Docker, I run with <code>-Dspring.profiles.active=docker</code>, but when the app is starting up, the following error happens:</p>  <pre><code>Caused by: org.springframework.beans.factory.BeanCreationException: Could not autowire field: private int com.inkdrop.config.cache.CacheConfiguration.redisPort; nested exception is org.springframework.beans.TypeMismatchException: Failed to convert value of type [java.lang.String] to required type [int]; nested exception is java.lang.NumberFormatException: For input string: 'tcp://172.17.0.3:6379' </code></pre>  <p>For some reason, Spring Boot is reading the <code>redis.port</code> as <code>tcp://172.17.0.3:6379</code>. So for tests proposes, I removed the <code>@Value</code> annotations from  <code>CacheConfiguration</code> class, and set it manually to <code>redis</code> as host and <code>6379</code> as port and it worked. Seems like when using environment variables and <code>@Value</code>, Spring get lost. Anyone have an idea?</p> ",
    "OwnerUserId": "587406",
    "LastEditorUserId": "587406",
    "LastEditDate": "2016-05-08T21:42:48.810",
    "LastActivityDate": "2016-05-08T21:58:06.483",
    "Title": "Environment variables and @Value can't work together on Spring Boot",
    "Tags": "<java><spring><docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>Based on the <a href='https://docs.docker.com/compose/link-env-deprecated/' rel='noreferrer'>Docker documentation</a>:</p>  <blockquote>   <p>Compose uses Docker links to expose services containers to one   another. Each linked container injects a set of environment variables,   <strong>each of which begins with the uppercase name of the container</strong>.</p> </blockquote>  <p>Docker Compose would create an Environment Variable representing the <em>Full URL</em> of the container using <strong><em>name_PORT</em></strong> format, e.g. <code>REDIS_PORT=tcp://172.17.0.5:6379</code>.</p>  <p>And based on your <code>docker-compose.yml</code> file:</p>  <pre><code>redis:    image: tutum/redis   ports:     - '6379:6379'   volumes:     - /data </code></pre>  <p>You would have an Environment Variable named <code>REDIS_PORT</code> with a value equals to <code>tcp://172.17.0.3:6379</code>.Since OS environment variables have more precedence with respect to Profile-specific application properties, Spring Boot would pick up the <code>REDIS_PORT</code> value over <code>redis.port</code>, hence the error:</p>  <blockquote>   <p>Caused by: org.springframework.beans.factory.BeanCreationException:   Could not autowire field: private int   com.inkdrop.config.cache.CacheConfiguration.redisPort; nested   exception is org.springframework.beans.TypeMismatchException: Failed   to convert value of type [java.lang.String] to required type [int];   nested exception is java.lang.NumberFormatException: For input string:   'tcp://172.17.0.3:6379'</p> </blockquote>  <p>As a workaround for this problem, you either should override the <code>REDIS_PORT</code> environment variable with your port value or rename your config name from <code>redis.name</code> to anything less controversial.</p>  <p>Kinda off topic but just quoting from <code>tutum-docker-redis</code> <a href='https://github.com/tutumcloud/redis' rel='noreferrer'>Github repository</a>:</p>  <blockquote>   <p>This image will be deprecated soon. Please use the docker official   image: <a href='https://hub.docker.com/_/redis/' rel='noreferrer'>https://hub.docker.com/_/redis/</a></p> </blockquote> ",
    "highest_rated_answer": null
  },
  {
    "Id": "44286937",
    "PostTypeId": "1",
    "CreationDate": "2017-05-31T14:03:21.837",
    "Score": "3",
    "ViewCount": "508",
    "Body": "<p>I am running elasticsearch image like this: docker-compose.yml</p>  <pre><code>version: '2' services:   elasticsearch:     image: elasticsearch:5.4     ports:       - '9200:9200'       - '9300:9300' </code></pre>  <p>I can check it is running with curl.</p>  <pre><code>curl http://127.0.0.1:9200/_cluster/health </code></pre>  <p>Response:</p>  <pre><code>{'cluster_name':'elasticsearch','status':'green','timed_out':false,'number_of_nodes':1,'number_of_data_nodes':1,'active_primary_shards':0,'active_shards':0,'relocating_shards':0,'initializing_shards':0,'unassigned_shards':0,'delayed_unassigned_shards':0,'number_of_pending_tasks':0,'number_of_in_flight_fetch':0,'task_max_waiting_in_queue_millis':0,'active_shards_percent_as_number':100.0} </code></pre>  <p>In application I configure TransportClient like this:</p>  <pre><code>@Bean(destroyMethod = 'close')     public TransportClient transportClient() throws UnknownHostException {         return new PreBuiltTransportClient(Settings.EMPTY)                 .addTransportAddress(new InetSocketTransportAddress(                         InetAddress.getByName('localhost'), 9300));     } </code></pre>  <p>And then I want to check it:</p>  <pre><code>@Autowired private TransportClient client; @GetMapping(value = 'test')     public Object test(){         return client.admin().cluster().health(Requests                 .clusterHealthRequest())                 .actionGet();     } </code></pre>  <p>but it fails with exception:</p>  <pre><code>org.elasticsearch.client.transport.NoNodeAvailableException: None of the configured nodes are available: [{#transport#-1}{_atMOwK5R5mgOXqAPJWvWg}{localhost}{127.0.0.1:9300}] </code></pre>  <p>BTW I am using this dependency: <code>compile('org.elasticsearch.client:transport:5.4.0')</code></p> ",
    "OwnerUserId": "8080668",
    "LastActivityDate": "2017-06-01T17:04:38.113",
    "Title": "Elasticsearch fails with NoNodeAvailableException",
    "Tags": "<java><elasticsearch><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "1",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Instead of local host try to give elasticsearch since this is your container name, in case spring boot app also running in docker</p> "
  },
  {
    "Id": "45178901",
    "PostTypeId": "1",
    "CreationDate": "2017-07-19T00:01:35.803",
    "Score": "3",
    "ViewCount": "1639",
    "Body": "<p>For example, set <code>environment: EUREKA_PORT=8762</code> in docker-compose.yml. </p>  <p>And the variable <code>${eureka.port=8761}</code> in jar will not effective.</p>  <hr>  <p>Why <code>environment: EUREKA_PORT=8762</code> will cover <code>${eureka.port=8761}</code>?</p>  <p>How are <strong>docker environment variable</strong> and <strong>variable in jar</strong> mapped?</p> ",
    "OwnerUserId": "8042463",
    "LastEditorUserId": "2449905",
    "LastEditDate": "2017-07-19T01:05:35.250",
    "LastActivityDate": "2017-08-18T14:45:50.927",
    "Title": "docker-compose environment will cover variables in jar, how are docker environment variable and variable in jar mapped?",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>You are exactly right with your way of thinking - <code>EUREKA_PORT=8762</code> will set <code>eureka.port</code> through the environment. It's the way it works:</p>  <blockquote>   <p>If you use environment variables rather than system properties, most operating systems disallow <strong>period-separated</strong> key names, but you can use <strong>underscores</strong> instead (e.g. <code>SPRING_CONFIG_NAME</code> instead of <code>spring.config.name</code>).</p> </blockquote>  <p>Taken straight from <a href='https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html' rel='nofollow noreferrer'>spring documentation</a>.</p> "
  },
  {
    "Id": "45330035",
    "PostTypeId": "1",
    "CreationDate": "2017-07-26T14:33:33.100",
    "Score": "3",
    "ViewCount": "2231",
    "Body": "<p>I'm trying to use docker-compose to run 2 simple services locally (Ubuntu): a eureka server, and config server (which is also a eureka client). Both of these have simple dockerfiles that run <code>java -jar</code>, expose their ports, and individually work fine. I also tried to add <code>eureka.client.service-url.defaultZone=http://company-service-discovery:8761/eureka</code> to see if it would register itself, and it worked.</p>  <p>My config server cannot successfully register to the eureka server, and I've googled it and nothing I've seen helped me solve this.</p>  <p>According to docker-compose documentation at <a href='https://docs.docker.com/compose/networking/' rel='nofollow noreferrer'>https://docs.docker.com/compose/networking/</a> :</p>  <blockquote>   <p>By default Compose sets up a single network for your app. Each container for a service joins the default network and is both reachable by other containers on that network, and discoverable by them at a hostname identical to the container name.</p> </blockquote>  <p>With the following example <code>web</code> should be able to use <code>postgres://db:5432</code> to communicate with the database.</p>  <pre><code>version: '3' services:   web:     build: .     ports:       - '8000:8000'   db:     image: postgres     ports:       - '8001:5432' </code></pre>  <p>I have used the same method to configure my services, but my config server gets connection refused when trying to register:</p>  <h1>docker-compose.yml</h1>  <pre><code>version: '3.3' services:   company-service-discovery:     build: company-service-discovery/     ports:       - '8761:8761'   company-config-server:     build: company-config-server/     ports:       - '8888:8888'     links:       - company-service-discovery </code></pre>  <h1>config server bootstrap.yml</h1>  <pre><code>server:   port: 8888  management:   security:     enabled: false  spring:   application:     name: company-config-server   cloud:     config:       server:         native:           search-locations: classpath:/shared   profiles:     include: native  eureka:   client:     service-url:       defaultZone: http://company-service-discovery:8761/eureka </code></pre>  <h1>eureka server bootstrap.yml</h1>  <pre><code>spring:   application:     name: company-service-discovery  server:   port: 8761  management:   security:     enabled: false </code></pre>  <h1>exception</h1>  <pre><code>2017-07-26 14:25:05.738  WARN 1 --- [nfoReplicator-0] c.n.d.s.t.d.RetryableEurekaHttpClient    : Request execution failed with message: java.net.ConnectException: Connection refused (Connection refused) 2017-07-26 14:25:05.739  WARN 1 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_COMPANY-CONFIG-SERVER/365d20275ab0:company-config-server:8888 - registration failed Cannot execute request on any known server </code></pre>  <h1>question</h1>  <p>Is there anything wrong with my configuration ? How can I make it work ?</p>  <p>Let me know if there's any info missing, I'll gladly give any info I can.</p> ",
    "OwnerUserId": "5229041",
    "LastEditorUserId": "5229041",
    "LastEditDate": "2017-07-26T14:40:38.443",
    "LastActivityDate": "2019-02-02T20:17:50.087",
    "Title": "Spring Cloud Netflix and Docker Compose - cannot register services with eureka",
    "Tags": "<spring-boot><docker-compose><spring-cloud><netflix-eureka>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Add the <code>defaultZone</code> configuration to the Eureka server's properties too (and change the <code>service-url</code> to <code>serviceUrl</code> in your <strong><em>config server bootstrap.yml</em></strong>).</p>  <h2>eureka server bootstrap.yml</h2>  <pre><code>spring:   application:     name: company-service-discovery  eureka:   client:     serviceUrl:       defaultZone: http://company-service-discovery:8761/eureka  server:   port: 8761  management:   security:     enabled: false </code></pre> "
  },
  {
    "Id": "47027510",
    "PostTypeId": "1",
    "CreationDate": "2017-10-31T03:39:07.450",
    "Score": "3",
    "ViewCount": "655",
    "Body": "<p>I have created a number of Spring Boot application, which all work like magic in isolation or when started up one of the other manually.</p>  <p>My challenge is that I want to deploy a stack with all the services in a Docker Swarm. </p>  <p>Initially I didn't understand what was going on, as it seemed like all my containers were hanging.</p>  <p>Turns out running a single Spring Boot application spikes up my CPU utilization to max it out for a good couple of seconds (20s+ to start up).</p>  <p>Now the issue is that Docker Swarm is launching 10 of these containers simultaneously and my load average goes above 80 and the system grinds to a halt. The container HEALTHCHECKS starts timing out and eventually Docker restarts them. This is an endless cycle and may or may not stabilize and if it does stabilize it takes a minimum of 30 minutes. So much for micro services vs big fat Java EE applications :(</p>  <p>Is there any way to convince Docker to rollout the containers one by one? I'm sure this will help a lot.</p>  <p>There is a rolling update parameter - <a href='https://docs.docker.com/engine/swarm/swarm-tutorial/rolling-update/' rel='nofollow noreferrer'>https://docs.docker.com/engine/swarm/swarm-tutorial/rolling-update/</a> - but is does not seem applicable to startup deployment.</p>  <p>Your help will be greatly appreciated. </p>  <p>I've also tried systemd (which isn't ideal for distributed micro services). It worked slightly better than Docker, but have the same issue when deploying all the applications at once.</p>  <p>Initially I wanted to try Kubernetes, but I've got enough on my plate and if I can get away with Docker Swarm, that would be awesome.</p>  <p>Thanks!</p> ",
    "OwnerUserId": "2538530",
    "LastEditorUserId": "2730527",
    "LastEditDate": "2017-10-31T03:49:11.677",
    "LastActivityDate": "2017-10-31T03:49:11.677",
    "Title": "Docker Swarm CPU overload on deploy with Spring Boot containers",
    "Tags": "<docker><spring-boot><docker-compose><docker-swarm>",
    "AnswerCount": "0",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": null
  },
  {
    "Id": "49806177",
    "PostTypeId": "1",
    "AcceptedAnswerId": "49808072",
    "CreationDate": "2018-04-12T21:29:55.520",
    "Score": "3",
    "ViewCount": "7240",
    "Body": "<p>I am running a Java app inside a Docker container which is supposed to connect MySQL inside the other container. Trying multiple options suggested in the forms, nothing really works. Here is my Docker Compose file:</p>  <pre><code>version: '3' services:    app:     build:       context: ./       dockerfile: /src/main/docker/Dockerfile     image: app1     environment:       - DB_HOST=Imrans-MacBook-Pro.local       - DB_PORT=3306     ports:       - 8080:8080     networks:       - backend     depends_on:       - mysql      mysql:     image: mysql:5.7.20     hostname: mysql     environment:       - MYSQL_USER=root       - MYSQL_ALLOW_EMPTY_PASSWORD=yes       - MYSQL_DATABASE=app1     ports:       - 3306:3306     command: mysqld --lower_case_table_names=1 --skip-ssl --character_set_server=utf8 --explicit_defaults_for_timestamp     networks:       - backend  networks:   backend:     driver: bridge </code></pre>  <p>Where <code>DB_HOST=Imrans-MacBook-Pro.local</code> is my laptop's name. This did not work. Some suggest that the container name can be used so tried <code>DB_HOST= mysql</code>, never worked.</p>  <p>The only thing works from times to time when I pass the laptop's IP address, which is not I want to do. So, what is a good way to create communication between those containers?</p> ",
    "OwnerUserId": "5834387",
    "LastEditorUserId": "472495",
    "LastEditDate": "2018-04-13T11:24:21.417",
    "LastActivityDate": "2018-04-13T11:24:21.417",
    "Title": "Connect from one Docker container to the other one",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>I have, in the past, gotten this to work without explicitly setting the host networking part in Docker Compose. Because Docker <a href='https://docs.docker.com/compose/networking/' rel='nofollow noreferrer'>images inside a Docker Compose File are put into a Docker Network with each other</a>, you really shouldn't have to do anything to get this to work: by default you should be able to attach into the container for your Spring app and be able to <code>ping mysql</code> and have it work out.</p> ",
    "highest_rated_answer": "<p>The mysql is running in the container so there are two things that you should consider here:</p>  <ol> <li><p>If the mysql is running in the container then you will need to link the app container to the mysql container. This will allow them to talk to each other using docker's inter container communication. The containers talk to each other using hostnames to resolve their respective internal IP addresses. See later in my answer I will show you how to get the two containers to communicate with each other using a compose file.</p></li> <li><p>The mysql container should make use of a docker volume to store the database. This will allow you to store the database and related files on the file system of the host (server or machine where the containers are running on). The docker volume will then be mounted as a directory in the container. Thus the container can now read and write to a directory on the machine where the docker containers are running on. This means that even if the containers are all deleted or removed you will still have the database data persist. Here is a nice beginner friendly article on docker volumes and using them with MySQL: </p></li> </ol>  <p><a href='https://severalnines.com/blog/mysql-docker-containers-understanding-basics' rel='nofollow noreferrer'>https://severalnines.com/blog/mysql-docker-containers-understanding-basics</a></p>  <h2>Container communication using only docker without compose:</h2>  <p>You have container 'app' and 'mysql', you want to be able to access 'app' on localhost and you want 'app' to be able to connect to mysql. How are you gonna do this? 1. You need to expose a port for container 'app' so we can access it on localhost. The docker containers have their own internal network and it is closed to you unless you expose some ports with docker.</p>  <ol start='2'> <li>You need to link the 'mysql' container to 'app' without exposing 'mysql' 's ports to the rest of the world. </li> </ol>  <p>This config should work for what you want to achieve:</p>  <pre><code>    version: '2'     services:        app:         build:           context: ./           dockerfile: /src/main/docker/Dockerfile         image: app1:latest         links:           - mysql         environment:           - DB_HOST=mysql           # This is the hostname that app will reach the mysql container on.           # If you do with app container:           # docker exec -it &lt;app container id&gt; bash           # # apt-get update -y &amp;&amp; apt-get install iputils-ping -y           #           # Then you should be able to ping mysql container with:           #           # # ping -c 2 mysql           - DB_PORT=3306         ports:           - 8080:8080           # You will access 'app' on localhost:8080 in your browser. If this is running on your own machine.          mysql: #hostname actually gets set here so no need to set it later         image: mysql:5.7.20         environment:           - MYSQL_USER=root           - MYSQL_ALLOW_EMPTY_PASSWORD=yes           - MYSQL_DATABASE=app1           # Remember to use a volume if you would like this container's data to persist or if you would like           # to restore a database backup.         command: mysqld --lower_case_table_names=1 --skip-ssl --character_set_server=utf8 --explicit_defaults_for_timestamp </code></pre>  <p>Now you can just start it up with:</p>  <pre><code>$ docker-compose up </code></pre>  <p>If you ran this before then just make sure to run this first before running docker-compose up:</p>  <pre><code>$ docker-compose down </code></pre>  <p>Let me know if that helps.</p> "
  },
  {
    "Id": "49864333",
    "PostTypeId": "1",
    "CreationDate": "2018-04-16T18:52:07.163",
    "Score": "3",
    "ViewCount": "1768",
    "Body": "<p><em>Hello guys !</em></p>  <p>It's my first so I will try to make the best that I can.</p>  <p>I want to create an app which is running with Springboot framework and I would like to connect it to a docker container which embeds MySQL (but the spring boot app is not running on docker)</p>  <p>So I have followed this  <a href='https://stackoverflow.com/questions/32360687/connect-to-docker-mysql-container-from-localhost'>post</a></p>  <p>I have made my docker-compose:</p>  <pre><code>  db:      image: mysql   ports:      - '3306:3306'   environment:      - MYSQL_ROOT_PASSWORD=secret      - MYSQL_DATABASE=users   volumes:      - ../data:/var/lib/mysql </code></pre>  <p>and I run it with this command :</p>  <pre><code>docker-compose run --service-ports db </code></pre>  <p>All is fine, so now I change my application.properties on spring boot :</p>  <pre><code>   ## Server Properties     server.port= 5000     ## Spring DATASOURCE (DataSourceAutoConfiguration &amp; DataSourceProperties)    spring.datasource.url= jdbc:mysql://127.0.0.1:3306/users?useSSL=false&amp;serverTimezone=UTC&amp;useLegacyDatetimeCode=false    spring.datasource.username= root    spring.datasource.password= secret     ## Hibernate Properties     #The SQL dialect makes Hibernate generate better SQL for the chosen database     spring.jpa.properties.hibernate.dialect= org.hibernate.dialect.MySQL5InnoDBDialect    spring.jpa.hibernate.ddl-auto = update     ## Hibernate Logging    logging.level.org.hibernate.SQL= DEBUG     ## Jackson Properties    spring.jackson.serialization.WRITE_DATES_AS_TIMESTAMPS= false    spring.jackson.time-zone= UTC </code></pre>  <p>But When I run my app, I have this error :( :</p>  <blockquote>   <p>Caused by: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure</p> </blockquote>  <p>I'm on MacOS...</p>  <p>I tried to follow callicoder's course ...</p>  <p><a href='https://www.callicoder.com/spring-boot-spring-security-jwt-mysql-react-app-part-1/' rel='nofollow noreferrer'>https://www.callicoder.com/spring-boot-spring-security-jwt-mysql-react-app-part-1/</a></p>  <p>Thanks for your help :)</p> ",
    "OwnerUserId": "9654475",
    "LastEditorUserId": "9654475",
    "LastEditDate": "2018-04-20T06:51:39.407",
    "LastActivityDate": "2019-08-09T19:59:43.630",
    "Title": "From Springboot app connect to mysql container",
    "Tags": "<java><mysql><docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>The problem is that the db container is not running on localhost but rather inside a mini Linux VM since you are on a MAC. </p>  <p>Thus to connect to the database you need to use the IP address of the machine where the container is running. To do that run the command <code>docker-machine ip default</code>. This will return the IP address which you would use in the connection url rather than localhost: </p>  <pre><code>spring.datasource.url= jdbc:mysql://&lt;docker-machine-ip&gt;:3306/users?useSSL=false&amp;serverTimezone=UTC&amp;useLegacyDatetimeCode=false </code></pre> "
  },
  {
    "Id": "49995402",
    "PostTypeId": "1",
    "AcceptedAnswerId": "49995589",
    "CreationDate": "2018-04-24T07:08:11.620",
    "Score": "3",
    "ViewCount": "599",
    "Body": "<p>i am containerising my spring boot app which uses selenium/standalone-firefox-debug i have created docker compose file,but when i up it it gives me error as</p>  <blockquote>   <p>Could not start a new session. Possible causes are invalid address of the remote server or browser start-up failure.</p> </blockquote>  <p>But if i run the spring-boot app directly and selenium/standalone-firefox-debug seperatly it works.I want to run it with docker-compose</p>  <p>Dockerfile:</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ARG JAR_FILE ADD ${JAR_FILE} app.jar ENTRYPOINT exec java  -jar /app.jar </code></pre>  <p>Dockercompose:</p>  <pre><code>version: '2.2' services:   employer-url:     image: 'adib/employer-url'     ports:      - '8080:8080'     depends_on:      - firefox   firefox:     image: 'selenium/standalone-firefox-debug'     ports:      - '4444:4444'     environment:      - no_proxy=localhost </code></pre>  <p>this is how i create driver in spring app</p>  <pre><code>RemoteWebDriver driver = new RemoteWebDriver(new URL('http://localhost:4444/wd/hub'), DesiredCapabilities.firefox()); </code></pre> ",
    "OwnerUserId": "7504603",
    "LastActivityDate": "2018-04-24T07:31:26.633",
    "Title": "Unable to run Springboot app using Selenium RemoteWebDriver with docker-compose",
    "Tags": "<selenium><docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<h2>Problem</h2>  <p>This <code>http://localhost:4444/wd/hub</code> URL refers to the localhost which belongs to the container runtime. The springboot container does not have port 4444 running that's why it's complaining.</p>  <h2>Solution</h2>  <p>You should access the selenium service from its hostname (not localhost). In springboot application, you can use, <code>http://firefox:4444/wd/hub</code> URL and you'd be good to go. </p>  <h2>Rationale</h2>  <p>You are missing the core of the networking concept in containers here. Both of these images (viz springboot and selenium) are running inside containers and hence they have their separate environments. If you refer to localhost inside any container, it means the localhost of that container. You are expecting localhost to refer to the localhost of the docker host machine. You exposed port 4444 on the docker host machine. So if you try to run your jar from the docker host (while selenium is containerized) <code>localhost:4444</code> would work but if you access it from inside a container, it's not going to work. Following Diagram shows the concept:</p>  <p><a href='https://i.stack.imgur.com/5BKXw.png' rel='nofollow noreferrer'><img src='https://i.stack.imgur.com/5BKXw.png' alt='docker network'></a></p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "50340169",
    "PostTypeId": "1",
    "AcceptedAnswerId": "50342931",
    "CreationDate": "2018-05-14T23:01:26.420",
    "Score": "3",
    "ViewCount": "5738",
    "Body": "<p>I have several microservices on spring. One of them is config server. I try to start services altogether with docker-compose. But there is problem. Microservices try to get configs from config server before it had been initialized. I want to write script for microservice's startup preventing false start. I have to now how i can determinate moment when my config server is ready. Port listening isn't working. Docker hides info about his networking. I believe there is better way than standard output parsing.</p> <p>Does somebody know how i can determine time of spring boot application starting?</p> ",
    "OwnerUserId": "8222921",
    "LastEditorUserId": "164802",
    "LastEditDate": "2020-09-07T08:28:08.457",
    "LastActivityDate": "2020-09-07T08:28:08.457",
    "Title": "How to understand that spring boot application is ready to work?",
    "Tags": "<java><spring><docker><spring-boot><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<blockquote>   <p>Does somebody know how i can determine time of spring boot application starting?</p> </blockquote>  <p>Your application must be ready when it returns code <code>200</code> from <code>/health</code> endpoint with a payload like that</p>  <pre><code>{   'status': 'UP' } </code></pre>  <p>It means that your application have no issues and is ready to work, anyway this endpoint is normally used by a monitor application to know about your application health that way it can maintain the cluster, this endpoint is not commonly used by others apps, this monitor commonly</p>  <ul> <li>Uses that endpoint to know when your application is ready to receive world requests, that way it can register your application to a public address for example</li> <li>Try to restart that application expecting it can solve it's problem when <code>/health</code> returns <strong>DOWN</strong> status</li> </ul>  <p>Take a look at <a href='https://docs.docker.com/engine/reference/builder/#healthcheck' rel='noreferrer'>docker healthcheck</a>, it uses the same concept as spring</p>  <p>To have that endpoint available you will need to add spring actuator dependency, here is a gradle sample</p>  <pre><code>compile group: 'org.springframework.boot', name: 'spring-boot-starter-actuator', version: '1.5.10.RELEASE' </code></pre>  <blockquote>   <p>Microservices try to get configs from config server before it had been initialized ....</p> </blockquote>  <p>Here some important points to let clear</p>  <ul> <li>Docker compose don't grants startup order unless you are using <a href='https://docs.docker.com/compose/compose-file/#depends_on' rel='noreferrer'>depends_on</a> clause, anyway docker will never wait to first container completely start up (event using healthcheck) to then start the second container</li> <li>If your microservice <strong>A</strong> depends microservice <strong>B</strong> then <strong>A</strong> must be prepared to deal with <strong>B</strong> failure and unavailability, it's a microservice premise, because it will just happens, someday or even worse, in a unexpected moment when it is not supposed to. What about <strong>config-server</strong> restarts in some moment? What will happen with the dependent apps?</li> </ul>  <p>So my advise is to you let your application just fail when it tries to get information from <strong>config server</strong> app, if it fails you can do some things:</p>  <ul> <li>Do some kind of retry <a href='https://docs.spring.io/spring-batch/trunk/reference/html/retry.html' rel='noreferrer'>using spring-retry</a> for example</li> <li>If you can deal with some temporary <strong>config server</strong> unavailability then my suggestion is to <a href='https://stackoverflow.com/questions/44849568/how-to-add-a-custom-health-check-in-spring-boot-health'>add a custom check</a> in your <code>/health</code> exposing this information to some monitor microservice</li> <li>If your app can't work without <strong>config server</strong>  then just call <code>System.exit(-1)</code> and let <a href='https://docs.docker.com/compose/compose-file/#restart' rel='noreferrer'>docker-compose restart your application</a> again and again until <strong>config server</strong> answer something helpfull</li> </ul>  <p>Here some compact example simulating your case and solving that using docker</p>  <ul> <li>config server</li> <li>app-1</li> </ul>  <p><strong>config-server</strong> will ever take longer than <strong>app-1</strong> to get ready, then <strong>app-1</strong> will stay <strong>unhealthy</strong> until <strong>config-server</strong> responds correctly</p>  <pre><code>version: '3.4' services:   mg-config-server:     image: nginx:1.10     healthcheck:       test: ['CMD', 'bash', '-c', 'sleep 15; exit 0']       interval: 10s       timeout: 17s       retries: 3       start_period: 10s     networks:       - my-net     command: bash -c 'echo starting; sleep 20; nginx -g 'daemon off;''    mg-app-1:     image: alpine:3.7     healthcheck:       test: ['CMD', 'curl', 'http://mg-config-server']       interval: 5s       timeout: 5s       retries: 3       start_period: 1s     command: sh -c 'echo starting; apk add --update curl; tail -f /dev/null'     restart: always     networks:        - my-net     dns:     - 8.8.8.8  networks:   my-net:     driver: overlay </code></pre>  <p>Then just start it</p>  <pre><code>docker-compose up docker ps | grep 'mg'  </code></pre>  <p>Anyway it makes more sense to use docker swarm in that case, because it will check healthcheck endpoints and restart the containers if it's not healthy</p>  <pre><code>docker swarm init --advertise-addr &lt;your-machine-ip&gt; docker stack deploy --compose-file docker-compose.yml my-stack &amp;&amp; docker ps | grep 'my-stack' </code></pre>  <p>Docker version: <code>18.02.0-ce</code></p>  <p>Sorry for the too long answer, hope it helps</p> ",
    "highest_rated_answer": "<p>If your issue is specific to Config server, You can also implement spring retry mechanism</p>  <pre><code>spring:    application:       name: test-service    cloud:       config:          enabled: true          uri: ${CONFIG_SERVER_URL:http://127.0.0.1:8761} #where the config-service is running          fail-fast: true #the service will not run if it can't reach the config-service          name: common,test-service          retry:            max-attempts: 10            max-interval: 5000 </code></pre>  <p>You need to have spring-retry dependency also </p>  <pre><code>// https://mvnrepository.com/artifact/org.springframework.retry/spring-retry compile group: 'org.springframework.retry', name: 'spring-retry', version: '1.2.4.RELEASE' </code></pre> "
  },
  {
    "Id": "51392666",
    "PostTypeId": "1",
    "CreationDate": "2018-07-18T02:22:30.233",
    "Score": "3",
    "ViewCount": "8307",
    "Body": "<p>I created a docker image and pushed it to docker hub. Now, I am trying to run it on a remote machine by using <code>docker-compose</code> and I get the following error.</p>  <pre><code>java.lang.IllegalStateException: Could not locate PropertySource and the fail fast property is set, failing my-test_1  |    at org.springframework.cloud.config.client.ConfigServicePropertySourceLocator.locate(ConfigServicePropertySourceLocator.java:132) my-test_1  |    at org.springframework.cloud.bootstrap.config.PropertySourceBootstrapConfiguration.initialize(PropertySourceBootstrapConfiguration.java:93) my-test_1  |    at org.springframework.boot.SpringApplication.applyInitializers(SpringApplication.java:567) my-test_1  |    at org.springframework.boot.SpringApplication.prepareContext(SpringApplication.java:338) my-test_1  |    at org.springframework.boot.SpringApplication.run(SpringApplication.java:301) my-test_1  |    at net.ptidej.seodin.SeodinApp.main(SeodinApp.java:68) my-test_1  |    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) my-test_1  |    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) my-test_1  |    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) my-test_1  |    at java.lang.reflect.Method.invoke(Method.java:498) my-test_1  |    at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:48) my-test_1  |    at org.springframework.boot.loader.Launcher.launch(Launcher.java:87) my-test_1  |    at org.springframework.boot.loader.Launcher.launch(Launcher.java:50) my-test_1  |    at org.springframework.boot.loader.WarLauncher.main(WarLauncher.java:59) my-test_1  | Caused by: org.springframework.web.client.ResourceAccessException: I/O error on GET request for 'http://localhost:8761/config/seodin/prod/master': Connection refused (Connection refused); nested exception is java.net.ConnectException: Connection refused (Connection refused) my-test_1  |    at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:674) my-test_1  |    at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:621) my-test_1  |    at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:539) my-test_1  |    at org.springframework.cloud.config.client.ConfigServicePropertySourceLocator.getRemoteEnvironment(ConfigServicePropertySourceLocator.java:172) my-test_1  |    at org.springframework.cloud.config.client.ConfigServicePropertySourceLocator.locate(ConfigServicePropertySourceLocator.java:93) my-test_1  |    ... 13 common frames omitted my-test_1  | Caused by: java.net.ConnectException: Connection refused (Connection refused) my-test_1  |    at java.net.PlainSocketImpl.socketConnect(Native Method) my-test_1  |    at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350) my-test_1  |    at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206) my-test_1  |    at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188) my-test_1  |    at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392) my-test_1  |    at java.net.Socket.connect(Socket.java:589) my-test_1  |    at java.net.Socket.connect(Socket.java:538) my-test_1  |    at sun.net.NetworkClient.doConnect(NetworkClient.java:180) my-test_1  |    at sun.net.www.http.HttpClient.openServer(HttpClient.java:463) my-test_1  |    at sun.net.www.http.HttpClient.openServer(HttpClient.java:558) my-test_1  |    at sun.net.www.http.HttpClient.&lt;init&gt;(HttpClient.java:242) my-test_1  |    at sun.net.www.http.HttpClient.New(HttpClient.java:339) my-test_1  |    at sun.net.www.http.HttpClient.New(HttpClient.java:357) my-test_1  |    at sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1220) my-test_1  |    at sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1156) my-test_1  |    at sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:1050) my-test_1  |    at sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:984) my-test_1  |    at org.springframework.http.client.SimpleBufferingClientHttpRequest.executeInternal(SimpleBufferingClientHttpRequest.java:78) my-test_1  |    at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48) my-test_1  |    at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:53) my-test_1  |    at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:112) my-test_1  |    at org.springframework.cloud.config.client.ConfigServicePropertySourceLocator$GenericRequestHeaderInterceptor.intercept(ConfigServicePropertySourceLocator.java:237) my-test_1  |    at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:88) my-test_1  |    at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:72) my-test_1  |    at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48) my-test_1  |    at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:53) my-test_1  |    at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:660) my-test_1  |    ... 17 common frames omitted my-test_1  |  </code></pre>  <p>I am guessing it has something to do with ports in one of the config files, but I don't know which one. What is the meaning of this error and where should I look to resolve it? I would appreciate any lead/hint to the problem in the source code/config files. Thank you.</p> ",
    "OwnerUserId": "4244347",
    "LastEditorUserId": "3094805",
    "LastEditDate": "2018-07-18T15:57:53.683",
    "LastActivityDate": "2023-11-13T08:01:55.213",
    "Title": "Could not locate PropertySource because of java.net.ConnectException: Connection refused",
    "Tags": "<spring><docker><spring-boot><docker-compose><microservices>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Your Spring Boot app is configured to load properties from a Spring Cloud Config server specified at</p>  <p><a href='http://localhost:8761/config/seodin/prod/master' rel='nofollow noreferrer'>http://localhost:8761/config/seodin/prod/master</a> </p>  <p>and it can't see it.</p>  <p>As you are running in Docker either make sure that a config server is running in Docker as well, and that your Spring Boot app is configured to point at that (the URL will not be localhost; it's likely to be the container name of the config server ifyou are running that in Docker, or the URL of an external config server)</p> "
  },
  {
    "Id": "51400896",
    "PostTypeId": "1",
    "CreationDate": "2018-07-18T11:28:23.663",
    "Score": "3",
    "ViewCount": "3133",
    "Body": "<p>I am trying to containerize one of my microservices using docker.</p>  <p>Below is the dokerfile content</p>  <pre><code>FROM openjdk:8-jdk-alpine    LABEL maintainer='shardajaiswal@gmail.com'  RUN mkdir -p /test/service/master/input/ RUN mkdir -p /test/service/master/output/ VOLUME /test/service/master/input/ VOLUME /test/service/master/output/  EXPOSE 8080 ARG JAR_FILE=target/master-1.1-SNAPSHOT.jar ADD ${JAR_FILE} master-1.1-SNAPSHOT.jar ENTRYPOINT ['java', '-jar','master-1.1-SNAPSHOT.jar'] </code></pre>  <p>I have created image using maven plugin successfully.</p>  <p>Now when I try to run the image using the below command on docker CLI the service is up and running fine</p>  <pre><code>docker run -p 7070:8080 -e spring.cloud.config.username=username123 -e \\spring.cloud.config.password=password123 -e \\spring.cloud.config.failFast=true -e \\spring.cloud.config.discovery.enabled=true -e \\eureka.client.serviceUrl.defaultZone=http://username123:password123@10.XXX.21.161:31120/eureka/,http://username123:password123@10.XXX.147.171:31120/eureka/  -e \\spring.profiles.active=staging,XYZServerName shardaspj:master-1.1-SNAPSHOT </code></pre>  <p>With above command from command line, its able to connect to config server and also able to register with Eureka.</p>  <p>Now I want to run the service using docker-compose.yml file since I want to add certain other parameters as well to the configuration.</p>  <p>My docker-compose.yml file looks like below:-</p>  <pre><code>version: '3.0' services:  master:   container_name: master   image: shardaspj:master-1.1-SNAPSHOT   environment:    SPRING_CLOUD_CONFIG_USERNAME: username123    SPRING_CLOUD_CONFIG_PASSWORD: password123    SPRING_CLOUD_CONFIG_FAILFAST: 'true'    SPRING_CLOUD_CONFIG_DISCOVERY_ENABLED: 'true'    EUREKA_CLIENT_SERVICE-URL_DEFAULTZONE: http://username123:password123@10.XXX.21.161:31120/eureka/,http://username123:password123@10.XXX.147.171:31120/eureka/    SPRING_PROFILES_ACTIVE: staging,XYZServerName  ports:    - '7070:8080' </code></pre>  <p>But on running the command docker-compose up on command line I am getting the below error and not able to connect to register on eureka and also not connecting to config server to fetch the configuration files.</p>  <pre><code>master    | 2018-07-18 11:18:51.867  WARN [master,,,] 1 --- [           main] c.n.d.s.t.d.RetryableEurekaHttpClient    : Request execution failed with message: java.net.ConnectException: Connectio n refused (Connection refused) master    | 2018-07-18 11:18:51.873 ERROR [master,,,] 1 --- [           main] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_MASTER/cd656dee7969:master - was unable to refresh its cach e! status = Cannot execute request on any known server master    | master    | com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server master    |     at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:111) master    |     at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134) master    |     at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137) master    |     at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77) master    |     at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134) master    |     at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1022) master    |     at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:936) master    |     at com.netflix.discovery.DiscoveryClient.&lt;init&gt;(DiscoveryClient.java:412) master    |     at com.netflix.discovery.DiscoveryClient.&lt;init&gt;(DiscoveryClient.java:267) master    |     at org.springframework.cloud.netflix.eureka.CloudEurekaClient.&lt;init&gt;(CloudEurekaClient.java:61) master    |     at org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration$EurekaClientConfiguration.eurekaClient(EurekaClientAutoConfiguration.java:234) master    |     at org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration$EurekaClientConfiguration$$EnhancerBySpringCGLIB$$f480408d.CGLIB$eurekaClient$0(&lt;generated&gt;) master    |     at org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration$EurekaClientConfiguration$$EnhancerBySpringCGLIB$$f480408d$$FastClassBySpringCGLIB$$cdb46f4f.invoke(&lt;gener ated&gt;) </code></pre>  <p>Also down the logs getting error:-</p>  <pre><code>2018-07-18 11:18:51.876  WARN [master,,,] 1 --- [           main] com.netflix.discovery.DiscoveryClient    : Using default backup registry implementation which does not do anything. 2018-07-18 11:18:51.886  INFO [master,,,] 1 --- [           main] com.netflix.discovery.DiscoveryClient    : Not registering with Eureka server per configuration 2018-07-18 11:18:51.951  INFO [master,,,] 1 --- [           main] com.netflix.discovery.DiscoveryClient    : Discovery Client initialized at timestamp 1531912731950 with initial instances count : 0  2018-07-18 11:18:53.381  WARN [master,,,] 1 --- [           main] lientConfigServiceBootstrapConfiguration : Could not locate configserver via discovery  java.lang.IllegalStateException: No instances found of configserver (registry)     at org.springframework.cloud.config.client.ConfigServerInstanceProvider.getConfigServerInstance(ConfigServerInstanceProvider.java:25)     at org.springframework.cloud.config.client.DiscoveryClientConfigServiceBootstrapConfiguration.refresh(DiscoveryClientConfigServiceBootstrapConfiguration.java:80)     at org.springframework.cloud.config.client.DiscoveryClientConfigServiceBootstrapConfiguration.startup(DiscoveryClientConfigServiceBootstrapConfiguration.java:66)     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke(Method.java:498)     at org.springframework.context.event.ApplicationListenerMethodAdapter.doInvoke(ApplicationListenerMethodAdapter.java:256)     at org.springframework.context.event.ApplicationListenerMethodAdapter.processEvent(ApplicationListenerMethodAdapter.java:177)     at org.springframework.context.event.ApplicationListenerMethodAdapter.onApplicationEvent(ApplicationListenerMethodAdapter.java:140)     at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172)     at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) </code></pre>  <p>Please help me with setting up the docker-compose.yml correctly.</p> ",
    "OwnerUserId": "1745202",
    "LastEditorUserId": "1745202",
    "LastEditDate": "2018-07-18T11:39:35.917",
    "LastActivityDate": "2020-07-14T11:26:01.367",
    "Title": "Eureka Client with Docker Compose",
    "Tags": "<docker><spring-boot><docker-compose><dockerfile>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>You are probably better off blanking out all the values for the environment variables in your docker-compose file and putting them in a .env file at the same level as your docker-compose file. The format of this file is key=value, one per line. That way you can re-use your compose file in different environments.</p>  <p>Then do a docker-compose config to see how the environment variables are plugged into your docker-compose set up.</p>  <p>I think the issue you have is you are missing hyphens. Instead of this:</p>  <pre><code>environment:    SPRING_CLOUD_CONFIG_USERNAME    SPRING_CLOUD_CONFIG_PASSWORD    SPRING_CLOUD_CONFIG_FAILFAST </code></pre>  <p>You need something like this:</p>  <pre><code>environment:    - SPRING_CLOUD_CONFIG_USERNAME    - SPRING_CLOUD_CONFIG_PASSWORD    - SPRING_CLOUD_CONFIG_FAILFAST </code></pre>  <p>Running docker-compose config after you've moved the values into .env will show if you've got it all working OK.</p> "
  },
  {
    "Id": "51827759",
    "PostTypeId": "1",
    "CreationDate": "2018-08-13T17:35:50.133",
    "Score": "3",
    "ViewCount": "3830",
    "Body": "<p>I have a small application where use I use redis for cache and Spring Boot. Application runs successfully in local but when I try to dockerize it, I'm getting connection refuse exception.</p>  <p>It's my docker-compose.yml file:</p>  <pre><code>version: '3.5'  services:   my-application:     image: my-application:latest     container_name: my-application     ports:       - 8080:8080     hostname: my-application    redis:     image: redis     command: [ 'redis-server', '--protected-mode', 'no' ]     volumes:       - ./data:/data     ports:       - 6379:6379    </code></pre>  <p>Dockerfile:</p>  <pre><code>FROM openjdk:7  VOLUME /tmp  ADD my-application-0.0.1.jar my-application-0.0.1.jar  EXPOSE 8080  ENTRYPOINT ['java', '-Djava.security.egd=file:/dev/./urandom', '-jar', 'my-application-0.0.1.jar'] </code></pre>  <p>When I check docker console, I saw that redis starts in standalone mode </p>  <p>What I'm missing ?</p>  <p>Thanks  </p> ",
    "OwnerUserId": "1934168",
    "LastEditorUserId": "2541276",
    "LastEditDate": "2018-08-17T13:15:16.740",
    "LastActivityDate": "2020-11-29T21:11:51.047",
    "Title": "Spring Boot Redis getting connection refused exception when using Redis",
    "Tags": "<docker><spring-boot><redis><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>You have to set:</p>  <pre><code>server.address=0.0.0.0 </code></pre>  <p>in your <code>application.properties</code>. If your application is listen on <code>127.0.0.1</code> in the container, you won't be able to reach it from your host.</p> "
  },
  {
    "Id": "52707667",
    "PostTypeId": "1",
    "CreationDate": "2018-10-08T17:52:28.553",
    "Score": "3",
    "ViewCount": "3743",
    "Body": "<p>I need to control the order of Docker containers instantiation, the problem is that I want to build a Jar file with the Docker maven container then pass that jar to an OpenJDK Docker container in order to build an image and then instantiate a MongoDB container and a Java-App container with the OpenJDK image generated before that communicates between them via docker-compose.</p>  <p>The problem is the Build always fails because some of the Unit tests talk to the database before it's initialized and since the tests fail the build also fails.</p>  <p>This is my dockerfile:</p>  <pre><code>FROM maven:3.5-alpine COPY ./ /app RUN cd /app &amp;&amp; mvn package  FROM openjdk:8 COPY spring-rest-iw-exam.jar /tmp/spring-rest-iw-exam.jar EXPOSE 8087 ENTRYPOINT ['java', '-jar', '/tmp/spring-rest-iw-exam.jar'] </code></pre>  <p>This is my Docker-Compose:</p>  <pre><code>version: '2' services:   mongodb:     image: mongo     container_name: iw_exam_mongo     restart: always     ports:     - '27017:27017'     environment:     - MONGO_INITDB_DATABASE=fizz_buzz_collection     volumes:     - /opt/iw-exam/data:/data/db   spring-app:     container_name: iw_exam_java_rest_api     build: ./     restart: always     ports:     - '8087:8087'     depends_on:     - mongodb </code></pre>  <p>I tried with depends_on and did some other tests with a tool call dockerize but none of it works, the maven build always starts before docker-compose even start to instantiate mongodb.</p>  <p>This is the github repository of the proyect: <a href='https://github.com/dsalasboscan/exam' rel='nofollow noreferrer'>https://github.com/dsalasboscan/exam</a></p>  <p>I need to instantiate Mongodb first and THEN start with the maven build and java image generation.</p> ",
    "OwnerUserId": "7875487",
    "LastActivityDate": "2021-01-06T16:06:57.047",
    "Title": "Docker-Compose - Control docker-compose execution order",
    "Tags": "<java><maven><docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>I came across similar problem before, and would like to share my experience. </p>  <p>Basically, we need to wait for a while to make sure mongodb is completely boot up, here is the <a href='https://github.com/ufoscout/docker-compose-wait' rel='nofollow noreferrer'>tool</a> that you can leverage. It's fairly easy to use.</p> "
  },
  {
    "Id": "54238132",
    "PostTypeId": "1",
    "CreationDate": "2019-01-17T14:32:34.787",
    "Score": "3",
    "ViewCount": "100",
    "Body": "<p>I create 2 spring boot application. ConnectToBd and ResourceCalculate</p>  <p>application.properties:</p>  <pre><code>nsi.url=http://ip:port/odo/find/root/ bd_connect=http://ip:port/connect-to-bd/getdata? </code></pre>  <p>Spring controller:</p>  <pre><code>@PropertySource('application.properties') @RestController public class ResourceCalculateCntr {  @Value('${nsi.url}') private String nsi;  @Value('${bd_connect}') private String connect;  @RequestMapping(value = 'getProperties', method = RequestMethod.GET) public String retProps() {     return nsi + '    ' + connect; } </code></pre>  <p>build with gradle</p>  <p>Dockerfile bdconnect and calculate. Example:</p>  <pre><code>FROM openjdk:8 EXROSE 8080 ADD resourceCalculate.war resourceCalculate.war ENTRYPOINT ['java', '-jar', 'resourceCalculate.war'] </code></pre>  <p>docker build succesfull</p>  <p>then I use docker-compose:</p>  <pre><code>version: '3'  services:   calc:     image: calculate     container_name: calc     ports:       - '2020:8080'     enviroment:       - bd_connect=connect     depend_on:       - connect     links:       - connect     networks:       - calc-net   connect:     image: dbconnect     container_name: connect     ports:       - '1010:8080'     networks:       - calc_net  networks:   calc_net:     driver: bridge </code></pre>  <p>do docker-compose up and write: Creating done Then I enter in container: 'docker-compose exec calc sh' and 'ping connect' all okey But if I request webservice in browser I see response:</p>  <pre><code>http://ip:port/odo/find/root/ connect </code></pre>  <p>Why so? </p> ",
    "OwnerUserId": "10928395",
    "LastActivityDate": "2019-01-17T14:32:34.787",
    "Title": "docker-compose + spring boot few application don't connect",
    "Tags": "<java><spring><spring-boot><docker><docker-compose>",
    "AnswerCount": "0",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": null
  },
  {
    "Id": "54403380",
    "PostTypeId": "1",
    "CreationDate": "2019-01-28T13:46:48.873",
    "Score": "3",
    "ViewCount": "3466",
    "Body": "<p>I am new to Docker. I am using Spring boot micro service. It's running well On my local machine. Now, I need to create a docker image for my application. It has a dependency on Mysql server. I am using docker-compose to create my containers. I am getting a communications link failure error while running my custom image (spring boot application). The Mysql image is running well independently. </p>  <p>My yml file :</p>  <pre><code>version: '2'  services:    mysql-dev:     image: mysql:5.7     container_name: mysql-dev     environment:       MYSQL_ROOT_PASSWORD: 'password'       MYSQL_DATABASE: 'onlinetutorialspoint'     networks:       - my_mysql_net     ports:       - 3306:3308    spring_boot_db_service:     depends_on:       - mysql-dev     image: spring_boot_db_service     ports:       - 8181:8181     links:       - mysql-dev:mysql     networks:       - my_mysql_net  networks:   my_mysql_net:     driver: bridge  </code></pre>  <p>application properties file :</p>  <pre><code>db.driver: com.mysql.jdbc.Driver  spring.datasource.url = jdbc:mysql://mysql-dev:3308/onlinetutorialspoint?useSSL=false  spring.datasource.username = root  spring.datasource.password = password </code></pre>  <p>Full Error Message :</p>  <blockquote>   <p>spring_boot_db_service_1  | 2019-01-28 13:34:06.955  INFO 1 --- [<br>   main] org.hibernate.cfg.Environment            : HHH000206:   hibernate.properties not found spring_boot_db_service_1  | 2019-01-28   13:34:07.000  INFO 1 --- [           main]   o.hibernate.annotations.common.Version   : HCANN000001: Hibernate   Commons Annotations {5.0.1.Final} spring_boot_db_service_1  |   2019-01-28 13:34:08.430  WARN 1 --- [           <strong>main]   o.h.e.j.e.i.JdbcEnvironmentInitiator     : HHH000342: Could not obtain   connection to query metadata : Communications link failure</strong>   spring_boot_db_service_1  |  spring_boot_db_service_1  | The last   packet sent successfully to the server was 0 milliseconds ago. The   driver has not received any packets from the server.   spring_boot_db_service_1  | 2019-01-28 13:34:08.443  INFO 1 --- [<br>   main] org.hibernate.dialect.Dialect            : HHH000400: Using   dialect: org.hibernate.dialect.MySQL5Dialect spring_boot_db_service_1    | 2019-01-28 13:34:08.459  INFO 1 --- [           main]   o.h.e.j.e.i.LobCreatorBuilderImpl        : HHH000422: Disabling   contextual LOB creation as connection was null   spring_boot_db_service_1  | 2019-01-28 13:34:08.921  WARN 1 --- [<br>   main] ConfigServletWebServerApplicationContext : Exception encountered   during context initialization - cancelling refresh attempt:   org.springframework.beans.factory.UnsatisfiedDependencyException:   Error creating bean with name 'dbServiceImpl': Unsatisfied dependency   expressed through field 'dbServiceDao'; nested exception is   org.springframework.beans.factory.UnsatisfiedDependencyException:   <strong>Error creating bean with name 'dbServiceDaoImpl': Unsatisfied dependency expressed through field 'sessionFactory'; nested exception   is org.springframework.beans.factory.BeanCreationException: Error   creating bean with name 'sessionFactory'</strong> defined in class path   resource [com/htc/dbservice/configuration/DBConfiguration.class]:   Invocation of init method failed; nested exception is   org.hibernate.MappingException: Could not get constructor for   org.hibernate.persister.entity.SingleTableEntityPersister   spring_boot_db_service_1  | 2019-01-28 13:34:08.923  WARN 1 --- [<br>   main] o.s.b.f.support.DisposableBeanAdapter    : Invocation of destroy   method 'close' failed on bean with name 'eurekaRegistration':   org.springframework.beans.factory.BeanCreationNotAllowedException:   Error creating bean with name   'org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration$RefreshableEurekaClientConfiguration':   Singleton bean creation not allowed while singletons of this factory   are in destruction (Do not request a bean from a BeanFactory in a   destroy method implementation!) spring_boot_db_service_1  | 2019-01-28   13:34:08.926  INFO 1 --- [           main]   o.apache.catalina.core.StandardService   : Stopping service [Tomcat]   docker_spring_boot_db_service_1 exited with code 1</p> </blockquote> ",
    "OwnerUserId": "6907939",
    "LastEditorUserId": "7218679",
    "LastEditDate": "2019-01-28T14:57:13.553",
    "LastActivityDate": "2019-01-30T13:39:44.113",
    "Title": "Unable to link mysql docker container with spring boot application - Communications link failure",
    "Tags": "<mysql><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "5",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Did you change the default mysql port? if not, you are pointing to wrong port number. When you map the port to pubilsh the service externally, the order is </p>  <pre><code>&lt;host-port&gt;:&lt;container-port&gt; </code></pre>  <pre><code>services:       mysql-dev:        image: mysql:5.7        container_name: mysql-dev        environment:          MYSQL_ROOT_PASSWORD: 'password'          MYSQL_DATABASE: 'onlinetutorialspoint'        networks:          - my_mysql_net        ports:          - 3308:3306   </code></pre>  <p>And using docker-compose and connecting both services to the same network you can connect directly to the container without pubishing the mysql port to the external network. Try to change your spring app pointing to mysql-dev:3306, or try to connect to the  container <strong>spring_boot_db_service</strong> using </p>  <pre><code>docker-compose exec spring_boot_db_service bash   </code></pre>  <p>and make a connectivity test to the database container.</p> "
  },
  {
    "Id": "55084722",
    "PostTypeId": "1",
    "AcceptedAnswerId": "55229628",
    "CreationDate": "2019-03-10T05:26:14.703",
    "Score": "3",
    "ViewCount": "11938",
    "Body": "<p>I am building an application by Spring Cloud ,Spring Boot and Docker. Entire application is working fine. I have couple of micro-services. Each of the project is running on Docker. When I try to consume my micro-services through Zuul API Gateway I am getting an error for the 1st call. But if I refresh the browser it's working fine. The error is given below--</p>  <pre><code>2019-03-10 04:54:55.440  WARN [netflix-  zuul-api-gateway-  server,1855093598d4f99c,1855093598d4f99c true] 1 --- [nio-8765-exec-1]  o.s.c.n.z.filters.post.SendErrorFilter    : Error during filtering   com.netflix.zuul.exception.ZuulException  at  org.springframework.cloud.netflix.zuul. filters.post.SendErrorFilter. findZuulException(SendErrorFilter.java: 114) ~[spring-cloud-netflix-zuul-  2.1.0.RC3.jar!/:2.1.0.RC3] at  org.springframework.cloud.netflix.zuul. filters.post.SendErrorFilter.run (SendErrorFilter.java:76) ~[spring-  cloud-  netflix-zuul-2.1.0.RC3.jar!/ :2.1.0.RC3] at  com.netflix.zuul.ZuulFilter.runFilter (ZuulFilter.java:117) [zuul-core-  1.3.1.jar!/:1.3.1] at  com.netflix.zuul.FilterProcessor. processZuulFilter(FilterProcessor. java:193) [zuul-core-1.3.1.jar!/:1.3.1]  at  com.netflix.zuul.FilterProcessor. runFilters(FilterProcessor.java:157)  [zuul-core-1.3.1.jar!/:1.3.1] at  com.netflix.zuul.FilterProcessor.error (FilterProcessor.java:105) [zuul-core-  1.3.1.jar!/:1.3.1] at com.netflix.zuul.ZuulRunner.error (ZuulRunner.java:112) [zuul-core-  1.3.1.jar!/:1.3.1] at  com.netflix.zuul.http.ZuulServlet.error (ZuulServlet.java:145) [zuul-core-  1.3.1.jar!/:1.3.1] at  com.netflix.zuul.http.ZuulServlet.servic e(ZuulServlet.java:83) [zuul-core-  1.3.1.jar!/:1.3.1] at org.springframework.web.servlet.mvc. Servlet  letWrappingController.java:165) [spring-  webmvc-  5.1.3.RELEASE.jar!/:5.1.3.RELEASE] at org.spr </code></pre>  <p>I have already created the images for all my projects. And push it in the DockerHub. And the Docker-Compose file I also push it in the GitHub. Below is the path.</p>  <p><a href='https://github.com/numery009/DockerCompose/blob/master/docker-compose.yaml' rel='nofollow noreferrer'>https://github.com/numery009/DockerCompose/blob/master/docker-compose.yaml</a> </p>  <p>I also deploy it on the Docker Swarm on EC2.  But When I try to consume my micro-services through Zuul it's not working at all. And I am getting the same 'Filter Error' for my every request.</p>  <p>Please help!!!.</p> ",
    "OwnerUserId": "5222307",
    "LastActivityDate": "2020-11-02T09:31:50.193",
    "Title": "ZuulException (SendErrorFilter) at first call",
    "Tags": "<spring-boot><docker><docker-compose><spring-cloud><netflix-zuul>",
    "AnswerCount": "3",
    "CommentCount": "7",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>There should be 3 things we need to keep on the top of our head for the request which are gone through the Zuul</p>  <p>1) According to this Document - <a href='https://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/1.4.3.RELEASE/single/spring-cloud-netflix.html#_zuul_eager_application_context_loading' rel='noreferrer'>https://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/1.4.3.RELEASE/single/spring-cloud-netflix.html#_zuul_eager_application_context_loading</a></p>  <p>Zuul internally uses Ribbon for calling the remote url\u2019s and Ribbon clients are by default lazily loaded up by Spring Cloud on first call. This behavior can be changed for Zuul using the following configuration and will result in the child Ribbon related Application contexts being eagerly loaded up at application startup time.</p>  <p>application.yaml</p>  <pre><code>zuul:    ribbon:       eager-load:          enabled: true </code></pre>  <p>application.properties</p>  <pre><code>zuul.ribbon.eager-load.enabled= true </code></pre>  <p>2) According to this Document - <a href='http://cloud.spring.io/spring-cloud-static/Edgware.SR3/single/spring-cloud.html#_service_discovery_configuration' rel='noreferrer'>http://cloud.spring.io/spring-cloud-static/Edgware.SR3/single/spring-cloud.html#_service_discovery_configuration</a></p>  <p><strong>Service Discovery Configuration</strong> --- If Zuul is using service discovery there are two timeouts you need to be concerned with, the Hystrix timeout (since all routes are wrapped in Hystrix commands by default) and the Ribbon timeout. The Hystrix timeout needs to take into account the Ribbon read and connect timeout PLUS the total number of retries that will happen for that service. By default Spring Cloud Zuul will do its best to calculate the Hystrix timeout for you UNLESS you specify the Hystrix timeout explicitly.</p>  <p>The Hystrix timeout is calculated using the following formula:</p>  <pre><code>(ribbon.ConnectTimeout + ribbon.ReadTimeout) * (ribbon.MaxAutoRetries + 1) *  (ribbon.MaxAutoRetriesNextServer + 1) </code></pre>  <p>As an example, if you set the following properties in your application properties</p>  <p>application.yaml</p>  <pre><code>ribbon:    ReadTimeout:100    ConnectTimeout:500    MaxAutoRetries:1    MaxAutoRetriesNextServer:1 </code></pre>  <p>application.properties</p>  <pre><code>ribbon.ReadTimeout= 100 ribbon.ConnectTimeout= 500 ribbon.MaxAutoRetries= 1 ribbon.MaxAutoRetriesNextServer= 1 </code></pre>  <p>Then the Hystrix timeout (for all routes in this case) will be set to 2400ms.</p>  <hr>  <p>In my zuul application config I have added the following properties. And it's working for my 1st call with out any error. </p>  <p>application.yaml</p>  <pre><code>hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 11000  ribbon:    ConnectTimeout: 10000    ReadTimeout: 10000 </code></pre>  <p>application.properties</p>  <pre><code>hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds= 11000  ribbon.ConnectTimeout= 10000 ribbon.ReadTimeout: 10000 </code></pre>  <p>3) This is the most easiest way. Disable the hystrix execution time out.</p>  <p>According to this Document -<a href='https://github.com/Netflix/Hystrix/wiki/Configuration#executiontimeoutenabled' rel='noreferrer'>https://github.com/Netflix/Hystrix/wiki/Configuration#executiontimeoutenabled</a></p>  <p>Following property will disable the hystrix execution time out on Zuul</p>  <p>application.properties</p>  <pre><code>hystrix.command.default.execution.timeout.enabled=false </code></pre>  <p>If we keep remember these 3 scenarios then we can easily get the solution of ZuulException (SendErrorFilter).</p> ",
    "highest_rated_answer": "<p>According to <a href='http://cloud.spring.io/spring-cloud-static/Finchley.SR1/single/spring-cloud.html#_zuul_eager_application_context_loading' rel='nofollow noreferrer'>this documentation</a>:</p>  <blockquote>   <p>Zuul internally uses Ribbon for calling the remote URLs. By default, Ribbon clients are lazily loaded by Spring Cloud on first call. This behavior can be changed for Zuul by using the following configuration, which results eager loading of the child Ribbon related Application contexts at application startup time.</p> </blockquote>  <p>The following example shows how to enable eager loading:</p>  <pre><code># application.yml zuul:   ribbon:     eager-load:       enabled: true </code></pre>  <p>Or</p>  <pre><code># application.properties ribbon.eager-load.enabled = true </code></pre>  <p>You might need to check the following related issues:</p>  <ul> <li><a href='https://github.com/spring-cloud/spring-cloud-netflix/issues/3021#issuecomment-413169329' rel='nofollow noreferrer'>Ryan Baxter's comment</a></li> <li><a href='https://github.com/spring-cloud/spring-cloud-netflix/issues/1783' rel='nofollow noreferrer'>First request through Zuul/Euruka will always timeout. Subsequent requests then behave as expected (no timeouts)</a></li> </ul> "
  },
  {
    "Id": "55121579",
    "PostTypeId": "1",
    "AcceptedAnswerId": "55122007",
    "CreationDate": "2019-03-12T12:32:55.090",
    "Score": "3",
    "ViewCount": "2107",
    "Body": "<p>I have a spring boot application which connects to a Mongo database. I have created a docker-compose file. The spring boot application has two instances. First instance runs on 8080 and 27017, which works perfectly fine. Now the second instance runs on 8083 and 27018. I can easily connect to 27017 and 27018 through Mongo GUI. However, when I run docker-compose up for the second instance, the spring boot gives the exception.</p>  <p>Following are my docker-compose files:</p>  <p><strong>First Instance(docker-compose.yml):</strong></p>  <pre><code>version: '3' services:   app:     container_name: HR-BACKEND     restart: always     build: .     ports:       - '8081:8080' #VF Webservice     links:       - mongo  mongo:     container_name: MONGOHR     image: mongo:4.0.2     ports:       - '27017:27017'     volumes:       - /data/hrdb:/data/db </code></pre>  <p><strong>First Instance (application.properties)</strong></p>  <pre><code>spring.data.mongodb.uri=mongodb://mongo:27017/tsp </code></pre>  <p><strong>Second Instance(docker-compose.yml):</strong></p>  <pre><code>version: '3' services:   app:     container_name: VF-BACKEND     restart: always     build: .     ports:       - '8083:8080' #VF Webservice     links:       - mongovf  mongovf:     container_name: MONGOVF     image: mongo:4.0.2     ports:       - '27018:27017'     volumes:       - /data/hrdb:/data/db </code></pre>  <p><strong>Second Instance (application.properties)</strong></p>  <pre><code>spring.data.mongodb.uri=mongodb://mongovf:27018/tsp </code></pre>  <p><strong>Docker version:</strong> </p>  <blockquote>   <p>Docker version 18.09.1, build 4c52b90</p> </blockquote>  <p>. I could not really find a solution in SO. Please let me know if more details are needed</p> ",
    "OwnerUserId": "617734",
    "LastEditorUserId": "107049",
    "LastEditDate": "2019-03-12T12:55:16.237",
    "LastActivityDate": "2019-03-12T12:55:16.237",
    "Title": "Exception opening socket exception when trying to connect docker container to mongodb",
    "Tags": "<mongodb><spring-boot><docker><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>In your second instance you are trying to connect to mongo on the wrong port. application.property should be:</p>  <p><code>spring.data.mongodb.uri=mongodb://mongovf:27017/tsp</code></p>  <hr>  <p>In a docker compose context, you connect directly to containers without going through the docker host. This is why you have to connect directly to the container port instead of trying to connect through the port published on the docker host.</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "55144892",
    "PostTypeId": "1",
    "CreationDate": "2019-03-13T14:55:49.123",
    "Score": "3",
    "ViewCount": "419",
    "Body": "<p>I have created a docker container for a springboot application. one of my method in the application calls a webservice (rest api) which is hosted on aws instance.</p>  <p>When the application runs in docker I get <code>org.springframework.web.client.HttpClientErrorException: 404 Not Found</code> exception.</p>  <p>When the application runs outside docker, it works fine.</p>  <p>I am not sure if there is anything which needs to be set or configured. Help appreciated.</p> ",
    "OwnerUserId": "3153928",
    "LastActivityDate": "2019-03-13T14:55:49.123",
    "Title": "Calling external web service from docker container java spring boot app",
    "Tags": "<java><spring-boot><docker-compose>",
    "AnswerCount": "0",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": null
  },
  {
    "Id": "56000337",
    "PostTypeId": "1",
    "AcceptedAnswerId": "58080306",
    "CreationDate": "2019-05-06T07:10:11.327",
    "Score": "3",
    "ViewCount": "548",
    "Body": "<p>I'm using docker to publish my spring-boot application with neo4j and mssql database. </p>  <p>I'm getting an exception<i> 500:Internal Server Error</i> when I'm trying to retrieve data from  Neoj4Repository, however the exception occurs only when the application published on docker. When I'm starting spring-boot application inside Intellij Idea everything is fine. When it's published to the docker-compose Neo4jRepository <b> Optional findById()</b> throws NullPointerException and other methods <b> CollectionfindFriendsById() </b> throw ArrayIndexBoundException. Furthermore when I'm trying to find my data in Neo4jBrowser <i> <a href='http://localhost:7474/browser/' rel='nofollow noreferrer'>http://localhost:7474/browser/</a> </i> - it works great. I see all data in my database, besides every query is successful. I'm attaching the code and config files. I would be very grateful if you could help me with my trouble. Please don't hesitate to give me any idea. Thanks a lot.</p>  <p>I've tried to use neo4j database inside docker-compose with my application instance.</p>  <p><strong>[Edited]:</strong> As I understood spring-boot-app doesn't see <em>neo4j</em> server overall. However the app communicates with <em>mssql</em> successfully, they are both on localhost. </p>  <p>My  <b> docker-compose.yaml file: </b></p>  <pre><code>version: '3' services:   docker-neo4j:     image: neo4j:3.5.5     ports:     - '7474:7474'     - '7687:7687'     volumes:       - /var/lib/neo4j/data:/data       - /var/lib/neo4j/logs:/logs    docker-current-app:     image: current:latest     depends_on:     - docker-neo4j     build:       context: ./       dockerfile: Dockerfile     volumes:       - /usr/app/springboot-docker-compose-app     network_mode: host     environment:     - JWT_SECRET=     - JWT_EXPIRATION_TIME_MS= </code></pre>  <p><b> DockerFile for app</b></p>  <pre><code>FROM openjdk:8-jdk-alpine COPY ./target/current-*.jar /usr/app/current-build.jar WORKDIR /usr/app ENTRYPOINT ['java','-jar','current-build.jar'] </code></pre>  <p><b>application.properties file </b></p>  <pre><code>spring.datasource.url=jdbc:sqlserver://localhost;database=dbForMe spring.datasource.username=SA spring.datasource.password=password spring.jpa.hibernate.ddl-auto=none spring.data.neo4j.uri=bolt://localhost spring.data.neo4j.username=neo4j spring.data.neo4j.password=password </code></pre>  <p><b> Repository/service/controller </b></p>  <pre class='lang-java prettyprint-override'><code> @Repository public interface Neo4jUserRepository extends Neo4jRepository&lt;NeoUser, Long&gt; {      Optional&lt;NeoUser&gt; findByUuid(String userId);      @Query('MATCH (u:User {uuid : {itemId}})&lt;-[:REQUEST]-(u2:User) RETURN u2')     Collection&lt;NeoUser&gt; findRequestsById(@Param('itemId') String userId);      @Query('MATCH (u:User {uuid:{itemId}})-[:FRIENDS]-(u2:User) RETURN u2')     Collection&lt;NeoUser&gt; findFriendsById(@Param('itemId') String userId);  }  @Service public class RelationshipsService {      private static final Logger log = LoggerFactory.getLogger(RelationshipsService.class.getName());      private final Neo4jUserRepository userRepository;  public RelationshipsService(Neo4jUserRepository userRepository) {         this.userRepository = userRepository;     }   public List&lt;UserPreview&gt; getReceivedRequests(String userId) {         log.info('Getting requests for itemId {}', userId);         return userRepository.findRequestsById(userId).stream()                 .map(this::toUserPreview)                 .collect(Collectors.toList());     }      public List&lt;UserPreview&gt; getFriends(String userId) {         log.info('Getting friends for itemId {}', userId);         return userRepository.findFriendsById(userId).stream()                 .map(this::toUserPreview)                 .collect(Collectors.toList());     } }  @RestController @RequestMapping('/relationships') public class RelationshipController {      private final RelationshipsService service;      public RelationshipController(RelationshipsService service) {         this.service = service;     }   @GetMapping('/getFriends/{userId}')     public List&lt;UserPreview&gt; getFriends(@PathVariable String userId) {         return service.getFriends(userId);     }      @GetMapping('/getRequests/{userId}')     public List&lt;UserPreview&gt; getReceivedRequests(@PathVariable String userId) {         return service.getReceivedRequests(userId);     }  }  </code></pre>  <p><b> pom.xml </b></p>  <pre class='lang-xml prettyprint-override'><code> &lt;?xml version='1.0' encoding='UTF-8'?&gt; &lt;project xmlns='http://maven.apache.org/POM/4.0.0' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'          xsi:schemaLocation='http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd'&gt;     &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;     &lt;parent&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;         &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;         &lt;relativePath/&gt;     &lt;/parent&gt;     &lt;groupId&gt;artem.bashtovyi&lt;/groupId&gt;     &lt;artifactId&gt;current&lt;/artifactId&gt;     &lt;version&gt;0.0.1&lt;/version&gt;     &lt;name&gt;current&lt;/name&gt;     &lt;description&gt;Demo project&lt;/description&gt;      &lt;dependencies&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;             &lt;scope&gt;test&lt;/scope&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;com.microsoft.sqlserver&lt;/groupId&gt;             &lt;artifactId&gt;mssql-jdbc&lt;/artifactId&gt;             &lt;scope&gt;runtime&lt;/scope&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;             &lt;artifactId&gt;jjwt&lt;/artifactId&gt;             &lt;version&gt;0.2&lt;/version&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;             &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-data-neo4j&lt;/artifactId&gt;         &lt;/dependency&gt;     &lt;/dependencies&gt;      &lt;build&gt;         &lt;plugins&gt;             &lt;plugin&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;             &lt;/plugin&gt;             &lt;plugin&gt;                 &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                 &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                 &lt;configuration&gt;                     &lt;compilerArgs&gt;                         &lt;arg&gt;-parameters&lt;/arg&gt;                     &lt;/compilerArgs&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt;         &lt;/plugins&gt;     &lt;/build&gt;   &lt;/project&gt;  </code></pre>  <pre><code>docker-current-app_1  | 2019-05-05 20:33:43.684  INFO 1 --- [nio-8080-exec-1] c.b.c.service.RelationshipsService       : Getting requests for itemId ff80818169ae57130169b0d4661f0002 docker-current-app_1  | 2019-05-05 20:33:43.965  INFO 1 --- [nio-8080-exec-1] Driver                                   : Direct driver instance 1518060028 created for server address localhost:7687 docker-current-app_1  | 2019-05-05 20:33:44.829  WARN 1 --- [nio-8080-exec-1] org.neo4j.ogm.session.Neo4jSession       : Error executing query : 0. Rolling back transaction. docker-current-app_1  | 2019-05-05 20:33:44.865 ERROR 1 --- [nio-8080-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.ArrayIndexOutOfBoundsException: 0] with root cause docker-current-app_1  |  docker-current-app_1  | java.lang.ArrayIndexOutOfBoundsException: 0 docker-current-app_1  |     at org.neo4j.ogm.context.EntityRowModelMapper.extractColumnValue(EntityRowModelMapper.java:75) ~[neo4j-ogm-core-3.1.6.jar!/:3.1.6] docker-current-app_1  |     at org.neo4j.ogm.context.EntityRowModelMapper.map(EntityRowModelMapper.java:64) ~[neo4j-ogm-core-3.1.6.jar!/:3.1.6] docker-current-app_1  |     at org.neo4j.ogm.session.delegates.ExecuteQueriesDelegate.lambda$executeAndMap$1(ExecuteQueriesDelegate.java:133) ~[neo4j-ogm-core-3.1.6.jar!/:3.1.6] docker-current-app_1  |     at org.neo4j.ogm.session.Neo4jSession.doInTransaction(Neo4jSession.java:579) ~[neo4j-ogm-core-3.1.6.jar!/:3.1.6] docker-current-app_1  |     at org.neo4j.ogm.session.Neo4jSession.doInTransaction(Neo4jSession.java:558) ~[neo4j-ogm-core-3.1.6.jar!/:3.1.6] docker-current-app_1  |     at org.neo4j.ogm.session.delegates.ExecuteQueriesDelegate.executeAndMap(ExecuteQueriesDelegate.java:124) ~[neo4j-ogm-core-3.1.6.jar!/:3.1.6] docker-current-app_1  |     at org.neo4j.ogm.session.delegates.ExecuteQueriesDelegate.query(ExecuteQueriesDelegate.java:94) ~[neo4j-ogm-core-3.1.6.jar!/:3.1.6] docker-current-app_1  |     at org.neo4j.ogm.session.Neo4jSession.query(Neo4jSession.java:413) ~[neo4j-ogm-core-3.1.6.jar!/:3.1.6] docker-current-app_1  |     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_111-internal] docker-current-app_1  |     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_111-internal] docker-current-app_1  |     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_111-internal] docker-current-app_1  |     at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_111-internal] docker-current-app_1  |     at org.springframework.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:246) ~[spring-core-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.data.neo4j.transaction.SharedSessionCreator$SharedSessionInvocationHandler.lambda$invoke$0(SharedSessionCreator.java:108) ~[spring-data-neo4j-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.data.neo4j.transaction.SharedSessionCreator$SharedSessionInvocationHandler.invokeInTransaction(SharedSessionCreator.java:139) ~[spring-data-neo4j-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.data.neo4j.transaction.SharedSessionCreator$SharedSessionInvocationHandler.invoke(SharedSessionCreator.java:110) ~[spring-data-neo4j-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at com.sun.proxy.$Proxy127.query(Unknown Source) ~[na:na] docker-current-app_1  |     at org.springframework.data.neo4j.repository.query.GraphQueryExecution$CollectionExecution.execute(GraphQueryExecution.java:96) ~[spring-data-neo4j-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.data.neo4j.repository.query.GraphRepositoryQuery.doExecute(GraphRepositoryQuery.java:92) ~[spring-data-neo4j-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.data.neo4j.repository.query.AbstractGraphRepositoryQuery.execute(AbstractGraphRepositoryQuery.java:57) ~[spring-data-neo4j-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.doInvoke(RepositoryFactorySupport.java:605) ~[spring-data-commons-2.1.4.RELEASE.jar!/:2.1.4.RELEASE] docker-current-app_1  |     at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.lambda$invoke$3(RepositoryFactorySupport.java:595) ~[spring-data-commons-2.1.4.RELEASE.jar!/:2.1.4.RELEASE] docker-current-app_1  |     at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:595) ~[spring-data-commons-2.1.4.RELEASE.jar!/:2.1.4.RELEASE] docker-current-app_1  |     at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.data.projection.DefaultMethodInvokingMethodInterceptor.invoke(DefaultMethodInvokingMethodInterceptor.java:59) ~[spring-data-commons-2.1.4.RELEASE.jar!/:2.1.4.RELEASE] docker-current-app_1  |     at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:294) ~[spring-tx-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:98) ~[spring-tx-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:139) ~[spring-tx-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:93) ~[spring-aop-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.data.repository.core.support.SurroundingTransactionDetectorMethodInterceptor.invoke(SurroundingTransactionDetectorMethodInterceptor.java:61) ~[spring-data-commons-2.1.4.RELEASE.jar!/:2.1.4.RELEASE] docker-current-app_1  |     at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:212) ~[spring-aop-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at com.sun.proxy.$Proxy133.findRequestsById(Unknown Source) ~[na:na] docker-current-app_1  |     at com.bashtovyi.current.service.RelationshipsService.getReceivedRequests(RelationshipsService.java:40) ~[classes!/:0.0.1] docker-current-app_1  |     at com.bashtovyi.current.controller.RelationshipController.getReceivedRequests(RelationshipController.java:39) ~[classes!/:0.0.1] docker-current-app_1  |     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_111-internal] docker-current-app_1  |     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_111-internal] docker-current-app_1  |     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_111-internal] docker-current-app_1  |     at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_111-internal] docker-current-app_1  |     at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:189) ~[spring-web-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) ~[spring-web-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:102) ~[spring-webmvc-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895) ~[spring-webmvc-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:800) ~[spring-webmvc-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1038) ~[spring-webmvc-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) ~[spring-webmvc-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005) ~[spring-webmvc-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:897) ~[spring-webmvc-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.14.jar!/:9.0.14] docker-current-app_1  |     at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:882) ~[spring-webmvc-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.14.jar!/:9.0.14] docker-current-app_1  |     at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.14.jar!/:9.0.14] docker-current-app_1  |     at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.14.jar!/:9.0.14] docker-current-app_1  |     at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.14.jar!/:9.0.14] docker-current-app_1  |     at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.14.jar!/:9.0.14] docker-current-app_1  |     at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.14.jar!/:9.0.14] docker-current-app_1  |     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:101) ~[spring-web-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.14.jar!/:9.0.14] docker-current-app_1  |     at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.14.jar!/:9.0.14] docker-current-app_1  |     at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320) ~[spring-security-web-5.1.3.RELEASE.jar!/:5.1.3.RELEASE] docker-current-app_1  |     at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:127) ~[spring-security-web-5.1.3.RELEASE.jar!/:5.1.3.RELEASE] docker-current-app_1  |     at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:91) ~[spring-security-web-5.1.3.RELEASE.jar!/:5.1.3.RELEASE] docker-current-app_1  |     at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.1.3.RELEASE.jar!/:5.1.3.RELEASE] docker-current-app_1  |     at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119) ~[spring-security-web-5.1.3.RELEASE.jar!/:5.1.3.RELEASE] docker-current-app_1  |     at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.1.3.RELEASE.jar!/:5.1.3.RELEASE] docker-current-app_1  |     at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137) ~[spring-security-web-5.1.3.RELEASE.jar!/:5.1.3.RELEASE] docker-current-app_1  |     at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.1.3.RELEASE.jar!/:5.1.3.RELEASE] docker-current-app_1  |     at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111) ~[spring-security-web-5.1.3.RELEASE.jar!/:5.1.3.RELEASE] docker-current-app_1  |     at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.1.3.RELEASE.jar!/:5.1.3.RELEASE] docker-current-app_1  |     at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:170) ~[spring-security-web-5.1.3.RELEASE.jar!/:5.1.3.RELEASE] docker-current-app_1  |     at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.1.3.RELEASE.jar!/:5.1.3.RELEASE] docker-current-app_1  |     at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63) ~[spring-security-web-5.1.3.RELEASE.jar!/:5.1.3.RELEASE] docker-current-app_1  |     at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.1.3.RELEASE.jar!/:5.1.3.RELEASE] docker-current-app_1  |     at com.bashtovyi.current.custom.token.JwtAuthFilter.doFilterInternal(JwtAuthFilter.java:52) ~[classes!/:0.0.1] docker-current-app_1  |     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.1.3.RELEASE.jar!/:5.1.3.RELEASE] docker-current-app_1  |     at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116) ~[spring-security-web-5.1.3.RELEASE.jar!/:5.1.3.RELEASE] docker-current-app_1  |     at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.1.3.RELEASE.jar!/:5.1.3.RELEASE] docker-current-app_1  |     at org.springframework.web.filter.CorsFilter.doFilterInternal(CorsFilter.java:96) ~[spring-web-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.1.3.RELEASE.jar!/:5.1.3.RELEASE] docker-current-app_1  |     at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:74) ~[spring-security-web-5.1.3.RELEASE.jar!/:5.1.3.RELEASE] docker-current-app_1  |     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.1.3.RELEASE.jar!/:5.1.3.RELEASE] docker-current-app_1  |     at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105) ~[spring-security-web-5.1.3.RELEASE.jar!/:5.1.3.RELEASE] docker-current-app_1  |     at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.1.3.RELEASE.jar!/:5.1.3.RELEASE] docker-current-app_1  |     at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56) ~[spring-security-web-5.1.3.RELEASE.jar!/:5.1.3.RELEASE] docker-current-app_1  |     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.1.3.RELEASE.jar!/:5.1.3.RELEASE] docker-current-app_1  |     at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215) ~[spring-security-web-5.1.3.RELEASE.jar!/:5.1.3.RELEASE] docker-current-app_1  |     at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178) ~[spring-security-web-5.1.3.RELEASE.jar!/:5.1.3.RELEASE] docker-current-app_1  |     at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:357) ~[spring-web-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:270) ~[spring-web-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.14.jar!/:9.0.14] docker-current-app_1  |     at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.14.jar!/:9.0.14] docker-current-app_1  |     at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) ~[spring-web-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.14.jar!/:9.0.14] docker-current-app_1  |     at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.14.jar!/:9.0.14] docker-current-app_1  |     at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:92) ~[spring-web-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.14.jar!/:9.0.14] docker-current-app_1  |     at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.14.jar!/:9.0.14] docker-current-app_1  |     at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) ~[spring-web-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.14.jar!/:9.0.14] docker-current-app_1  |     at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.14.jar!/:9.0.14] docker-current-app_1  |     at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) ~[spring-web-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.4.RELEASE.jar!/:5.1.4.RELEASE] docker-current-app_1  |     at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.14.jar!/:9.0.14] docker-current-app_1  |     at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.14.jar!/:9.0.14] docker-current-app_1  |     at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199) ~[tomcat-embed-core-9.0.14.jar!/:9.0.14] docker-current-app_1  |     at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.14.jar!/:9.0.14] docker-current-app_1  |     at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490) [tomcat-embed-core-9.0.14.jar!/:9.0.14] docker-current-app_1  |     at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.14.jar!/:9.0.14] docker-current-app_1  |     at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.14.jar!/:9.0.14] docker-current-app_1  |     at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.14.jar!/:9.0.14] </code></pre> ",
    "OwnerUserId": "9914613",
    "LastEditorUserId": "9914613",
    "LastEditDate": "2019-05-06T09:52:56.207",
    "LastActivityDate": "2019-12-23T13:23:27.637",
    "Title": "Neo4jSession Error when trying to retrieve data from Neo4jRepository published on docker[ONLY DOCKER ISSUE]",
    "Tags": "<spring-boot><docker><neo4j><docker-compose><spring-data-neo4j>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>I had the same issue. It appeared that server had some old Oracle JDK. When I installed a newer OpenJDK package (change like 1.8.0_141 -> 1.8.0_222), problem disappeared.</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "59963013",
    "PostTypeId": "1",
    "AcceptedAnswerId": "59965633",
    "CreationDate": "2020-01-29T08:21:36.223",
    "Score": "3",
    "ViewCount": "1717",
    "Body": "<p>I have two docker containers which I'm building using docker-compose. One of which initializes the ibm mqs and another is the one exposes rest end points(using SpringBoot project) to send message to the ibm mq which were set up by first container. When I get the docker-compose up I am getting the below error</p>  <pre><code>mock-service_1  | 2020-01-29 08:07:52.928 ERROR 1 --- [nio-7090-exec-2] c.j.ids.controller.AcarsController       : JMSWMQ0018: Failed to connect to queue manager 'QM1' with connection mode 'Client' and host name 'localhost(1414)'. acars-mock-service_1  | com.ibm.msg.client.jms.DetailedIllegalStateException: JMSWMQ0018: Failed to connect to queue manager 'QM1' with connection mode 'Client' and host name 'localhost(1414)'. Caused by: com.ibm.mq.MQException: JMSCMQ0001: IBM MQ call failed with compcode '2' ('MQCC_FAILED') reason '2538' ('MQRC_HOST_NOT_AVAILABLE').  mock-service_1  |         at com.ibm.msg.client.wmq.common.internal.Reason.createException(Reason.java:203) </code></pre>  <p>I'm able to put the messages in the same queue if I run the SpringBoot application locally from my IDE without any error. Not sure what is the issue using separate containers. My DockerFile looks like this </p>  <pre><code>FROM ibmcom/mq USER root RUN useradd ibm-mq -G mqm &amp;&amp; \\     echo ibm-mq:passw0rd | chpasswd USER mqm COPY config.mqsc /etc/mqm/  EXPOSE 9443 1414 </code></pre>  <p>And config.mqsc</p>  <pre><code>ALTER QMGR CHLAUTH(DISABLED) </code></pre>  <p>docker-compose.yml </p>  <pre><code>version: '3.3' services:   ibm-mq-mock:     build:        context: ../mock-service/ibm-mq       dockerfile: Dockerfile     ports:       - 9443:9443       - 1414:1414     environment:      LICENSE: accept      MQ_QMGR_NAME: QM1    mock-service:     build:       context: ../mock-service     ports:       - 7090:7090     depends_on:      - ibm-mq-mock     environment:      MQ_QMGR_NAME: QM1      CHANNEL: DEV.ADMIN.SVRCONN      IBM_MQ_HOST: localhost      IBM_MQ_PORT: 1414      IBM_MQ_USERID: admin      IBM_MQ_PASSWORD: passw0rd      IBM_MQ_QUEUE: DEV.QUEUE.1      LOG_LEVEL: INFO      PROFILE: test </code></pre> ",
    "OwnerUserId": "10384047",
    "LastEditorUserId": "10384047",
    "LastEditDate": "2020-03-24T08:39:27.337",
    "LastActivityDate": "2020-03-24T08:39:27.337",
    "Title": "Unable to put message in ibm mq using container",
    "Tags": "<java><spring-boot><docker-compose><dockerfile><ibm-mq>",
    "AnswerCount": "1",
    "CommentCount": "2",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>Localhost inside your spring container, is your spring container. Instead of setting the host to localhost for your MQ Connection you need your container's / host ip. </p>  <p>How you do it depends on your host's platform, but it will be something like <code>host.docker.internal</code> </p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "61368689",
    "PostTypeId": "1",
    "AcceptedAnswerId": "61401330",
    "CreationDate": "2020-04-22T15:17:45.097",
    "Score": "3",
    "ViewCount": "5121",
    "Body": "<p>I am working on micro service where micro services are communicating with each other. I am using Zipkin with Sleuth and Apache Kafka as a message broker and running micro service and kafka using docker-compose.</p> <p>I am using Spring Boot (2.2.6.RELEASE), Spring Cloud (Hoxton.SR3), Kafka Image(wurstmeister/kafka:2.12-2.4.1) and latest image of Zipkin.</p> <p>When i try to spin the container, micro service is giving below error:</p> <blockquote> <p>APPLICATION FAILED TO START</p> <p>Description:</p> <p>Parameter 2 of method reporter in org.springframework.cloud.sleuth.zipkin2.ZipkinAutoConfiguration &gt; required a bean of type 'zipkin2.reporter.Sender' that could not be found.</p> </blockquote> <pre><code>pom.xml  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;     &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;     &lt;parent&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;         &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;         &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;     &lt;/parent&gt;     &lt;groupId&gt;com.adi.example&lt;/groupId&gt;     &lt;artifactId&gt;currency-conversion-service&lt;/artifactId&gt;     &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;     &lt;name&gt;currency-conversion-service&lt;/name&gt;     &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;      &lt;properties&gt;         &lt;java.version&gt;1.8&lt;/java.version&gt;         &lt;spring-cloud.version&gt;Hoxton.SR3&lt;/spring-cloud.version&gt;     &lt;/properties&gt;      &lt;dependencies&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;             &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;         &lt;/dependency&gt;          &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;             &lt;scope&gt;runtime&lt;/scope&gt;             &lt;optional&gt;true&lt;/optional&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;             &lt;scope&gt;test&lt;/scope&gt;             &lt;exclusions&gt;                 &lt;exclusion&gt;                     &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;                     &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;                 &lt;/exclusion&gt;             &lt;/exclusions&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;             &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;             &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;             &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;             &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;         &lt;/dependency&gt;     &lt;/dependencies&gt;      &lt;dependencyManagement&gt;         &lt;dependencies&gt;             &lt;dependency&gt;                 &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;                 &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;                 &lt;version&gt;${spring-cloud.version}&lt;/version&gt;                 &lt;type&gt;pom&lt;/type&gt;                 &lt;scope&gt;import&lt;/scope&gt;             &lt;/dependency&gt;         &lt;/dependencies&gt;     &lt;/dependencyManagement&gt;      &lt;build&gt;         &lt;plugins&gt;             &lt;plugin&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;             &lt;/plugin&gt;         &lt;/plugins&gt;         &lt;finalName&gt;conversion-server&lt;/finalName&gt;     &lt;/build&gt;  &lt;/project&gt;  </code></pre> <pre><code> Application.properties  spring.application.name=exchange-service server.port=9000      eureka.client.fetch-registry=true eureka.client.register-with-eureka=true #eureka.client.service-url.defaultZone=http://localhost:9765/eureka/ eureka.client.service-url.defaultZone=http://eureka-server:9765/eureka/ eureka.instance.prefer-ip-address=true  spring.sleuth.sampler.probability=1  spring.zipkin.base-url=http://zipkin-server:9411/ spring.zipkin.sender.type=kafka  spring.kafka.bootstrap-servers=http://kafka:9092  </code></pre> <pre><code>docker-compose.yml  version: '3'  services:       zookeeper:      image: wurstmeister/zookeeper     container_name: zookeeper-server     ports:       - &quot;2181:2181&quot;     environment:       - ALLOW_ANONYMOUS_LOGIN= 'yes'     networks:       - service-network          kafka:      image: wurstmeister/kafka:2.12-2.4.1     container_name: kafka-server     ports:        - &quot;9092:9092&quot;     depends_on:        - zookeeper     networks:        - service-network     environment:        - KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR= 1       - KAFKA_ZOOKEEPER_CONNECT= zookeeper:2181       - KAFKA_LISTENERS= PLAINTEXT://:9092       - KAFKA_ADVERTISED_LISTENERS= PLAINTEXT://:9092             eureka-server:     image: discovery-server:1.0.0     restart: always     depends_on:        - zipkin-server     ports:        - &quot;9765:9765&quot;     networks:        - service-network        exchange-server:      image: exchange-server:1.0.0     restart: always     ports:        - &quot;9000:9000&quot;     depends_on:        - eureka-server     networks:        - service-network        conversion-server:      image: conversion-server:1.0.0     restart: always     ports:        - &quot;9100:9100&quot;     depends_on:        - eureka-server       - exchange-server     networks:        - service-network          zipkin-server:      image: openzipkin/zipkin     ports:        - &quot;9411:9411&quot;     restart: always     depends_on:        - zookeeper     networks:       - service-network        networks:    service-network:   </code></pre> <pre><code>console-log  . ____ _ __ _ _  /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\  ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\  \\\\/ ___)| |_)| | | | | || (_| | ) ) ) )  ' |____| .__|_| |_|_| |_\\__, | / / / /  =========|_|==============|___/=/_/_/_/  :: Spring Boot :: (v2.2.6.RELEASE)  2020-04-22 15:03:47.165 INFO [exchange-service,,,] 1 --- [ main] c.e.d.CurrencyExchangeServiceApplication : No active profile set, falling back to default profiles: default  2020-04-22 15:03:51.847 INFO [exchange-service,,,] 1 --- [ main] o.s.cloud.context.scope.GenericScope : BeanFactory id=a980a587-b2e4-3cb6-b4e7-9abfad8a56f8  2020-04-22 15:03:55.619 INFO [exchange-service,,,] 1 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 9000 (http)  2020-04-22 15:03:55.687 INFO [exchange-service,,,] 1 --- [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat]  2020-04-22 15:03:55.688 INFO [exchange-service,,,] 1 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/9.0.33]  2020-04-22 15:03:55.890 INFO [exchange-service,,,] 1 --- [ main] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext  2020-04-22 15:03:55.893 INFO [exchange-service,,,] 1 --- [ main] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 8565 ms  2020-04-22 15:03:56.382 ERROR [exchange-service,,,] 1 --- [ main] o.s.b.web.embedded.tomcat.TomcatStarter : Error starting Tomcat context. Exception: org.springframework.beans.factory.UnsatisfiedDependencyException. Message: Error creating bean with name 'tracingFilter' defined in class path resource [org/springframework/cloud/sleuth/instrument/web/TraceWebServletAutoConfiguration.class]: Unsatisfied dependency expressed through method 'tracingFilter' parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'httpTracing' defined in class path resource [org/springframework/cloud/sleuth/instrument/web/TraceHttpAutoConfiguration.class]: Unsatisfied dependency expressed through method 'httpTracing' parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'tracing' defined in class path resource [org/springframework/cloud/sleuth/autoconfig/TraceAutoConfiguration.class]: Unsatisfied dependency expressed through method 'tracing' parameter 6; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'zipkinReporter' defined in class path resource [org/springframework/cloud/sleuth/zipkin2/ZipkinAutoConfiguration.class]: Unsatisfied dependency expressed through method 'reporter' parameter 2; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'zipkin2.reporter.Sender' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Qualifier(value=zipkinSender)}  2020-04-22 15:03:56.443 INFO [exchange-service,,,] 1 --- [ main] o.apache.catalina.core.StandardService : Stopping service [Tomcat]  2020-04-22 15:03:56.472 WARN [exchange-service,,,] 1 --- [ main] ConfigServletWebServerApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.context.ApplicationContextException: Unable to start web server; nested exception is org.springframework.boot.web.server.WebServerException: Unable to start embedded Tomcat  2020-04-22 15:03:56.522 INFO [exchange-service,,,] 1 --- [ main] ConditionEvaluationReportLoggingListener :  Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled.  2020-04-22 15:03:57.082 ERROR [exchange-service,,,] 1 --- [ main] o.s.b.d.LoggingFailureAnalysisReporter :  ***************************  APPLICATION FAILED TO START  Description:  Parameter 2 of method reporter in org.springframework.cloud.sleuth.zipkin2.ZipkinAutoConfiguration required a bean of type 'zipkin2.reporter.Sender' that could not be found.  The following candidates were found but could not be injected:  - Bean method 'rabbitSender' in 'ZipkinRabbitSenderConfiguration' not loaded because @ConditionalOnProperty (spring.zipkin.sender.type=rabbit) found different value in property 'spring.zipkin.sender.type'  - Bean method 'restTemplateSender' in 'ZipkinRestTemplateSenderConfiguration' not loaded because ZipkinSender org.springframework.cloud.sleuth.zipkin2.sender.ZipkinRestTemplateSenderConfiguration kafka sender type  Action:  Consider revisiting the entries above or defining a bean of type 'zipkin2.reporter.Sender' in your configuration.  </code></pre> <pre><code>MainApp.java  import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; import org.springframework.cloud.openfeign.EnableFeignClients; import org.springframework.context.annotation.Bean;  import brave.sampler.Sampler;  @SpringBootApplication @EnableEurekaClient @EnableFeignClients(&quot;com.example&quot;) public class MainApp {      public static void main(String[] args) {         SpringApplication.run(CurrencyConversionServiceApplication.class, args);     }          @Bean     public Sampler sampler() {         return Sampler.ALWAYS_SAMPLE;     }  }  </code></pre> ",
    "OwnerUserId": "11657025",
    "LastEditorUserId": "-1",
    "LastEditDate": "2020-06-20T09:12:55.060",
    "LastActivityDate": "2022-02-24T19:53:45.293",
    "Title": "zipkin2.reporter.Sender bean not found when using with Zipkin with kafka in docker",
    "Tags": "<spring-boot><apache-kafka><docker-compose><microservices><zipkin>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>The reason behind error was that i forgot to add the kafka dependency in pom.xml After adding the dependency, error was gone.</p> ",
    "highest_rated_answer": "<p>in my case I added <code>@EnableConfigurationProperties({KafkaProperties.class}) to @SpringBootApplication class</code></p> <pre><code>@SpringBootApplication @EnableConfigurationProperties({KafkaProperties.class}) public class Application{ ... } </code></pre> "
  },
  {
    "Id": "62929155",
    "PostTypeId": "1",
    "CreationDate": "2020-07-16T06:54:52.813",
    "Score": "3",
    "ViewCount": "914",
    "Body": "<p>Hi I'm trying to use the trick described <a href='https://stackoverflow.com/a/41878387/10837478'>here</a> to allow continuous building inside docker containers. The trick works fine when I open two separate terminals on my host machine, but fails when used in docker containers.</p> <p>docker-compose.yml</p> <pre><code>  build_server:     image: gradle:6.3.0-jdk8     working_dir: /home/gradle/server     volumes:       - ./server:/home/gradle/server     command: [&quot;gradle&quot;, &quot;build&quot;, &quot;--continuous&quot;, &quot;-x&quot;, &quot;test&quot;]    server:     image: gradle:6.3.0-jdk8     working_dir: /home/gradle/server     volumes:       - ./server:/home/gradle/server     ports:       - 8080:8080     depends_on:       - build_server     restart: on-failure     command: [&quot;gradle&quot;, &quot;bootRun&quot;] </code></pre> <p>The error message I got from server container:</p> <pre><code>server_1         | FAILURE: Build failed with an exception. server_1         | server_1         | * What went wrong: server_1         | Gradle could not start your build. server_1         | &gt; Could not create service of type ScriptPluginFactory using BuildScopeServices.createScriptPluginFactory(). server_1         |    &gt; Could not create service of type ChecksumService using BuildSessionScopeServices.createChecksumService(). server_1         |       &gt; Timeout waiting to lock checksums cache (/home/gradle/server/.gradle/checksums). It is currently in use by another Gradle instance. server_1         |         Owner PID: unknown server_1         |         Our PID: 31 server_1         |         Owner Operation: unknown server_1         |         Our operation: server_1         |         Lock file: /home/gradle/server/.gradle/checksums/checksums.lock </code></pre> <p>It looks like gradle has added locks on local cache files and prevents <code>bootRun</code> task from being run in the other container. However, the trick works fine when I run the tasks in two terminals on my host machine, or when I only run the <code>build_server</code> container and run <code>bootRun</code> on host terminal. I wonder why it doesn't work inside docker containers. Thanks for helping in advance!</p> ",
    "OwnerUserId": "10837478",
    "LastActivityDate": "2020-07-16T10:03:39.983",
    "Title": "gradle continuous build trick doesn't work in docker container",
    "Tags": "<spring-boot><docker><gradle><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "3",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>Found a workaround by setting a different project cache dir for the server container. i.e. replace the command with the following</p> <pre><code>command: [&quot;gradle&quot;, &quot;bootRun&quot;, &quot;--project-cache-dir=/tmp/cache&quot;] </code></pre> <p>Might not be the best solution but it does circumvent the problem caused by gradle's lock.</p> "
  },
  {
    "Id": "62997711",
    "PostTypeId": "1",
    "CreationDate": "2020-07-20T14:31:13.353",
    "Score": "3",
    "ViewCount": "3256",
    "Body": "<p>Eureka server not working on Docker compose</p> <p>Here is the docker-compose for the Eureka server and config server</p> <pre><code>version: '3' services:     fetebird-eurekaservice:         container_name: FeteBird-EurekaService         build:             context: ../../Eureka-Service-Registry/             dockerfile: Dockerfile         image: fetebird/eurekaservice         ports:             - &quot;8761:8761&quot;         networks:             - spring-cloud-network         volumes:             - ./fetebird-eurekaservice/data:/data         logging:             driver: json-file          fetebird-configserver:         container_name: FeteBird-ConfigServer         build:             context: ../../FeteBird-ConfigServer             dockerfile: Dockerfile         image: fetebird/configserver         ports:             - &quot;8085:8085&quot;         networks:             - spring-cloud-network         volumes:             - ./fetebird-configserver/data:/data         logging:             driver: json-file          networks:     spring-cloud-network:         driver: bridge </code></pre> <p>I tried with the expose command as well but no luck</p> <h1>Eureka server docker file</h1> <pre><code>FROM openjdk:14  WORKDIR /fetebird-eurekaservice/service  ADD build/libs/fete-bird-eureka-service-registry-0.0.1-SNAPSHOT.jar fete-bird-eureka-service-registry-0.0.1-SNAPSHOT.jar  ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;fete-bird-eureka-service-registry-0.0.1-SNAPSHOT.jar&quot;] </code></pre> <h1>Config server Client Docker file</h1> <pre><code>FROM openjdk:14  WORKDIR /fetebird-eurekaservice/service  ADD build/libs/fete-bird-configuration-server-0.0.1-SNAPSHOT.jar fete-bird-configuration-server-0.0.1-SNAPSHOT.jar  ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;fete-bird-configuration-server-0.0.1-SNAPSHOT.jar&quot;] </code></pre> <h1>Config Server</h1> <pre><code>@SpringBootApplication @EnableEurekaServer public class FeteBirdEurekaServiceRegistryApplication {     public static void main(String[] args) {         SpringApplication.run(FeteBirdEurekaServiceRegistryApplication.class, args);     } } </code></pre> <h1>Configuration of Eureka server</h1> <h1>application.yml</h1> <pre><code>server:   port: 8761  eureka:   client:     register-with-eureka: false     fetch-registry: false spring:   profiles:     active: dev </code></pre> <h1>bootstrap.yml</h1> <pre><code>spring:   application:     name: CONFIG-SERVER   profiles:     active: native   cloud:     config:       server:         native:           search-locations: classpath:/config </code></pre> <h1>Config Server</h1> <p>server: port: 8085</p> <h1>Discovery Server Access</h1> <pre><code>eureka:   client:     register-with-eureka: true     fetch-registry: true     service-url:       defaultZone: http://localhost:8761/eureka/   instance:     hostname: localhost </code></pre> <p><strong>Errors</strong></p> <pre><code>com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server FeteBird-ConfigServer     |     at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112) ~[eureka-client-1.9.21.jar!/:1.9.21] FeteBird-ConfigServer     |     at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56) ~[eureka-client-1.9.21.jar!/:1.9.21] FeteBird-ConfigServer     |     at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59) ~[eureka-client-1.9.21.jar!/:1.9.21] FeteBird-ConfigServer     |     at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77) ~[eureka-client-1.9.21.jar!/:1.9.21] FeteBird-ConfigServer     |     at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56) ~[eureka-client-1.9.21.jar!/:1.9.21] FeteBird-ConfigServer     |     at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:857) ~[eureka-client-1.9.21.jar!/:1.9.21] FeteBird-ConfigServer     |     at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121) ~[eureka-client-1.9.21.jar!/:1.9.21] FeteBird-ConfigServer     |     at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515) ~[na:na] FeteBird-ConfigServer     |     at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) ~[na:na] FeteBird-ConfigServer     |     at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304) ~[na:na] FeteBird-ConfigServer     |     at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130) ~[na:na] FeteBird-ConfigServer     |     at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630) ~[na:na] FeteBird-ConfigServer     |     at java.base/java.lang.Thread.run(Thread.java:832) ~[na:na] FeteBird-ConfigServer     |  FeteBird-ConfigServer     | 2020-07-20 14:30:19.268  WARN 1 --- [nfoReplicator-0] c.n.discovery.InstanceInfoReplicator     : There was a problem with the instance info replicator </code></pre> ",
    "OwnerUserId": "1162409",
    "LastEditorUserId": "1162409",
    "LastEditDate": "2020-07-21T03:25:31.257",
    "LastActivityDate": "2023-04-16T19:02:39.463",
    "Title": "EurekaServer com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server on Docker",
    "Tags": "<java><spring><spring-boot><docker><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "7",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>The problem is this</p> <pre><code>eureka:   client:     serviceUrl:       defaultZone: http://localhost:1111/eureka </code></pre> <p>It is pointing to localhost and Eureka is no longer running on localhost, localhost in this case is the individual containers. The containers are linked together so you can just change this to</p> <pre><code>eureka:   client:     serviceUrl:       defaultZone: http://fetebird-eurekaservice:8761/eureka/     instance:       hostname: fetebird-eurekaservice </code></pre> <p>Each docker file</p> <pre><code>ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;fete-bird-configuration-server-0.0.1-SNAPSHOT.jar&quot;] fetebird-eurekaservice </code></pre> <p>Docker compose file (Add links and depends_on)</p> <pre><code>fetebird-configserver:         container_name: FeteBird-ConfigServer         build:             context: ../../FeteBird-ConfigServer             dockerfile: Dockerfile         image: fetebird/configserver         ports:             - &quot;8085:8085&quot;         links:             - fetebird-eurekaservice         depends_on:             - fetebird-eurekaservice         networks:             - spring-cloud-network         volumes:             - ./fetebird-configserver/data:/data         logging:             driver: json-file   </code></pre> <p>Reference - <a href='https://github.com/spring-cloud/spring-cloud-netflix/issues/2442' rel='nofollow noreferrer'>https://github.com/spring-cloud/spring-cloud-netflix/issues/2442</a></p> "
  },
  {
    "Id": "65108105",
    "PostTypeId": "1",
    "CreationDate": "2020-12-02T12:28:34.583",
    "Score": "3",
    "ViewCount": "5547",
    "Body": "<p>I have a <code>Spring</code> <code>MVC</code> application that I want to add to <code>Docker</code>. I created the <code>image</code>, configured <code>Docker</code>, but the application in <code>Docker</code> does not want to start. In the application I use <code>Spring Boot</code> and <code>PostgresSQL</code> database.</p> <p><em>Dockerfile</em>:</p> <pre class='lang-java prettyprint-override'><code>FROM openjdk:11 ADD build/libs/Coffeetearea-0.0.1-SNAPSHOT.jar Coffeetearea-0.0.1-SNAPSHOT.jar #EXPOSE 8080:8080 ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;Coffeetearea-0.0.1-SNAPSHOT.jar&quot;] </code></pre> <p><em>docker-compose.yml</em>:</p> <pre class='lang-java prettyprint-override'><code>version: '3.1' services:   app:     container_name: coffeetearea     image: coffeeteareaimage     build: ./     ports:       - &quot;8080:8080&quot;     depends_on:       - coffeeteareadb   coffeeteareadb:     image: coffeeteareadb     ports:       - &quot;5432:5432&quot;     environment:       - POSTGRES_PASSWORD=pass123       - POSTGRES_USER=postgres       - POSTGRES_DB=coffeetearea </code></pre> <p><em>application.propeerties</em>:</p> <pre class='lang-java prettyprint-override'><code>#Databse spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect spring.datasource.driver-class-name=org.postgresql.Driver spring.datasource.url=jdbc:postgresql://coffeeteareadb:5432/coffeetearea spring.datasource.username=postgres spring.datasource.password=pass123 spring.jpa.generate-ddl=false spring.jpa.hibernate.ddl-auto=validate </code></pre> <p>MY STEPS in TERMINAL:</p> <pre class='lang-java prettyprint-override'><code>C:\\Users\\vartanyan\\IdeaProjects\\Coffeetearea&gt;docker-compose up Creating network &quot;coffeetearea_default&quot; with the default driver Pulling coffeeteareadb (coffeeteareadb:)... ERROR: The image for the service you're trying to recreate has been removed. If you continue, volume data could be lost. Consider backing up your data before continuing.  Continue with the new image? [yN] y Pulling coffeeteareadb (coffeeteareadb:)... ERROR: pull access denied for coffeeteareadb, repository does not exist or may require 'docker login': denied: requested access to the resource is denied </code></pre> ",
    "OwnerDisplayName": "user14342151",
    "LastEditorDisplayName": "user14342151",
    "LastEditDate": "2020-12-02T12:38:05.640",
    "LastActivityDate": "2020-12-02T15:39:37.000",
    "Title": "DOCKER error: Pull access denied for coffeeteareadb, repository does not exist or may require 'docker login'",
    "Tags": "<java><postgresql><spring-boot><docker><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "2",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>The error means that Docker cannot find an image named <code>coffeeteareadb</code> locally or on <a href='https://hub.docker.com/' rel='nofollow noreferrer'>https://hub.docker.com/</a> . If your image is in private repository (meaning that someone in your party have already created it) you have to login Docker into that repository first. Although for private repository you image name should look like an URL: <code>registry.example.com/image-name:tag</code>.</p> <p>If you want <code>coffeeteareadb</code> to be a regular PostgreSQL database, you probably want to change the <code>image</code> here:</p> <pre class='lang-yaml prettyprint-override'><code>  coffeeteareadb:     image: postgres:13  # https://hub.docker.com/_/postgres </code></pre> <p>If you are new to Docker, an <code>image</code> is like an executable or binary file, while a <code>container</code> is something like a running process of that executable. An <code>image</code> consists of several incremental layers of data: an application, dependencies, some basic config, etc. When you run an image you create a <code>container</code>. A container is an instance of an image. It differs from the image in the way that apart from just application, it has some information on how to run it (which ports to map, which volumes to mount, etc). There can be many containers using the same image. So when you asked to select an image you basically need to tell what application you want to use. Docker will look for it locally and on the hub, download it, and create a container from it. If you want to create your own image, you need a Dockerfile (see this reference <a href='https://docs.docker.com/engine/reference/builder/' rel='nofollow noreferrer'>https://docs.docker.com/engine/reference/builder/</a> ).</p> "
  },
  {
    "Id": "66169935",
    "PostTypeId": "1",
    "AcceptedAnswerId": "66171015",
    "CreationDate": "2021-02-12T10:14:17.170",
    "Score": "3",
    "ViewCount": "13776",
    "Body": "<p>I created a Spring Boot application which uses a MySQL database. I use a docker-compose to launch the database.</p> <pre><code> services:   adminer:     image: adminer     restart: always     ports:       - 8888:8080   db:     image: mysql:latest     restart: always     environment:       MYSQL_ROOT_PASSWORD: 'example' # TODO: Change this           volumes:       - &quot;./config/my.conf:/etc/mysql/conf.d/config-file.cnf&quot;       - &quot;./data:/var/lib/mysql:rw&quot; </code></pre> <p>The Spring Boot Application (Backend) currently does not use Docker, I run it inside Eclipse. Before launching the Backend I have to grep the Docker Container for IPAddress:</p> <pre><code>docker inspect mysql_ex_db_1 | grep 'IPAddress' </code></pre> <p>which results something like this (this exact address changes time-to time)</p> <pre><code>                &quot;IPAddress&quot;: &quot;&quot;,                     &quot;IPAddress&quot;: &quot;172.21.0.2&quot;,  </code></pre> <p>Then I take this value and I set <code>spring.datasource.url</code> inside Eclipse in the file <code>Application.properties</code> with it.</p> <pre><code>spring.datasource.url=jdbc:mysql://172.21.0.2:3306/employee_management_system?allowPublicKeyRetrieval=true&amp;useSSL=false&amp;createDatabaseIfNotExist=true  </code></pre> <p>After this I can launch the Backend in Eclipse the Connection to database is there, everything works.</p> <p>Now I want to move the launching of Backend from Eclipse to the same docker-compose file I use to launch the database. Therefore I built an image, and appended the docker-compose file:</p> <pre><code>version: '3.1'  services:   adminer:     image: adminer     restart: always     ports:       - 8888:8080   db:     image: mysql:latest     restart: always     environment:       MYSQL_ROOT_PASSWORD: 'example' # TODO: Change this           volumes:       - &quot;./config/my.conf:/etc/mysql/conf.d/config-file.cnf&quot;       - &quot;./data:/var/lib/mysql:rw&quot;   backend:     image: backend:latest     restart: always     ports:       - 8090:8080 </code></pre> <p>In this case how can I configure the IPAddress in <code>spring.datasource.url</code>? The exact IPAddress changes whenever I re-launch the mysql containers.</p> <pre><code>spring.datasource.url=jdbc:mysql://172.21.0.2:3306/employee_management_system?allowPublicKeyRetrieval=true&amp;useSSL=false&amp;createDatabaseIfNotExist=true  </code></pre> <p>So what should I write instead of '172.21.0.2' ?</p> <p>I tried <strong>localhost</strong> here but it does not seem to work.</p> ",
    "OwnerUserId": "1107591",
    "LastEditorUserId": "1107591",
    "LastEditDate": "2021-02-12T10:20:32.740",
    "LastActivityDate": "2021-08-04T16:56:53.087",
    "Title": "How to set 'spring.datasource.url' inside a Docker Container",
    "Tags": "<mysql><spring><spring-boot><docker><docker-compose>",
    "AnswerCount": "3",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>First of all, you can set environment variables like <code>spring.datasource.url</code> outside of your docker image. This allows you to dynamically set these variables according to your deployment needs (like connecting to a dev or prod database).</p> <p>All docker containers running from your docker-compose file run in the same virtual network and their service names correspond to their hostnames within this network. When you want to access your database from your dockerized spring backend the hostname and port will be <code>db:3306</code>. You can overwrite <code>spring.datasource.url</code> in your docker-compose file by introducing an environment variable like:</p> <pre><code>version: '3.1'  services:   adminer:     image: adminer     restart: always     ports:       - 8888:8080   db:     image: mysql:latest     restart: always     environment:       MYSQL_ROOT_PASSWORD: 'example' # TODO: Change this           volumes:       - &quot;./config/my.conf:/etc/mysql/conf.d/config-file.cnf&quot;       - &quot;./data:/var/lib/mysql:rw&quot;   backend:     image: backend:latest     restart: always     ports:       - 8090:8080     environment:       spring.datasource.url: &quot;jdbc:mysql://db:3306/employee_management_system?allowPublicKeyRetrieval=true&amp;useSSL=false&amp;createDatabaseIfNotExist=true&quot; </code></pre> ",
    "highest_rated_answer": "<p>Add this env variable to your <code>backend</code> in <code>docker-compose</code>:</p> <pre><code>backend:   ...   environment:     - SPRING_DATASOURCE_URL=jdbc:mysql://db:3306/employee_management_system?allowPublicKeyRetrieval=true&amp;useSSL=false&amp;createDatabaseIfNotExist=true </code></pre> "
  },
  {
    "Id": "67302528",
    "PostTypeId": "1",
    "AcceptedAnswerId": "67310383",
    "CreationDate": "2021-04-28T14:48:44.370",
    "Score": "3",
    "ViewCount": "5148",
    "Body": "<p>I have my spring boot project connected to mysql and cassandra db. When I run it locally with spring boot, all went ok. I use docker-compose to run these three services. For three weeks, my application runs without problems. But now an error occure : Caused by: java.security.KeyStoreException: Key protection  algorithm not found: java.security.UnrecoverableKeyException: Encrypt Private Key failed: unrecognized algorithm name: PBEWithSHA1AndDESede. Can someone help me please?</p> ",
    "OwnerUserId": "11927366",
    "LastActivityDate": "2024-02-01T07:49:56.077",
    "Title": "java.security.KeyStoreException when running my app with docker-compose",
    "Tags": "<java><spring-boot><security><docker-compose><keystore>",
    "AnswerCount": "4",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>Recently got the same problem and found the following discussion saying it is a bug that happens on JDK 8u292 but not on 8u282: <a href='https://github.com/bcgit/bc-java/issues/941' rel='noreferrer'>https://github.com/bcgit/bc-java/issues/941</a></p> <p>In my case, I switched back to 8u282 and the error is gone.</p> ",
    "highest_rated_answer": "<p>It's a bug in openjdk 8u292. Update openjdk to 8u302 or higher version.</p> <p>8u292 -&gt; 8u312 I resolve this problem.</p> <pre><code>hanwei@hanweideMacBook-Air tt]$ java -version openjdk version &quot;1.8.0_292&quot; OpenJDK Runtime Environment (Zulu 8.54.0.21-CA-macos-aarch64) (build 1.8.0_292-b10) OpenJDK 64-Bit Server VM (Zulu 8.54.0.21-CA-macos-aarch64) (build 25.292-b10, mixed mode) hanwei@hanweideMacBook-Air tt]$ java -version openjdk version &quot;1.8.0_312&quot; OpenJDK Runtime Environment (Zulu 8.58.0.13-CA-macos-aarch64) (build 1.8.0_312-b07) OpenJDK 64-Bit Server VM (Zulu 8.58.0.13-CA-macos-aarch64) (build 25.312-b07, mixed mode) </code></pre> <blockquote> <p>https://bugs.openjdk.java.net/browse/JDK-8266261</p> </blockquote> <blockquote> <p>https://bugs.openjdk.java.net/browse/JDK-8242565</p> </blockquote> "
  },
  {
    "Id": "68092997",
    "PostTypeId": "1",
    "CreationDate": "2021-06-23T02:58:45.973",
    "Score": "3",
    "ViewCount": "1799",
    "Body": "<p>When I execute the <code>docker-compose up command</code>, the following error is generated:</p> <pre><code>Caused by: java.net.ConnectException: Connection refused </code></pre> <p>I am trying to establish a connection between two containers, MySQL and My-API container, using docker-compose, but it is somehow not connecting. Here is the docker-compose.yml:</p> <pre class='lang-yaml prettyprint-override'><code>version: '3'  services:    discovery-mysql:     image: mysql:5.7.34     container_name: discovery-mysql     environment:       - MYSQL_ROOT_PASSWORD=tomo       - MYSQL_DATABASE=r2dbc     ports:       - 3307:3306     networks:       - common-network    flyway:     image: flyway/flyway     command:       - url=jdbc:mysql://discovery-mysql:3306/r2dbc?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false -user=root -password=tomo migrate     volumes:       - ./src/main/resources/db/migration:/flyway/sql       - ./flyway/conf/flyway.config:/flyway.config     depends_on:       - discovery-mysql     networks:       - common-network    discovery-app:     image: tomojava3284/helloworldapi:latest     restart: on-failure     depends_on:       - discovery-mysql     ports:       - 8001:8080     environment:       - spring.datasource.url=r2dbc:mysql://root:tomo@discovery-mysql:3306/r2dbc     networks:       - common-network  networks:   common-network:     driver: bridge </code></pre> <h2>Things that I had tried:</h2> <p>I added networks: -common-network to put into the same network, but didn't work. I don't see anything wrong with the URL <code>r2dbc:mysql://root:tomo@discovery-mysql:3306/r2dbc</code>. By the way, when I run the program locally on IDE (not using docker-compose up), given the <code>url=r2dbc:mysql://root:tomo@127.0.0.1:3306/r2dbc</code>, it works fine.</p> <p>I have seen similar threads on stack overflow, but many of their solutions didn't work (I specified in the &quot;Things that I had tried&quot; section).</p> <p>What could be the reason that the lead to the error <code>Caused by: java.net.ConnectException: Connection refused</code>?</p> <h2>Here are the full details of errors:</h2> <pre><code>C:\\Users\\me\\github\\HelloWorld&gt;docker-compose up WARNING: Found orphan containers (mysql) for this project. If you removed or renamed this service in your compose file, you can run this command with the --remove-orphans flag to clean it up. Starting discovery-mysql ... done Starting helloworld_flyway_1        ... done Starting helloworld_discovery-app_1 ... done Attaching to discovery-mysql, helloworld_flyway_1, helloworld_discovery-app_1 discovery-mysql    | 2021-06-23 16:03:23+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 5.7.34-1debian10 started. discovery-mysql    | 2021-06-23 16:03:23+00:00 [Note] [Entrypoint]: Switching to dedicated user 'mysql' discovery-mysql    | 2021-06-23 16:03:23+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 5.7.34-1debian10 started. discovery-mysql    | 2021-06-23T16:03:23.899462Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).  discovery-mysql    | 2021-06-23T16:03:23.900841Z 0 [Note] mysqld (mysqld 5.7.34) starting as process 1 ... discovery-mysql    | 2021-06-23T16:03:23.903779Z 0 [Note] InnoDB: PUNCH HOLE support available discovery-mysql    | 2021-06-23T16:03:23.903816Z 0 [Note] InnoDB: Mutexes and rw_locks use GCC atomic builtins discovery-mysql    | 2021-06-23T16:03:23.903821Z 0 [Note] InnoDB: Uses event mutexes discovery-mysql    | 2021-06-23T16:03:23.903824Z 0 [Note] InnoDB: GCC builtin __atomic_thread_fence() is used for memory barrier discovery-mysql    | 2021-06-23T16:03:23.903827Z 0 [Note] InnoDB: Compressed tables use zlib 1.2.11 discovery-mysql    | 2021-06-23T16:03:23.903829Z 0 [Note] InnoDB: Using Linux native AIO discovery-mysql    | 2021-06-23T16:03:23.904263Z 0 [Note] InnoDB: Number of pools: 1 discovery-mysql    | 2021-06-23T16:03:23.904371Z 0 [Note] InnoDB: Using CPU crc32 instructions discovery-mysql    | 2021-06-23T16:03:23.905996Z 0 [Note] InnoDB: Initializing buffer pool, total size = 128M, instances = 1, chunk size = 128M discovery-mysql    | 2021-06-23T16:03:23.914593Z 0 [Note] InnoDB: Completed initialization of buffer pool discovery-mysql    | 2021-06-23T16:03:23.916694Z 0 [Note] InnoDB: If the mysqld execution user is authorized, page cleaner thread priority can be changed. See the man page of setpriority(). discovery-mysql    | 2021-06-23T16:03:23.928540Z 0 [Note] InnoDB: Highest supported file format is Barracuda. discovery-mysql    | 2021-06-23T16:03:23.947396Z 0 [Note] InnoDB: Creating shared tablespace for temporary tables discovery-mysql    | 2021-06-23T16:03:23.947471Z 0 [Note] InnoDB: Setting file './ibtmp1' size to 12 MB. Physically writing the file full; Please wait ... discovery-mysql    | 2021-06-23T16:03:23.978325Z 0 [Note] InnoDB: File './ibtmp1' size is now 12 MB. discovery-mysql    | 2021-06-23T16:03:23.978805Z 0 [Note] InnoDB: 96 redo rollback segment(s) found. 96 redo rollback segment(s) are active. discovery-mysql    | 2021-06-23T16:03:23.978846Z 0 [Note] InnoDB: 32 non-redo rollback segment(s) are active. discovery-mysql    | 2021-06-23T16:03:23.979683Z 0 [Note] InnoDB: 5.7.34 started; log sequence number 12664810 discovery-mysql    | 2021-06-23T16:03:23.979948Z 0 [Note] InnoDB: Loading buffer pool(s) from /var/lib/mysql/ib_buffer_pool discovery-mysql    | 2021-06-23T16:03:23.980060Z 0 [Note] Plugin 'FEDERATED' is disabled. discovery-mysql    | 2021-06-23T16:03:23.982100Z 0 [Note] InnoDB: Buffer pool(s) load completed at 210623 16:03:23 discovery-mysql    | 2021-06-23T16:03:23.984495Z 0 [Note] Found ca.pem, server-cert.pem and server-key.pem in data directory. Trying to enable SSL support using them. discovery-mysql    | 2021-06-23T16:03:23.984525Z 0 [Note] Skipping generation of SSL certificates as certificate files are present in data directory. discovery-mysql    | 2021-06-23T16:03:23.985024Z 0 [Warning] CA certificate ca.pem is self signed. discovery-mysql    | 2021-06-23T16:03:23.985071Z 0 [Note] Skipping generation of RSA key pair as key files are present in data directory. discovery-mysql    | 2021-06-23T16:03:23.985582Z 0 [Note] Server hostname (bind-address): '*'; port: 3306 discovery-mysql    | 2021-06-23T16:03:23.985650Z 0 [Note] IPv6 is available. discovery-mysql    | 2021-06-23T16:03:23.985661Z 0 [Note]   - '::' resolves to '::'; discovery-mysql    | 2021-06-23T16:03:23.985676Z 0 [Note] Server socket created on IP: '::'. discovery-mysql    | 2021-06-23T16:03:23.992611Z 0 [Warning] Insecure configuration for --pid-file: Location '/var/run/mysqld' in the path is accessible to all OS users. Consider choosing a different directory.  discovery-mysql    | 2021-06-23T16:03:23.999904Z 0 [Note] Event Scheduler: Loaded 0 events discovery-mysql    | 2021-06-23T16:03:24.000165Z 0 [Note] mysqld: ready for connections. discovery-mysql    | Version: '5.7.34'  socket: '/var/run/mysqld/mysqld.sock'  port: 3306  MySQL Community Server (GPL) flyway_1           | ERROR: Invalid argument: url=jdbc:mysql://discovery-mysql:3306/r2dbc?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false -user=root -password=tomo migrate helloworld_flyway_1 exited with code 1 discovery-app_1    |  discovery-app_1    |   .   ____          _            __ _ _ discovery-app_1    |  /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\ discovery-app_1    | ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ discovery-app_1    |  \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) ) discovery-app_1    |   '  |____| .__|_| |_|_| |_\\__, | / / / / discovery-app_1    |  =========|_|==============|___/=/_/_/_/ discovery-app_1    |  :: Spring Boot ::                (v2.5.0) discovery-app_1    | discovery-app_1    | 2021-06-23 16:03:25.501  INFO 1 --- [           main] c.t.HelloWorld.HelloWorldApplication     : Starting HelloWorldApplication v0.0.1-SNAPSHOT using Java 16.0.1 on 1d485fdb3de3 with PID 1 (/app.jar started by root in /) discovery-app_1    | 2021-06-23 16:03:25.503  INFO 1 --- [           main] c.t.HelloWorld.HelloWorldApplication     : No active profile set, falling back to default profiles: default discovery-app_1    | 2021-06-23 16:03:26.119  INFO 1 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data R2DBC repositories in DEFAULT mode. discovery-app_1    | 2021-06-23 16:03:26.242  INFO 1 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 118 ms. Found 1 R2DBC repository interfaces. discovery-app_1    | **************************************************************************************************************** discovery-app_1    | r2dbc:mysql://root:tomo@discovery-mysql:3306/r2dbc  // System.out.println(@Value(&quot;${spring.datasource.url}&quot;)) discovery-app_1    | **************************************************************************************************************** discovery-app_1    | 2021-06-23 16:03:27.354  INFO 1 --- [           main] o.f.c.internal.license.VersionPrinter    : Flyway Community Edition 7.10.0 by Redgate discovery-app_1    | 2021-06-23 16:03:27.469  WARN 1 --- [           main] onfigReactiveWebServerApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.spring framework.beans.factory.BeanCreationException: Error creating bean with name 'flywayInitializer' defined in class path resource [org/springframework/boot/autoconfigure/flyway/FlywayAutoConfiguration$FlywayConfi guration.class]: Invocation of init method failed; nested exception is org.flywaydb.core.internal.exception.FlywaySqlException: discovery-app_1    | Unable to obtain connection from database: Communications link failure discovery-app_1    | discovery-app_1    | The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server. discovery-app_1    | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ----------- discovery-app_1    | SQL State  : 08S01 discovery-app_1    | Error Code : 0 discovery-app_1    | Message    : Communications link failure discovery-app_1    | discovery-app_1    | The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server. discovery-app_1    | discovery-app_1    | 2021-06-23 16:03:27.485  INFO 1 --- [           main] ConditionEvaluationReportLoggingListener : discovery-app_1    | discovery-app_1    | Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled. discovery-app_1    | 2021-06-23 16:03:27.505 ERROR 1 --- [           main] o.s.boot.SpringApplication               : Application run failed discovery-app_1    | discovery-app_1    | org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'flywayInitializer' defined in class path resource [org/springframework/boot/autoconfigure/flyway/Flyw ayAutoConfiguration$FlywayConfiguration.class]: Invocation of init method failed; nested exception is org.flywaydb.core.internal.exception.FlywaySqlException: discovery-app_1    | Unable to obtain connection from database: Communications link failure discovery-app_1    | discovery-app_1    | The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server. discovery-app_1    | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ----------- discovery-app_1    | SQL State  : 08S01 discovery-app_1    | Error Code : 0 discovery-app_1    | Message    : Communications link failure discovery-app_1    | discovery-app_1    | The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server. discovery-app_1    | discovery-app_1    |    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1786) ~[spring-beans-5.3.7.jar!/:5.3.7] discovery-app_1    |    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:602) ~[spring-beans-5.3.7.jar!/:5.3.7] discovery-app_1    |    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:524) ~[spring-beans-5.3.7.jar!/:5.3.7] discovery-app_1    |    at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.7.jar!/:5.3.7] discovery-app_1    |    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.7.jar!/:5.3.7] discovery-app_1    |    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.7.jar!/:5.3.7] discovery-app_1    |    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.7.jar!/:5.3.7] discovery-app_1    |    at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:944) ~[spring-beans-5.3.7.jar!/:5.3.7] discovery-app_1    |    at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:918) ~[spring-context-5.3.7.jar!/:5.3.7] discovery-app_1    |    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:583) ~[spring-context-5.3.7.jar!/:5.3.7] discovery-app_1    |    at org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext.refresh(ReactiveWebServerApplicationContext.java:64) ~[spring-boot-2.5.0.jar!/:2.5.0] discovery-app_1    |    at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:758) ~[spring-boot-2.5.0.jar!/:2.5.0] discovery-app_1    |    at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:438) ~[spring-boot-2.5.0.jar!/:2.5.0] discovery-app_1    |    at org.springframework.boot.SpringApplication.run(SpringApplication.java:337) ~[spring-boot-2.5.0.jar!/:2.5.0] discovery-app_1    |    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1336) ~[spring-boot-2.5.0.jar!/:2.5.0] discovery-app_1    |    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1325) ~[spring-boot-2.5.0.jar!/:2.5.0] discovery-app_1    |    at com.tomoaki3284.HelloWorld.HelloWorldApplication.main(HelloWorldApplication.java:11) ~[classes!/:0.0.1-SNAPSHOT] discovery-app_1    |    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na] discovery-app_1    |    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78) ~[na:na] discovery-app_1    |    at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na] discovery-app_1    |    at java.base/java.lang.reflect.Method.invoke(Method.java:567) ~[na:na] discovery-app_1    |    at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:49) ~[app.jar:0.0.1-SNAPSHOT] discovery-app_1    |    at org.springframework.boot.loader.Launcher.launch(Launcher.java:108) ~[app.jar:0.0.1-SNAPSHOT] discovery-app_1    |    at org.springframework.boot.loader.Launcher.launch(Launcher.java:58) ~[app.jar:0.0.1-SNAPSHOT] discovery-app_1    |    at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:88) ~[app.jar:0.0.1-SNAPSHOT] discovery-app_1    | Caused by: org.flywaydb.core.internal.exception.FlywaySqlException: discovery-app_1    | Unable to obtain connection from database: Communications link failure discovery-app_1    | discovery-app_1    | The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server. discovery-app_1    | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ----------- discovery-app_1    | SQL State  : 08S01 discovery-app_1    | Error Code : 0 discovery-app_1    | Message    : Communications link failure discovery-app_1    | discovery-app_1    | The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server. discovery-app_1    | discovery-app_1    |    at org.flywaydb.core.internal.jdbc.JdbcUtils.openConnection(JdbcUtils.java:71) ~[flyway-core-7.10.0.jar!/:na] discovery-app_1    |    at org.flywaydb.core.internal.jdbc.JdbcConnectionFactory.&lt;init&gt;(JdbcConnectionFactory.java:68) ~[flyway-core-7.10.0.jar!/:na] discovery-app_1    |    at org.flywaydb.core.Flyway.execute(Flyway.java:510) ~[flyway-core-7.10.0.jar!/:na] discovery-app_1    |    at org.flywaydb.core.Flyway.migrate(Flyway.java:170) ~[flyway-core-7.10.0.jar!/:na] discovery-app_1    |    at org.springframework.boot.autoconfigure.flyway.FlywayMigrationInitializer.afterPropertiesSet(FlywayMigrationInitializer.java:66) ~[spring-boot-autoconfigure-2.5.0.jar!/:2.5.0] discovery-app_1    |    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1845) ~[spring-beans-5.3.7.jar!/:5.3.7] discovery-app_1    |    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1782) ~[spring-beans-5.3.7.jar!/:5.3.7] discovery-app_1    |    ... 24 common frames omitted discovery-app_1    | Caused by: com.mysql.cj.jdbc.exceptions.CommunicationsException: Communications link failure discovery-app_1    | discovery-app_1    | The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server. discovery-app_1    |    at com.mysql.cj.jdbc.exceptions.SQLError.createCommunicationsException(SQLError.java:174) ~[mysql-connector-java-8.0.25.jar!/:8.0.25] discovery-app_1    |    at com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException(SQLExceptionsMapping.java:64) ~[mysql-connector-java-8.0.25.jar!/:8.0.25] discovery-app_1    |    at com.mysql.cj.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:833) ~[mysql-connector-java-8.0.25.jar!/:8.0.25] discovery-app_1    |    at com.mysql.cj.jdbc.ConnectionImpl.&lt;init&gt;(ConnectionImpl.java:453) ~[mysql-connector-java-8.0.25.jar!/:8.0.25] discovery-app_1    |    at com.mysql.cj.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:246) ~[mysql-connector-java-8.0.25.jar!/:8.0.25] discovery-app_1    |    at com.mysql.cj.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:198) ~[mysql-connector-java-8.0.25.jar!/:8.0.25] discovery-app_1    |    at org.springframework.jdbc.datasource.SimpleDriverDataSource.getConnectionFromDriver(SimpleDriverDataSource.java:144) ~[spring-jdbc-5.3.7.jar!/:5.3.7] discovery-app_1    |    at org.springframework.jdbc.datasource.AbstractDriverBasedDataSource.getConnectionFromDriver(AbstractDriverBasedDataSource.java:205) ~[spring-jdbc-5.3.7.jar!/:5.3.7] discovery-app_1    |    at org.springframework.jdbc.datasource.AbstractDriverBasedDataSource.getConnection(AbstractDriverBasedDataSource.java:169) ~[spring-jdbc-5.3.7.jar!/:5.3.7] discovery-app_1    |    at org.flywaydb.core.internal.jdbc.JdbcUtils.openConnection(JdbcUtils.java:55) ~[flyway-core-7.10.0.jar!/:na] discovery-app_1    |    ... 30 common frames omitted discovery-app_1    | Caused by: com.mysql.cj.exceptions.CJCommunicationsException: Communications link failure discovery-app_1    | discovery-app_1    | The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server. discovery-app_1    |    at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) ~[na:na] discovery-app_1    |    at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:78) ~[na:na] discovery-app_1    |    at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) ~[na:na] discovery-app_1    |    at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499) ~[na:na] discovery-app_1    |    at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480) ~[na:na] discovery-app_1    |    at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:61) ~[mysql-connector-java-8.0.25.jar!/:8.0.25] discovery-app_1    |    at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:105) ~[mysql-connector-java-8.0.25.jar!/:8.0.25] discovery-app_1    |    at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:151) ~[mysql-connector-java-8.0.25.jar!/:8.0.25] discovery-app_1    |    at com.mysql.cj.exceptions.ExceptionFactory.createCommunicationsException(ExceptionFactory.java:167) ~[mysql-connector-java-8.0.25.jar!/:8.0.25] discovery-app_1    |    at com.mysql.cj.protocol.a.NativeSocketConnection.connect(NativeSocketConnection.java:89) ~[mysql-connector-java-8.0.25.jar!/:8.0.25] discovery-app_1    |    at com.mysql.cj.NativeSession.connect(NativeSession.java:144) ~[mysql-connector-java-8.0.25.jar!/:8.0.25] discovery-app_1    |    at com.mysql.cj.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:953) ~[mysql-connector-java-8.0.25.jar!/:8.0.25] discovery-app_1    |    at com.mysql.cj.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:823) ~[mysql-connector-java-8.0.25.jar!/:8.0.25] discovery-app_1    |    ... 37 common frames omitted discovery-app_1    | Caused by: java.net.ConnectException: Connection refused discovery-app_1    |    at java.base/sun.nio.ch.Net.connect0(Native Method) ~[na:na] discovery-app_1    |    at java.base/sun.nio.ch.Net.connect(Net.java:576) ~[na:na] discovery-app_1    |    at java.base/sun.nio.ch.Net.connect(Net.java:565) ~[na:na] discovery-app_1    |    at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:588) ~[na:na] discovery-app_1    |    at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:333) ~[na:na] discovery-app_1    |    at java.base/java.net.Socket.connect(Socket.java:645) ~[na:na] discovery-app_1    |    at com.mysql.cj.protocol.StandardSocketFactory.connect(StandardSocketFactory.java:155) ~[mysql-connector-java-8.0.25.jar!/:8.0.25] discovery-app_1    |    at com.mysql.cj.protocol.a.NativeSocketConnection.connect(NativeSocketConnection.java:63) ~[mysql-connector-java-8.0.25.jar!/:8.0.25] discovery-app_1    |    ... 40 common frames omitted discovery-app_1    |  // from here, the same log repeatedly because Spring Boot App would restart on failure. </code></pre> <h2>How I am pushing changes every time:</h2> <pre><code>mvnw package &amp;&amp; java -jar target/spring-boot-0.0.1-SNAPSHOT.jar docker build -t tomojava3284/helloworldapi . docker push tomojava3284/helloworldapi:latest docker-compose pull docker-compose up </code></pre> ",
    "OwnerUserId": "10985519",
    "LastEditorUserId": "10985519",
    "LastEditDate": "2021-06-23T16:12:18.737",
    "LastActivityDate": "2022-07-21T10:26:08.390",
    "Title": "Spring Boot, Java, Docker Compose, Getting 'Connection refused' while trying to make connection between two container (mysql, my-api)",
    "Tags": "<mysql><spring-boot><docker><docker-compose><r2dbc>",
    "AnswerCount": "2",
    "CommentCount": "3",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>I think there is a bug there when accessing the database by service name. as a solution I can suggest you use <code>host.docker.internal</code>.<br /> then the URL will be like the below. it will not be a problem in the production mode due to using a managed database.</p> <pre class='lang-bash prettyprint-override'><code>- spring.datasource.url=r2dbc:mysql://root:tomo@host.docker.internal:3306/r2dbc </code></pre> <p><a href='https://docs.docker.com/desktop/networking/#i-want-to-connect-from-a-container-to-a-service-on-the-host' rel='nofollow noreferrer'>https://docs.docker.com/desktop/networking/#i-want-to-connect-from-a-container-to-a-service-on-the-host</a></p> "
  },
  {
    "Id": "68856586",
    "PostTypeId": "1",
    "CreationDate": "2021-08-20T03:10:18.480",
    "Score": "3",
    "ViewCount": "633",
    "Body": "<p>I have discovery service: <a href='https://github.com/Naresh-Chaurasia/API-MicroServices-Kafka/tree/master/Microservices-CQRS-SAGA-Kafka/DiscoveryService' rel='nofollow noreferrer'>https://github.com/Naresh-Chaurasia/API-MicroServices-Kafka/tree/master/Microservices-CQRS-SAGA-Kafka/DiscoveryService</a></p> <p>I have product service: <a href='https://github.com/Naresh-Chaurasia/API-MicroServices-Kafka/tree/master/Microservices-CQRS-SAGA-Kafka/ProductsService' rel='nofollow noreferrer'>https://github.com/Naresh-Chaurasia/API-MicroServices-Kafka/tree/master/Microservices-CQRS-SAGA-Kafka/ProductsService</a></p> <p>Following is my <strong>docker-compose.yml</strong> file: <a href='https://github.com/Naresh-Chaurasia/API-MicroServices-Kafka/tree/master/Microservices-CQRS-SAGA-Kafka/docker-compose.yml' rel='nofollow noreferrer'>https://github.com/Naresh-Chaurasia/API-MicroServices-Kafka/tree/master/Microservices-CQRS-SAGA-Kafka/docker-compose.yml</a></p> <pre><code>version: &quot;3.8&quot;  services:    axon-server:     image: axoniq/axonserver     container_name: axon-server     ports:       - 8124:8124       - 8024:8024     networks:       - axon-demo    discovery-service:     build:       context: ./DiscoveryService     container_name: discovery-service     ports:       - 8010:8010     networks:       - axon-demo  networks:   axon-demo:     driver: bridge </code></pre> <p>When i run the following command <code>docker-compose up</code>, I get <strong>axon-server</strong> and <strong>discovery-service</strong> running.</p> <p>I now run ProductService using the following file <code>src/main/java/com/appsdeveloperblog/estore/ProductsService/ProductsServiceApplication.java</code> which is under <a href='https://github.com/Naresh-Chaurasia/API-MicroServices-Kafka/tree/master/Microservices-CQRS-SAGA-Kafka/ProductsService' rel='nofollow noreferrer'>https://github.com/Naresh-Chaurasia/API-MicroServices-Kafka/tree/master/Microservices-CQRS-SAGA-Kafka/ProductsService</a>.</p> <p>It works fine.</p> <p>The problem start when I try to run ProductService as a microservice, and it fails to connect to axon server. To do that I modify the <strong>docker-compose.yml</strong> as follows:</p> <pre><code>version: &quot;3.8&quot;  services:    axon-server:     image: axoniq/axonserver     container_name: axon-server     ports:       - 8124:8124       - 8024:8024     networks:       - axon-demo    discovery-service:     build:       context: ./DiscoveryService     container_name: discovery-service     ports:       - 8010:8010     networks:       - axon-demo    product-service:     build:       context: ./ProductsService     ports:       - 8090:8090     depends_on:       - axon-server       - discovery-service     networks:       - axon-demo  networks:   axon-demo:     driver: bridge </code></pre> <p>Now if I try to run <code>docker-compose up</code>, I get the following error:</p> <pre><code>product-service_1    | 2021-08-20 03:06:27.973  INFO 1 --- [@29db04f6c0a4-0] i.a.a.c.impl.AxonServerManagedChannel    : Requesting connection details from localhost:8124 product-service_1    | 2021-08-20 03:06:30.004  WARN 1 --- [@29db04f6c0a4-0] i.a.a.c.impl.AxonServerManagedChannel    : Connecting to AxonServer node [localhost:8124] failed: UNAVAILABLE: io exception </code></pre> <p>I have gone through the following link, <a href='https://stackoverflow.com/questions/68328914/spring-boot-microservices-are-unable-to-connect-to-axon-server'>Spring Boot Microservices are unable to connect to Axon Server</a>, which looks like similar problem but still not able to fix my problem.</p> <p>Please guide.</p> <p>Thanks.</p> ",
    "OwnerUserId": "3532455",
    "LastEditorUserId": "3532455",
    "LastEditDate": "2021-08-20T03:13:37.493",
    "LastActivityDate": "2021-09-01T12:54:11.077",
    "Title": "Microservice not able to connect to AXON Server running as docker image",
    "Tags": "<spring-boot><docker><docker-compose><axon>",
    "AnswerCount": "2",
    "CommentCount": "4",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>I made the following changes and it works fine now.</p> <p>In the file <code>ProductsService\\src\\main\\resources\\application.properties</code></p> <p>Old Entry: <code>eureka.client.serviceUrl.defaultZone = http://localhost:8010/eureka</code></p> <p>New Entry: <code>eureka.client.serviceUrl.defaultZone = http://discovery-service:8010/eureka</code></p> <p>Added the following line in the above file: <code>axon.axonserver.servers=axon-server:8124</code></p> <p>In the File:  <code>Microservices-CQRS-SAGA-Kafka\\docker-compose.yml</code></p> <p>Old Entry: version: &quot;3.8&quot;</p> <p>New Entry: version: &quot;2&quot;</p> <p>Added following code in yml file</p> <pre><code>   product-service:     build:       context: ./ProductsService     ports:       - 8090:8090     networks:       - axon-demo </code></pre> <p>I have also checked in the code in git. The micro services can talk to each other, and connect to axon server and the problem reported earlier is resolved.</p> <p>Thanks.</p> "
  },
  {
    "Id": "69900773",
    "PostTypeId": "1",
    "AcceptedAnswerId": "70082078",
    "CreationDate": "2021-11-09T15:25:18.200",
    "Score": "3",
    "ViewCount": "2058",
    "Body": "<p>I'm running a spring boot application inside docker container and that it is linked another Cassandra's container with a docker network (drive bridge). The problem is that I'm using an environment variable linux called <code>CASSANDRA_HOST</code> to save the Cassandra's container IP and the spring boot <code>could not resolve placeholder 'CASSANDRA_HOST' in value &quot;${CASSANDRA_HOST}&quot;</code>.</p> <p>The environment variable was created ok in the Spring Boot container. And I tested other environment variable and some works and others doesn't work. So, I don't understand where is the error.</p> <p><strong>ERROR:</strong></p> <pre><code> Caused by: java.lang.IllegalArgumentException: Could not resolve placeholder 'CASSANDRA_HOST' in value &quot;${CASSANDRA_HOST}&quot;                 at org.springframework.util.PropertyPlaceholderHelper.parseStringValue(PropertyPlaceholderHelper.java:178)                 at org.springframework.util.PropertyPlaceholderHelper.replacePlaceholders(PropertyPlaceholderHelper.java:124)                 at org.springframework.core.env.AbstractPropertyResolver.doResolvePlaceholders(AbstractPropertyResolver.java:239)                 at org.springframework.core.env.AbstractPropertyResolver.resolveRequiredPlaceholders(AbstractPropertyResolver.java:210)                 at org.springframework.core.env.AbstractPropertyResolver.resolveNestedPlaceholders(AbstractPropertyResolver.java:230)                 at org.springframework.core.env.PropertySourcesPropertyResolver.getProperty(PropertySourcesPropertyResolver.java:88)                 at org.springframework.core.env.PropertySourcesPropertyResolver.getProperty(PropertySourcesPropertyResolver.java:62)                 at org.springframework.core.env.AbstractEnvironment.getProperty(AbstractEnvironment.java:535)                 at org.springframework.context.support.PropertySourcesPlaceholderConfigurer$1.getProperty(PropertySourcesPlaceholderConfigurer.java:137)                 at org.springframework.context.support.PropertySourcesPlaceholderConfigurer$1.getProperty(PropertySourcesPlaceholderConfigurer.java:133)                 at org.springframework.core.env.PropertySourcesPropertyResolver.getProperty(PropertySourcesPropertyResolver.java:85)                 at org.springframework.core.env.PropertySourcesPropertyResolver.getPropertyAsRawString(PropertySourcesPropertyResolver.java:74)                 at org.springframework.util.PropertyPlaceholderHelper.parseStringValue(PropertyPlaceholderHelper.java:151)                 at org.springframework.util.PropertyPlaceholderHelper.replacePlaceholders(PropertyPlaceholderHelper.java:124)                 at org.springframework.core.env.AbstractPropertyResolver.doResolvePlaceholders(AbstractPropertyResolver.java:239)                 at org.springframework.core.env.AbstractPropertyResolver.resolveRequiredPlaceholders(AbstractPropertyResolver.java:210)                 at org.springframework.context.support.PropertySourcesPlaceholderConfigurer.lambda$processProperties$0(PropertySourcesPlaceholderConfigurer.java:175)                 at org.springframework.beans.factory.support.AbstractBeanFactory.resolveEmbeddedValue(AbstractBeanFactory.java:936)                 at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1321)                 at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1300)                 at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:640)                 at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119)                 at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399)                 ... 59 more </code></pre> <p>In the <strong>application.properties</strong>, I set the variable as below:</p> <pre><code>cassandra.contactpoints= ${CASSANDRA_HOST} </code></pre> <p>In the class <strong>CassandraCoonfig</strong>, I set the @value to read the IP:</p> <pre><code>@Configuration  public class CassandraConfig extends  AbstractCassandraConfiguration {      @Value(&quot;${cassandra.contactpoints}&quot;)         private String contactPoints; </code></pre> <p>In the <strong>POM.XML</strong>, I'm using the tag <code>&lt; filtering &gt;</code>:</p> <pre><code>&lt;resources&gt;     &lt;resource&gt;         &lt;directory&gt;src/main/resources&lt;/directory&gt;         &lt;filtering&gt;true&lt;/filtering&gt;     &lt;/resource&gt; &lt;/resources&gt; </code></pre> <p><strong>EDIT:</strong> This is the print of all environment variable in the spring container. The CASSANDRA_HOST is there in the line 14.</p> <p><a href='https://i.stack.imgur.com/ZMp1C.png' rel='nofollow noreferrer'><img src='https://i.stack.imgur.com/ZMp1C.png' alt='enter image description here' /></a></p> ",
    "OwnerUserId": "15200705",
    "LastEditorUserId": "1054558",
    "LastEditDate": "2022-06-16T20:10:38.460",
    "LastActivityDate": "2022-07-26T05:12:20.087",
    "Title": "ERROR :docker Spring boot container : java.lang.IllegalArgumentException: Could not resolve placeholder 'CASSANDRA_HOST' in value '${CASSANDRA_HOST}'",
    "Tags": "<spring-boot><docker><docker-compose><cassandra><cassandra-3.0>",
    "AnswerCount": "2",
    "CommentCount": "4",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>I resolved this issue building a bridge in the <code>docker-compose.yml</code> with the command below:</p> <pre><code>networks:   net:     driver: &quot;bridge&quot; </code></pre> <p>This is the complete <code>docker-compose.yml</code>:</p> <pre><code>version: '3'  services:   ... (your code)   networks:      - net  networks:       net:         driver: &quot;bridge&quot; </code></pre> <p>With this net in the docker image, in the container, you inspect the net and you'll find the IP that you need. Then you set the environment variable with this IP.</p> <p>It resolved in my scenario.</p> ",
    "highest_rated_answer": "<p>My solution is</p> <pre><code>@Bean public static PropertySourcesPlaceholderConfigurer placeholderConfigurer() {     PropertySourcesPlaceholderConfigurer placeholderConfigurer = new PropertySourcesPlaceholderConfigurer();     placeholderConfigurer.setIgnoreUnresolvablePlaceholders(true);     return placeholderConfigurer; } </code></pre> <p>Set whether to ignore unresolvable placeholders. Default is &quot;false&quot;: An exception will be thrown if a placeholder fails to resolve. Switch this flag to &quot;true&quot; in order to preserve the placeholder String as-is in such a case, leaving it up to other placeholder configurers to resolve it.</p> "
  },
  {
    "Id": "72348615",
    "PostTypeId": "1",
    "AcceptedAnswerId": "72352837",
    "CreationDate": "2022-05-23T12:35:52.937",
    "Score": "3",
    "ViewCount": "1404",
    "Body": "<p>I want to start up a docker container with debug options as follows, but the startup won't work:</p> <p><code>Dockerfile</code>:</p> <pre><code># syntax=docker/dockerfile:1 FROM maven:3-eclipse-temurin-11 as dependencies WORKDIR /opt/app COPY .dockerdev/settings.xml . COPY pom.xml . COPY src src ENTRYPOINT[&quot;mvn&quot;, &quot;spring-boot:run&quot;] </code></pre> <p><code>docker-compose.yml</code>:</p> <pre><code>version: '3.7' services:   app:     environment:       - &quot;JAVA_TOOL_OPTIONS=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005&quot;     ports:       - 8080:8080       - 5005:5005        </code></pre> <p>Result:</p> <pre><code>docker-compose up Recreating my_app ... done Attaching to my_app app_1  | Picked up JAVA_TOOL_OPTIONS: -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005 app_1  | Listening for transport dt_socket at address: 5005 app_1  | [INFO] Scanning for projects... app_1  | [INFO] --- maven-resources-plugin:3.2.0:resources (default-resources) @ my_app --- app_1  | [INFO] Using 'UTF-8' encoding to copy filtered resources. app_1  | [INFO] Using 'UTF-8' encoding to copy filtered properties files. app_1  | [INFO] Copying 3 resources app_1  | [INFO] Copying 3 resources app_1  | [INFO]  app_1  | [INFO] --- maven-compiler-plugin:3.8.1:compile (default-compile) @ my_app --- app_1  | [INFO] Changes detected - recompiling the module! app_1  | [INFO]  app_1  | [INFO] --- maven-resources-plugin:3.2.0:testResources (default-testResources) @ my_app --- app_1  | [INFO] Using 'UTF-8' encoding to copy filtered resources. app_1  | [INFO] Using 'UTF-8' encoding to copy filtered properties files. app_1  | [INFO] Copying 3 resources app_1  | [INFO]  app_1  | [INFO] --- maven-compiler-plugin:3.8.1:testCompile (default-testCompile) @ my_app --- app_1  | [INFO] Changes detected - recompiling the module! app_1  | [INFO] Compiling 5 source files to /opt/app/target/test-classes app_1  | [INFO]  app_1  | [INFO] &lt;&lt;&lt; spring-boot-maven-plugin:2.6.7:run (default-cli) &lt; test-compile @ my_app &lt;&lt;&lt; app_1  | [INFO]  app_1  | [INFO]  app_1  | [INFO] --- spring-boot-maven-plugin:2.6.7:run (default-cli) @ my_app --- app_1  | [INFO] Attaching agents: [] app_1  | Picked up JAVA_TOOL_OPTIONS: -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005 app_1  | ERROR: transport error 202: bind failed: Address already in use app_1  | ERROR: JDWP Transport dt_socket failed to initialize, TRANSPORT_INIT(510) app_1  | JDWP exit error AGENT_ERROR_TRANSPORT_INIT(197): No transports initialized [./src/jdk.jdwp.agent/share/native/libjdwp/debugInit.c:735] app_1  | [INFO] ------------------------------------------------------------------------ app_1  | [INFO] BUILD FAILURE app_1  | [INFO] ------------------------------------------------------------------------ app_1  | [INFO] Total time:  3.000 s app_1  | [INFO] Finished at: 2022-05-23T12:30:50Z app_1  | [INFO] ------------------------------------------------------------------------ app_1  | [ERROR] Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:2.6.7:run (default-cli) on project my_app: Application finished with exit code: 2 -&gt; [Help 1] app_1  | [ERROR]  app_1  | [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch. app_1  | [ERROR] Re-run Maven using the -X switch to enable full debug logging. app_1  | [ERROR]  app_1  | [ERROR] For more information about the errors and possible solutions, please read the following articles: app_1  | [ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException my_app exited with code 1 </code></pre> <p>Sidenote: Port 5005 is of course <em>not</em> running/listening on my host! Also, if I change the port to 5006, 5007 etc, the error is always the same.</p> <p>So why is the port blocked on <code>mvn spring-boot:run</code>?</p> ",
    "OwnerUserId": "1194415",
    "LastActivityDate": "2022-05-23T17:48:16.313",
    "Title": "How to debug a JDK docker container in intellij idea?",
    "Tags": "<java><spring-boot><docker><maven><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "9",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>The problem with your solution is that there are 2 debug sessions being started. 1 for the maven command and 1 for the forked JVM voor Spring Boot. Hence the error and changing the port won't solve this as the problem will remain.</p> <p>What you need to do is remove the <code>JAVA_TOOL_OPTIONS</code> from your docker compose file and instead add the following to your entry point</p> <pre><code>-Dspring-boot.run.jvmArguments=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005 </code></pre> <p>That way it will only apply to the Spring Boot plugin and will be taken into account when launching the app in a new JVM.</p> ",
    "highest_rated_answer": null
  },
  {
    "Id": "73552304",
    "PostTypeId": "1",
    "AcceptedAnswerId": "73555812",
    "CreationDate": "2022-08-31T07:28:28.633",
    "Score": "3",
    "ViewCount": "2025",
    "Body": "<p>I have a folder which already contains images. The user can add/update/delete the image with the object. Problem is when I dockerize my application, the user who get my docker image it gets the folder with images (I have a folder where are stored image.png) too? If not how can I make sure it gets the folder too inside docker.</p> <p>[This other problem it was solved] My problem is that inside Docker I don't know how to show these images to my angular application.</p> <p>Here is my dockerfile:</p> <pre><code>FROM openjdk:17 ENV APP_HOME=/usr/app/ WORKDIR $APP_HOME ADD target/Nation-0.0.1-SNAPSHOT.jar target/springboot-docker-county.jar EXPOSE 8090 CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;target/springboot-docker-county.jar&quot;] </code></pre> <p>Here my docker compose:</p> <pre><code>services:   db:     image: mongo:latest     ports:       - 27017:27017     environment:       SPRING_DATA_MONGODB_URI: mongodb://host.docker.internal:27017       MONGO_INITDB_ROOT_USERNAME: user       MONGO_INITDB_ROOT_PASSWORD: pass     volumes:       - ./mongo-init.js:/docker-entrypoint-initdb.d/mongo-init.js:r   web:     build: ./WorldBE/target/classes/county-fe     ports:       - 80:80   api:     build: ./WorldBE     ports:       - 8090:8090     volumes:       - ./images/:/usr/app/application/images  volumes:   county: </code></pre> <p>Here my application.yml to get the folder:</p> <pre><code>spring:   web:     resources:       static-locations: /usr/app/application/images </code></pre> <p>Here how can I perform the add method (it works):</p> <pre><code> public void saveFile(String region, Integer id, Binary image) throws Exception {         Path url = Paths.get( pathToSave);         if (image != null) {             File fileToSave = new File(url +&quot;/&quot;+ this.regional(region, id) + &quot;.png&quot;);             if (fileToSave.exists()) {                 log.error(&quot;Image for {} and regional: {} already exist! file: {}&quot;, id, region, fileToSave);                 throw new Exception(String.format(&quot;Image for : %s and region: %s already exist!&quot;, id, region));             }              if (!fileToSave.exists()) {                 log.info(&quot;file doesn't exist: {}&quot;, fileToSave);             }             // Try-with-resource             try (OutputStream out = new FileOutputStream(fileToSave)) {                 out.write(image.getData());                 out.flush();                 log.info(&quot;file saved: {}&quot;, fileToSave);             } catch (IOException e) {                 e.printStackTrace();             }         } else {             log.error(&quot;No image set&quot;);         } </code></pre> <p>The user get the mount (folder with image.png) already populate when it pulls the image or should I do something else to store this folder in docker?</p> ",
    "OwnerUserId": "19869319",
    "LastEditorUserId": "19869319",
    "LastEditDate": "2022-08-31T11:14:58.453",
    "LastActivityDate": "2022-08-31T12:19:48.060",
    "Title": "Spring Boot get images from an external folder with Docker",
    "Tags": "<java><spring><spring-boot><docker><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>Move the folder with the images in your resource/static folder, than in your docker file (after MKDIR) add:</p> <pre><code>ADD src/main/resources/static/images application/images </code></pre> <p>and delete from your docker-compose:</p> <pre><code>  volumes:       - ./images/:/usr/app/application/images </code></pre> ",
    "highest_rated_answer": "<p>In spring-boot, you can expose the endpoint as a static resource with the following properties:</p> <pre><code>spring.web.resources.static-locations=file:/usr/app/application/images spring.mvc.static-path-pattern=/images/** </code></pre> <p>Please note the <code>file</code> prefix when defining <code>static-locations</code></p> "
  },
  {
    "Id": "75885269",
    "PostTypeId": "1",
    "AcceptedAnswerId": "75899112",
    "CreationDate": "2023-03-30T07:26:06.227",
    "Score": "3",
    "ViewCount": "1679",
    "Body": "<p>I'm building my Docker image using Spring Boot's built in Gradle <code>:bootBuildImage</code> task, which is quite convenient, because I don't have to maintain my own <code>Dockerfile</code>.</p> <p>The Gradle task uses the <a href='https://github.com/paketo-buildpacks/bionic-base-stack' rel='nofollow noreferrer'>Paketo Bionic Base Stack</a> under the hood and will build a layered Docker image just fine.</p> <p>Now, some orchestration engines like Docker Swarm (or simply Docker Compose for dev purposes) execute health checks <em>within</em> the container. Unfortunately, however, the resulting Spring Boot Docker image doesn't have any health checker tools like <code>curl</code> or <code>wget</code> installed, so something like</p> <pre><code>version: '3.7'  services:   springBootApp:     image: my/springboot/docker-image     healthcheck:       test: [&quot;CMD-SHELL&quot;, &quot;curl http://localhost:8080/actuator/health&quot;]         </code></pre> <p>in <code>docker-compose.yml</code> will fail. (I checked that actuators themselves are working fine)</p> <p>I know that <code>curl</code> or <code>wget</code> aren't ideal. I was actually hoping that the Paketo Builder would pick up something like this <a href='https://github.com/paketo-buildpacks/health-checker' rel='nofollow noreferrer'>Health Checker BuildPack</a>.</p> <p>Is there a way to configure my <code>bootBuildImage</code> Gradle task to include that (or a similar) additional BuildPack?</p> <p>As mentioned above, I'm looking for an easy to maintain solution and don't want to write my own <code>Dockerfile</code> to be able to profit from all the baked in best practices Paketo offers.</p> ",
    "OwnerUserId": "287138",
    "LastActivityDate": "2023-03-31T13:30:33.357",
    "Title": "Spring Boot Build Image with Health Check",
    "Tags": "<spring-boot><docker><docker-compose><health-check><paketo>",
    "AnswerCount": "1",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>The Health Checkers buildpack hasn't been added to the main builders just yet, but it is fully available to use with your apps.</p> <h3>Instructions</h3> <ol> <li><p><a href='https://docs.spring.io/spring-boot/docs/3.0.5/gradle-plugin/reference/htmlsingle/#build-image.examples.buildpacks' rel='noreferrer'>Modify your <code>build.gradle</code> file</a>:</p> <pre><code>tasks.named(&quot;bootBuildImage&quot;) {   environment[&quot;BP_HEALTH_CHECKER_ENABLED&quot;] = &quot;true&quot;   buildpacks = [&quot;urn:cnb:builder:paketo-buildpacks/java&quot;, &quot;gcr.io/paketo-buildpacks/health-checker:latest&quot;] } </code></pre> <p>This will set an env variable at build time instructing the health-checkers buildpack to participate. It also tells Spring Boot build tools to append the health-checkers buildpack to the list of Java buildpacks that ship in the builder by default.</p> <p><strong>NOTE</strong> you may want to put in a particular version of health-checkers, that's up to you. It supports standard tag conventions like <code>:1</code>, <code>:1.4</code>, <code>:1.4.0</code> and <code>:latest</code> so you can pin to latest major/minor or a specific version.</p> </li> <li><p>Build.  <code>./gradlew bootBuildImage</code>. You'll see the health checkers buildpack included in detection.</p> <pre><code>[creator]     ===&gt; DETECTING [creator]     7 of 27 buildpacks participating [creator]     paketo-buildpacks/ca-certificates   3.6.0 [creator]     paketo-buildpacks/bellsoft-liberica 10.0.0 [creator]     paketo-buildpacks/syft              1.26.0 [creator]     paketo-buildpacks/executable-jar    6.6.2 [creator]     paketo-buildpacks/dist-zip          5.5.2 [creator]     paketo-buildpacks/spring-boot       5.23.0 [creator]     paketo-buildpacks/health-checker    1.3.1 ... </code></pre> </li> <li><p>Optional. Run <code>pack inspect &lt;image&gt;</code> against the produced image. You can see that health checkers has contributed a <code>health-check</code> process type.</p> <pre><code>Processes:   TYPE                  SHELL        COMMAND        ARGS                                               WORK DIR   web (default)                      java           org.springframework.boot.loader.JarLauncher        /workspace   executable-jar                     java           org.springframework.boot.loader.JarLauncher        /workspace   health-check                       thc                                                               /workspace   task                               java           org.springframework.boot.loader.JarLauncher        /workspace </code></pre> </li> <li><p>Run your app. <code>docker run -d --health-cmd /cnb/process/health-check -p 8080:8080 -e THC_PATH=/actuator/health &lt;image&gt;</code>.</p> <p>The health checker that's used by default is <a href='https://github.com/dmikusa/tiny-health-checker#usage' rel='noreferrer'>tiny-health-checker</a>. It has other env variables you can configure but for a Spring Boot app you just need to set the actuator path (unless you have management port set differently, then set <code>THC_PORT=&lt;management-port&gt;</code> also.</p> </li> </ol> <p>If you are a Maven user, the process is very similar. Just substitute these instructions for step #1 and then #2 build with <code>./mvnw spring-boot:build-image</code>.</p> <pre><code>    &lt;plugin&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;         &lt;configuration&gt;             &lt;layers&gt;                 &lt;enabled&gt;true&lt;/enabled&gt;             &lt;/layers&gt;             &lt;image&gt;                 &lt;env&gt;                     &lt;BP_HEALTH_CHECKER_ENABLED&gt;true&lt;/BP_HEALTH_CHECKER_ENABLED&gt;                 &lt;/env&gt;                 &lt;buildpacks&gt;                     &lt;buildpack&gt;urn:cnb:builder:paketo-buildpacks/java&lt;/buildpack&gt;                     &lt;buildpack&gt;gcr.io/paketo-buildpacks/health-checker:latest&lt;/buildpack&gt;                 &lt;/buildpacks&gt;             &lt;/image&gt;         &lt;/configuration&gt;     &lt;/plugin&gt; </code></pre> ",
    "highest_rated_answer": null
  },
  {
    "Id": "50553352",
    "PostTypeId": "1",
    "AcceptedAnswerId": "50554515",
    "CreationDate": "2018-05-27T14:50:49.103",
    "Score": "24",
    "ViewCount": "21733",
    "Body": "<p>I have a docker-compose setup to start my SpringBoot application and a MySQL database. If the database starts first, then my application can connect successfully. But if my application starts first, no database exists yet, so the application throws the following exception and exits:</p>  <pre><code>app_1       | 2018-05-27 14:15:03.415  INFO 1 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting... app_1       | 2018-05-27 14:15:06.770 ERROR 1 --- [           main] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Exception during pool initialization app_1       | com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure </code></pre>  <p>I could edit my docker-compose file to make sure the database is always up before the application starts up, but I want the application to be able to handle this case on its own, and not immediately exit when it cannot reach the database address.</p>  <p>There are ways to configure the datasource in the application.properties file to make the application reconnect to the database, as answered <a href='https://stackoverflow.com/a/33213802/6566891'>here</a> and <a href='https://stackoverflow.com/a/22687418/6566891'>here</a>. But that doesn't work for a startup connection to the datasource.</p>  <p>How can I make my SpringBoot application retry the connection at startup to the database at a given interval until it successfully connects to the database?</p> ",
    "OwnerUserId": "6566891",
    "LastActivityDate": "2020-11-17T12:32:11.997",
    "Title": "Spring retry connection until datasource is available",
    "Tags": "<mysql><spring><spring-boot><docker-compose><hikaricp>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": "<p>Set HikariCP's <code>initializationFailTimeout</code> property to 0 (zero), or a negative number.  As documented <a href='https://github.com/brettwooldridge/HikariCP#infrequently-used' rel='noreferrer'>here</a>:</p>  <blockquote>   <p>\u231a<code>initializationFailTimeout</code></p>      <p>This property controls whether the pool will 'fail fast' if the pool cannot be seeded with an initial connection successfully. Any positive number is taken to be the number of milliseconds to attempt to acquire an initial connection; the application thread will be blocked during this period. If a connection cannot be acquired before this timeout occurs, an exception will be thrown. This timeout is applied <em>after</em> the <code>connectionTimeout</code> period. If the value is zero (0), HikariCP will attempt to obtain and validate a connection. If a connection is obtained, but fails validation, an exception will be thrown and the pool not started. However, if a connection cannot be obtained, the pool will start, but later efforts to obtain a connection may fail. A value less than zero will bypass any initial connection attempt, and the pool will start immediately while trying to obtain connections in the background. Consequently, later efforts to obtain a connection may fail. <em>Default</em>: 1</p> </blockquote> ",
    "highest_rated_answer": "<p>There is an alternative way to do this, <em>which doesn't rely on a specific Connection Pool library or a specific database</em>. Note that you will need to use <code>spring-retry</code> to achieve the desired behaviour with this approach</p> <p>First you need to add spring-retry to your dependencies :</p> <pre><code>&lt;dependency&gt;     &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;     &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;     &lt;version&gt;${spring-retry.version}&lt;/version&gt; &lt;/dependency&gt; </code></pre> <p>Then you can create a decorator over <code>DataSource</code> that will extends <code>AbstractDataSource</code> like bellow :</p> <pre><code>@Slf4j @RequiredArgsConstructor public class RetryableDataSource extends AbstractDataSource {      private final DataSource dataSource;      @Override     @Retryable(maxAttempts = 5, backoff = @Backoff(multiplier = 1.3, maxDelay = 10000))     public Connection getConnection() throws SQLException {         log.info(&quot;getting connection ...&quot;);         return dataSource.getConnection();     }      @Override     @Retryable(maxAttempts = 5, backoff = @Backoff(multiplier = 2.3, maxDelay = 10000))     public Connection getConnection(String username, String password) throws SQLException {         log.info(&quot;getting connection by username and password ...&quot;);         return dataSource.getConnection(username, password);     } } </code></pre> <p>Then you will need to inject this custom DataSource decorator into Spring context by creating a custom <code>BeanPostProcessor</code> :</p> <pre><code>@Slf4j @Order(value = Ordered.HIGHEST_PRECEDENCE) @Component public class RetryableDatabasePostProcessor implements BeanPostProcessor {     @Override     public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {         if(bean instanceof DataSource) {             log.info(&quot;-----&gt; configuring a retryable datasource for beanName = {}&quot;, beanName);             return new RetryableDataSource((DataSource) bean);         }         return bean;     }      @Override     public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {         return bean;     } } </code></pre> <p>Last but not least you will need to enable Spring retry by adding <code>@EnableRetry</code> annotation to spring main class, example :</p> <pre><code>@EnableRetry @SpringBootApplication public class RetryableDbConnectionApplication {      public static void main(String[] args) {         SpringApplication.run(RetryableDbConnectionApplication.class, args);     }  } </code></pre> "
  },
  {
    "Id": "39728643",
    "PostTypeId": "1",
    "CreationDate": "2016-09-27T15:28:33.407",
    "Score": "2",
    "ViewCount": "2940",
    "Body": "<p>Is it possible to configure dockercloud/haproxy with more than one backend service but listening on a different port? I'm trying to get a docker-compose config working with nginx on port 80 for a web frontend, and then a container on 8080 running a Spring Boot app.</p>  <p>It appears by default haproxy is seeing the linked containers for web and addressbook (see .yml file below), but by default they are both being exposed on port 80 by happroxy, and so the Spring Boot container never receives traffic on 8080.</p>  <p>Is this config possible, or do I need to run 2 different haproxy containers too, one for web, and one for the REST backend service?</p>  <p>Here's my docker-compose.yml so far:</p>  <pre><code>version: '2'  #build: #  context: ./haproxy #  image: haproxy # dockerfile: Dockerfile  services:     mongodata:         image: mongo:3.2     volumes:     - /data/db     entrypoint: /bin/bash mongo:     image: mongo:3.2     depends_on:          - mongodata     volumes_from:         - mongodata     ports:     #only specify internal port, not external, so we can scale with docker-compose scale         - '27017' addressbook:     image: addressbook     depends_on:          - mongo     environment:         - MONGODB_DB_NAME=addressbook     ports:         - '8080'     links:         - mongo web:     image: docker-web-angularjs     ports:         - '80' lb:     image: dockercloud/haproxy     #TODO: need to add an haproxy.cfg to configure for addressbook instances exposed behind 8080?     #or can be configured via container properties?     #image: haproxy     depends_on:          - addressbook     environment:         - STATS_PORT=1936         - STATS_AUTH='admin:password'     links:         - addressbook         - web     volumes:         - /var/run/docker.sock:/var/run/docker.sock     ports:         - 80:80         - 8080:8080         - 1936:1936 </code></pre> ",
    "OwnerUserId": "406290",
    "LastActivityDate": "2017-11-28T08:24:50.727",
    "Title": "dockercloud haproxy with more than one service on different ports",
    "Tags": "<docker><spring-boot><docker-compose><haproxy>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p>To me, it's easier to use <a href='https://docs.traefik.io/' rel='nofollow noreferrer'>Traefik</a> to achieve the goal.</p>  <pre><code>addressbook:   image: addressbook   depends_on:      - mongo   environment:     - MONGODB_DB_NAME=addressbook   labels:     - 'traefik.backend=spring_boot'     - 'traefik.protocol=http'     - 'traefik.port=8080'     - 'traefik.frontend.entryPoints=http_8080'   ports:     - '8080'   links:     - mongo  web:   image: docker-web-angularjs   labels:     - 'traefik.backend=nginx'     - 'traefik.protocol=http'     - 'traefik.port=80'     - 'traefik.frontend.entryPoints=http_80'   ports:     - '80'  lb:   image: traefik   command: '--web --web.address=8081 --docker --docker.domain=docker.localhost \\             --logLevel=DEBUG \\             --entryPoints='Name:http_80 Address::80' \\             --entryPoints='Name:http_8080 Address::8080''   ports:     - 80:80     - 8080:8080     - 8081:8081   volumes:     - /var/run/docker.sock:/var/run/docker.sock     - /dev/null:/traefik.toml </code></pre> "
  },
  {
    "Id": "43562842",
    "PostTypeId": "1",
    "AcceptedAnswerId": "43588469",
    "CreationDate": "2017-04-22T18:12:23.393",
    "Score": "2",
    "ViewCount": "1903",
    "Body": "<p>In my docker-compose.yal file I define a spring-boot based web service and a postgresql database service. The web services references the db services and has an environment variable for the database datasource URL where it needs to reference the hostname of the database service. This is what it looks like:</p>  <pre><code>version: '3' services:    web:     container_name: medmap-server     hostname: medmap-server     build: ../../../build/docker     ports: ['8090:8090']     links:       - db:database     environment:       - spring.datasource.url=jdbc:postgresql://medmap-db:5433/medmapdb       - spring.datasource.username=docker       - spring.datasource.password=docker             - logging.level.org.hibernate=DEBUG    db:     container_name: medmap-db     hostname: medmap-db     image: postgres:9.6.2     ports:       - '5433:5433'     volumes:       - /var/lib/medmap/data     environment:       - POSTGRES_PASSWORD=docker       - POSTGRES_USER=docker       - POSTGRES_DB=medmapdb       - PGDATA=/var/lib/medmap/data/pgdata </code></pre>  <p>When I start this application using <code>docker-compose up</code> I get the following error:</p>  <pre><code>medmap-server | Caused by: org.postgresql.util.PSQLException: Connection to medmap-db:5433 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections . medmap-server |         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:239) ~[postgresql-9.4-1200-jdbc41.jar!/:9.4] medmap-server |         at org.postgresql.core.ConnectionFactory.openConnection(ConnectionFactory.java:66) ~[postgresql-9.4-1200-jdbc41.jar!/:9.4] medmap-server |         at org.postgresql.jdbc2.AbstractJdbc2Connection.&lt;init&gt;(AbstractJdbc2Connection.java:127) ~[postgresql-9.4-1200-jdbc41.jar!/:9.4] medmap-server |         at org.postgresql.jdbc3.AbstractJdbc3Connection.&lt;init&gt;(AbstractJdbc3Connection.java:29) ~[postgresql-9.4-1200-jdbc41.jar!/:9.4] medmap-server |         at org.postgresql.jdbc3g.AbstractJdbc3gConnection.&lt;init&gt;(AbstractJdbc3gConnection.java:21) ~[postgresql-9.4-1200-jdbc41.jar!/:9.4] medmap-server |         at org.postgresql.jdbc4.AbstractJdbc4Connection.&lt;init&gt;(AbstractJdbc4Connection.java:41) ~[postgresql-9.4-1200-jdbc41.jar!/:9.4] medmap-server |         at org.postgresql.jdbc4.Jdbc4Connection.&lt;init&gt;(Jdbc4Connection.java:24) ~[postgresql-9.4-1200-jdbc41.jar!/:9.4] medmap-server |         at org.postgresql.Driver.makeConnection(Driver.java:414) ~[postgresql-9.4-1200-jdbc41.jar!/:9.4] medmap-server |         at org.postgresql.Driver.connect(Driver.java:282) ~[postgresql-9.4-1200-jdbc41.jar!/:9.4] medmap-server |         at org.apache.tomcat.jdbc.pool.PooledConnection.connectUsingDriver(PooledConnection.java:310) ~[tomcat-jdbc-8.5.11.jar!/:na] medmap-server |         at org.apache.tomcat.jdbc.pool.PooledConnection.connect(PooledConnection.java:203) ~[tomcat-jdbc-8.5.11.jar!/:na] medmap-server |         at org.apache.tomcat.jdbc.pool.ConnectionPool.createConnection(ConnectionPool.java:732) ~[tomcat-jdbc-8.5.11.jar!/:na] medmap-server |         at org.apache.tomcat.jdbc.pool.ConnectionPool.borrowConnection(ConnectionPool.java:664) ~[tomcat-jdbc-8.5.11.jar!/:na] medmap-server |         at org.apache.tomcat.jdbc.pool.ConnectionPool.init(ConnectionPool.java:479) ~[tomcat-jdbc-8.5.11.jar!/:na] medmap-server |         at org.apache.tomcat.jdbc.pool.ConnectionPool.&lt;init&gt;(ConnectionPool.java:154) ~[tomcat-jdbc-8.5.11.jar!/:na] medmap-server |         at org.apache.tomcat.jdbc.pool.DataSourceProxy.pCreatePool(DataSourceProxy.java:118) ~[tomcat-jdbc-8.5.11.jar!/:na] medmap-server |         at org.apache.tomcat.jdbc.pool.DataSourceProxy.createPool(DataSourceProxy.java:107) ~[tomcat-jdbc-8.5.11.jar!/:na] medmap-server |         at org.apache.tomcat.jdbc.pool.DataSourceProxy.getConnection(DataSourceProxy.java:131) ~[tomcat-jdbc-8.5.11.jar!/:na] medmap-server |         at org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection(DatasourceConnectionProviderImpl.java:122) ~[hibernate-core-5.0.12.Final.jar!/: 5.0.12.Final] medmap-server |         at org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess.obtainConnection(JdbcEnvironmentInitiator.java:180) ~[hibernate-core-5 .0.12.Final.jar!/:5.0.12.Final] medmap-server |         at org.hibernate.tool.schema.extract.internal.ExtractionContextImpl.getJdbcConnection(ExtractionContextImpl.java:62) ~[hibernate-core-5.0.12.Final.jar!/:5.0.12.Final] medmap-server |         ... 38 common frames omitted medmap-server | Caused by: java.net.ConnectException: Connection refused (Connection refused) medmap-server |         at java.net.PlainSocketImpl.socketConnect(Native Method) ~[na:1.8.0_121] medmap-server |         at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350) ~[na:1.8.0_121] medmap-server |         at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206) ~[na:1.8.0_121] medmap-server |         at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188) ~[na:1.8.0_121] medmap-server |         at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392) ~[na:1.8.0_121] medmap-server |         at java.net.Socket.connect(Socket.java:589) ~[na:1.8.0_121] medmap-server |         at org.postgresql.core.PGStream.&lt;init&gt;(PGStream.java:61) ~[postgresql-9.4-1200-jdbc41.jar!/:9.4] medmap-server |         at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:121) ~[postgresql-9.4-1200-jdbc41.jar!/:9.4] medmap-server |         ... 58 common frames omitted medmap-server | medmap-server exited with code 1 </code></pre>  <p>What I do not know is how the pg_hba.conf file is created to allow the web service in one container to access the db service in another container. TIA for any help on this. </p> ",
    "OwnerUserId": "256770",
    "LastActivityDate": "2017-04-24T12:53:43.183",
    "Title": "docker-compose: spring-boot web service access postgres db service",
    "Tags": "<postgresql><spring-boot><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "2",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>The <a href='https://www.postgresql.org/docs/current/static/runtime-config-connection.html' rel='nofollow noreferrer'>default port for postgres is 5432</a>, try defining it instead of 5433</p>  <blockquote>   <p>port (integer) The TCP port the server listens on; 5432 by default.   Note that the same port number is used for all IP addresses the server   listens on. This parameter can only be set at server start.</p> </blockquote> ",
    "highest_rated_answer": "<p>My thanks to @vao-tsun for suggesting I look at the postgres port.</p>  <p>I looked at port used by postgres in my db service by staring a bash shell on the db service's conatiner using:</p>  <p><code>docker exec -i -t medmap-db /bin/bash</code></p>  <p>And then in the bash shell executing following psql command:</p>  <p><code>psql -U postgres -c 'SELECT * FROM pg_settings WHERE name = 'port';'</code></p>  <p>This showed that I was using port 5432 rather than 5423 which is what my web service was using in its IDBC URL specified by spring.datasource.url env variable.</p>  <p>To fix this I needed to specify PGPORT=5433 env variable in my db service. A common mistake is to assume that the ports field in docker-compose tells what port the service should use. The port fields just declares ports used by service. You need to configure ports for your service in service-specific manner (for postgres it was the env variable PGPORT).</p>  <p>Below is my revised docker-compose.yml file that worked:</p>  <pre><code>version: '3' services:    web:     container_name: medmap-server     hostname: medmap-server     build: ../../../build/docker     ports: ['8090:8090']     links:       - db:database     environment:       - server.port=8090       - spring.datasource.url=jdbc:postgresql://medmap-db:5433/medmapdb       - spring.datasource.username=postgres       - spring.datasource.password=postgres       #      - logging.level.org.hibernate=DEBUG    db:     container_name: medmap-db     hostname: medmap-db     image: postgres:9.6.2     ports:       - '5433:5433'     volumes:       - /var/lib/medmap/data     environment:       - POSTGRES_PASSWORD=postgres       - POSTGRES_USER=postgres       - POSTGRES_DB=medmapdb       - PGDATA=/var/lib/medmap/data/pgdata       - PGPORT=5433 </code></pre> "
  },
  {
    "Id": "43707742",
    "PostTypeId": "1",
    "AcceptedAnswerId": "43708880",
    "CreationDate": "2017-04-30T14:54:08.603",
    "Score": "2",
    "ViewCount": "3005",
    "Body": "<p>I've got a spring boot application with producer and receiver which uses the local rabbitmq to send and receive messages. I am trying to deploy both the app and rabbit on docker container and once deployed run the boot app. Once the app is started it has a producer which implements Spring CommandLineRunner meaning that the app immediately starts sending messages so there must be a rabbitmq broker running prior. I am very new to docker. I tried so far:</p>  <p>1). I created image for the spring boot app as the following</p>  <pre><code>FROM java:8 EXPOSE 8080 ADD /target/MessagingApp.jar MessagingApp.jar ENTRYPOINT ['java','-jar','MessagingApp.jar'] </code></pre>  <p>2). Then created docker.compose file for rabbit and my newly created image</p>  <pre><code>rabbitmq:   image: rabbitmq:management   ports:     - '5672:5672'     - '15672:15672' messagingapp:   image: messagingapp:latest   ports:     - '80:8080'   links:     - rabbitmq </code></pre>  <p>I then ran docker-compose up and I can see rabbit started to some extend and then spring boot app but fails sending messages with </p>  <pre><code>at com.rabbitmq.client.impl.SocketFrameHandlerFactory.create.. </code></pre>  <p>I think my issue is that my spring boot app automatically tries to connect to the localhost rabbit host. So how do I make it point to the docker rabbitmq server?</p>  <p>Any help?</p> ",
    "OwnerUserId": "3793865",
    "LastEditorUserId": "3793865",
    "LastEditDate": "2017-04-30T17:12:43.410",
    "LastActivityDate": "2020-11-10T18:36:01.437",
    "Title": "RabbitMq Spring Boot deploy docker",
    "Tags": "<java><spring><docker><spring-boot><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>Try update part of <code>links</code> for <code>depends_on</code>. Your application probably start before <code>messagingapp</code>.</p>  <p>Part of documentation for <code>depends_on</code></p>  <blockquote>   <p>docker-compose up will start services in dependency order. When docker-compose execute V2 files, it will automatically build a network between all of the containers defined in the file, and every container will be immediately able to refer to the others just using the names defined in the docker-compose.yml file.</p> </blockquote>  <p><strong>But</strong></p>  <blockquote>   <p>Note: depends_on will not wait for db and redis to be \u201cready\u201d before starting web - only until they have been started.</p> </blockquote>  <p>For that check <a href='https://docs.docker.com/compose/startup-order/' rel='nofollow noreferrer'>Controlling startup order</a>.</p>  <p>You need add <code>command</code> for checking state of service. More in documentation...</p>  <pre><code>depends_on:       - 'db'     command: ['./wait-for-it.sh', 'db:5432', '--', 'python', 'app.py'] </code></pre> ",
    "highest_rated_answer": "<p>Your Dockerfile and docker-compose.yml files seem correct except for two things:</p> <ol> <li><p>instead of the keyword <code>links</code>, you need to use <code>depends_on</code>. This will build and run RabbitMQ instance first, then your web service.</p> </li> <li><p>you should add this line under your messagingapp service:</p> </li> </ol> <p>--&gt;</p> <pre><code>environment: -  SPRING_RABBITMQ_HOST=rabbitmq </code></pre> <p>This will let your Spring Boot application to recognize the RabbitMQ image in Docker.</p> <p>So, try to update your docker-compose.yml file like this:</p> <pre><code>rabbitmq:   image: rabbitmq:management   ports:     - &quot;5672:5672&quot;     - &quot;15672:15672&quot; messagingapp:   image: messagingapp:latest   ports:     - &quot;80:8080&quot;   environment:     - SPRING_RABBITMQ_HOST=rabbitmq   depends_on:     - rabbitmq </code></pre> "
  },
  {
    "Id": "45376280",
    "PostTypeId": "1",
    "CreationDate": "2017-07-28T14:40:03.370",
    "Score": "2",
    "ViewCount": "1138",
    "Body": "<p>I have created a spring boot application that runs perfectly on my machine. I run it with Intellij. I use a application.yml file within the src/main/resources directory that contains this kind of data:</p>  <pre><code>spring:   main:     banner-mode: 'off'   jpa:     database: MYSQL     properties:       hibernate:         ddl-auto: validate         format_sql: true         show_sql: true </code></pre>  <p>I have quiet a few properties so this is just a small part of the properties file.</p>  <p>Now I want to deploy the spring boot with docker compose. I install docker and docker-compose and this is how my docker-compose.yml file looks like: </p>  <pre><code>version: '2'   services:     backend:       image: backend:latest       ports:         - '8080:8080'       env_file:         - backend.env </code></pre>  <p>My backend.env file looks almost like the application.yml in my project however with different values like different mysql url etc</p>  <p>Now when I start the backend with </p>  <pre><code>docker-compose up backend </code></pre>  <p>I get a message that the project is still trying to connect to the database specified in the project application.yml. In short docker compose isn't overriding the properties passed on to my spring boot project.</p>  <p>I am wandering if my approach is the right one. What is the best practice for a Spring boot project that is deployed in docker compose? How can I deel with different environment files for each environment?</p>  <p>Thanks</p> ",
    "OwnerUserId": "4614579",
    "LastActivityDate": "2017-07-28T14:40:03.370",
    "Title": "Setting properties for Spring boot with docker compose",
    "Tags": "<spring-boot><docker-compose>",
    "AnswerCount": "0",
    "CommentCount": "3",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": null
  },
  {
    "Id": "47429314",
    "PostTypeId": "1",
    "AcceptedAnswerId": "47444612",
    "CreationDate": "2017-11-22T07:48:26.113",
    "Score": "2",
    "ViewCount": "4955",
    "Body": "<p>I'm trying to start 3 docker containers in a sequential order using the docker-compose. I have the following containers: </p>  <ul> <li>app-service-db  container -> Database </li> <li>config-service  container -> Spring boot application</li> <li>app-service     container -> Spring boot application</li> </ul>  <p>I want the ' app-service ' container to start only when the other two containers have finish starting.  I'm using the ' wait-for ' script to wait for the services to become available (<a href='https://github.com/Eficode/wait-for' rel='nofollow noreferrer'>https://github.com/Eficode/wait-for</a>). </p>  <p>Here is what I have inside the docker-compose.yml</p>  <pre><code>    version: '3.4' services:     config-service:       image: 'config-service:1.0'       hostname: config-service       container_name: config-service       build:         context: ../config         dockerfile: config.dockerfile       expose:         - '8888'       logging:         driver: json-file     app-service-db:       image: 'app-service-db:10.3'       hostname: app-service-db       container_name: app-service-db       build:         context: ../app-service         dockerfile: app-db.dockerfile       environment:         MYSQL_ROOT_PASSWORD: password         MYSQL_DATABASE: app       expose:         - '3306'       logging:         driver: json-file       app-service:         image: 'app-service:1.0'         hostname: app-service         container_name: app-service         build:           context: ../app-service           dockerfile: app.dockerfile         ports:           - '8080:8080'         expose:           - '8080'         logging:           driver: json-file         command: sh -c './wait-for app-service-db:3306 &amp;&amp; config-service:8888'           depends_on:           - config-service           - app-service-db </code></pre>  <p>config.dockerfile</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ADD target/config-1.0-final.jar config.jar ENTRYPOINT ['java', '-jar', 'config.jar'] EXPOSE 8888 </code></pre>  <p>app-db.dockerfile</p>  <pre><code>FROM mariadb:10.3 </code></pre>  <p>app.dockerfile</p>  <pre><code>FROM openjdk:8-jdk-alpine VOLUME /tmp ADD target/app-1.0-final.jar app.jar ENTRYPOINT ['java', '-jar', 'app.jar'] EXPOSE 8080 </code></pre>  <p>When I run the ' docker-compose up ' cmd the ' app-service ' container is starting before the ' app-service-db ' and ' config-service ' have finished and is exited because it can't find any connection.  How can I make this work and force the ' app-service ' container to start only when the other two containers have started.</p>  <p>Thanks in advance.</p> ",
    "OwnerUserId": "1464404",
    "LastEditorUserId": "1464404",
    "LastEditDate": "2017-11-22T07:57:23.837",
    "LastActivityDate": "2017-11-22T22:07:20.913",
    "Title": "Docker-compose services starting order",
    "Tags": "<docker><spring-boot><docker-compose>",
    "AnswerCount": "2",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": "<p>I see more problems in your configs. There is problem with entrypoint and command relation, to fully uderstand that please see this <a href='https://stackoverflow.com/questions/21553353/what-is-the-difference-between-cmd-and-entrypoint-in-a-dockerfile'>What is the difference between CMD and ENTRYPOINT in a Dockerfile?</a> So your entrypoint is to run java application - that's probably why wait is not working. I would suggest to override entrypoint for app-service by adding following section in docker-compose:</p>  <pre><code>entrypoint: sh -c './wait-for app-service-db:3306 &amp;&amp; ./wait-for config-service:8888 &amp;&amp; java -jar app.jar' </code></pre>  <p>Also I can't see where you are adding this script wait-for into docker image (missing ADD in app's dockerfile?) </p> ",
    "highest_rated_answer": "<p>You can ensure the start ordering of your services defined in your <code>docker-compose.yml</code> with the <code>depends_on</code> keyword:  <a href='https://docs.docker.com/compose/compose-file/#depends_on' rel='nofollow noreferrer'>https://docs.docker.com/compose/compose-file/#depends_on</a></p>  <p>This is a Docker runtime thing. You don't specify this in a <code>Dockerfile</code>, from which you build your Docker image.</p>  <p>Docker does not wait for your config and db services to finish starting, before starting your service. But Docker has a article in the official documentation explaining two alternatives to solve this use-case: <a href='https://docs.docker.com/compose/startup-order/' rel='nofollow noreferrer'>https://docs.docker.com/compose/startup-order/</a></p>  <ol> <li>Use tools as <em>wait-for-it</em> (<a href='https://github.com/vishnubob/wait-for-it' rel='nofollow noreferrer'>https://github.com/vishnubob/wait-for-it</a>) or <em>dockerize</em> (<a href='https://github.com/jwilder/dockerize' rel='nofollow noreferrer'>https://github.com/jwilder/dockerize</a>)</li> <li>or write your own wait script</li> </ol>  <p>In the article <a href='https://docs.docker.com/compose/startup-order/' rel='nofollow noreferrer'>https://docs.docker.com/compose/startup-order/</a> are examples for both solutions.</p> "
  },
  {
    "Id": "49592445",
    "PostTypeId": "1",
    "CreationDate": "2018-03-31T21:11:51.433",
    "Score": "2",
    "ViewCount": "717",
    "Body": "<p>my spring boot application connected with mongo db. here is the configs:</p>  <pre><code>spring.mongodb.embedded.storage.repl-set-name=mongo spring.data.mongodb.host=mongo spring.data.mongodb.port=27017 </code></pre>  <p>it works fine, but I want to create mongo replicas using docker service, like this:</p>  <pre><code> docker service create --name mongo --replicas=3 mongo </code></pre>  <p>here is my mongo service</p>  <pre><code>53cf3b73a510        mongo:latest        'docker-entrypoint...'   23 seconds ago      Up 23 seconds       27017/tcp                mongo.3.i5yvbe0mo0d2x83j2xf9ubvnv 54c9a5dbb93a        mongo:latest        'docker-entrypoint...'   24 seconds ago      Up 23 seconds       27017/tcp                mongo.1.rlqtw055adklfr4jqn8uete94 a6b78191b0e3        mongo:latest        'docker-entrypoint...'   24 seconds ago      Up 23 seconds       27017/tcp                mongo.2.52ha34l414k1k8xgndkkzm25m </code></pre>  <p>So after this my connection to mongodb does not work. I do not want use IP address.</p>  <p>I am using docker-compose and docker network. <a href='https://github.com/armdev/docker-mongo-service/blob/master/docker-compose.yml' rel='nofollow noreferrer'>https://github.com/armdev/docker-mongo-service/blob/master/docker-compose.yml</a></p>  <p>This is also does not work</p>  <pre><code>org.mongodb.driver.cluster               : Exception in monitor thread while connecting to server mongo.2:27017     spring.data.mongodb.uri=mongodb://mongo.1:27017,mongo.2:27017/guruDB?replicaSet=mc </code></pre> ",
    "OwnerUserId": "2182398",
    "LastEditorUserId": "2730527",
    "LastEditDate": "2018-05-03T20:50:06.237",
    "LastActivityDate": "2018-05-03T20:50:06.237",
    "Title": "Spring boot connect to docker service mongodb",
    "Tags": "<java><docker><spring-boot><docker-compose><spring-data-mongodb>",
    "AnswerCount": "0",
    "CommentCount": "0",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 3.0",
    "accepted_answer": null,
    "highest_rated_answer": null
  },
  {
    "Id": "50834723",
    "PostTypeId": "1",
    "CreationDate": "2018-06-13T10:17:33.210",
    "Score": "2",
    "ViewCount": "284",
    "Body": "<p>Trying to run integration tests locally on Mac using docker-compose The only way I can connect application to database is using network_mode: host.</p>  <p>It could be this way but I can't reach the application endpoint as in a Linux env by:  curl localhost:8080/blabla</p>  <p>I've tried all the Stack Overflow answers and many many configurations and different versions of docker-compose.yml but none worked so far.</p>  <p>Always the same problem unless network host.</p>  <pre> version: '3' services:   app:     build:       context: .     expose:       - '8085'     network_mode: host     depends_on:       - mypostgres     environment:       - PROFILE=local       - DB_URL=jdbc:postgresql://localhost/db       - DB_USER=xxxx       - DB_SECRET=xxxx       - DB_PORT=5432     mypostgres:     restart: always     build:       context: ./db     ports:       - '5433:5432'     network_mode: host     volumes:       - $HOME/data:/var/lib/postgresql/data     environment:       - POSTGRES_PASSWORD=xxxx       - POSTGRES_USER=xxxx       - POSTGRES_DB=xxxx     nginx:     image: nginx:1.13     restart: always     ports:       - 80:80       - 443:443     depends_on:       - app     volumes:       - ./nginx/conf.d:/etc/nginx/conf.d </pre> ",
    "OwnerUserId": "7524100",
    "LastEditorUserId": "7524100",
    "LastEditDate": "2018-06-13T10:40:33.623",
    "LastActivityDate": "2018-06-13T10:40:33.623",
    "Title": "docker-compose - Spring boot doesn't connect to postgres unless network_mode: host",
    "Tags": "<postgresql><spring-boot><docker-compose>",
    "AnswerCount": "0",
    "CommentCount": "1",
    "FavoriteCount": "0",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": null
  },
  {
    "Id": "50855368",
    "PostTypeId": "1",
    "CreationDate": "2018-06-14T10:31:48.673",
    "Score": "2",
    "ViewCount": "1541",
    "Body": "<p>I have 3 docker containers:</p>  <p>Backend (Spring boot rest api) Frontend (Js and html in the apache image) Mongodb</p>  <p>I'm orchestrating them through docker-compose and works nicely.</p>  <p>However I don't know how to let my frontend javascript client know the backend container's host/ip in order to reach it.</p>  <p>This is my docker-compose.yml:</p>  <pre><code>version: '3.1'  services:   project-server:     build: .     restart: always     container_name: project-server     ports:       - 8200:8200     working_dir: /opt/app     depends_on:       - mongo    httpd:     image: project-ui     container_name: project-ui     ports:       - 8201:80     mongo:     image: project-mongo     container_name: project-mongo     ports:       - 27018:27017     volumes:       - $HOME/data/mongo-data:/data/db       - $HOME/data/mongo-bkp:/data/bkp     restart: always </code></pre>  <p>So i've tried with this in my js client app:</p>  <pre><code>export default {   REMOTE_HOST: 'http://project-server:8200' } </code></pre>  <p>But it doesn't work. (Failed to load resource: net::ERR_NAME_NOT_RESOLVED)</p>  <p>And i'm pretty sure it's because JS runs locally on the browser so it has no way to resolve that.</p>  <p>What's the right way to do this? There is any way for the frontend service (apache) to pass/render the real host to Javascript and get it somehow?</p>  <p>Thanks a lot</p> ",
    "OwnerUserId": "1687540",
    "LastEditorUserId": "1687540",
    "LastEditDate": "2018-06-14T11:40:09.340",
    "LastActivityDate": "2018-06-14T12:30:13.657",
    "Title": "How to make REST calls between Frontend and Backend using Docker containers",
    "Tags": "<apache><docker><spring-boot><docker-compose>",
    "AnswerCount": "1",
    "CommentCount": "5",
    "ContentLicense": "CC BY-SA 4.0",
    "accepted_answer": null,
    "highest_rated_answer": "<p><code>project-server</code> can be resolved only within the network created by <code>docker-compose</code>. As you mentioned, to connect from the outside world you need to export the IP of your host instead of <code>project-server</code>. The problem is the guest container doesn't know the IP of the guest. Here is a detailed discussion about that: <a href='https://stackoverflow.com/questions/22944631/how-to-get-the-ip-address-of-the-docker-host-from-inside-a-docker-container'>How to get the IP address of the docker host from inside a docker container</a></p>  <p>What you probably need in your situation is to run the container passing the IP of the host as an environment variable:</p>  <pre><code>run --env &lt;IP&gt;=&lt;value&gt; </code></pre>  <p>Then in node you can just read that variable.  Hope it helps</p> "
  }
]